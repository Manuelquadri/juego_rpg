<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Camino del Cultivador</title>
    <style>
   /****************************************
       * 1. ESTILOS GENERALES Y LAYOUT
       ****************************************/
       * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", monospace;
        background: linear-gradient(135deg, #2c1810, #8b4513);
        color: #f4e4bc;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Evita el scroll indeseado */
      }

      .game-container {
        display: flex;
        flex-grow: 1;
        /* El padding-top crea el espacio para la barra de navegaci√≥n superior */
        padding-top: 55px; /* Ajusta este valor si cambia la altura de la barra */
      }

      .sidebar {
        display: none; /* La barra lateral ya no se usa, se oculta permanentemente */
      }
      
      button {
        background: linear-gradient(135deg, #d4af37, #b8941f);
        color: #2c1810;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      button:hover {
        background: linear-gradient(135deg, #f4d03f, #d4af37);
        transform: translateY(-2px);
      }

      button:disabled {
        background: #666;
        color: #999;
        cursor: not-allowed;
        transform: none;
      }
      /* Esta regla se aplicar√° a TODAS las barras de estad√≠sticas del juego */
      .stat-bar {
          width: 100%;
          height: 18px; /* Una altura est√°ndar y visible. Puedes ajustarla. */
          background-color: rgba(0, 0, 0, 0.4);
          border-radius: 9px;
          overflow: hidden; /* Asegura que el relleno no se salga */
          border: 1px solid rgba(212, 175, 55, 0.2);
          margin: 8px 0; /* Un poco de espacio vertical para que no se pegue a otros elementos */
      }

      /* El relleno de la barra */
      .stat-fill {
          height: 100%; /* Ahora esto funcionar√°, porque el padre (.stat-bar) tiene una altura fija */
          transition: width 0.3s linear;
      }
      /****************************************
       * 2. INTERFAZ PRINCIPAL (HUD, BARRAS, BOTONES)
       ****************************************/
      
      /* --- Barra de Navegaci√≥n Superior --- */
      .top-nav-bar {
        position: fixed;
        top: 0; 
        left: 0;
        width: 100%;
        height: 55px; /* Altura fija para el c√°lculo de padding */
        background: linear-gradient(180deg, #2c1810, #1a1a1a);
        border-bottom: 2px solid #d4af37;
        display: flex;
        justify-content: space-around;
        align-items: center;
        z-index: 250;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease-in-out;
        transform: translateY(0);
      }

      .top-nav-bar.hidden {
        transform: translateY(-100%); 
      }
      
      .nav-button {
        position: relative;
        background: transparent;
        border: none;
        color: #f4e4bc;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 8px 5px;
        cursor: pointer;
        font-family: "Courier New", monospace;
        font-size: 0.75rem;
        flex-grow: 1;
        max-width: 20%;
        transition: background-color 0.2s, color 0.2s;
      }

      .nav-button:hover,
      .nav-button.active {
        background-color: rgba(212, 175, 55, 0.15);
        color: #f4d03f;
      }

      .nav-icon {
        font-size: 1.5rem;
        margin-bottom: 3px;
      }
      
      /* --- HUD de Stats del Jugador (Esquina superior izquierda) --- */
      .stats-panel {
        position: fixed; /* FIJO en la ventana, no relativo al mapa */
        top: 70px; /* 55px de la barra + 15px de margen */
        left: 15px;
        z-index: 100;
        width: 180px;
        background: rgba(26, 26, 26, 0.75);
        backdrop-filter: blur(4px);
        border: 2px solid #d4af37;
        border-radius: 8px;
        padding: 10px;
        margin: 0;
      }

      .stats-panel .stat-bar {
        width: 100%;
        height: 12px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 7px;
        margin-top: 3px;
        margin-bottom: 8px;
        overflow: hidden;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }
      
      .stat-fill {
        height: 100%;
        transition: width 0.3s;
      }
      .stats-panel .stat-line, 
      .stats-panel .stat-block {
        margin-bottom: 8px; /* Espaciado consistente */
      }

      .stats-panel .stat-stones {
          color: #f4d03f; /* Destacar las piedras espirituales */
          font-weight: bold;
          margin-top: 4px;
      }
      
      .stats-panel .stat-block span {
          display: block; /* Asegura que el texto est√© en su propia l√≠nea */
          font-size: 0.9em;
          margin-bottom: 2px;
      }
      .hp-fill { background: linear-gradient(90deg, #ff4444, #ff6666); }
      .mana-fill { background: linear-gradient(90deg, #4444ff, #6666ff); }
      .exp-fill { background: linear-gradient(90deg, #44ff44, #66ff66); }

      /* --- Barra de Acceso R√°pido Inferior --- */
      .quick-slot-bar {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        padding: 8px;
        background: rgba(26, 26, 26, 0.8);
        border: 2px solid #d4af37;
        border-radius: 12px;
        z-index: 150;
        box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
        backdrop-filter: blur(4px);
      }

      .quick-slot {
        width: 55px;
        height: 55px;
        border: 2px solid rgba(212, 175, 55, 0.5);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        position: relative;
        transition: all 0.2s;
      }
      .quick-slot:hover {
        background-color: rgba(212, 175, 55, 0.2);
        border-color: #f4d03f;
      }
      .quick-slot.empty { border-style: dashed; }

      .slot-item-count {
        position: absolute;
        bottom: 2px;
        right: 4px;
        font-size: 14px;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px black;
      }

      .slot-key-hint {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 12px;
        color: #f4e4bc;
        opacity: 0.7;
      }
      .cultivate-slot {
            font-size: 28px; /* Hacemos el emoji un poco m√°s grande */
            border-style: solid; /* Para que no se vea punteado como un slot vac√≠o */
        }

        /* Estilo para cuando el cultivo est√° activo */
        .cultivate-slot.active-cultivation {
            background-color: rgba(139, 69, 19, 0.5); /* Un brillo sutil de color del tema */
            border-color: #f4d03f;
            box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
            animation: pulse-cultivation 2s infinite;
        }
        .conversion-slot {
            font-size: 28px;
            border-style: solid;
            color: #f4e4bc;
            opacity: 0.6; /* Un poco tenue cuando est√° inactivo */
            transition: all 0.3s;
        }

        .conversion-slot:hover {
            opacity: 1;
        }

        .conversion-slot.active-conversion {
            opacity: 1;
            background-color: rgba(68, 68, 255, 0.3); /* Brillo azulado */
            border-color: #6666ff;
            box-shadow: 0 0 10px rgba(102, 102, 255, 0.7);
            animation: pulse-conversion 2s infinite;
        }

        @keyframes pulse-conversion {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes pulse-cultivation {
            0% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 15px rgba(244, 208, 63, 0.8);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
            }
        }

      /* --- Botones de Control Superpuestos (M√≥vil) --- */
      #mobileMenuBtn {
        display: none;
        position: fixed;
        top: 10px;
        right: 10px; /* <--- CORREGIDO */
        z-index: 1000;
        width: 45px;
        height: 45px;
        font-size: 24px;
        padding: 0;
        }
      
        #toggleMapControlsBtn {
        display: none;
        position: fixed;
        top: 60px; /* <--- CORREGIDO (10px + 45px del bot√≥n de arriba + 5px de espacio) */
        right: 10px;
        z-index: 1005;
        padding: 8px 12px;
        font-size: 14px;
        }

      #toggleMapControlsBtn.hidden-during-battle {
        display: none !important;
      }

      /****************************************
       * 3. MAPA Y ELEMENTOS DEL MAPA
       ****************************************/
      .map-container {
        flex: 1;
        position: relative;
        background: #1a3d2e;
        border: 3px solid #d4af37;
        overflow: hidden;
      }

      .map {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .tile {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .player {
        z-index: 10;
        color: transparent; /* Oculta el emoji de fallback */
        font-size: 0;
        background-image: url("img/tu_sprite_sheet.png"); /* Aseg√∫rate que la ruta sea correcta */
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: 256px 256px; /* Ajusta al tama√±o total de tu spritesheet */
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }

      /* Barras de stats sobre el jugador en el mapa */
      #playerOnMapBarsContainer {
        position: absolute;
        width: 48px;
        display: none; /* JS lo controla */
        flex-direction: column;
        gap: 1px;
        z-index: 15;
        pointer-events: none;
        transform: translateX(-50%);
      }

      .on-map-stat-bar {
        width: 100%;
        height: 6px;
        background-color: rgba(50, 50, 50, 0.7);
        border: 1px solid rgba(0, 0, 0, 0.5);
        border-radius: 2px;
        overflow: hidden;
      }

      .on-map-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerOnMapHpFill { background-color: #f44336; }
      #playerOnMapManaFill { background-color: #2196f3; }
      .entity-name-plate {
        position: absolute; /* Para posicionarlo relativo al mapa */
        bottom: 100%; /* Lo coloca justo encima del 'top' del sprite */
        left: 50%;
        transform: translateX(-50%); /* Lo centra horizontalmente */
        background-color: rgba(10, 10, 10, 0.7);
        color: #f4e4bc;
        padding: 2px 5px;
        border-radius: 4px;
        font-size: 10px; /* Un tama√±o de fuente peque√±o y legible */
        font-weight: bold;
        white-space: nowrap; /* Evita que el nombre se parta en dos l√≠neas */
        z-index: 6; /* Asegura que est√© por encima de la entidad */
        pointer-events: none; /* Evita que la etiqueta intercepte clics del rat√≥n */
        border: 1px solid rgba(212, 175, 55, 0.3);
    }

      /****************************************
       * 4. PANTALLA DE BATALLA
       ****************************************/
       
      .battle-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        display: none;
        flex-direction: column;
        z-index: 300;
        overflow: hidden;
      }

      .battle-area {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: space-around;
        padding: 20px 10px;
        gap: 10px;
        overflow-y: auto;
      }

      .character, .enemy {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-basis: 45%;
        max-width: 280px;
        min-width: 120px;
        padding: 60px 0;
      }

      .character-sprite, .enemy-sprite {
        width: 80px;
        height: 80px;
        font-size: 60px;
        margin-bottom: 10px;
      }
      .enemy-sprite {
            background-size: contain; /* Asegura que la imagen quepa completa en el div */
            background-repeat: no-repeat;
            background-position: center; /* Centra la imagen del sprite */
            image-rendering: pixelated; /* Mantiene la est√©tica pixel-art si la tienes */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

      .character-sprite {
        background-image: url("img/tu_sprite_sheet.png");
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: auto;
        color: transparent;
      }

      .battle-actions {
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-top: 2px solid #d4af37;
        flex-shrink: 0;
      }

      .action-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 5px;
        margin-bottom: 10px;
      }
      
      .battle-actions button {
        padding: 8px 10px;
        font-size: 0.8em;
      }
      
      .log { display: none; }

      /* Barras sobre sprites en batalla */
      #playerInBattleSpriteBarsContainer, #enemyInBattleInfoContainer {
        position: absolute;
        display: none;
        flex-direction: column;
        gap: 2px;
        z-index: 5;
        pointer-events: none;
        transform: translateX(-50%);
      }

      #playerInBattleSpriteBarsContainer { width: 60px; }
      #enemyInBattleInfoContainer {
        min-width: 70px;
        max-width: 190px;
        align-items: center;
        padding: 2px 4px;
        background-color: rgba(10, 10, 10, 0.6);
        border-radius: 3px;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      .in-battle-sprite-stat-bar {
        width: 100%;
        height: 5px;
        background-color: rgba(50, 50, 50, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.6);
        border-radius: 2px;
        overflow: hidden;
      }
      .in-battle-sprite-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }
      
      #playerInBattleSpriteHpFill { background-color: #e53935; }
      #playerInBattleSpriteManaFill { background-color: #1e88e5; }
      #enemyInBattleSpriteHpFill { background-color: #c62828; }

      .enemy-battle-name-level {
        font-size: 0.8em;
        color: #f4e4bc;
        font-weight: bold;
        white-space: nowrap;
      }

      /****************************************
       * 5. MODALES Y ELEMENTOS DE UI
       ****************************************/
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 500; /* M√°s alto que la batalla */
        padding: 10px;
      }

      .modal-content {
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        border: 3px solid #d4af37;
        border-radius: 15px;
        padding: 20px;
        max-width: 95%;
        width: 500px;
        text-align: center;
        max-height: 90vh;
        overflow-y: auto;
      }
      
      .cultivation-option-btn {
        display: block;
        width: 100%;
        padding: 10px;
        margin-bottom: 8px;
        text-align: left;
      }

      /* Controles t√°ctiles del mapa (Joystick, Bot√≥n Acci√≥n) */
      #joystick-container {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
        z-index: 200;
        display: none;
        opacity: 0.7;
      }
      #joystick-pad {
        z-index: 1;
        width: 100%;
        height: 100%;
        background-color: rgba(128, 128, 128, 0.5);
        border-radius: 50%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid rgba(255, 255, 255, 0.7);
      }
      #joystick-handle {
        width: 50px;
        height: 50px;
        background-color: rgba(80, 80, 80, 0.8);
        border-radius: 50%;
        position: absolute;
        border: 2px solid rgba(200, 200, 200, 0.9);
      }
      #action-button-touch {
        position: fixed;
        bottom: 60px;
        right: 60px;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        z-index: 200;
        display: none;
        font-size: 0.8em;
      }
      /* --- Estilos para Modal de Inventario --- */
        .inventory-modal-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            padding: 10px;
            margin-bottom: 8px;
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.15);
        }

        .inventory-modal-item .item-details {
            flex-grow: 1;
        }

        .inventory-modal-item .item-name {
            font-weight: bold;
            color: #f4d03f;
            font-size: 1.1em;
        }

        .inventory-modal-item .item-description {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 4px;
        }

        .inventory-modal-item .item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .inventory-modal-item .item-actions button {
            padding: 6px 10px;
            font-size: 0.8em;
        }
        .assignable-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .assignable-item:hover {
            background-color: rgba(212, 175, 55, 0.1);
            border-color: rgba(212, 175, 55, 0.4);
        }
        /* --- Fin Estilos Modal Inventario --- */

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
          @media (max-width: 768px), 
              (max-height: 500px), 
              (hover: none) and (pointer: coarse)  {
        .game-container {
          padding-top: 0; /* En m√≥vil, no hay espacio arriba, el men√∫ es un overlay */
          /* --- CORRECCI√ìN CLAVE --- */
          /* Hacemos que el contenedor del juego pueda estar detr√°s de la barra */
          position: relative;
          z-index: 1; 
        }
        
        .map-container {
          height: 100vh;
        }

        #mobileMenuBtn, #toggleMapControlsBtn {
          display: block;
        }
        
        .top-nav-bar {
          flex-direction: column;
          justify-content: flex-start;
          align-items: stretch;
          height: auto;
          padding-top: 60px;
          /* --- CORRECCI√ìN CLAVE --- */
          /* Aseguramos que la barra est√© por encima del game-container */
          z-index: 200; 
          transform: translateY(-100%);
          transition: transform 0.4s ease-in-out;
        }

        .top-nav-bar.open {
          transform: translateY(0);
        }

        .top-nav-bar .nav-button {
          justify-content: flex-start;
          padding: 15px 20px;
          max-width: 100%;
        }

        .stats-panel .desktop-only {
          display: none;
        }

        .stats-panel {
            /* Ajustes existentes para m√≥vil */
            width: 180px; /* Un poco m√°s ancho para la nueva info */
            padding: 8px;
            font-size: 0.8em; /* Un poco m√°s grande para legibilidad */
            top: 10px;
            left: 10px;
            backdrop-filter: blur(2px);
        }
        
        #toggleMapControlsBtn {
            top: 60px; /* Vuelve a su posici√≥n original en m√≥vil */
        }

        .character-sprite, .enemy-sprite {
            width: 60px; height: 60px; font-size: 55px;
        }
      }

      @media (max-width: 480px) {
        .nav-text { display: none; }
        .nav-icon { font-size: 1.8rem; margin-bottom: 0; }
        .nav-button { padding: 10px 5px; }
        
        .stats-panel {
            width: 160px;
            font-size: 0.8em;
        }
        .stats-panel h3 { font-size: 1.1em; }
        
        .character-sprite, .enemy-sprite {
            width: 50px; height: 50px; font-size: 50px;
        }
        .battle-actions button {
            padding: 6px 8px; font-size: 0.75em;
        }

    }
    /****************************************
       * NUEVO: 7. ESTILOS DE LA TIENDA
       ****************************************/
      
       #shopModal .modal-content {
        max-width: 90%;
        width: 1000px; /* Un ancho mayor para la tienda */
        height: 90vh;
        display: flex;
        flex-direction: column;
      }

      .shop-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        flex-shrink: 0;
      }

      .shop-stats {
        font-size: 1.1em;
        color: #f4d03f;
      }

      .shop-container {
        display: flex;
        gap: 20px;
        flex-grow: 1;
        overflow: hidden; /* Evita que el contenedor principal scrollee */
      }
      
      .shop-filters {
        flex: 0 0 220px; /* No crece, no se encoge, base de 220px */
        padding-right: 15px;
        border-right: 1px solid rgba(212, 175, 55, 0.2);
        overflow-y: auto;
      }
      
      .shop-products {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .products-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 15px;
        overflow-y: auto; /* El scroll ahora est√° aqu√≠ */
        padding: 5px;
        flex-grow: 1;
      }

      .section-title {
        color: #f4d03f;
        margin-bottom: 10px;
        border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        padding-bottom: 5px;
      }

      .search-box {
        width: 100%;
        padding: 8px;
        background-color: rgba(0,0,0,0.3);
        border: 1px solid #555;
        border-radius: 5px;
        color: #f4e4bc;
        margin-bottom: 15px;
      }

      .filter-group {
        margin-bottom: 20px;
      }
      .filter-title {
        font-weight: bold;
        margin-bottom: 8px;
        font-size: 0.9em;
        opacity: 0.8;
      }

      .category-list {
        list-style: none;
      }
      .category-item {
        padding: 8px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .category-item:hover {
        background-color: rgba(212, 175, 55, 0.1);
      }
      .category-item.active {
        background-color: rgba(212, 175, 55, 0.2);
        color: #f4d03f;
        font-weight: bold;
      }

      .product-card {
        background: rgba(0,0,0,0.2);
        border: 1px solid rgba(212, 175, 55, 0.3);
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
      }

      .product-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 10px;
      }

      .product-name {
        font-weight: bold;
        color: #f4d03f;
      }
      .product-type {
        font-size: 0.8em;
        opacity: 0.7;
      }
      .product-price {
        font-weight: bold;
        white-space: nowrap;
      }
      
      .product-description {
        font-size: 0.9em;
        margin: 10px 0;
        opacity: 0.9;
        flex-grow: 1; /* Hace que la descripci√≥n empuje el bot√≥n hacia abajo */
      }

      .product-actions {
        margin-top: auto; /* Empuja el bot√≥n al final de la tarjeta */
      }
      .buy-btn {
        width: 100%;
      }

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
      @media (max-width: 768px) {
        /* ... (tus otras media queries) ... */
      
        /* A√ëADE ESTAS REGLAS DENTRO DE LA MEDIA QUERY DE 768px */
        #shopModal .modal-content {
            width: 95%; /* Ocupa m√°s ancho en m√≥vil */
            /* Quitamos la altura fija para que se adapte al contenido en m√≥vil */
            height: auto; 
            max-height: 85vh; /* Ponemos una altura m√°xima para que no ocupe toda la pantalla */
        }

        .shop-container {
            flex-direction: column; /* Apila los filtros encima de los productos */
            /* Hacemos que el scroll sea manejado por el .modal-content general en m√≥vil */
            overflow: visible; 
        }

        .shop-filters {
            flex: 0 0 auto; /* No debe crecer, su tama√±o ser√° determinado por su contenido */
            border-right: none;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            padding-bottom: 15px;
            margin-bottom: 15px;
            overflow-y: visible; /* Correcto, no queremos scroll aqu√≠ */
        }

        .shop-products {
            /* Quitamos el overflow: hidden que podr√≠a estar ocultando el contenido */
            overflow: visible;
        }

        .products-grid {
            grid-template-columns: 1fr; /* Una sola columna para los productos en m√≥vil */
            overflow-y: visible; /* El scroll lo maneja el padre */
            /* Quitamos el flex-grow para evitar conflictos */
        }
    }
    /****************************************
       * NUEVO: 8. ESTILOS DE COMBATE FLOTANTES
       ****************************************/
      .damage-popup {
        position: absolute;
        z-index: 310; /* Encima de todo en la batalla */
        font-family: 'Courier New', monospace;
        font-weight: bold;
        pointer-events: none; /* Para que no intercepte clics */
        text-shadow: 2px 2px 3px rgba(0,0,0,0.7);
        animation: floatUpAndFade 1.5s ease-out forwards;
      }

      /* Estilos espec√≠ficos */
      .damage-popup.damage { color: #ff4d4d; font-size: 1.8em; }
      .damage-popup.heal { color: #66ff66; font-size: 1.8em; }
      .damage-popup.mana { color: #87CEFA; font-size: 1.5em; }
      .damage-popup.ability { color: #f4d03f; font-size: 1.2em; }
      .damage-popup.debuff { color: #dda0dd; font-size: 1.2em; }

      @keyframes floatUpAndFade {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        100% {
          transform: translateY(-80px) scale(1.2);
          opacity: 0;
        }
      }
   
    </style>
  </head>
  <body>
      <!-- BOT√ìN DE MEN√ö PARA M√ìVILES -->
      <button id="mobileMenuBtn">‚ò∞</button>
      <!-- FIN DEL BOT√ìN -->

      <!-- ================================================================= -->
      <!-- CORRECCI√ìN 1: PANEL DE ESTAD√çSTICAS MOVIDO AQU√ç -->
      <!-- Este panel ahora es un hijo directo del body. Gracias a `position: fixed` en su CSS,
          se quedar√° anclado en la esquina superior izquierda sin importar el resto del layout. -->
     <div class="stats-panel">
        <!-- Estos se mostrar√°n siempre -->
        <p class="stat-line stat-coords">Coords: <span id="playerCoords">X: 0, Y: 0</span></p>
        <p class="stat-line stat-zone">Zona: <span id="playerZone">Desconocida</span></p>
        
        <!-- Estos se ocultar√°n en m√≥vil -->
        <p class="stat-line stat-level desktop-only">Nivel: <span id="playerLevel">1</span></p>
        <p class="stat-line stat-realm desktop-only">Reino: <span id="playerRealm">Mortal</span></p>

        <div class="stat-block desktop-only">
          <span>Vida: <span id="hpText">100/100</span></span>
          <div class="stat-bar">
            <div class="stat-fill hp-fill" id="hpBar" style="width: 100%"></div>
          </div>
        </div>

        <div class="stat-block desktop-only">
          <span>Man√°: <span id="manaText">50/50</span></span>
          <div class="stat-bar">
            <div
              class="stat-fill mana-fill"
              id="manaBar"
              style="width: 100%"
            ></div>
          </div>
        </div>
        
        <!-- Estos se mostrar√°n siempre -->
        <div class="stat-block">
            <span>Experiencia: <span id="expText">0/100</span></span>
            <div class="stat-bar">
              <div class="stat-fill exp-fill" id="expBar" style="width: 0%"></div>
            </div>
        </div>
        <p class="stat-line stat-stones">P. Espirituales: <span id="playerStonesHud">0</span></p>
    </div>
      <!-- ================================================================= -->
  
      <!-- PANEL LATERAL -->
      <input type="file" id="fileInput" accept=".json" style="display: none" />
      <button id="toggleMapControlsBtn">Ocultar Controles</button>
      <!-- Bot√≥n para ocultar/mostrar controles -->

      <div class="game-container">
          
        <div class="map-container">
          
          <div class="map" id="gameMap"></div>
          <div class="tile player" id="player">üßò</div>

          <!-- Este contenedor ahora S√ìLO tiene las barras peque√±as que van sobre el sprite en el mapa -->
          <div id="playerOnMapBarsContainer">
            <div class="on-map-stat-bar">
              <!-- Barra de Vida -->
              <div class="on-map-stat-fill" id="playerOnMapHpFill"></div>
            </div>
            <div class="on-map-stat-bar">
              <!-- Barra de Man√° -->
              <div class="on-map-stat-fill" id="playerOnMapManaFill"></div>
            </div>
          </div>
          
        <div id="joystick-container">
          <div id="joystick-pad">
            <div id="joystick-handle"></div>
          </div>
        </div>
        <button id="action-button-touch">Acci√≥n</button>

        <div class="sidebar">
          <div class="inventory-panel">
            <h3>Inventario</h3>
            <div class="inventory-grid" id="inventory"></div>
          </div>

          <div class="controls-panel">
            <h3>Controles</h3>
            <p><strong>Escritorio:</strong></p>
            <p>WASD/Flechas: Moverse</p>
            <p>ESPACIO: Interactuar</p>
            <p style="margin-top: 5px"><strong>M√≥vil:</strong></p>
            <p>Joystick: Moverse</p>
            <p>Bot√≥n Acci√≥n: Interactuar</p>
            <p>
              "Ocultar/Mostrar Controles": Alterna visibilidad de controles
              t√°ctiles.
            </p>

            <button id="cultivateButton" onclick="toggleCultivation()">
              üßò‚Äç‚ôÄÔ∏è Cultivar
            </button>
            <button onclick="showTechniquePanel()">üìñ T√©cnicas</button>
            
            <button onclick="saveGame()">üíæ Guardar Partida</button>
            <button onclick="triggerFileUpload()">üìÅ Cargar Partida</button>
            <button onclick="showHelp()">‚ùì Ayuda</button>
          </div>
          <div class="secta-panel">
            <h3><span id="sectaNombreDisplay">Secta</span></h3>
            <p>Rango: <span id="playerSectRank">Disc√≠pulo Externo</span></p>
            <p>Puntos de Contribuci√≥n: <span id="playerPCS">0</span> PCS</p>
            <h4>Misiones Activas:</h4>
            <div
              id="activeMissionsList"
              style="font-size: 0.9em; max-height: 150px; overflow-y: auto"
            >
              <p>Ninguna misi√≥n activa.</p>
            </div>
          </div>
        </div>
      </div>
      <!-- FIN PANEL LATERAL -->
      <!-- Pantalla de Combate -->
      <div class="battle-screen" id="battleScreen">
        <div class="battle-area">
          <div class="character">
            <!-- NUEVO: Contenedor para barras SOBRE el sprite en batalla -->
            <div id="playerInBattleSpriteBarsContainer">
              <div class="in-battle-sprite-stat-bar">
                <!-- Barra de Vida -->
                <div
                  class="in-battle-sprite-stat-fill"
                  id="playerInBattleSpriteHpFill"
                ></div>
              </div>
              <div class="in-battle-sprite-stat-bar">
                <!-- Barra de Man√° -->
                <div
                  class="in-battle-sprite-stat-fill"
                  id="playerInBattleSpriteManaFill"
                ></div>
              </div>
            </div>
            <!-- FIN NUEVO -->
            <div class="character-sprite">üßò</div>
            <h3 id="playerBattleName">Cultivador</h3>
            <div>Vida: <span id="playerBattleHp">100/100</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill hp-fill"
                id="playerBattleHpBar"
                style="width: 100%"
              ></div>
            </div>
          </div>

          <div class="enemy">
            <!-- === NUEVO: Contenedor para informaci√≥n y barras SOBRE el sprite del ENEMIGO === -->
            <div id="enemyInBattleInfoContainer">
              <div class="enemy-battle-name-level" id="enemyBattleNameLevel">
                Enemigo (Nv. X)
              </div>
              <div class="in-battle-sprite-stat-bar enemy-hp-bar">
                <!-- Barra de Vida del Enemigo -->
                <div
                  class="in-battle-sprite-stat-fill"
                  id="enemyInBattleSpriteHpFill"
                ></div>
              </div>
            </div>
            <!-- === FIN NUEVO === -->
            <div class="enemy-sprite" id="enemySprite"></div>
            <h3 id="enemyName">Demonio</h3>
            <div>Vida: <span id="enemyHp">80/80</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill hp-fill"
                id="enemyHpBar"
                style="width: 100%"
              ></div>
              <div
                class="stat-fill hp-fill"
                id="enemyHpBar"
                style="width: 100%"
              ></div>
            </div>
          </div>
        </div>

        <div class="battle-actions">
          <div class="action-buttons" id="battleActionButtons">
            {/* Botones de batalla se generan por JS */}
          </div>
          <div class="log" id="battleLog"></div>
        </div>
      </div>

      <!-- Modal para Cultivo Activo -->
  <div class="modal" id="activeCultivationModal">
      <div class="modal-content" style="max-width: 450px;">
          <h3 id="activeCultivationTitle">Cultivando...</h3>
          <p id="activeCultivationDescription">Concentrando tu energ√≠a...</p>

          <!-- SECCI√ìN PARA CULTIVO DE T√âCNICA -->
          <div id="activeCultivationProgressUI" style="display: none;">
              <p>
                  Progreso:
                  <span id="activeCultivationTargetName">T√©cnica X</span> (Nv.
                  <span id="activeCultivationTargetLevel">Y</span>)
              </p>
              <!-- El contenedor de la barra -->
              <div class="stat-bar"style="background: #444; margin: 10px 0;"> 
                  <!-- La barra de relleno -->
                  <div class="stat-fill" id="activeCultivationProgressBar" style="width: 0%; background: linear-gradient(90deg, #ffd700, #ffae42);"></div>
              </div>
              <p id="activeCultivationProgressText" style="text-align: center; font-size: 0.9em;">0s / 0s</p>
          </div>

          <!-- SECCI√ìN PARA MEDITACI√ìN RESTAURADORA -->
          <div id="recoveryCultivationProgressUI" style="display: none; margin-top: 15px;">
              <p>Absorbiendo Qi del entorno...</p>
              <div style="margin-top: 15px; font-size: 0.9em;">
                  <div>Vida: <span id="modalHpText">100/100</span></div>
                  <div class="stat-bar">
                      <div class="stat-fill hp-fill" id="modalHpBar" style="width: 100%;"></div>
                  </div>
                  <div>Man√°: <span id="modalManaText">50/50</span></div>
                  <div class="stat-bar">
                      <div class="stat-fill mana-fill" id="modalManaBar" style="width: 100%;"></div>
                  </div>
              </div>
          </div>

          <!-- SECCI√ìN PARA ACELERACI√ìN -->
          <div id="cultivationBoostSection" style="display: none; margin-top: 15px; padding-top: 10px; border-top: 1px solid #555;">
              <p>Piedras Espirituales: <span id="cultivationModalPlayerStones">0</span></p>
              <button id="boostCultivationButton" onclick="boostCultivationProgress()" style="margin-top: 8px; width: 100%;">‚ö° Acelerar Cultivo (1 Piedra = 10s)</button>
          </div>

          <!-- Bot√≥n para detener -->
          <button onclick="stopCultivation(true)" style="margin-top: 20px;">üö´ Detener Cultivo</button>
      </div>
  </div>


      <!-- Modal para tienda -->
      <div class="modal" id="shopModal">
        <div class="modal-content">
          
          <div class="shop-header">
            <h2 id="shopName">Pabell√≥n de Tesoros del Drag√≥n Oculto</h2>
            <div class="shop-stats">
              <span id="playerSpiritualStones">Piedras Espirituales: 0</span>
            </div>
          </div>
          <div class="shop-container">
            <div class="shop-filters">
              <h3 class="section-title">Filtros</h3>
              <input
                type="text"
                class="search-box"
                id="shopSearch"
                placeholder="Buscar..."
              />
              <div class="filter-group">
                <div class="filter-title">Categor√≠as</div>
                <ul class="category-list" id="shopCategories">
                  <li class="category-item active" data-category="all">Todas</li>
                  <li class="category-item" data-category="combat">T. Combate</li>
                  <li class="category-item" data-category="cultivation">
                    T. Cultivo
                  </li>
                  <li class="category-item" data-category="weapon">Armas</li>
                  <li class="category-item" data-category="armor">Armaduras</li>
                  <li class="category-item" data-category="consumable">
                    Consumibles
                  </li>
                  <li class="category-item" data-category="material">
                    Materiales
                  </li>
                  <li class="category-item" data-category="scroll">Rollos</li>
                </ul>
              </div>
              <div class="filter-group">
                <div class="filter-title">Rango de Precio</div>
                <div>
                  <input
                    type="range"
                    id="priceRange"
                    min="0"
                    max="1000"
                    value="1000"
                    style="width: 100%"
                  />
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    font-size: 0.8em;
                  "
                >
                  <span>0 PS</span><span id="priceRangeValue">1000 PS</span>
                </div>
              </div>
            </div>
            <div class="shop-products">
              <h3 class="section-title">T√©cnicas y Objetos</h3>
              <div class="products-grid" id="shopProducts"></div>
              <div class="pagination" id="shopPagination"></div>
            </div>
          </div>
          <div>
            <button onclick="closeShopModal()" style="margin-top: 20px">
              Salir de la Tienda
            </button>
          </div>
        </div>
      </div>

      <!-- Modal para Secta -->
      <div class="modal" id="sectHallModal">
        <div class="modal-content" style="max-width: 600px; text-align: left">
          <h3 id="sectHallModalTitle">Sal√≥n de la Secta del Viento Azure</h3>
          <div id="sectHallOptions">
            <p>
              Bienvenido, Disc√≠pulo <span id="sectHallPlayerRank">Externo</span>.
            </p>
            <p>Puntos de Contribuci√≥n: <span id="sectHallPlayerPCS">0</span></p>
            <hr />
            <h4>Tabl√≥n de Misiones</h4>
            <div
              id="sectHallAvailableMissions"
              style="
                max-height: 150px;
                overflow-y: auto;
                margin-bottom: 10px;
                border: 1px solid #444;
                padding: 5px;
              "
            >
              <p>Habla con el Gu√≠a Lin para nuevas asignaciones.</p>
            </div>
            <h4>Contribuciones a la Secta</h4>
            <div id="sectHallContributions" style="margin-bottom: 10px">
              <p>Visita al Administrador Yao para entregar recursos.</p>
            </div>
            <h4>Desaf√≠os de Rango</h4>
            <div id="sectHallRankChallenges" style="margin-bottom: 10px">
              <p id="sectHallChallengeStatus">
                Consulta con el Maestro de la Arena.
              </p>
            </div>
            <h4>Tienda de la Secta</h4>
            <button onclick="openSectShop()">Visitar Dep√≥sito de la Secta</button>
            <hr />
          </div>
          <button
            onclick="closeSectHallModal()"
            style="display: block; margin: 20px auto 0"
          >
            Salir del Sal√≥n
          </button>
        </div>
      </div>
      <!-- Modal gen√©rico para confirmaciones (S√≠/No) -->
    <div class="modal" id="confirmationModal">
      <div class="modal-content" style="max-width: 450px;">
        <h3 id="confirmationModalTitle">Confirmar Acci√≥n</h3>
        <p id="confirmationModalText" style="margin: 15px 0; line-height: 1.5;">¬øEst√°s seguro?</p>
        <div style="display: flex; justify-content: space-around; margin-top: 20px;">
          <button id="confirmBtn" style="background-color: #4CAF50;">Confirmar</button>
          <button id="cancelBtn" onclick="closeConfirmationModal()" style="background-color: #f44336;">Cancelar</button>
        </div>
      </div>
    </div>
      <!-- Modal para Misiones -->
      <div class="modal" id="missionsModal">
          <div class="modal-content" style="max-width: 600px; text-align: left;">
          <h3 style="text-align: center;">Diario de Misiones</h3>
          <div id="missionsContainer" style="margin-top: 15px; max-height: 400px; overflow-y: auto; padding-right: 10px;">
              <!-- El contenido de las misiones se generar√° aqu√≠ -->
          </div>
          <button onclick="closeMissionsModal()" style="display: block; margin: 20px auto 0;">Cerrar</button>
          </div>
      </div>
      <!-- Modal para Revisi√≥n de Batalla -->
      <div class="modal" id="battleReviewModal">
          <div class="modal-content" style="max-width: 600px; text-align: left;">
          <h3 style="text-align: center;">Resumen del Combate</h3>
          <div id="battleReviewLog" style="margin-top: 15px; max-height: 60vh; overflow-y: auto; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; font-size: 0.9em; line-height: 1.5;">
              <!-- El log de la batalla se insertar√° aqu√≠ -->
          </div>
          <button onclick="closeBattleReviewModal()" style="display: block; margin: 20px auto 0;">Cerrar</button>
          </div>
      </div>
      
      <!-- Modal para Selecci√≥n de Cultivo -->
      <div class="modal" id="cultivationChoiceModal">
        <div class="modal-content" style="max-width: 500px; text-align: left">
          <h3>¬øQu√© deseas cultivar?</h3>
          <div id="cultivationOptionsContainer">
            <button
              class="cultivation-option-btn"
              onclick="startCultivationMode('recovery')"
            >
              üßò Meditaci√≥n Restauradora
            </button>
            <hr />
            <h4>Cultivar T√©cnica:</h4>
            <div
              id="cultivableTechniquesList"
              style="max-height: 200px; overflow-y: auto"
            ></div>
          </div>
          <button
            onclick="closeCultivationChoiceModal()"
            style="margin-top: 20px"
          >
            Cancelar
          </button>
        </div>
      </div>

      <!-- Modal gen√©rico para interacciones y notificaciones -->
      <div class="modal" id="interactionModal">
        <div class="modal-content" style="max-width: 450px">
          <h3 id="modalTitle">T√≠tulo del Modal</h3>
          <p
            id="modalText"
            style="margin-top: 15px; margin-bottom: 20px; line-height: 1.5"
          >
            Texto.
          </p>
          <button onclick="closeModal()" class="close-modal-btn">Cerrar</button>
        </div>
      </div>

      <!-- Modal para T√©cnicas -->
      <div class="modal" id="techniqueModal">
        <div class="modal-content" style="max-width: 600px; text-align: left">
          <h3 style="text-align: center">T√©cnicas Aprendidas</h3>
          <div
            id="learnedTechniquesContainer"
            style="
              margin-top: 15px;
              max-height: 400px;
              overflow-y: auto;
              padding-right: 10px;
            "
          ></div>
          <button
            onclick="closeTechniqueModal()"
            style="display: block; margin: 20px auto 0"
          >
            Cerrar
          </button>
        </div>
      </div>

      <!-- Modal para Recompensa de Ascenso de Rango -->
      <div class="modal" id="rankUpRewardModal">
        <div class="modal-content" style="max-width: 550px; text-align: left;">
          <h3 id="rankUpRewardTitle">Recompensa por Ascenso</h3>
          <p>Como reconocimiento a tu progreso, la secta te otorga un manual de t√©cnica. Elige sabiamente, pues este conocimiento definir√° tu camino.</p>
          <div id="rankUpRewardOptionsContainer" style="margin-top: 15px;">
            <!-- Las opciones de recompensa se generar√°n aqu√≠ -->
          </div>
          <button onclick="closeRankUpRewardModal()" style="margin-top: 20px;">Decidir√© m√°s tarde</button>
        </div>
      </div>

      <!-- ================================================================= -->
      <!-- CORRECCI√ìN 2: BARRA DE NAVEGACI√ìN SUPERIOR RELLENADA CON BOTONES -->
      <!-- Se han a√±adido los botones que faltaban. Ahora el JavaScript podr√° encontrarlos
          y asignarles las funciones de click correspondientes. -->
      <nav class="top-nav-bar" id="topNavBar">
          <button id="navBtnCharacter" class="nav-button">
              <div class="nav-icon">üë§</div>
              <span class="nav-text">Personaje</span>
          </button>
          <button id="navBtnMissions" class="nav-button">
              <div class="nav-icon">üìñ</div>
              <span class="nav-text">Misiones</span>
          </button>
          <button id="navBtnInventory" class="nav-button">
              <div class="nav-icon">üéí</div>
              <span class="nav-text">Inventario</span>
          </button>
          <button id="navBtnCultivate" class="nav-button">
              <div class="nav-icon">üßò</div>
              <span class="nav-text">Cultivar</span>
          </button>
          <button id="navBtnTechniques" class="nav-button">
              <div class="nav-icon">üìú</div>
              <span class="nav-text">T√©cnicas</span>
          </button>
          <button id="navBtnMenu" class="nav-button">
              <div class="nav-icon">‚öôÔ∏è</div>
              <span class="nav-text">Men√∫</span>
          </button>
      </nav>
      <!-- ================================================================= -->
      <script>

  let lastSuccessfulMoveTime = 0;
          const PLAYER_MOVE_COOLDOWN = 250;  // <-- ¬°ESTE ES EL N√öMERO QUE AJUSTAR√ÅS! (en milisegundos)
          const topNavBar = document.getElementById("topNavBar");
        const navBtnInventory = document.getElementById('navBtnInventory');
          console.log("Bot√≥n de Inventario (navBtnInventory):", navBtnInventory);     
        const navBtnCharacter = document.getElementById("navBtnCharacter");
        const navBtnCultivate = document.getElementById("navBtnCultivate");
        const navBtnTechniques = document.getElementById("navBtnTechniques");
        const navBtnMenu = document.getElementById("navBtnMenu");
        let movePlayerCallCount = 0;
        // --- ESTADO DEL JUEGO ---
        let gameState = {
          /* ... (tu gameState existente sin cambios) ... */
        };
        // Estado del juego y datos principales
        gameState = {
          player: {
            x: 11,
            y: 15,
            level: 1,
            baseMaxHp: 100,
            baseMaxMana: 50,
            baseAttack: 15,
            baseDefense: 5,
            hp: 100,
            maxHp: 100,
            mana: 50,
            maxMana: 50,
            attack: 15,
            defense: 5,
            exp: 0,
            expToNext: 100,
            realm: "Mortal",
            quickSlots: [null, null, null, null, null], // 5 slots, inicialmente vac√≠os
            isCultivating: false,
            cultivationMode: {
              type: null,
              targetId: null,
              startTime: 0,

            },
            cultivationStartTime: 0,
            qiPerSecondBase: 1,
            expPerSecondBase: 0.5,
            hpPerSecondBase: 1,
            learnedTechniques: {},
            activeRefiningTechniqueId: null,
            canUseQiConversion: false,
            isQiConversionActive: false,
            worldState: {
              defeatedBosses: {},
              currentBossToSpawn: "boss_dem",
              defeatedFixedEntities: {},
            },
            secta: {
              nombre: "Secta del Viento Azure",
              rango: "Disc√≠pulo Externo",
              puntosContribucion: 0,
              misionesActivas: [],
              misionesCompletadas: {},
              rivalesDerrotadosClave: {},
            },
            // ---- PROPIEDADES DE ANIMACI√ìN DEL SPRITE - ASEG√öRATE QUE EST√âN AQU√ç Y CORRECTAS ----
            spriteSheetUrl: "img/personaje_cultivador_spritesheet.png",
            frameWidth: 64, // Ancho de un solo frame del sprite
            frameHeight: 64, // Alto de un solo frame del sprite
            directionRowMap: {
              // Mapeo de direcci√≥n a la fila Y en la hoja de sprites (0-indexed)
              down: 0, // Fila 0 para mirar/caminar hacia abajo
              left: 1, // Fila 1 para mirar/caminar hacia la izquierda
              right: 2, // Fila 2 para mirar/caminar hacia la derecha
              up: 3, // Fila 3 para mirar/caminar hacia arriba
            },
            animationFrames: 4, // N√∫mero de frames por direcci√≥n en la hoja
            currentFrame: 0, // Frame actual de la animaci√≥n (0 a animationFrames - 1)
            currentDirection: "down", // Direcci√≥n inicial: 'up', 'down', 'left', 'right'
            isMoving: false,
            animationTimer: null, // Para el intervalo de la animaci√≥n de caminar
            idleTimeout: null, // Para volver al estado idle despu√©s de moverse
            animationSpeed: 150, // Milisegundos entre frames de animaci√≥n
            // ---- FIN PROPIEDADES DE ANIMACI√ìN ----
            // NUEVO: Para animaci√≥n de sprites
            sprites: {
              idle: "img/personaje_cultivador_idle.png", // O 'img/personaje_cultivador_down.png' si es tu frontal
              up: "img/personaje_cultivador_up.png",
              down: "img/personaje_cultivador_down.png",
              left: "img/personaje_cultivador_left.png",
              right: "img/personaje_cultivador_right.png",
            },
            currentSpriteKey: "idle", // 'idle', 'up', 'down', 'left', 'right'
            movementAnimationTimeout: null,
            
            defenseBoostTurns: 0,
            defenseBoostAmount: 0,
            // ===  DEBUFFS ===
            defenseReductionTurns: 0,
            defenseReductionAmount: 0,
            attackReductionTurns: 0,
            attackReductionAmount: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            burningTurns: 0,
            burnDamage: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            // ===================================
            dodgeNextAttack: false,
            healingRainTurns: 0,
            
            defenseBoostTurns: 0,
            defenseBoostAmount: 0,
            dodgeNextAttack: false,
            healingRainTurns: 0,
            healingRainAmount: 0,
            // Para Ritual de Sangre
            bloodRitualTurns: 0,
            bloodRitualAttackBoost: 0,
            // Nuevos estados para t√©cnicas de alto nivel
            isImmuneToStatus: false, // Inmunidad a quemaduras, veneno, stun, etc.
            passiveHpRegen: 0, // Cantidad de HP a regenerar por segundo pasivamente
            reviveChance: 0, // Probabilidad de resucitar al morir
            deathSaveChance: 0, // Probabilidad de sobrevivir con 1 HP
            damageToHealingTurns: 0, // Turnos para convertir da√±o en curaci√≥n
            intangibleTurns: 0, // Turnos de ser intangible (inmune a da√±o directo)
            canRevive: false, // Flag activado por Llama del F√©nix
            // Fin nuevos estados
            // Para Aura de Pureza
            immuneTurns: 0,
          },
          cultivationInterval: null,
          inventory: {
            "Piedras Espirituales": 0,
            "Hierbas Medicinales": 0,
            "Cristales de Qi": 0,
          },
          map: {
            width: 600, // M√°s peque√±o para pruebas iniciales
            height: 600,
            defaultTerrain: "GRASSLAND",
            terrainZones: [


              // ARENA DE LA SECTA
              {
                x1: 4,
                y1: 12,
                x2: 8,
                y2: 16, // Ejemplo de coordenadas (ajusta seg√∫n tu mapa)
                type: "ARENA", // Puedes usar 'DESERT' o crear un G_TERRAIN_TYPES.ARENA
                name: "Arena de la Secta",
                // No necesita spawnSettings por ahora, a menos que quieras peque√±os mobs decorativos all√≠.
              },
              // Ejemplo de Zona de Inicio cerca de la Secta (PRADERA)
             //ZONAS
              

             {
                x1: 2,
                y1: 10,
                x2: 29,
                y2: 24,
               

                
                type: "GRASSLAND",
                name: "Terreno de la Secta (Seguro)", 
             
              },
              {
                x1: 2,
                y1: 25,
                x2: 29,
                y2: 39,
               

                
                type: "GRASSLAND",
                name: "Praderas de la Secta",
                spawnSettings: {
                  targetEntities: [
                    // Lista de objetivos de spawn para esta zona
                    {
                      entityTypeId: "monster_secta_debil",
                      count: 10,
                      currentCount: 0,
                    },
                    { entityTypeId: "monster", count: 10, currentCount: 0 },
                    {
                      entityTypeId: "resource_hierbas_bosque",
                      count: 3,
                      currentCount: 0,
                    },
                    { entityTypeId: "cristal_qi", count: 3, currentCount: 0 },
                    {
                      entityTypeId: "cultivator_rival_low",
                      count: 5,
                      currentCount: 0,
                    },
                  ],
                  respawnTimer: 0, // Cuando llegue a 0, puede reaparecer
                  respawnCooldown: 300, // Segundos para reaparecer despu√©s de vaciarse o parcialmente
                  lastSpawnCheck: 0, // Timestamp del √∫ltimo intento de spawn
                },
              },
              // Bosque Esmeralda
              {
                  x1: 30,
                  y1: 10,
                  x2: 59,
                  y2: 39,
                  type: "GRASSLAND", // <-- El terreno base ahora es hierba
                  name: "Bosque Esmeralda",
                  decorations: [ 
                      { entityTypeId: 'deco_arbol_grande', density: 0.1 }, // 10% de las celdas tendr√°n un √°rbol grande
                      { entityTypeId: 'deco_arbol_normal', density: 0.3 }, // 30% tendr√°n un √°rbol normal
                      { entityTypeId: 'deco_roca_musgosa', density: 0.05 }  // 5% tendr√°n una roca
                  ],
                  spawnSettings: { 
                      targetEntities: [
                          { entityTypeId: "monster_bosque_lobo", count: 8, currentCount: 0 },
                          { entityTypeId: "monster_bosque_arana", count: 5, currentCount: 0 },
                          { entityTypeId: "resource_hierbas_bosque", count: 3, currentCount: 0 },
                          { entityTypeId: "monster_alpha", count: 5, currentCount: 0 },
                      ],
                      respawnTimer: 0,
                      respawnCooldown: 450,
                      lastSpawnCheck: 0,
                  },
              },
              // Desierto Abrasador
              {
                x1: 1,
                y1: 41,
                x2: 90,
                y2: 69,
                type: "DESERT",
                name: "Desierto Abrasador",
                decorations: [ 
                      { entityTypeId: 'deco_desierto', density: 0.05 }, // 5% de las celdas tendr√°n un √°rbol grande
                      
              
                  ],
                spawnSettings: {
                  targetEntities: [
                    {
                      entityTypeId: "monster_desierto_escorpion",
                      count: 7,
                      currentCount: 0,
                    },
                    {
                      entityTypeId: "monster_desierto_golem_arena",
                      count: 2,
                      currentCount: 0,
                      isElite: true,
                    }, // Golem como elite
                  ],
                  respawnTimer: 0,
                  respawnCooldown: 600,
                  lastSpawnCheck: 0,
                },
              },
              // RUINAS
              {
                x1: 500, y1: 500,
                x2: 550, y2: 550,
                type: "RUINS",
                name: "Coraz√≥n de las Ruinas Olvidadas",
                decorations: [ 
                      
                      { entityTypeId: 'deco_ruina_pilar', density: 0.02 }, 
                     
                  ],
                isIsolated: true,          // Marca esta zona como un "mapa" separado
                ambientColor: '#1a1a1a',   // Color del "vac√≠o" alrededor de la zona
                spawnSettings: {
                  targetEntities: [
                    { entityTypeId: "esqueleto_podrido", count: 25, currentCount: 0 },
                    { entityTypeId: "boss_ancient_golem", count: 25, currentCount: 0 }, 
                  ],
                  respawnTimer: 0,
                  respawnCooldown: 400,
                  lastSpawnCheck: 0,
                },
              },
              // Ci√©naga Sombr√≠a
              {
                x1: 60,
                y1: 15,
                x2: 90,
                y2: 45,
                type: "SWAMP",
                name: "Ci√©naga Sombr√≠a",
                decorations: [ // <-- NUEVA PROPIEDAD
                      { entityTypeId: 'deco_arbol_pantano', density: 0.1 }, // 10% de las celdas tendr√°n un √°rbol grande
                      { entityTypeId: 'deco_agua_estancada', density: 0.05 }
              
                  ],
                spawnSettings: {
                  targetEntities: [
                    {
                      entityTypeId: "monster_cienaga_serpiente",
                      count: 4,
                      currentCount: 0,
                    },
                  ],
                  respawnTimer: 0,
                  respawnCooldown: 400,
                  lastSpawnCheck: 0,
                },
              },
              //L√çMITES DE MAPA
              // ... otras zonas (monta√±as, ruinas, agua sin spawns de monstruos terrestres)
              {
                x1: 0,
                y1: 0,
                x2: 190,
                y2: 8,
                type: "MOUNTAIN_SUP",
                name: "Monta√±as del Norte",
              }, // Sin spawnSettings = no spawns
              {
                x1:-20,
                y1: 0,
                x2: 0,
                y2: 600,
                type: "MOUNTAIN_SUP",
                name: "Monta√±as del Norte",
              }, // Sin spawnSettings = no spawns
              {
                x1: 92,
                y1: 0,
                x2: 190,
                y2: 600,
                type: "MOUNTAIN_SUP",
                name: "Monta√±as del Norte",
              }, // Sin spawnSettings = no spawns
              {
                x1: 91,
                y1: 9,
                x2: 91,
                y2: 9,
                type: "MOUNTAIN_SUP_DER",
                name: "Monta√±as del Norte",
              }, // Sin spawnSettings = no spawns
               {
                x1: 1,
                y1: 9,
                x2: 1,
                y2: 9,
                type: "MOUNTAIN_SUP_IZQ",
                name: "Monta√±as del Norte",
              }, // Sin spawnSettings = no spawns
              {
                x1: 1,
                y1: 40,
                x2: 1,
                y2: 40,
                type: "MOUNTAIN_INF_IZQ",
                name: "Monta√±as del Norte",
              }, // Sin spawnSettings = no spawns
               {
                x1: 1,
                y1: 69,
                x2: 1,
                y2: 69,
                type: "MOUNTAIN_INF_IZQ",
                name: "borde desierto",
              }, // Sin spawnSettings = no spawns
               {
                x1: 2,
                y1: 40,
                x2: 23,
                y2: 40,
                type: "MOUNTAIN_ABAJO_SUP",
                name: "frontera pradera-desierto",
              }, // Sin spawnSettings = no spawns
              {
                x1: 26,
                y1: 40,
                x2: 89,
                y2: 40,
                type: "MOUNTAIN_ABAJO_SUP",
                name: "frontera pradera-desierto",
              }, // Sin spawnSettings = no spawns
                {
                x1: 1,
                y1: 70,
                x2: 89,
                y2: 70,
                type: "MOUNTAIN_ABAJO_SUP_DES",
                name: "l√≠mite inferior desierto",
              }, // Sin spawnSettings = no spawns
              {
                x1: 1,
                y1: 71,
                x2: 89,
                y2: 90,
                type: "MOUNTAIN_SUP",
                name: "l√≠mite inferior desierto",
              }, // Sin spawnSettings = no spawns
              
          
              {
                x1: 2,
                y1: 9,
                x2: 90,
                y2: 9,
                type: "MOUNTAIN_FRENTE",
                name: "l√≠mite norte",
              }, // Sin spawnSettings = no spawns
              {
                x1: 91,
                y1: 10,
                x2: 91,
                y2: 600,
                type: "MOUNTAIN_DER",
                name: "L√≠mite este",
              }, // Sin spawnSettings = no spawns
              {
                x1: 1,
                y1: 10,
                x2: 1,
                y2: 39,
                type: "MOUNTAIN_IZQ",
                name: "l√≠mite oeste pradera",
              }, // Sin spawnSettings = no spawns
              // ...
            
              
            ],
            terrainGrid: null,
            entities: [],
          },
          battle: {
            active: false,
            enemy: null,
            playerTurn: true,
          },
          gameTime: 0, // Un simple contador de segundos del juego para los temporizadores
          lastGameTimeUpdate: Date.now(),
          activeCombatAbilities: [],
        };

        let battleLogHistory = [];

        // --- CONSTANTES Y DATOS DEL JUEGO --- (sin cambios, deben estar aqu√≠)
        let G_TILE_SIZE = 100; // Valor por defecto para escritorio
        const G_PLAYER_DISCOVERY_RANGE = 3;
        // --- VARIABLES GLOBALES ADICIONALES PARA CONTROL UI M√ìVIL ---
        let mapControlsManuallyHidden = false;
        let currentTileSize = G_TILE_SIZE; // Usaremos este para los c√°lculos de renderizado
        let recoveryProgress = 0;
        let recoveryDirection = 1; // 1 para aumentar, -1 para disminuir
        const RECOVERY_CYCLE_DURATION = 2;
        const G_COMBAT_ENTITY_TYPES = [
          "monster",
          "esqueleto_podrido",
          "bandido_desfiladero",
          "monster_desierto_escorpion",
          "monster_secta_debil",
          "monster_alpha",
          "cultivator_rival_low",
          "cultivator_adept_hostile",
          "boss_dem",
          "boss_ancient_golem",
          "monster_cienaga_serpiente",
          "monster_bosque_lobo",
          "monster_bosque_arana",
          "monster_desierto_golem_arena",
          "jabali_colmilludo_alfa",
          "jabali_alfa_1",
          "jabali_alfa_2",
          "jabali_alfa_3",
          "jabali_alfa_4",
          "jabali_alfa_5",
          "jabali_alfa_6",
          "jabali_alfa_7",
          "jabali_alfa_8",
          "jabali_alfa_9",
          "jabali_alfa_10",
          "jabali_alfa_11",
          "jabali_alfa_12",
           
        ];
        const G_MAX_MAP_ENTITIES = 30;
        const G_RESPAWN_THRESHOLD = 15;
        const G_SAFE_RESPAWN_X = 10;
        const G_SAFE_RESPAWN_Y = 10;
        const G_SAFE_RESPAWN_SEARCH_RADIUS = 3;
        const G_TERRAIN_TYPES = {
          VOID: {
            textureUrl: "img/mont_sup.png", // ¬°Aseg√∫rate de que esta imagen exista!
            name: "Vac√≠o"
          },
          ARENA: { 
            symbol: "üèüÔ∏è",
            textureUrl: "img/b_arena.png", 
            color: "#D2B48C", 
            name: "Arena" },

          GRASSLAND: { 
              symbol: "üü©", 
              textureUrl: "img/grassland.png",
              color: "#34A853", 
              name: "Pradera" 
          
          }, // Verde para pastizales
          FOREST: { 
              symbol: "üå≤", 
              textureUrl: "img/grassland.png",
              color: "#1E824C", 
              name: "Bosque" 
          }, // Verde oscuro para bosques
          MOUNTAIN_FRENTE: { 
              symbol: "‚õ∞Ô∏è", 
              textureUrl: "img/mont_frente.png",
              color: "#A9A9A9", 
              name: "Monta√±a" 
          }, // Gris para monta√±as
          MOUNTAIN_SUP: { 
              symbol: "‚õ∞Ô∏è", 
              textureUrl: "img/mont_sup.png",
              color: "#A9A9A9", 
              name: "Monta√±a" 
          }, 
            MOUNTAIN_SUP_DER: { 
              symbol: "‚õ∞Ô∏è", 
              textureUrl: "img/mont_sup_der.png",
              color: "#A9A9A9", 
              name: "Monta√±a" 
          }, 
          MOUNTAIN_SUP_IZQ: { 
              symbol: "‚õ∞Ô∏è", 
              textureUrl: "img/mont_sup_izq.png",
              color: "#A9A9A9", 
              name: "Monta√±a" 
          }, 
           MOUNTAIN_DER: { 
              symbol: "‚õ∞Ô∏è", 
              textureUrl: "img/mont_der.png",
              color: "#A9A9A9", 
              name: "Monta√±a" 
          }, 
          MOUNTAIN_IZQ: { 
              symbol: "‚õ∞Ô∏è", 
              textureUrl: "img/mont_izq.png",
              color: "#A9A9A9", 
              name: "Monta√±a" 
          }, 
           MOUNTAIN_INF_IZQ: { 
              symbol: "‚õ∞Ô∏è", 
              textureUrl: "img/mont_int_inf_izq.png",
              color: "#A9A9A9", 
              name: "Monta√±a" 
          }, 
          MOUNTAIN_ABAJO_SUP: { 
              symbol: "‚õ∞Ô∏è", 
              textureUrl: "img/mont_abajo_sup.png",
              color: "#A9A9A9", 
              name: "Monta√±a" 
          }, 
             MOUNTAIN_ABAJO_SUP_DES: { 
              symbol: "‚õ∞Ô∏è", 
              textureUrl: "img/mont_abajo_sup_des.png",
              color: "#A9A9A9", 
              name: "Monta√±a" 
          },
          WATER: { 
              symbol: "üü¶", 
              color: "#4A86E8", 
              name: "Agua" }, // Azul para agua (intransitable)
          RUINS: { 
              symbol: "üèõÔ∏è", 
              textureUrl: "img/suelo_ruinas.png",
              color: "#706050", 
              name: "Ruinas" 
          }, // Marr√≥n/Gris para ruinas
          DESERT: { 
              symbol: "üü®",
              textureUrl: "img/arena.png", 
              color: "#F9E79F", 
              name: "Desierto" 
          }, // Amarillo claro para desierto
          SWAMP: { 
              symbol: "üü™", 
              textureUrl: "img/pantano.png",
              color: "#5D3A9A", 
              name: "Pantano" 
          }, // P√∫rpura/Verde oscuro para pantano
          
          // A√±ade m√°s seg√∫n necesites
        };

        const PLAYER_SPRITE_FRAME_WIDTH = 64; // <--- ¬°AJUSTA ESTO AL ANCHO DE UN FRAME DE TU SPRITE!
        const PLAYER_SPRITE_FRAME_HEIGHT = 64; // <--- ¬°AJUSTA ESTO AL ALTO DE UN FRAME DE TU SPRITE!
        const PLAYER_ANIMATION_SPEED = 150; // Milisegundos entre frames de caminata (ajusta a gusto)
        const PLAYER_WALK_CYCLE = [0, 1, 0, 2]; // Los frames de columna a ciclar para caminar.
        // Si tu animaci√≥n es 0-1-2-1, ser√≠a [0,1,2,1]
        // Si es 0-1-0-2 ser√≠a [0,1,0,2] (para un efecto de pie y luego paso)
        // Para tu sprite de 4 frames por direcci√≥n: [0, 1, 2, 3] y el frame 0 es el de "quieto"
        // o puedes usar [1,2,3,0] si el 0 es un frame de paso
        // Una animaci√≥n com√∫n es "quieto" -> paso1 -> "quieto" -> paso2
        // O para ciclo continuo: paso1 -> paso2 -> paso3 -> paso4 -> paso1 ...
        // Para el sprite que mostraste, parece ser:
        // Frame 0: Quieto
        // Frame 1: Paso A
        // Frame 2: Quieto (o un frame intermedio)
        // Frame 3: Paso B
        // Entonces un ciclo podr√≠a ser [0, 1, 0, 3] o [1,0,3,0] para animaci√≥n mientras se mueve
        // O si todos son frames de paso: [0,1,2,3]
        // VAMOS A USAR UN CICLO [1,0,3,0] (asumiendo frame 0 es el base/quieto y 1,3 son pasos)
        // Si el frame 0 es un paso y el personaje se "desliza" al estar quieto, cambia esto.
        // Definir las posiciones Y del sprite sheet para cada direcci√≥n
        const PLAYER_SPRITE_DIRECTIONS_Y = {
          down: 0 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 1 (√≠ndice 0) para caminar hacia abajo
          left: 1 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 2 (√≠ndice 1) para caminar hacia la izquierda
          right: 2 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 3 (√≠ndice 2) para caminar hacia la derecha
          up: 3 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 4 (√≠ndice 3) para caminar hacia arriba
        };
        // Podr√≠amos a√±adir una propiedad 'walkable' a cada tipo de terreno
        G_TERRAIN_TYPES.MOUNTAIN_FRENTE.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables 
        G_TERRAIN_TYPES.MOUNTAIN_SUP.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_SUP_DER.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_DER.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_IZQ.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP_DES.walkable = false
        G_TERRAIN_TYPES.WATER.walkable = false;
        // Por defecto, asumimos que son transitables si no se especifica 'walkable: false'
        const G_BLOCKING_ENTITY_TYPES = [
          "shop",
          "secta_entrada_principal",
          "npc_secta_guia",
          "npc_secta_admin",

          // A√±ade aqu√≠ otros 'originalEntityTypeId' o 'type' de entidades que deben bloquear
          // Por ejemplo, si tus NPCs tienen un 'type' espec√≠fico o los identificas por 'npcId'
        ];
        const SECTA_DATA = {
          nombre: "Secta del Viento Azure",
          rangos: [
            {
              nombre: "Disc√≠pulo Externo",
              pcsRequeridos: 0,
              beneficios: "Acceso b√°sico a la secta.",
            },
            {
              nombre: "Disc√≠pulo Interno", // GRADO 1
              pcsRequeridos: 50,
              desafioRivalId: "rival_interno_1",
              beneficios: "Acceso al Patio Interno, misiones de mayor nivel, +5% ganancia de Qi al cultivar en la secta.",
              techniqueChoice: ["sword_t1", "body_t1", "formation_t1", "fire_t1", "lightning_t1"]
            },
            {
              nombre: "Disc√≠pulo Principal", // GRADO 2
              pcsRequeridos: 200,
              desafioRivalId: "rival_principal_1",
              beneficios: "Acceso a la Biblioteca de T√©cnicas (nuevas t√©cnicas), +10% ganancia de EXP en misiones de secta.",
              techniqueChoice: ["sword_t2", "body_t2", "formation_t2", "movement_t2", "fire_t2"]
            },
            {
              nombre: "Di√°cono", // GRADO 3
              pcsRequeridos: 500,
              desafioRivalId: "guardian_diacono_1",
              beneficios: "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir peque√±os grupos de disc√≠pulos (mec√°nica futura).",
              techniqueChoice: ["sword_t3", "body_t3", "formation_t3", "lightning_t3", "movement_t3"]
            },
            {
              nombre: "Anciano", // GRADO 4
              pcsRequeridos: 1500,
              desafioRivalId: "guardian_anciano_1",
              beneficios: "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir medianos grupos de disc√≠pulos (mec√°nica futura).",
              techniqueChoice: ["sword_t4", "body_t4", "fire_t4", "lightning_t4", "formation_t4"]
            },
            {
              nombre: "Gran Anciano", // GRADO 5
            pcsRequeridos: 2500,
            desafioRivalId: "guardian_gran_anciano_1",
            beneficios: "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir grandes grupos de disc√≠pulos (mec√°nica futura).",
            techniqueChoice: ["sword_t5", "body_t5", "fire_t5", "lightning_t5", "formation_t5", "movement_t5"]
          },
          {
            nombre: "Maestro de Secta", // GRADO 6
            pcsRequeridos: 5000,
            desafioRivalId: "guardian_maestro_1",
            beneficios: "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir la secta completa (mec√°nica futura).",
            techniqueChoice: ["sword_t6", "body_t6", "fire_t6", "lightning_t6", "formation_t6", "movement_t6"]
          },
          // === NUEVOS RANGOS A√ëADIDOS ===
          {
            nombre: "Patriarca", // GRADO 7
            pcsRequeridos: 10000,
            desafioRivalId: "guardian_patriarca_1", // Necesitar√≠as definir este rival
            beneficios: "Tu influencia trasciende la secta. Obtienes acceso a dominios secretos.",
            techniqueChoice: ["sword_t7", "body_t7", "fire_t7", "lightning_t7", "formation_t7", "movement_t7"]
          },
          {
            nombre: "Soberano Inmortal", // GRADO 8
            pcsRequeridos: 25000,
            desafioRivalId: "guardian_soberano_1", // Necesitar√≠as definir este rival
            beneficios: "Tu nombre es leyenda. El mundo mortal ya no puede contenerte.",
            techniqueChoice: ["sword_t8", "body_t8", "fire_t8", "lightning_t8", "formation_t8", "movement_t8"]
          },
          {
            nombre: "Soberano del Dao", // GRADO 9
            pcsRequeridos: 50000,
            desafioRivalId: "guardian_dao_1", // Necesitar√≠as definir este rival
            beneficios: "Te has fusionado con el Gran Dao. Eres uno con la creaci√≥n.",
            techniqueChoice: ["sword_t9"] // Ejemplo con una sola t√©cnica definitiva
          },
          ],
          npcs: {
            guia_lin: {
              nombre: "Gu√≠a Lin",
              rol: "Maestro de Reclutas",
              dialogoInicial:
                "Bienvenido, joven aspirante... ¬øEst√°s listo para empezar? Compra Items con Piedras espirituales,aprende t√©cnicas, completa misiones y sube de rango en la secta",
                
              misionesOfrecidas: [
                "mision_recolectar_hierbas_1", // Aunque la entrega sea a Yao, Lin puede ofrecerla
                "mision_eliminar_demonios_1",
                "mision_lobos_bosque_1", // Nueva misi√≥n ofrecida por Lin
                "mision_cultivador_hostil_1", // Nueva misi√≥n ofrecida por Lin
                "mision_componentes_alquimia_1",
                "mision_investigar_anomalia_1",
                "mision_cazar_bestia_especifica_1",
                "mision_escolta_mercader_1",
                "mision_recuperar_artefacto_1",
                // ... a√±ade m√°s ID de misiones que Lin ofrezca
              ],
            },
            admin_yao: {
              nombre: "Administrador Yao",
              rol: "Intendente de la Secta",
              dialogoInicial:
                "Entrega recursos valiosos o completa encargos para ganar Puntos de Contribuci√≥n. Tambi√©n puedes adquirir algunos suministros aqu√≠.",
              aceptaRecursos: [
                "Hierbas Medicinales",
                "Cristales de Qi",
                "N√∫cleo de Bestia Menor",
              ], // ...etc.
              tiendaSectaId: "tienda_secta_basica",
              misionesOfrecidas: [
                "mision_escorpiones_desierto_1", // Nueva misi√≥n ofrecida por Yao
                // ... a√±ade m√°s ID de misiones que Yao ofrezca
              ],
            },
          },
        };
        const MISIONES_DATA = {
          mision_recolectar_hierbas_1: {
            titulo: "Suministros para la Enfermer√≠a",
            descripcion:
              "La hermana mayor Mei necesita 10 Hierbas Medicinales para reponer las existencias de la enfermer√≠a. Recolecta Hierbas Medicinales y entr√©gaselas al Administrador Yao.",
            objetivo: {
              tipo: "entregar_item",
              item: "Hierbas Medicinales",
              cantidad: 10,
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 50,
              exp: 100,
              items: { "Piedras Espirituales": 20 },
            },
            npcInicio: "guia_lin",
          },
          mision_eliminar_demonios_1: {
              titulo: "Limpiando la pradera de la secta",
              descripcion:
              "Peque√±os demonios han estado merodeando en la pradera cercana al sur de la secta. Elimina 5 Demonios Menores para asegurar el √°rea y reporta tu √©xito al Gu√≠a Lin.",
              objetivo: {
                  tipo: "eliminar_enemigo",
                  enemigoTipo: "monster",
                  cantidad: 5,
                  nombreDisplay: "Demonio Menor",
                  npcEntrega: "guia_lin",
              },
              recompensa: {
                  pcs: 75,
                  exp: 150,
                  items: { "Piedras Espirituales": 30 },
              },
              npcInicio: "guia_lin", // Ahora esta es la √∫ltima propiedad
          },
          mision_componentes_alquimia_1: {
            titulo: "Medicina Urgente",
            descripcion:
              "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Ra√≠ces de Fuego Terrenal' para una p√≠ldora vital. Se dice que crecen en zonas con fluctuaciones elementales.",
            objetivo: {
              tipo: "recolectar_multiples_items",
              items: [
                { nombre: "Flor de Luna Escarchada", cantidad: 3 },
                { nombre: "Ra√≠z de Fuego Terrenal", cantidad: 2 },
              ],
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 120,
              exp: 250,
              items: {
                "P√≠ldora de Recuperaci√≥n Menor": 2,
                "Piedras Espirituales": 50,
              },
            },
            npcInicio: "guia_lin",
            requisitoRango: "Disc√≠pulo Externo",
          },
          
          
          /* mision_escolta_mercader_1: {
            titulo: "Protecci√≥n Mercantil",
            descripcion:
              "Un mercader aliado de la secta necesita una escolta para atravesar el Desfiladero Sombr√≠o, conocido por sus bandidos. Aseg√∫rate de que llegue a salvo al Puesto Comercial del Oeste.",
            objetivo: {
              tipoSimplificado: "eliminar_enemigos_en_area",
              enemigoTipo: "bandido_desfiladero",
              cantidad: 5,
              areaNombre: "Desfiladero Sombr√≠o",
              npcReporte: "admin_yao",
            },
            recompensa: {
              pcs: 250,
              exp: 500,
              items: {
                "Mapa del Tesoro Fragmentado": 1,
                "Piedras Espirituales": 150,
              },
            },
            npcInicio: "guia_lin",
            requisitoRango: "Disc√≠pulo Interno",
          }, */
          mision_recuperar_artefacto_1: {
            titulo: "El Comp√°s Espiritual Perdido",
            descripcion:
              "Un antiguo Comp√°s Espiritual, vital para la navegaci√≥n en las Ruinas Olvidadas, fue robado por cultivadores renegados. Inf√≠ltrate en su campamento en las colinas y recupera el artefacto.",
            objetivo: {
              tipo: "derrotar_mini_boss_y_recuperar_item",
              enemigoMiniBossId: "lider_renegado_1",
              itemArtefacto: "Comp√°s Espiritual Antiguo",
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 300,
              exp: 600,
              items: {
                "Manual de Formaci√≥n B√°sica": 1,
                "Piedras Espirituales": 200,
              },
            },
            npcInicio: "guia_lin",
            requisitoRango: "Disc√≠pulo Interno",
            requisitoNivel: 8,
          },
          mision_desafio_interno_1: {
            titulo: "Prueba de Disc√≠pulo Interno",
            descripcion:
              "Para ser reconocido como Disc√≠pulo Interno, debes demostrar tu fuerza venciendo al Guardi√°n de la Prueba, Han Li. Encu√©ntralo en la arena de desaf√≠os de la secta.",
            objetivo: {
              tipo: "derrotar_npc_especifico",
              npcId: "rival_interno_1",    
              npcEntrega: "guia_lin", 
            },
            recompensa: { pcs: 200, exp: 300, nuevoRango: "Disc√≠pulo Interno" },
            autoActivarAlCumplirRequisitos: true,
          },
          mision_desafio_principal_1: {
            titulo: "Prueba de Disc√≠pulo Principal",
            descripcion:
              "La Anciana Shui espera en la arena. Demuestra que eres digno del rango de Disc√≠pulo Principal.",
            objetivo: {
              tipo: "derrotar_npc_especifico",
              npcId: "rival_principal_1",
              npcEntrega: "guia_lin",
            },
            recompensa: { pcs: 500, exp: 800, nuevoRango: "Disc√≠pulo Principal" },
            autoActivarAlCumplirRequisitos: true,
          },
          // Misiones de Ejemplo por Nivel:
          mision_lobos_bosque_1: {
            titulo: "Amenaza Lupina",
            descripcion:
              "Una manada de Lobos del Bosque se ha vuelto agresiva. El Gu√≠a Lin te pide que elimines 3 de ellos.",
            objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "monster_bosque_lobo",
              cantidad: 3,
              nombreDisplay: "Lobo del Bosque",
              npcEntrega: "guia_lin",
            },
            recompensa: {
              pcs: 100,
              exp: 200,
              items: { "Piedras Espirituales": 10, "Colmillo de Lobo": 1 },
            },
            npcInicio: "guia_lin",
            requisitoNivel: 5, // Se desbloquea al nivel 5
          },
          mision_escorpiones_desierto_1: {
            titulo: "Aguijones Peligrosos",
            descripcion:
              "Los Escorpiones de las Dunas est√°n causando problemas a las caravanas. Elimina 5 y reporta al Administrador Yao.",
            objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "monster_desierto_escorpion",
              cantidad: 5,
              nombreDisplay: "Escorpi√≥n de las Dunas",
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 150,
              exp: 350,
              items: { "Piedras Espirituales": 11, "Aguij√≥n de Escorpi√≥n": 2 },
            },
            npcInicio: "admin_yao", // Puede ser otro NPC
            requisitoNivel: 10, // Se desbloquea al nivel 10
          },
          mision_cultivador_hostil_1: {
            titulo: "Rivalidad Temprana",
            descripcion:
              "Un Cultivador Novato Hostil ha estado desafiando a disc√≠pulos de nuestra secta. El Gu√≠a Lin quiere que le des una lecci√≥n. Derr√≥talo.",
            objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "cultivator_rival_low",
              cantidad: 10,
              nombreDisplay: "Cultivador Novato Hostil",
              npcEntrega: "guia_lin",
            },
            recompensa: {
              pcs: 200,
              exp: 400,
              items: {
                "P√≠ldora de Recuperaci√≥n Menor": 1,
                "Piedras Espirituales": 12,
              },
            },
            npcInicio: "guia_lin",
            requisitoNivel: 8,
          },
          // Aseg√∫rate de que las misiones que quieres que se entreguen a un NPC tengan `npcEntrega` en su `objetivo`.
          mision_componentes_alquimia_1: {
            titulo: "Medicina Urgente",
            descripcion:
              "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Ra√≠ces de Fuego Terrenal' para una p√≠ldora vital. Se dice que crecen en zonas con fluctuaciones elementales. Entr√©galas al Administrador Yao.",
            objetivo: {
              tipo: "recolectar_multiples_items",
              items: [
                { nombre: "Flor de Luna Escarchada", cantidad: 3 },
                { nombre: "Ra√≠z de Fuego Terrenal", cantidad: 2 },
              ],
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 120,
              exp: 250,
              items: {
                "P√≠ldora de Recuperaci√≥n Menor": 2,
                "Piedras Espirituales": 10,
              },
            },
            npcInicio: "guia_lin",
            requisitoRango: "Disc√≠pulo Externo",
          },
          mision_cazar_bestia_especifica_1: {
            titulo: "La Amenaza del Jabal√≠ Colmilludo",
            descripcion:
              "Un Jabal√≠ Colmilludo particularmente agresivo ha estado atacando a los recolectores de la secta en lo profundo del bosque. Caza a esta bestia y trae su 'Colmillo intacto' como prueba al Gu√≠a Lin.",
            objetivo: {
              tipo: "cazar_y_recuperar_item_de_loot",
              enemigoTipo: "jabali_colmilludo_alfa",
              itemPrueba: "Colmillo de Jabal√≠ Alfa",
              cantidadItemPrueba: 1,
              npcEntrega: "guia_lin",
            },
            recompensa: {
              pcs: 150,
              exp: 300,
              items: { "Piedras Espirituales": 20, "Carne de Bestia Ex√≥tica": 3 },
            },
            npcInicio: "guia_lin",
            requisitoNivel: 10,
          },
          mision_cazar_bestia_especifica_1: {
            titulo: "Elimina el golem de piedra",
            descripcion:
              "Elimina al golem de piedra Geo al sur de la pradera de la secta.Regresa con el Gu√≠a Lin luego de eliminarlo.",
            objetivo: {
              objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "cultivator_rival_low",
              cantidad: 1,
              nombreDisplay: "Cultivador Novato Hostil",
              npcEntrega: "guia_lin",
            },
            },
            recompensa: {
              pcs: 150,
              exp: 300,
              items: { "Piedras Espirituales": 20, "Carne de Bestia Ex√≥tica": 3 },
            },
            npcInicio: "guia_lin",
            requisitoNivel: 10,
          },
        };

        const shopData = {
          name: "Pabell√≥n de Tesoros del Drag√≥n Oculto",
          inventory: [
            { itemName: "Hierbas Medicinales", price: 1, stock: 100 },
            { itemName: "Cristales de Qi", price: 1, stock: 100 },
            {
              itemName: "Espada de Hierro",
              type: "equipment",
              category: "weapon",
              attackBonus: 5,
              price: 50,
              stock: 1,
              description: "Una espada b√°sica pero fiable. (+5 Ataque)",
            },
            { itemName: "Rollo: Tajo del Viento Veloz", price: 150, stock: 3 },
          { itemName: "Rollo: F√≠sico de Buey de Piedra", price: 200, stock: 2 },
          { itemName: "Rollo: Matriz de Escudo de Qi", price: 180, stock: 3 },
          { itemName: "Rollo: Chispa √çgnea", price: 170, stock: 3 },
          { itemName: "Rollo: Dedo de Rel√°mpago", price: 220, stock: 2 },
            { itemName: "Rollo: Absorci√≥n de Qi Menor", price: 15, stock: 10 },
            { itemName: "Rollo: Corte de Espada B√°sico", price: 50, stock: 10 },
            { itemName: "Rollo: Conversi√≥n de Qi", price: 25, stock: 10 },
            { itemName: "Rollo: Prisi√≥n de Hielo", price: 180, stock: 5 },
            { itemName: "Rollo: Golpe de Llamas", price: 170, stock: 5 },
            { itemName: "Rollo: Furia del Trueno", price: 190, stock: 5 },
            { itemName: "Rollo: Dardo Venenoso", price: 150, stock: 5 },
            { itemName: "Rollo: Piel de Piedra", price: 175, stock: 5 },
            { itemName: "Rollo: Paso de las Sombras", price: 220, stock: 3 },
            { itemName: "Rollo: Drenaje de Alma", price: 200, stock: 3 },
            { itemName: "Rollo: Golpe Cicl√≥n", price: 250, stock: 3 },
            { itemName: "Rollo: Lluvia Curativa", price: 210, stock: 3 },
            { itemName: "Rollo: Explosi√≥n Mental", price: 230, stock: 3 },
            { itemName: "Rollo: Voluntad de Hierro", price: 200, stock: 3 },
            { itemName: "Rollo: Flecha Celestial", price: 280, stock: 2 },
            { itemName: "Rollo: Abrazo de la Naturaleza", price: 190, stock: 3 },
            { itemName: "Rollo: Rugido de Drag√≥n", price: 300, stock: 2 },
            { itemName: "Rollo: Clon Fantasma", price: 240, stock: 2 },
            { itemName: "Rollo: Cambio Temporal", price: 260, stock: 2 },
            { itemName: "Rollo: Ritual de Sangre", price: 210, stock: 3 },
            { itemName: "Rollo: Aura de Pureza", price: 230, stock: 3 },
            { itemName: "Rollo: Invocar Elemental", price: 320, stock: 1 },
            { itemName: "Rollo: Barrera M√≠stica", price: 220, stock: 3 },
          ],
        };
        const techniqueData = {
          // =================================================================
          // == GRADO 1 (Rango: Disc√≠pulo Externo)
          // =================================================================
          "qi_to_hp_conversion_1": { id: "qi_to_hp_conversion_1", name: "T√©cnica de Conversi√≥n de Qi", description: "Permite activar/desactivar la conversi√≥n de Man√° en HP al cultivar. Mejora la tasa de conversi√≥n y eficiencia con cada nivel de refinamiento.", type: "active_refinement_effect", effect: { baseManaCostPerSecond: 2.0, baseHpGainPerSecond: 1.0, hpGainIncreasePerLevel: 2, manaCostReductionPerLevel: 0.1 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 90, levelTimeMultiplier: 1.6 }, refinementCost: { baseTime: 60, materials: { "Cristales de Qi": 5, "Piedras Espirituales": 10 }, levelRequirement: 1 }, icon: "‚òØÔ∏è" },
          "qi_absorption_boost_1": { id: "qi_absorption_boost_1", name: "T√©cnica de Absorci√≥n de Qi Menor", description: "Aumenta la cantidad de Qi ganado por segundo al cultivar en 0.5.", type: "passive_cultivation", effect: { statToBoost: "qiPerSecondBase", value: 0.5 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 60, levelTimeMultiplier: 1.5 }, refinementCost: { baseTime: 30, materials: { "Piedras Espirituales": 20 }, levelRequirement: 1 }, icon: "üìú" },
        
          
          // =================================================================
          // == GRADO 1 (Rango: Disc√≠pulo Interno) - Nivel Mortal
          // =================================================================
          sword_t1: {
            id: "sword_t1", name: "Tajo del Viento Veloz", icon: "üí®",
            description: "Un corte de espada r√°pido y eficiente. Un pilar del combate b√°sico.",
            type: "active_ability", abilityId: "sword_t1",
            effect: { baseDamageMultiplier: 1.2 }, manaCost: 10,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 90, levelTimeMultiplier: 1.6 },
          },
          body_t1: {
            id: "body_t1", name: "F√≠sico de Buey de Piedra", icon: "üêÇ",
            description: "Fortalece pasivamente tu cuerpo, aumentando tu Vida M√°xima base.",
            type: "passive_stat", effect: { statToBoost: "baseMaxHp", value: 25 },
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 120, levelTimeMultiplier: 1.7 },
          },
          formation_t1: {
            id: "formation_t1", name: "Matriz de Escudo de Qi", icon: "üí†",
            description: "Crea un escudo temporal que absorbe una peque√±a cantidad de da√±o.",
            type: "active_ability", abilityId: "formation_t1",
            effect: { shieldValue: 40, duration: 3 }, manaCost: 20,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 100, levelTimeMultiplier: 1.8 },
          },
          fire_t1: {
            id: "fire_t1", name: "Chispa √çgnea", icon: "üî•",
            description: "Lanza una peque√±a bola de fuego que causa da√±o y puede aplicar una quemadura menor.",
            type: "active_ability", abilityId: "fire_t1",
            effect: { baseDamageMultiplier: 0.8, burnDamagePerTurn: 5, burnDuration: 2 }, manaCost: 15,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 110, levelTimeMultiplier: 1.7 },
          },
          lightning_t1: {
              id: "lightning_t1", name: "Dedo de Rel√°mpago", icon: "‚ö°",
              description: "Un r√°pido chispazo de rel√°mpago que puede aturdir brevemente al enemigo.",
              type: "active_ability", abilityId: "lightning_t1",
              effect: { baseDamageMultiplier: 0.9, stunChance: 0.2 }, manaCost: 18,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 130, levelTimeMultiplier: 1.8 },
          },

          // =================================================================
          // == GRADO 2 (Rango: Disc√≠pulo Principal) - Nivel Terrenal
          // =================================================================
          sword_t2: {
            id: "sword_t2", name: "Estocada Perfora-Armadura", icon: "üó°Ô∏è",
            description: "Un ataque preciso que ignora una porci√≥n de la defensa del enemigo.",
            type: "active_ability", abilityId: "sword_t2",
            effect: { baseDamageMultiplier: 1.1, defensePenetration: 0.25 }, manaCost: 25,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 180, levelTimeMultiplier: 1.6 },
          },
          body_t2: {
            id: "body_t2", name: "Piel de Acero Fundido", icon: "ü¶æ",
            description: "Aumenta pasivamente tu Defensa base, haci√©ndote m√°s resistente.",
            type: "passive_stat", effect: { statToBoost: "baseDefense", value: 5 },
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 200, levelTimeMultiplier: 1.7 },
          },
          formation_t2: {
            id: "formation_t2", name: "Matriz de Grilletes de Qi", icon: "üîó",
            description: "Una formaci√≥n que intenta enraizar al enemigo, impidiendo su movimiento y causando da√±o leve.",
            type: "active_ability", abilityId: "formation_t2",
            effect: { rootDuration: 2, damagePerTurn: 10, rootChance: 0.7 }, manaCost: 30,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 190, levelTimeMultiplier: 1.8 },
          },
          movement_t2: {
            id: "movement_t2", name: "Paso Et√©reo", icon: "üëü",
            description: "Te mueves como el viento, d√°ndote una alta probabilidad de esquivar el pr√≥ximo ataque.",
            type: "active_ability", abilityId: "movement_t2",
            effect: { dodgeNextAttack: true }, manaCost: 40,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 220, levelTimeMultiplier: 1.9 },
          },
          fire_t2: {
            id: "fire_t2", name: "Aliento de Drag√≥n Menor", icon: "üê≤",
            description: "Exhalas un cono de fuego que quema con mayor intensidad.",
            type: "active_ability", abilityId: "fire_t2",
            effect: { baseDamageMultiplier: 1.0, burnDamagePerTurn: 15, burnDuration: 3 }, manaCost: 35,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 200, levelTimeMultiplier: 1.7 },
          },
          
          // =================================================================
          // == GRADO 3 (Rango: Di√°cono) - Nivel Celestial
          // =================================================================
          sword_t3: {
              id: "sword_t3", name: "Danza de Espada Cicl√≥nica", icon: "üå™Ô∏è",
              description: "Giras como un cicl√≥n, golpeando al enemigo m√∫ltiples veces en un solo ataque devastador.",
              type: "active_ability", abilityId: "sword_t3",
              effect: { baseDamageMultiplier: 2.5 }, manaCost: 50,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 300, levelTimeMultiplier: 1.6 },
          },
          body_t3: {
              id: "body_t3", name: "Coraz√≥n de Voluntad Indomable", icon: "‚ù§Ô∏è‚Äçüî•",
              description: "Pasivamente, tu voluntad de hierro reduce una porci√≥n de todo el da√±o recibido.",
              type: "passive_stat", effect: { statToBoost: "damageReduction", value: 0.05 }, // Esto necesitar√° l√≥gica en el c√°lculo de da√±o
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 350, levelTimeMultiplier: 1.7 },
          },
          formation_t3: {
              id: "formation_t3", name: "Matriz de Supresi√≥n Espiritual", icon: "üï∏Ô∏è",
              description: "Crea un campo que debilita al enemigo, reduciendo su ataque y defensa por varios turnos.",
              type: "active_ability", abilityId: "formation_t3",
              effect: { attackReduction: 15, defenseReduction: 15, duration: 4 }, manaCost: 45,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 320, levelTimeMultiplier: 1.8 },
          },
          lightning_t3: {
              id: "lightning_t3", name: "Jaula de Rayos", icon: "‚õìÔ∏è",
              description: "Encierra al enemigo en una jaula el√©ctrica, causando da√±o continuo y con alta probabilidad de aturdir.",
              type: "active_ability", abilityId: "lightning_t3",
              effect: { baseDamageMultiplier: 1.2, damagePerTurn: 20, stunChance: 0.5, duration: 3 }, manaCost: 60,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 380, levelTimeMultiplier: 1.8 },
          },
          movement_t3: {
              id: "movement_t3", name: "Parpadeo de Sombra", icon: "üëª",
              description: "Te teletransportas instant√°neamente detr√°s del enemigo para un golpe cr√≠tico garantizado.",
              type: "active_ability", abilityId: "movement_t3",
              effect: { baseDamageMultiplier: 2.0, isCritical: true }, manaCost: 55, // isCritical necesitar√° l√≥gica en battleAction
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 400, levelTimeMultiplier: 1.9 },
          },

          // =================================================================
          // == GRADO 4 (Rango: Anciano) - Nivel Soberano
          // =================================================================
          sword_t4: {
              id: "sword_t4", name: "Intento de Espada del Tirano", icon: "üëë",
              description: "Canalizas tu Qi en la espada para liberar una onda de energ√≠a que da√±a y aturde.",
              type: "active_ability", abilityId: "sword_t4",
              effect: { baseDamageMultiplier: 2.8, stunChance: 0.4 }, manaCost: 70,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 500, levelTimeMultiplier: 1.5 },
          },
          body_t4: {
              id: "body_t4", name: "Cuerpo Dorado Inmortal", icon: "üåü",
              description: "Tu cuerpo se vuelve tan duro que regenera vida pasivamente incluso fuera del cultivo.",
              type: "passive_stat", effect: { statToBoost: "passiveHpRegen", value: 0.5 }, // Necesitar√° l√≥gica en el game tick
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 600, levelTimeMultiplier: 1.6 },
          },
          fire_t4: {
              id: "fire_t4", name: "Sol Abrasador", icon: "‚òÄÔ∏è",
              description: "Creas un sol en miniatura que explota, causando da√±o masivo a todos los enemigos.",
              type: "active_ability", abilityId: "fire_t4",
              effect: { baseDamageMultiplier: 2.5, aoe: true }, manaCost: 80,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 550, levelTimeMultiplier: 1.6 },
          },
          lightning_t4: {
              id: "lightning_t4", name: "Llamada del Juicio del Trueno", icon: "üå©Ô∏è",
              description: "Invocas un rayo celestial que golpea al enemigo, ignorando toda su defensa.",
              type: "active_ability", abilityId: "lightning_t4",
              effect: { baseDamageMultiplier: 2.0, ignoreDefense: true }, manaCost: 75,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 580, levelTimeMultiplier: 1.7 },
          },
          formation_t4: {
              id: "formation_t4", name: "Santuario Dorado Protector", icon: "üè∞",
              description: "Una matriz defensiva definitiva que te hace inmune al da√±o por 2 turnos.",
              type: "active_ability", abilityId: "formation_t4",
              effect: { immunityDuration: 2 }, manaCost: 100,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 620, levelTimeMultiplier: 1.8 },
          },
          
            // =================================================================
          // == GRADO 5 (Rango: Gran Anciano) - Nivel Transcendente
          // =================================================================
          sword_t5: {
              id: "sword_t5", name: "Corte que Divide Cielos y Tierra", icon: "‚öîÔ∏è",
              description: "Una t√©cnica legendaria que corta a trav√©s de cualquier defensa y causa da√±o verdadero.",
              type: "active_ability", abilityId: "sword_t5",
              effect: { baseDamageMultiplier: 4.0, trueDamage: true, criticalChance: 0.3 }, manaCost: 120,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 800, levelTimeMultiplier: 1.4 },
          },
          body_t5: {
              id: "body_t5", name: "Constituci√≥n de Drag√≥n Ancestral", icon: "üêâ",
              description: "Tu cuerpo alcanza la perfecci√≥n drac√≥nica, ganando inmunidad a efectos de estado y regeneraci√≥n poderosa.",
              type: "passive_stat", effect: { statToBoost: "statusImmunity", value: true, passiveHpRegen: 2.0 },
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 900, levelTimeMultiplier: 1.5 },
          },
          fire_t5: {
              id: "fire_t5", name: "Llama del F√©nix Renaciente", icon: "üî•",
              description: "Invocas el fuego sagrado del f√©nix que causa da√±o masivo y puede resucitarte al morir.",
              type: "active_ability", abilityId: "fire_t5",
              effect: { baseDamageMultiplier: 3.5, aoe: true, reviveChance: 0.25 }, manaCost: 150,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 850, levelTimeMultiplier: 1.5 },
          },
          lightning_t5: {
              id: "lightning_t5", name: "Tribulaci√≥n de los Nueve Cielos", icon: "üå©Ô∏è",
              description: "Canalizas el poder de la tribulaci√≥n celestial para devastar a todos los enemigos.",
              type: "active_ability", abilityId: "lightning_t5",
              effect: { baseDamageMultiplier: 3.0, aoe: true, paralyzeChance: 0.6, duration: 2 }, manaCost: 140,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 880, levelTimeMultiplier: 1.6 },
          },
          formation_t5: {
              id: "formation_t5", name: "Matriz de Reversi√≥n del Cosmos", icon: "üåå",
              description: "Una formaci√≥n que invierte el da√±o recibido, convirti√©ndolo en curaci√≥n.",
              type: "active_ability", abilityId: "formation_t5",
              effect: { damageToHealingDuration: 3, reflectDamage: 0.5 }, manaCost: 180,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 950, levelTimeMultiplier: 1.7 },
          },
          movement_t5: {
              id: "movement_t5", name: "Paso del Vac√≠o Infinito", icon: "üåÄ",
              description: "Te mueves entre dimensiones, volvi√©ndote intangible y atacando desde m√∫ltiples √°ngulos.",
              type: "active_ability", abilityId: "movement_t5",
              effect: { baseDamageMultiplier: 2.5, intangibleTurns: 2, multiHit: 3 }, manaCost: 130,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 820, levelTimeMultiplier: 1.8 },
          },

          // =================================================================
          // == GRADO 6 (Rango: Patriarca) - Nivel M√≠tico
          // =================================================================
          sword_t6: {
              id: "sword_t6", name: "Espada del Emperador Celestial", icon: "üëë",
              description: "El arte supremo de la espada que puede cortar a trav√©s del destino mismo.",
              type: "active_ability", abilityId: "sword_t6",
              effect: { baseDamageMultiplier: 6.0, ignoreAllEffects: true, executeThreshold: 0.2 }, manaCost: 200,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1200, levelTimeMultiplier: 1.3 },
          },
          body_t6: {
              id: "body_t6", name: "Cuerpo Inmortal de Jade", icon: "üíé",
              description: "Tu cuerpo trasciende la mortalidad, volvi√©ndose pr√°cticamente indestructible.",
              type: "passive_stat", effect: { statToBoost: "damageReduction", value: 0.25, deathSaveChance: 0.5 },
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1400, levelTimeMultiplier: 1.4 },
          },
          fire_t6: {
              id: "fire_t6", name: "Incineraci√≥n del Mundo Mortal", icon: "üåã",
              description: "Reduces todo a cenizas con el fuego que arde desde el n√∫cleo de la creaci√≥n.",
              type: "active_ability", abilityId: "fire_t6",
              effect: { baseDamageMultiplier: 5.0, aoe: true, burnDamagePerTurn: 100, burnDuration: 5 }, manaCost: 250,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1300, levelTimeMultiplier: 1.4 },
          },
          lightning_t6: {
              id: "lightning_t6", name: "Decreto del Se√±or del Trueno", icon: "‚ö°",
              description: "Como se√±or de las tormentas, tu palabra se convierte en ley absoluta.",
              type: "active_ability", abilityId: "lightning_t6",
              effect: { baseDamageMultiplier: 4.5, aoe: true, silenceDuration: 3, stunChance: 0.8 }, manaCost: 220,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1350, levelTimeMultiplier: 1.5 },
          },
          formation_t6: {
              id: "formation_t6", name: "Matriz del Sello del Demonio", icon: "üîí",
              description: "Sella completamente al enemigo, impidiendo todas sus acciones por varios turnos.",
              type: "active_ability", abilityId: "formation_t6",
              effect: { sealDuration: 4, damagePerTurn: 50 }, manaCost: 300,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1500, levelTimeMultiplier: 1.6 },
          },
          movement_t6: {
              id: "movement_t6", name: "Omnipresencia Divina", icon: "üëÅÔ∏è",
              description: "Existes en m√∫ltiples lugares simult√°neamente, atacando desde todas partes.",
              type: "active_ability", abilityId: "movement_t6",
              effect: { baseDamageMultiplier: 3.0, unavoidable: true, multiHit: 5 }, manaCost: 280,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1250, levelTimeMultiplier: 1.7 },
          },

          // =================================================================
          // == GRADO 7 (Rango: Soberano Supremo) - Nivel Legendario
          // =================================================================
          sword_t7: {
              id: "sword_t7", name: "Lamento del Fin del Mundo", icon: "üó°Ô∏è",
              description: "Una t√©cnica que lleva la esencia de la destrucci√≥n apocal√≠ptica.",
              type: "active_ability", abilityId: "sword_t7",
              effect: { baseDamageMultiplier: 8.0, aoe: true, ignoreAllDefenses: true, lifeSteal: 0.5 }, manaCost: 350,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2000, levelTimeMultiplier: 1.2 },
          },
          body_t7: {
              id: "body_t7", name: "Forma del Ancestro Primordial", icon: "üåü",
              description: "Tu cuerpo alcanza la forma perfecta de los antiguos dioses creadores.",
              type: "passive_stat", effect: { statToBoost: "allStats", multiplier: 2.0, regenAllPerTurn: true },
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2500, levelTimeMultiplier: 1.3 },
          },
          fire_t7: {
              id: "fire_t7", name: "G√©nesis √çgneo", icon: "üî•",
              description: "El fuego que cre√≥ el universo, capaz de destruir y recrear la realidad.",
              type: "active_ability", abilityId: "fire_t7",
              effect: { baseDamageMultiplier: 7.0, aoe: true, resetEnemyBuffs: true, burnDamagePerTurn: 200 }, manaCost: 400,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2200, levelTimeMultiplier: 1.3 },
          },
          lightning_t7: {
              id: "lightning_t7", name: "C√≥lera del Emperador Celestial", icon: "‚ö°",
              description: "La ira divina se manifiesta como rayos que juzgan a todos los seres.",
              type: "active_ability", abilityId: "lightning_t7",
              effect: { baseDamageMultiplier: 6.5, aoe: true, judgmentEffect: true, chainLightning: 10 }, manaCost: 380,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2300, levelTimeMultiplier: 1.4 },
          },
          formation_t7: {
              id: "formation_t7", name: "Matriz del Caos Primordial", icon: "üåÄ",
              description: "Invocas el caos que exist√≠a antes de la creaci√≥n para deshacer a tus enemigos.",
              type: "active_ability", abilityId: "formation_t7",
              effect: { randomCatastrophicEffects: true, reality_distortion: 5 }, manaCost: 450,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2800, levelTimeMultiplier: 1.5 },
          },
          movement_t7: {
              id: "movement_t7", name: "Danza del Tejido Espacio-Tiempo", icon: "üåå",
              description: "Manipulas el espacio y el tiempo para existir en m√∫ltiples momentos simult√°neamente.",
              type: "active_ability", abilityId: "movement_t7",
              effect: { baseDamageMultiplier: 4.0, timeLoop: 3, spacialDistortion: true }, manaCost: 420,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2400, levelTimeMultiplier: 1.6 },
          },

          // =================================================================
          // == GRADO 8 (Rango: Emperador Inmortal) - Nivel √âpico
          // =================================================================
          sword_t8: {
              id: "sword_t8", name: "Decreto Imperial: Extinci√≥n", icon: "üëë",
              description: "Como emperador, tu palabra es ley absoluta. Decretas la extinci√≥n de tus enemigos.",
              type: "active_ability", abilityId: "sword_t8",
              effect: { baseDamageMultiplier: 12.0, instantKillChance: 0.3, ignoreAllProtections: true }, manaCost: 500,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 3500, levelTimeMultiplier: 1.1 },
          },
          body_t8: {
              id: "body_t8", name: "Avatar del Dao Eterno", icon: "‚òØÔ∏è",
              description: "Te conviertes en la manifestaci√≥n f√≠sica del Dao, trascendiendo todas las limitaciones.",
              type: "passive_stat", effect: { statToBoost: "transcendence", value: true, immuneToAll: true },
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 4000, levelTimeMultiplier: 1.2 },
          },
          fire_t8: {
              id: "fire_t8", name: "Apocalipsis de Llamas Divinas", icon: "üî•",
              description: "El fuego que consume universos enteros, purificando la existencia misma.",
              type: "active_ability", abilityId: "fire_t8",
              effect: { baseDamageMultiplier: 10.0, aoe: true, purificationEffect: true, universeScaleDamage: true }, manaCost: 600,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 3800, levelTimeMultiplier: 1.2 },
          },
          lightning_t8: {
              id: "lightning_t8", name: "Tribulaci√≥n del Fin de los Tiempos", icon: "‚ö°",
              description: "Invocas la tribulaci√≥n final que marcar√° el fin de una era.",
              type: "active_ability", abilityId: "lightning_t8",
              effect: { baseDamageMultiplier: 9.0, aoe: true, eraEndingEffect: true, temporalDamage: true }, manaCost: 550,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 3600, levelTimeMultiplier: 1.3 },
          },
          formation_t8: {
              id: "formation_t8", name: "Matriz de Reescritura de la Realidad", icon: "üìú",
              description: "Reescribes las leyes fundamentales de la realidad a tu favor.",
              type: "active_ability", abilityId: "formation_t8",
              effect: { realityRewrite: true, lawManipulation: true, existenceControl: 7 }, manaCost: 700,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 4500, levelTimeMultiplier: 1.4 },
          },
          movement_t8: {
              id: "movement_t8", name: "Trascendencia Dimensional", icon: "üåÄ",
              description: "Trasciendes las limitaciones dimensionales, existiendo en todas las dimensiones.",
              type: "active_ability", abilityId: "movement_t8",
              effect: { baseDamageMultiplier: 6.0, dimensionalTravel: true, omnipresence: true }, manaCost: 650,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 4200, levelTimeMultiplier: 1.5 },
          },

          // =================================================================
          // == GRADO 9 (Rango: Soberano del Dao) - Nivel M√≠tico Supremo
          // =================================================================
          sword_t9: {
              id: "sword_t9", name: "Corte del Origen Absoluto", icon: "‚öîÔ∏è",
              description: "Cortas a trav√©s del origen mismo de la existencia, negando la realidad de tus enemigos.",
              type: "active_ability", abilityId: "sword_t9",
              effect: { baseDamageMultiplier: 20.0, existenceNegation: true, conceptualDamage: true }, manaCost: 800,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 6000, levelTimeMultiplier: 1.0 },
          },
        };
        
// ===  DICCIONARIO DE HABILIDADES DE ENEMIGOS ===
      const enemyAbilityData = {
        poison_sting: {
          name: "Aguij√≥n Venenoso",
          type: "debuff_damage",
          logMessage: (enemyName, damage, poisonDmg, duration) => `¬°${enemyName} te clava su Aguij√≥n Venenoso! Recibes ${damage} de da√±o y quedas envenenado por ${poisonDmg} de da√±o durante ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 0.5, // El golpe inicial no es tan fuerte
            poison: {
              damagePerTurn: 10, // Da√±o base del veneno
              duration: 3
            }
          }
        },
        armor_break: {
            name: "Golpe Rompe-Armadura",
            type: "debuff_stat",
            logMessage: (enemyName, damage, reduction, duration) => `¬°${enemyName} usa un Golpe Rompe-Armadura! Recibes ${damage} de da√±o y tu defensa se reduce en ${reduction} por ${duration} turnos.`,
            effect: {
                baseDamageMultiplier: 1.2,
                debuff: {
                    stat: "defense",
                    amount: 10,
                    duration: 3
                }
            }
        },
        intimidating_roar: {
            name: "Rugido Intimidante",
            type: "debuff_stat_no_damage",
            logMessage: (enemyName, reduction, duration) => `¬°${enemyName} suelta un Rugido Intimidante! Tu ataque se reduce en ${reduction} por ${duration} turnos.`,
            effect: {
                debuff: {
                    stat: "attack",
                    amount: 8,
                    duration: 3
                }
            }
        },
        curacion_basica: {
            name: "Curaci√≥n",
            type: "buff",
            logMessage: (enemyName,healAmount) => `¬°${enemyName} Toma una medicina y se cura ${healAmount}.`,
            effect: {
                healAmount:50,
            }
        },
        life_drain: {
            name: "Drenaje Vital",
            type: "heal_damage",
            logMessage: (enemyName, damage, healAmount) => `¬°${enemyName} usa Drenaje Vital! Te roba ${damage} de vida y se cura ${healAmount}.`,
            effect: {
                baseDamageMultiplier: 0.8,
                lifesteal: 0.5 // 50% del da√±o infligido se convierte en curaci√≥n para el enemigo
            }
        }
      };
      
 
        const entityTypes = {
          //FIJOS
          shop: {
            symbol: "üè™",
            name: "Tienda Misteriosa",
            spriteUrl: "img/shop.png",
            interaction: "browse",
            type: "shop", // 'type' es importante para la interacci√≥n
            // fixedX: 12, // Podr√≠as tener esto
            // fixedY: 13, // O esto
            fixedLocation: { x: 12, y: 13 }, // O esto (preferiblemente esto)
            discovered: true, // ¬°IMPORTANTE para que se muestre desde el inicio!
          },

          secta_entrada_principal: {
            symbol: "‚õ©Ô∏è",
            name: "Sal√≥n Principal de la Secta",
            spriteUrl: "img/secta.png",
            interaction: "access_sect_hall",
            // fixedX: 12, // Si ten√≠as esto antes
            // fixedY: 15, // Si ten√≠as esto antes
            // ASEG√öRATE DE TENER ESTO EN SU LUGAR:
            fixedLocation: { x: 15, y: 15 }, // O las coordenadas correctas para tu secta
            discovered: true,
          },

          // --- ELEMENTOS DECORATIVOS ---
          deco_pino: {
            symbol: "üå≥",
            name: "Pino",
            spriteUrl: "img/pino.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_arbol_peque√±o: {
            symbol: "üå≥",
            name: "Pino",
            spriteUrl: "img/arbol.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_arbol_normal: {
            symbol: "",
            name: "Otro arbol",
            spriteUrl: "img/arbol.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_desierto: {
            symbol: "ü™®",
            name: "Roca Musgosa",
            spriteUrl: "img/deco_desierto.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_agua_estancada: {
            
            name: "Agua Estancada",
            spriteUrl: "img/agua_estancada.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_arbol_pantano: {
            symbol: "üå≥",
            name: "Arbol Pantano",
            spriteUrl: "img/arbol_pantano.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_ruina_pilar: {
            symbol: "üèõ",
            name: "Pilar Ca√≠do",
            spriteUrl: "img/columnas.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          }, // Usar un s√≠mbolo diferente si 'üèõÔ∏è' ya est√° en uso
          deco_flor_rara: {
            symbol: "üå∏",
            name: "Flor Luminiscente",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          }, // Diferente de tu lugar de cultivo
          // ... a√±ade m√°s seg√∫n necesites
          //NPCS
       
          npc_secta_guia: {
            symbol: "üë®‚Äçüè´",
            name: "Gu√≠a Lin",
            spriteUrl: "img/guia_lin.png",
            interaction: "talk_secta_npc",
            npcId: "guia_lin",
            fixedLocation: { x: 13, y: 15 },
            discovered: true,
          },
          npc_secta_admin: {
            symbol: " üë¥",
            name: "Administrador Yao",
            spriteUrl: "img/adm_yao.png",
            interaction: "talk_secta_npc",
            npcId: "admin_yao",
            fixedLocation: { x: 17, y: 15 },
            discovered: true,
          },
          rival_interno_1: {
            symbol: "üò†",
            name: "Han Li (Guardi√°n Interno)",
            spriteUrl: "img/lobo_bosque.png",
            typeOverride: "monster",
            hp: 250,
            attack: 60,
            defense: 15,
            exp: 150,
            maxHp: 250,
            isSectChallengeRival: true,
            npcId: "rival_interno_1",
            fixedLocation: { x: 5, y: 12 },
          },
          rival_principal_1: {
            symbol: "üò°",
            name: "Anciana Shui (Prueba Principal)",
            typeOverride: "monster",
            hp: 600,
            attack: 90,
            defense: 25,
            exp: 400,
            maxHp: 600,
            isSectChallengeRival: true,
            npcId: "rival_principal_1",
            fixedLocation: { x: 4, y: 12 },
            specialChance: 0.2,
            specialAttackMultiplier: 1.6,
          },
          //== FIN NPC===
          //RECURSOS
          cristal_qi: {
            symbol: "üíé",
            name: "Cristal de Qi",
            spriteUrl: "img/cristal_de_qi.png",
            reward: "Cristales de Qi",
            interaction: "collect_resource",
          },
          piedras_espirituales: {
            symbol: "üíé",
            name: "Piedra espiritual",
            spriteUrl: "img/piedra_esp.png",
            reward: "Piedras Espirituales",
            interaction: "collect_resource",
          },
          cultivation: {
            symbol: "üå∏",
            name: "Lugar de Cultivo",
            benefit: "mana",
            manaGain: 20,
            interaction: "meditate_spot",
          },
          resource_hierbas_bosque: {
            symbol: "üåø", // <--- ¬°ASEG√öRATE DE QUE ESTO EST√â!
            name: "Hierbas del Bosque Profundo",
            spriteUrl: "img/hierbas.png",
            type: "resource",
            reward: "Hierbas Medicinales",
            interaction: "collect_resource",
          },

           // === NUEVAS ENTIDADES DE TRANSICI√ìN ===
          transition_ruins_entrance: {
            symbol: "üåÄ",
            name: "Entrada a las Ruinas",
            spriteUrl: "img/entrada_ruinas.png", // Crea o usa una imagen para el portal
            interaction: "transition",
            fixedLocation: { x: 45, y: 45 }, // Ubicaci√≥n en el mundo principal
            targetX: 501, // Coordenada X de destino (dentro de la zona de ruinas)
            targetY: 501, // Coordenada Y de destino
            discovered: true,
          },
          transition_ruins_exit: {
            symbol: "üåÄ",
            name: "Salida de las Ruinas",
            spriteUrl: "img/portal.png",
            interaction: "transition",
            fixedLocation: { x: 501, y: 500 }, // Ubicaci√≥n DENTRO de las ruinas
            targetX: 45,  // Coordenada X de destino (de vuelta al mundo principal)
            targetY: 46,  // Coordenada Y de destino (aparece al lado de la entrada)
            discovered: true,
          },


//ENEMIGOS
          monster: {
            symbol: "üëπ",
            name: "Demonio Menor",
            spriteUrl: "img/demonio_menor.png",
            level:2,
            hp: 60,
            attack: 30,
            defense: 2,
            exp: 25,
            maxHp: 60,
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
              { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            ],
          },
          monster_secta_debil: {
            symbol: "üêæ",
            name: "Bestia Menor de Pradera",
            spriteUrl: "img/monstruo_pradera.png",
            level:1,
            hp: 40,
            attack: 30,
            defense: 1,
            exp: 12,
            maxHp: 40,
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            ],
          },
          monster_bosque_lobo: {
            symbol: "üê∫",
            name: "Lobo del Bosque",
            spriteUrl: "img/lobo_bosque.png",
            hp: 70,
            level:2,
            attack: 40,
            defense: 3,
            exp: 20,
            maxHp: 70,
            lootTable: [
              { itemName: "Colmillo de Lobo", quantity: [1, 1], chance: 0.4 },
              {
                itemName: "Flor de Luna Escarchada",
                quantity: [1, 2],
                chance: 0.6,
              },
              { itemName: "Carne Fresca", quantity: [1, 2], chance: 0.6 },
              { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            ],
          },
          monster_bosque_arana: {
            symbol: "üï∑Ô∏è",
            name: "Ara√±a Tejesombras",
            hp: 50,
            level:1,
            attack: 45,
            defense: 5,
            exp: 18,
            maxHp: 50,
            lootTable: [
              { itemName: "Seda de Ara√±a", quantity: [1, 3], chance: 0.7 },
              { itemName: "Veneno D√©bil", quantity: [1, 1], chance: 0.2 },
              { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            ],
          },

          monster_desierto_escorpion: {
            symbol: "ü¶Ç",
            name: "Escorpi√≥n de las Dunas",
            hp: 90,
            level:5,
            attack: 30,
            defense: 8,
            exp: 35,
            maxHp: 90,
            specialChance: 0.35,
            specialAttackMultiplier: 1.8,
            aabilities: [
          {
            abilityId: "poison_sting", // ID de la habilidad en enemyAbilityData
            chance: 0.40 // 40% de probabilidad de usar esta habilidad en su turno
          }
        ],
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "Aguij√≥n de Escorpi√≥n", quantity: [1, 1], chance: 0.5 },
              { itemName: "Quitina Resistente", quantity: [1, 1], chance: 0.3 },
              { itemName: "Piedras Espirituales", quantity: [2, 4], chance: 1 },
            ],
          },
          monster_desierto_golem_arena: {
            symbol: "üß±",
            name: "Golem de Tormenta de Arena",
            hp: 200,
            level:9,
            attack: 35,
            defense: 15,
            exp: 80,
            maxHp: 200,
            specialChance: 0.35,
            specialAttackMultiplier: 1.8,
            abilities: [
              {
                name: "Tornado de arena",
                damageMultiplier: 2.0,
                chance: 0.2,
                type: "area_attack_simulated",
              },
              {
                name: "stone_skin_1",
                effect: { defenseBoost: 15, duration: 3, manaCost: 25 },
                chance: 0.2,
                type: "area_attack_simulated",
              },
            ],
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "N√∫cleo de Arena", quantity: [1, 1], chance: 0.6 },
              { itemName: "Fragmento Des√©rtico", quantity: [1, 2], chance: 0.4 },
              { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
            ],
          },
          monster_cienaga_serpiente: {
            symbol: "üêç",
            name: "Serpiente de Ci√©naga",
            hp: 60,
            level:3,
            attack: 28,
            defense: 2,
            exp: 22,
            maxHp: 60,
            specialChance: 0.35,
            specialAttackMultiplier: 1.8,
            abilities: [
              {
                name: "Mordida Venenosa",
                damageMultiplier: 2.0,
                chance: 0.4,
                type: "area_attack_simulated",
              },
            ],
            lootTable: [
              { itemName: "Escama de Serpiente", quantity: [1, 2], chance: 0.5 },
              {
                itemName: "Ra√≠z de Fuego Terrenal",
                quantity: [1, 1],
                chance: 0.3,
              },
              { itemName: "Veneno de Ci√©naga", quantity: [1, 1], chance: 0.3 },
              { itemName: "Piedras Espirituales", quantity: [2, 4], chance: 1 },
            ],
          },
          cultivator_rival_low: {
            symbol: "üò†",
            name: "Cultivador Novato Hostil",
            spriteUrl: "img/cultivador_hostil.png",
            hp: 150,
            level:5,
            attack: 50,
            defense: 5,
            exp: 80,
            maxHp: 150,
            specialChance: 0.2,
            specialAttackMultiplier: 1.5,
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
              { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            ],
          },
          monster_alpha: {
            symbol: "üê∫",
            name: "Lobo Alfa",
            spriteUrl: "img/lobo_alfa.png",
            hp: 200,
            level:9,
            attack: 60,
            defense: 4,
            exp: 35,
            maxHp: 200,
            abilities: [
                { abilityId: "armor_break", chance: 0.3 },
                { abilityId: "intimidating_roar", chance: 0.2 }
            ],
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
              { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
              {
                itemName: "N√∫cleo de Bestia Menor",
                quantity: [1, 1],
                chance: 0.25,
              },
              { itemName: "Cristal de Hielo", quantity: [1, 2], chance: 0.1 },
              { itemName: "Esencia de Fuego", quantity: [1, 2], chance: 0.1 },
              { itemName: "Piedras Espirituales", quantity: [4, 10], chance: 1 },
            ],
          },
          cultivator_adept_hostile: {
            symbol: "üò°",
            name: "Cultivador Adepto Agresivo",
            hp: 400,
            level:15,
            attack: 80,
            defense: 10,
            exp: 250,
            maxHp: 400,
            specialChance: 0.25,
            specialAttackMultiplier: 1.7,
            healChance: 0.1,
            lootTable: [
              { itemName: "Piedras Espirituales", quantity: [1, 10], chance: 1 },
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "Venenos Mortales", quantity: [1, 3], chance: 0.05 },
              { itemName: "Fragmentos de Jade", quantity: [1, 2], chance: 0.02 },
              { itemName: "Esencia Oscura", quantity: [1, 1], chance: 0.05 },
              {
                itemName: "Rollo: Dardo Venenoso",
                quantity: [1, 1],
                chance: 0.05,
              },
              {
                itemName: "Rollo: Piel de Piedra",
                quantity: [1, 1],
                chance: 0.05,
              },
              {
                itemName: "Rollo: Voluntad de Hierro",
                quantity: [1, 1],
                chance: 0.015,
              },
              {
                itemName: "Rollo: Flecha Celestial",
                quantity: [1, 1],
                chance: 0.05,
              },
              {
                itemName: "Rollo: Abrazo de la Naturaleza",
                quantity: [1, 1],
                chance: 0.01,
              },
              {
                itemName: "Rollo: Rugido de Drag√≥n",
                quantity: [1, 1],
                chance: 0.01,
              },
              {
                itemName: "Rollo: Clon Fantasma",
                quantity: [1, 1],
                chance: 0.01,
              },
            ],
          },

          flor_luna_escarchada_guardian: {
            symbol: "‚ùÑÔ∏è",
            name: "Esp√≠ritu de Hielo Protector",
            typeOverride: "monster",
            hp: 120,
            level:5,
            attack: 35,
            defense: 10,
            exp: 40,
            maxHp: 120,
            lootTable: [
              {
                itemName: "Flor de Luna Escarchada",
                quantity: [1, 2],
                chance: 0.8,
              },
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            ],
          },
          raiz_fuego_terrenal_elemental: {
            symbol: "üî•",
            name: "Elemental de Magma Menor",
            typeOverride: "monster",
            hp: 150,
            level:7,
            attack: 40,
            defense: 5,
            exp: 45,
            maxHp: 150,
            lootTable: [
              {
                itemName: "Ra√≠z de Fuego Terrenal",
                quantity: [1, 1],
                chance: 0.7,
              },
              {
                itemName: "Piedras Espirituales",
                quantity: [5, 10],
                chance: 0.5,
              },
            ],
          },
          bandido_desfiladero: {
            symbol: "üò†",
            name: "Bandido del Desfiladero",
            typeOverride: "monster",
            hp: 180,
            level:9,
            attack: 45,
            defense: 10,
            exp: 60,
            maxHp: 180,
            healChance: 0.15,
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [10, 30],
                chance: 0.5,
              },
              { itemName: "Daga Oxidada", quantity: [1, 1], chance: 0.2 },
            ],
            fixedLocation: { x: 25, y: 40 },
          },

          esqueleto_podrido: {
            symbol: "üíÄ",
            name: "Esqueleto podrido",
            spriteUrl: "img/esqueleto_1.png",
            typeOverride: "monster",
            hp: 180,
            level:9,
            attack: 45,
            defense: 10,
            exp: 60,
            maxHp: 180,
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [8, 10],
                chance: 0.8,
              },
              
            ],
          },
             jabali_alfa_1: { 
              symbol: "üêó",
              name: "Jabal√≠ Colmilludo",
              spriteUrl: "img/jabali.png",
              typeOverride: "monster",
              hp: 300, 
              level:9, 
              attack: 55, 
              defense: 20, 
              exp: 120, 
              maxHp: 300,
              
              lootTable: [
                
                { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
                
                { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
              ],
              fixedLocation: { x: 53, y: 26 },
          },
          jabali_alfa_2: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 55, y: 26 },
          },
          jabali_alfa_3: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 57, y: 26 },
          },
          jabali_alfa_4: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 59, y: 26 },
          },
          jabali_alfa_5: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 50, y: 28 },
          },
          jabali_alfa_6: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 52, y: 28 },
          },
          jabali_alfa_7: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 54, y: 28 },
          },
           jabali_alfa_8: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 56, y: 30 },
          },
           jabali_alfa_9: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
            lootTable: [ /* (mismo loot) */ ],
            fixedLocation: { x: 58, y: 30 },
          },
           jabali_alfa_10: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",      
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 55, y: 32 },
          },
          jabali_alfa_10: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 52, y: 30 },
          },
          jabali_alfa_11: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 52, y: 32 },
          },
          jabali_alfa_12: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 52, y: 34 },
          },
          
          //BOSSES
           jabali_colmilludo_alfa: { 
            symbol: "üêó",
            name: "Jabal√≠ Colmilludo Alfa (BOSS)",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 400, 
            level:10, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            isBoss: true,
            healChance: 0.2,
            lootTable: [
              { itemName: "Colmillo de Jabal√≠ Alfa", quantity: [1, 1], chance: 0.9, },
              { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6, },
              { itemName: "Piel Resistente", quantity: [1, 2], chance: 0.4 },
              { itemName: "Piedras Espirituales", quantity: [6, 10], chance: 1 },
            ],
            fixedLocation: { x: 57, y: 28 },
      },
        
          golem_de_piedra: {
            symbol: "üóø",
            name: "Golem Ancestral de Jade",
            spriteUrl: "img/golem_jade.png",
            typeOverride: "monster",
            hp: 800,
            level:11,
            attack: 35,
            defense: 50,
            exp: 500,
            maxHp: 800,
            isBoss: true,
            abilities: [
              {
                name: "Golpe S√≠smico",
                damageMultiplier: 2.0,
                chance: 0.2,
                type: "area_attack_simulated",
              },
              { name: "Restauraci√≥n P√©trea", healPercentage: 0.2, chance: 0.1 },
            ],
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [10, 15],
                chance: 1.0,
              },
              {
                itemName: "Coraz√≥n de Golem de Jade",
                quantity: [1, 1],
                chance: 0.9,
              },
      
              { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
              {
                itemName: "N√∫cleo Elemental",
                quantity: [1, 2],
                chance: 0.3,
                extraData: { elementalType: "earth" },
              },
              
            ],
            
          },

          lider_renegado_1: {
            symbol: "üë§",
            name: "L√≠der Cultor Renegado Kai",
            typeOverride: "monster",
            hp: 500,
            level:15,
            attack: 70,
            defense: 25,
            exp: 250,
            maxHp: 500,
            isMiniBoss: true,
            specialChance: 0.25,
            specialAttackMultiplier: 1.6,
            lootTable: [
              {
                itemName: "Comp√°s Espiritual Antiguo",
                quantity: [1, 1],
                chance: 1.0,
              },
              {
                itemName: "P√≠ldora de Qi Condensado",
                quantity: [1, 1],
                chance: 0.3,
              },
              {
                itemName: "Piedras Espirituales",
                quantity: [10, 20],
                chance: 0.8,
              },
            ],
            fixedLocation: { x: 17, y: 12 },
          },

          //BOSSES

          boss_dem: {
            symbol: "üëø",
            name: "General Demonio",
            spriteUrl: "img/boss_dem.png",
            typeOverride: "monster",
            hp: 500,
            level:10,
            attack: 45,
            defense: 20,
            exp: 300,
            maxHp: 500,
            isBoss: true,
            specialChance: 0.35,
            specialAttackMultiplier: 1.8,
            healChance: 0.15,
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [15, 30],
                chance: 1.0,
              },
              {
                itemName: "N√∫cleo Demon√≠aco Mayor",
                quantity: [1, 1],
                chance: 0.8,
              },
              {
                itemName: "Rollo: Palma Destructora de Monta√±as",
                quantity: [1, 1],
                chance: 0.25,
              },
             
              {
                itemName: "Rollo: Barrera M√≠stica",
                quantity: [1, 1],
                chance: 0.25,
              },
            ],
            nextBossId: "boss_ancient_golem",
            fixedLocation: { x: 9, y: 36 },
          },

          boss_ancient_golem: {
            symbol: "üóø",
            name: "Golem Ancestral de Jade",
            spriteUrl: "img/golem_jade.png",
            typeOverride: "monster",
            hp: 800,
            level:11,
            attack: 35,
            defense: 50,
            exp: 500,
            maxHp: 800,
            isBoss: true,
            abilities: [
              {
                name: "Golpe S√≠smico",
                damageMultiplier: 2.0,
                chance: 0.2,
                type: "area_attack_simulated",
              },
              { name: "Restauraci√≥n P√©trea", healPercentage: 0.2, chance: 0.1 },
            ],
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [10, 15],
                chance: 1.0,
              },
              {
                itemName: "Coraz√≥n de Golem de Jade",
                quantity: [1, 1],
                chance: 0.9,
              },
      
              { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
              {
                itemName: "N√∫cleo Elemental",
                quantity: [1, 2],
                chance: 0.3,
                extraData: { elementalType: "earth" },
              },
              
            ],
            nextBossId: null,
            fixedLocation: { x: 72, y: 51 },
          },
        };

        const itemData = {
          "Hierbas Medicinales": {
            description: "Restaura un 30 de HP.",
            effect: (ps) => {
              if (ps.hp >= ps.maxHp) return "Vida al m√°ximo.";
              const h = 30;
              const o = ps.hp;
              ps.hp = Math.min(ps.maxHp, ps.hp + h);
              return `Usada P√≠ldora, recuperado ${ps.hp - o} HP.`;
            },
            canUse: (ps) => ps.hp < ps.maxHp,
          },
          "Cristales de Qi": {
            description: "Restaura un 30% de tu Man√° M√°ximo.",
            effect: (ps) => {
              if (ps.mana >= ps.maxMana) return "Man√° al m√°ximo.";
              const h = Math.floor(ps.maxMana * 0.3);
              const o = ps.mana;
              ps.mana = Math.min(ps.maxMana, ps.mana + h);
              return `Recuperado ${ps.mana - o} Man√°.`;
            },
            canUse: (ps) => ps.mana < ps.maxMana,
          },
          "Piedras Espirituales": {
            description: "Imbuida de energ√≠a. Otorga 50 EXP.",
            effect: (ps, gex) => {
              gex(50);
              return `Absorbido Piedra Espiritual y ganado 50 EXP.`;
            },
            canUse: () => true,
          },
          "Flor de Luna Escarchada": {
            description: "Flor brillante usada en alquimia.Item de misi√≥n",
            canUse: () => false,
          },
          "Ra√≠z de Fuego Terrenal": {
            description: "Ra√≠z que irradia calor, ingrediente alqu√≠mico.",
            canUse: () => false,
          },
          "P√≠ldora de Recuperaci√≥n Menor": {
            description: "P√≠ldora alqu√≠mica que restaura 50 HP.",
            effect: (ps) => {
              if (ps.hp >= ps.maxHp) return "Vida al m√°ximo.";
              const h = 50;
              const o = ps.hp;
              ps.hp = Math.min(ps.maxHp, ps.hp + h);
              return `Usada P√≠ldora, recuperado ${ps.hp - o} HP.`;
            },
            canUse: (ps) => ps.hp < ps.maxHp,
          },
          "Talism√°n de Percepci√≥n": {
            description: "Agudiza sentidos. Otorga EXP.",
            effect: (ps, gex) => {
              gex(100);
              return `Estudiado Talism√°n, ganado 100 EXP.`;
            },
            canUse: () => true,
          },
          "Colmillo de Jabal√≠ Alfa": {
            description: "Colmillo intacto de Jabal√≠ Alfa. Item de misi√≥n de caza.",
            canUse: () => false,
          },
          "Carne de Bestia Ex√≥tica": {
            description: "Nutritiva. Restaura 25% HP y 10% Man√°.",
            effect: (ps) => {
              let m = "";
              const hA = Math.floor(ps.maxHp * 0.25);
              if (ps.hp < ps.maxHp) {
                const o = ps.hp;
                ps.hp = Math.min(ps.maxHp, ps.hp + hA);
                m += `Recuperado ${ps.hp - o} HP. `;
              }
              const mA = Math.floor(ps.maxMana * 0.1);
              if (ps.mana < ps.maxMana) {
                const o = ps.mana;
                ps.mana = Math.min(ps.maxMana, ps.mana + mA);
                m += `Recuperado ${ps.mana - o} Man√°.`;
              }
              return m || "HP y Man√° al m√°ximo.";
            },
            canUse: (ps) => ps.hp < ps.maxHp || ps.mana < ps.maxMana,
          },
          "Mapa del Tesoro Fragmentado": {
            description: "Fragmento de mapa antiguo. ¬øOtras partes?",
            effect: (ps, gex) => {
              gex(50);
              return `Examinado fragmento, ganado 50 EXP. Indica zona monta√±osa...`;
            },
            canUse: () => true,
          },
          "Comp√°s Espiritual Antiguo": {
            description: "Artefacto de secta que resuena con energ√≠as.",
            canUse: () => false,
          },
          "Manual de Formaci√≥n B√°sica": {
            description: "Ense√±a principios de formaciones defensivas.",
            effect: (ps) => {
              ps.baseDefense += 2;
              recalculatePlayerStats();
              return `Estudiado Manual. Defensa base +2.`;
            },
            canUse: () => true,
          },
          "N√∫cleo de Bestia Menor": {
            description: "N√∫cleo de bestia demon√≠aca. Otorga 20 EXP.",
            effect: (ps, gex) => {
              gex(20);
              return `Absorbido N√∫cleo, ganado 20 EXP.`;
            },
            canUse: () => true,
          },
          // -- Rollos Grado 1 --
        "Rollo: Tajo del Viento Veloz": { description: "Ense√±a 'Tajo del Viento Veloz'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t1"), canUse: () => true },
        "Rollo: F√≠sico de Buey de Piedra": { description: "Ense√±a 'F√≠sico de Buey de Piedra'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t1"), canUse: () => true },
        "Rollo: Matriz de Escudo de Qi": { description: "Ense√±a 'Matriz de Escudo de Qi'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t1"), canUse: () => true },
        "Rollo: Chispa √çgnea": { description: "Ense√±a 'Chispa √çgnea'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t1"), canUse: () => true },
        "Rollo: Dedo de Rel√°mpago": { description: "Ense√±a 'Dedo de Rel√°mpago'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t1"), canUse: () => true },

        // -- Rollos Grado 2 --
        "Rollo: Estocada Perfora-Armadura": { description: "Ense√±a 'Estocada Perfora-Armadura'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t2"), canUse: () => true },
        "Rollo: Piel de Acero Fundido": { description: "Ense√±a 'Piel de Acero Fundido'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t2"), canUse: () => true },
        "Rollo: Matriz de Grilletes de Qi": { description: "Ense√±a 'Matriz de Grilletes de Qi'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t2"), canUse: () => true },
        "Rollo: Paso Et√©reo": { description: "Ense√±a 'Paso Et√©reo'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t2"), canUse: () => true },
        "Rollo: Aliento de Drag√≥n Menor": { description: "Ense√±a 'Aliento de Drag√≥n Menor'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t2"), canUse: () => true },

        // -- Rollos Grado 3 --
        "Rollo: Danza de Espada Cicl√≥nica": { description: "Ense√±a 'Danza de Espada Cicl√≥nica'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t3"), canUse: () => true },
        "Rollo: Coraz√≥n de Voluntad Indomable": { description: "Ense√±a 'Coraz√≥n de Voluntad Indomable'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t3"), canUse: () => true },
        "Rollo: Matriz de Supresi√≥n Espiritual": { description: "Ense√±a 'Matriz de Supresi√≥n Espiritual'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t3"), canUse: () => true },
        "Rollo: Jaula de Rayos": { description: "Ense√±a 'Jaula de Rayos'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t3"), canUse: () => true },
        "Rollo: Parpadeo de Sombra": { description: "Ense√±a 'Parpadeo de Sombra'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t3"), canUse: () => true },

        // -- Rollos Grado 4 --
        "Rollo: Intento de Espada del Tirano": { description: "Ense√±a 'Intento de Espada del Tirano'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t4"), canUse: () => true },
        "Rollo: Cuerpo Dorado Inmortal": { description: "Ense√±a 'Cuerpo Dorado Inmortal'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t4"), canUse: () => true },
        "Rollo: Sol Abrasador": { description: "Ense√±a 'Sol Abrasador'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t4"), canUse: () => true },
        "Rollo: Llamada del Juicio del Trueno": { description: "Ense√±a 'Llamada del Juicio del Trueno'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t4"), canUse: () => true },
        "Rollo: Santuario Dorado Protector": { description: "Ense√±a 'Santuario Dorado Protector'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t4"), canUse: () => true },
        // -- Rollos Grado 5 --
        "Rollo: Corte que Divide Cielos y Tierra": { description: "Ense√±a 'Corte que Divide Cielos y Tierra'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"), canUse: () => true },
        "Rollo: Constituci√≥n de Drag√≥n Ancestral": { description: "Ense√±a 'Constituci√≥n de Drag√≥n Ancestral'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"), canUse: () => true },
        "Rollo: Llama del F√©nix Renaciente": { description: "Ense√±a 'Llama del F√©nix Renaciente'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"), canUse: () => true },
        "Rollo: Tribulaci√≥n de los Nueve Cielos": { description: "Ense√±a 'Tribulaci√≥n de los Nueve Cielos'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"), canUse: () => true },
        "Rollo: Matriz de Reversi√≥n del Cosmos": { description: "Ense√±a 'Matriz de Reversi√≥n del Cosmos'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"), canUse: () => true },
        "Rollo: Paso del Vac√≠o Infinito": { description: "Ense√±a 'Paso del Vac√≠o Infinito'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"), canUse: () => true },

        // -- Rollos Grado 6 --
        "Rollo: Espada del Emperador Celestial": { description: "Ense√±a 'Espada del Emperador Celestial'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"), canUse: () => true },
        "Rollo: Cuerpo Inmortal de Jade": { description: "Ense√±a 'Cuerpo Inmortal de Jade'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t6"), canUse: () => true },
        "Rollo: Incineraci√≥n del Mundo Mortal": { description: "Ense√±a 'Incineraci√≥n del Mundo Mortal'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t6"), canUse: () => true },
        "Rollo: Decreto del Se√±or del Trueno": { description: "Ense√±a 'Decreto del Se√±or del Trueno'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t6"), canUse: () => true },
        "Rollo: Matriz del Sello del Demonio": { description: "Ense√±a 'Matriz del Sello del Demonio'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t6"), canUse: () => true },
        "Rollo: Omnipresencia Divina": { description: "Ense√±a 'Omnipresencia Divina'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t6"), canUse: () => true },
        // -- Rollos Grado 7 --
        "Rollo: Lamento del Fin del Mundo": { description: "Ense√±a 'Lamento del Fin del Mundo'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"), canUse: () => true },
        "Rollo: Forma del Ancestro Primordial": { description: "Ense√±a 'Forma del Ancestro Primordial'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"), canUse: () => true },
        "Rollo: G√©nesis √çgneo": { description: "Ense√±a 'G√©nesis √çgneo'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"), canUse: () => true },
        "Rollo: C√≥lera del Emperador Celestial": { description: "Ense√±a 'C√≥lera del Emperador Celestia'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"), canUse: () => true },
        "Rollo: Matriz del Caos Primordial": { description: "Ense√±a 'Matriz del Caos Primordial'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"), canUse: () => true },
        "Rollo: Danza del Tejido Espacio-Tiempo": { description: "Ense√±a 'Danza del Tejido Espacio-Tiempo'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"), canUse: () => true },

        // -- Rollos Grado 8 --
        "Rollo: Decreto Imperial: Extinci√≥n": { description: "Decreto Imperial: Extinci√≥n'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"), canUse: () => true },
        "Rollo: Avatar del Dao Eterno": { description: "Ense√±a 'Avatar del Dao Eterno'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t6"), canUse: () => true },
        "Rollo: Apocalipsis de Llamas Divinas": { description: "Ense√±a 'Apocalipsis de Llamas Divinas'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t6"), canUse: () => true },
        "Rollo: Tribulaci√≥n del Fin de los Tiempos": { description: "Ense√±a 'Tribulaci√≥n del Fin de los Tiempos'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t6"), canUse: () => true },
        "Rollo: Matriz de Reescritura de la Realidad": { description: "Ense√±a 'Matriz de Reescritura de la Realidad'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t6"), canUse: () => true },
        "Rollo: Trascendencia Dimensional": { description: "Ense√±a 'Trascendencia Dimensional'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t6"), canUse: () => true },
        // -- Rollos Grado 9 --
        "Rollo: Corte del Origen Absoluto": { description: "Ense√±a 'Corte del Origen Absoluto'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"), canUse: () => true },
        "Rollo: Constituci√≥n de Drag√≥n Ancestral": { description: "Ense√±a 'Constituci√≥n de Drag√≥n Ancestral'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"), canUse: () => true },
        "Rollo: Llama del F√©nix Renaciente": { description: "Ense√±a 'Llama del F√©nix Renaciente'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"), canUse: () => true },
        "Rollo: Tribulaci√≥n de los Nueve Cielos": { description: "Ense√±a 'Tribulaci√≥n de los Nueve Cielos'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"), canUse: () => true },
        "Rollo: Matriz de Reversi√≥n del Cosmos": { description: "Ense√±a 'Matriz de Reversi√≥n del Cosmos'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"), canUse: () => true },
        "Rollo: Paso del Vac√≠o Infinito": { description: "Ense√±a 'Paso del Vac√≠o Infinito'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"), canUse: () => true },

        // -- Rollos Grado 10 --
        "Rollo: Espada del Emperador Celestial": { description: "Ense√±a 'Espada del Emperador Celestial'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"), canUse: () => true },
        "Rollo: Cuerpo Inmortal de Jade": { description: "Ense√±a 'Cuerpo Inmortal de Jade'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t6"), canUse: () => true },
        "Rollo: Incineraci√≥n del Mundo Mortal": { description: "Ense√±a 'Incineraci√≥n del Mundo Mortal'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t6"), canUse: () => true },
        "Rollo: Decreto del Se√±or del Trueno": { description: "Ense√±a 'Decreto del Se√±or del Trueno'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t6"), canUse: () => true },
        "Rollo: Matriz del Sello del Demonio": { description: "Ense√±a 'Matriz del Sello del Demonio'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t6"), canUse: () => true },
        "Rollo: Omnipresencia Divina": { description: "Ense√±a 'Omnipresencia Divina'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t6"), canUse: () => true },
        
        

          "Rollo: Absorci√≥n de Qi Menor": {
            description: "Ense√±a 'T√©cnica de Absorci√≥n de Qi Menor'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "qi_absorption_boost_1"),
            canUse: () => true,
          },


          "Rollo: Fortificaci√≥n Corporal B√°sica": {
            description: "Ense√±a 'Fortificaci√≥n Corporal B√°sica'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "body_fortification_1"),
            canUse: () => true,
          },
          "Rollo: Corte de Espada B√°sico": {
            description: "Ense√±a 'Corte de Espada B√°sico'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "sword_slash_1"),
            canUse: () => true,
          },
          "Rollo: Conversi√≥n de Qi": {
            description: "Ense√±a 'T√©cnica de Conversi√≥n de Qi'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "qi_to_hp_conversion_1"),
            canUse: () => true,
          },
          "Rollo: Prisi√≥n de Hielo": {
            description: "Ense√±a 'Prisi√≥n de Hielo'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "ice_prison_1"),
            canUse: () => true,
          },
          "Rollo: Golpe de Llamas": {
            description: "Ense√±a 'Golpe de Llamas'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "flame_strike_1"),
            canUse: () => true,
          },
          "Rollo: Furia del Trueno": {
            description: "Ense√±a 'Furia del Trueno'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "thunder_fury_1"),
            canUse: () => true,
          },
          "Rollo: Dardo Venenoso": {
            description: "Ense√±a 'Dardo Venenoso'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "poison_dart_1"),
            canUse: () => true,
          },
          "Rollo: Piel de Piedra": {
            description: "Ense√±a 'Piel de Piedra'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "stone_skin_1"),
            canUse: () => true,
          },
          "Rollo: Paso de las Sombras": {
            description: "Ense√±a 'Paso de las Sombras'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "shadow_step_1"),
            canUse: () => true,
          },
          "Rollo: Drenaje de Alma": {
            description: "Ense√±a 'Drenaje de Alma'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "soul_drain_1"),
            canUse: () => true,
          },
          "Rollo: Golpe Cicl√≥n": {
            description: "Ense√±a 'Golpe Cicl√≥n'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "cyclone_strike_1"),
            canUse: () => true,
          },
          "Rollo: Lluvia Curativa": {
            description: "Ense√±a 'Lluvia Curativa'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "healing_rain_1"),
            canUse: () => true,
          },
          "Rollo: Explosi√≥n Mental": {
            description: "Ense√±a 'Explosi√≥n Mental'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "mind_blast_1"),
            canUse: () => true,
          },
          "Rollo: Voluntad de Hierro": {
            description: "Ense√±a 'Voluntad de Hierro'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "iron_will_1"),
            canUse: () => true,
          },
          "Rollo: Flecha Celestial": {
            description: "Ense√±a 'Flecha Celestial'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "celestial_arrow_1"),
            canUse: () => true,
          },
          "Rollo: Abrazo de la Naturaleza": {
            description: "Ense√±a 'Abrazo de la Naturaleza'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "nature_grasp_1"),
            canUse: () => true,
          },
          "Rollo: Rugido de Drag√≥n": {
            description: "Ense√±a 'Rugido de Drag√≥n'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "dragon_roar_1"),
            canUse: () => true,
          },
          "Rollo: Clon Fantasma": {
            description: "Ense√±a 'Clon Fantasma'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "phantom_clone_1"),
            canUse: () => true,
          },
          "Rollo: Cambio Temporal": {
            description: "Ense√±a 'Cambio Temporal'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "temporal_shift_1"),
            canUse: () => true,
          },
          "Rollo: Ritual de Sangre": {
            description: "Ense√±a 'Ritual de Sangre'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "blood_ritual_1"),
            canUse: () => true,
          },
          "Rollo: Aura de Pureza": {
            description: "Ense√±a 'Aura de Pureza'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "aura_of_purity_1"),
            canUse: () => true,
          },
          "Rollo: Invocar Elemental": {
            description: "Ense√±a 'Invocar Elemental'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "summon_elemental_1"),
            canUse: () => true,
          },
          "Rollo: Barrera M√≠stica": {
            description: "Ense√±a 'Barrera M√≠stica'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "mystic_barrier_1"),
            canUse: () => true,
          },
          "Cristal de Hielo": {
            description: "Cristal g√©lido. Otorga 25 EXP.",
            effect: (ps, gex) => {
              gex(25);
              return `Absorbido Cristal de Hielo, ganado 25 EXP.`;
            },
            canUse: () => true,
          },
          "Esencia de Fuego": {
            description: "Energ√≠a √≠gnea concentrada. Otorga 25 EXP.",
            effect: (ps, gex) => {
              gex(25);
              return `Absorbido Esencia de Fuego, ganado 25 EXP.`;
            },
            canUse: () => true,
          },
          "N√∫cleo de Tormenta": {
            description: "Coraz√≥n de tormenta. Otorga 50 EXP.",
            effect: (ps, gex) => {
              gex(50);
              return `Absorbido N√∫cleo de Tormenta, ganado 50 EXP.`;
            },
            canUse: () => true,
          },
          "Venenos Mortales": {
            description: "Venenos potentes. Otorga 15 EXP.",
            effect: (ps, gex) => {
              gex(15);
              return `Estudiado Venenos Mortales, ganado 15 EXP.`;
            },
            canUse: () => true,
          },
          "Fragmentos de Jade": {
            description: "Jade imbuido de energ√≠a. Otorga 20 EXP.",
            effect: (ps, gex) => {
              gex(20);
              return `Absorbido Fragmentos de Jade, ganado 20 EXP.`;
            },
            canUse: () => true,
          },
          "Esencia Oscura": {
            description: "Energ√≠a de sombras. Otorga 30 EXP.",
            effect: (ps, gex) => {
              gex(30);
              return `Absorbido Esencia Oscura, ganado 30 EXP.`;
            },
            canUse: () => true,
          },
          "Almas Condenadas": {
            description: "Ecos de almas. Otorga 40 EXP.",
            effect: (ps, gex) => {
              gex(40);
              return `Liberado Almas Condenadas, ganado 40 EXP.`;
            },
            canUse: () => true,
          },
          "N√∫cleo de V√≥rtice": {
            description: "Energ√≠a ca√≥tica. Otorga 50 EXP.",
            effect: (ps, gex) => {
              gex(50);
              return `Absorbido N√∫cleo de V√≥rtice, ganado 50 EXP.`;
            },
            canUse: () => true,
          },
          "Roc√≠o Celestial": {
            description: "Gotas de energ√≠a celestial. Otorga 35 EXP.",
            effect: (ps, gex) => {
              gex(35);
              return `Bebido Roc√≠o Celestial, ganado 35 EXP.`;
            },
            canUse: () => true,
          },
          "Cristales Ps√≠quicos": {
            description: "Resuenan con poder mental. Otorga 45 EXP.",
            effect: (ps, gex) => {
              gex(45);
              return `Meditado con Cristales Ps√≠quicos, ganado 45 EXP.`;
            },
            canUse: () => true,
          },
          "Mineral de Hierro Espiritual": {
            description: "Hierro imbuido con Qi. Otorga 25 EXP.",
            effect: (ps, gex) => {
              gex(25);
              return `Refinado Mineral, ganado 25 EXP.`;
            },
            canUse: () => true,
          },
          "Plumas de F√©nix": {
            description: "Imbuidas con esencia de renovaci√≥n. Otorga 60 EXP.",
            effect: (ps, gex) => {
              gex(60);
              return `Meditado con Plumas de F√©nix, ganado 60 EXP.`;
            },
            canUse: () => true,
          },
          "Semillas Ancestrales": {
            description: "Llenas de vitalidad. Otorga 30 EXP.",
            effect: (ps, gex) => {
              gex(30);
              return `Plantado Semillas en dantian, ganado 30 EXP.`;
            },
            canUse: () => true,
          },
          "Escamas de Drag√≥n": {
            description: "Imbuidas con poder drac√≥nico. Otorga 70 EXP.",
            effect: (ps, gex) => {
              gex(70);
              return `Estudiado Escamas de Drag√≥n, ganado 70 EXP.`;
            },
            canUse: () => true,
          },
          "Espejos Astrales": {
            description: "Reflejan otros planos. Otorga 40 EXP.",
            effect: (ps, gex) => {
              gex(40);
              return `Meditado con Espejos Astrales, ganado 40 EXP.`;
            },
            canUse: () => true,
          },
          "Relojes de Arena": {
            description: "Manipulan flujo del tiempo. Otorga 50 EXP.",
            effect: (ps, gex) => {
              gex(50);
              return `Estudiado Relojes de Arena, ganado 50 EXP.`;
            },
            canUse: () => true,
          },
          "Sangre de Demonio": {
            description: "Sangre corrupta pero potente. Otorga 35 EXP.",
            effect: (ps, gex) => {
              gex(35);
              return `Analizado Sangre de Demonio, ganado 35 EXP.`;
            },
            canUse: () => true,
          },
          "L√°grimas de Unicornio": {
            description:
              "Purificadoras con propiedades curativas. Otorga 45 EXP.",
            effect: (ps, gex) => {
              gex(45);
              return `Usado L√°grimas para purificar Qi, ganado 45 EXP.`;
            },
            canUse: () => true,
          },
          "N√∫cleo Elemental": {
            description: "Esencia de poder elemental. Otorga 65 EXP.",
            effect: (ps, gex) => {
              gex(65);
              return `Absorbido N√∫cleo Elemental, ganado 65 EXP.`;
            },
            canUse: () => true,
          },
          "Polvo de Arcano": {
            description: "Brillante con propiedades m√°gicas. Otorga 40 EXP.",
            effect: (ps, gex) => {
              gex(40);
              return `Utilizado Polvo de Arcano en ritual, ganado 40 EXP.`;
            },
            canUse: () => true,
          },
        };

  
        // --- FUNCIONES HELPER PARA UI M√ìVIL ---
        function isMobileView() {
          return (
            window.matchMedia("(max-width: 768px)").matches ||
            window.matchMedia("(hover: none) and (pointer: coarse)").matches
          );
        }

        /// <!-- CAMBIO TAMA√ëO MAPA M√ìVIL -->
        //TAMA√ëO TILE
        function calculateAndSetTileSize() {
          const mapContainerElement = document.querySelector(".map-container");
          if (!mapContainerElement) {
            console.warn(
              "calculateAndSetTileSize: mapContainerElement no encontrado, usando G_TILE_SIZE por defecto."
            );
            currentTileSize = G_TILE_SIZE;
            return G_TILE_SIZE;
          }

          if (isMobileView()) {
            const availableWidth = mapContainerElement.clientWidth;
            const availableHeight = mapContainerElement.clientHeight;

            // --- INICIO DE LA L√ìGICA DE ORIENTACI√ìN ---

            // Determina si estamos en modo horizontal (landscape) o vertical (portrait)
            const isLandscape = availableWidth > availableHeight;

            // Define cu√°ntos tiles queremos ver en cada orientaci√≥n.
            // Estos valores son la clave. ¬°Puedes ajustarlos a tu gusto!
            const TILES_VISIBLE_X_PORTRAIT = 7;  // Menos tiles de ancho en vertical
            const TILES_VISIBLE_Y_PORTRAIT = 5;  // M√°s tiles de alto en vertical
            
            const TILES_VISIBLE_X_LANDSCAPE = 8; // M√°s tiles de ancho en horizontal
            const TILES_VISIBLE_Y_LANDSCAPE = 6;  // Menos tiles de alto en horizontal

            let tileSizeBasedOnWidth;
            let tileSizeBasedOnHeight;

            if (isLandscape) {
              // Si la pantalla es m√°s ancha que alta
              console.log("Orientaci√≥n: Horizontal (Landscape)");
              tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_LANDSCAPE;
              tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_LANDSCAPE;
            } else {
              // Si la pantalla es m√°s alta que ancha
              console.log("Orientaci√≥n: Vertical (Portrait)");
              tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_PORTRAIT;
              tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_PORTRAIT;
            }

            // --- FIN DE LA L√ìGICA DE ORIENTACI√ìN ---

            // El tama√±o del tile ser√° el menor de los dos c√°lculos para asegurar que todo quepa
            currentTileSize = Math.floor(
              Math.min(tileSizeBasedOnWidth, tileSizeBasedOnHeight)
            );
            currentTileSize = Math.max(20, currentTileSize); // Asegurar un tama√±o m√≠nimo razonable

            console.log(
              `Mobile View: Container W: ${availableWidth}, H: ${availableHeight}. Calculated Tile Size: ${currentTileSize}`
            );
          } else {
            currentTileSize = G_TILE_SIZE; // Usar el tama√±o fijo para escritorio
            console.log(`Desktop View: Using G_TILE_SIZE: ${currentTileSize}`);
          }
          return currentTileSize;
        }
        // <!-- FIN CAMBIO TAMA√ëO MAPA M√ìVIL -->

        function isAnyModalOpen() {
          const modals = [
            "interactionModal",
            "activeCultivationModal",
            "shopModal",
            "sectHallModal",
            "cultivationChoiceModal",
            "techniqueModal",
          ];
          for (const modalId of modals) {
            const modalElement = document.getElementById(modalId);
            if (modalElement && modalElement.style.display === "flex") {
              return true;
            }
          }
          return false;
        }

        // NUEVA FUNCI√ìN para controlar la visibilidad de la barra inferior
        function updateTopNavVisibility() { // Renombramos la funci√≥n para claridad
          if (!topNavBar) return;

          if (gameState.battle.active || isAnyModalOpen()) {
              topNavBar.classList.add("hidden");
          } else {
              topNavBar.classList.remove("hidden");
          }
      }
        function openMissionsModal() {
          const container = document.getElementById("missionsContainer");
          container.innerHTML = "";
          const player = gameState.player;

          if (player.secta.misionesActivas.length === 0) {
              container.innerHTML = "<p style='text-align: center;'>No tienes misiones activas en este momento.</p>";
          } else {
              player.secta.misionesActivas.forEach((misionActiva) => {
                  const misionData = MISIONES_DATA[misionActiva.id];
                  if (!misionData) return;

                  // Reutilizamos la l√≥gica de la UI de la secta para mostrar el progreso
                  let progresoTexto = "";
                  const objetivo = misionActiva.objetivoOriginal;
                  if (objetivo) {
                      const npcEntregaNombre = SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre || "el NPC correspondiente";
                      if (objetivo.tipo === "eliminar_enemigo") {
                          progresoTexto = `Progreso: ${misionActiva.progreso || 0}/${objetivo.cantidad} ${objetivo.nombreDisplay || "objetivos"}`;
                          if ((misionActiva.progreso || 0) >= objetivo.cantidad) progresoTexto += ` <strong>(¬°Listo para entregar a ${npcEntregaNombre}!)</strong>`;
                      } else if (objetivo.tipo === "entregar_item") {
                          progresoTexto = `Reunir: ${gameState.inventory[objetivo.item] || 0}/${objetivo.cantidad} ${objetivo.item}`;
                          if ((gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad) progresoTexto += ` <strong>(¬°Listo para entregar a ${npcEntregaNombre}!)</strong>`;
                      }
                      // Puedes a√±adir m√°s casos para otros tipos de misiones
                  }
                  
                  const div = document.createElement("div");
                  div.style.border = "1px solid #d4af37";
                  div.style.borderRadius = "8px";
                  div.style.padding = "10px";
                  div.style.marginBottom = "10px";
                  div.style.background = "rgba(0,0,0,0.2)";

                  div.innerHTML = `
                      <h4>${misionData.titulo}</h4>
                      <p style="font-size: 0.9em; margin-top: 5px;">${misionData.descripcion}</p>
                      <p style="font-size: 0.8em; color: #f4d03f; margin-top: 8px;">${progresoTexto}</p>
                  `;
                  container.appendChild(div);
              });
          }

          document.getElementById("missionsModal").style.display = "flex";
          hideTouchControls();
      }

      function closeMissionsModal() {
          document.getElementById("missionsModal").style.display = "none";
          showTouchControls();
      }
        function showTouchControls() {
          const joystick = document.getElementById("joystick-container");
          const actionBtn = document.getElementById("action-button-touch");

          if (
            isMobileView() &&
            !mapControlsManuallyHidden &&
            !gameState.battle.active &&
            !isAnyModalOpen()
          ) {
            if (joystick) joystick.style.display = "block";
            if (actionBtn) actionBtn.style.display = "block";
          } else {
            if (joystick) joystick.style.display = "none";
            if (actionBtn) actionBtn.style.display = "none";
          }
        }

        function hideTouchControls() {
          const joystick = document.getElementById("joystick-container");
          const actionBtn = document.getElementById("action-button-touch");
          if (joystick) joystick.style.display = "none";
          if (actionBtn) actionBtn.style.display = "none";
        }

        function toggleMapControlsVisibility() {
          mapControlsManuallyHidden = !mapControlsManuallyHidden;
          const btn = document.getElementById("toggleMapControlsBtn");
          if (mapControlsManuallyHidden) {
            hideTouchControls();
            btn.textContent = "Mostrar Controles";
          } else {
            showTouchControls();
            btn.textContent = "Ocultar Controles";
          }
        }

        // --- FUNCIONES DEL JUEGO (MODIFICADAS Y EXISTENTES) ---

        function learnTechniqueFromRoll(playerState, techId) {
          if (!techniqueData[techId]) return "Error: T√©cnica desconocida.";
          if (playerState.learnedTechniques[techId]) {
            return `Ya conoces esta t√©cnica: ${techniqueData[techId].name}.`;
          }
          const techCultivationSettings =
            techniqueData[techId].cultivationSettings;
          playerState.learnedTechniques[techId] = {
            level: 0,
            currentCultivationProgress: 0,
            cultivationTimeToNextLevel: techCultivationSettings
              ? techCultivationSettings.baseTimeToLevelUp
              : 60,
          };
          if (techId === "qi_to_hp_conversion_1") {
            playerState.canUseQiConversion = true;
            updateToggleQiConversionButtonVisibility();
          }
          return `Has aprendido '${techniqueData[techId].name}'. Puedes cultivarla para mejorarla.`;
        }

        function showModal(title, text, nonInteractive = false) {
          document.querySelector('.stats-panel').style.display = 'none';
          const modalElement = document.getElementById("interactionModal");
          const modalTitleEl = document.getElementById("modalTitle");
          const modalTextEl = document.getElementById("modalText");

          if (!modalElement || !modalTitleEl || !modalTextEl) {
            console.error(
              "CRITICAL: Modal o sus elementos internos no encontrados."
            );
            alert(`Error UI: Modal no encontrado.\nMensaje: ${title} - ${text}`);
            return;
          }

          modalTitleEl.textContent = title;
          modalTextEl.innerHTML = text.replace(/\n/g, "<br>");

          const closeButton = modalElement.querySelector(
            "button.close-modal-btn"
          ); // Busca por clase

          if (closeButton) {
            if (nonInteractive) {
              closeButton.style.display = "none"; // Ocultar si es no interactivo
            } else {
              closeButton.style.display = "block"; // Asegurar que sea visible si es interactivo
              // El onclick="closeModal()" ya est√° en el HTML, por lo que no necesitamos reasignarlo.
            }
          } else if (!nonInteractive) {
            console.warn(
              "#interactionModal no tiene un bot√≥n de cierre con clase .close-modal-btn y no es nonInteractive."
            );
          }

          modalElement.style.display = "flex";
          hideTouchControls();
          updateTopNavVisibility();
        }

        function closeModal() {
          const modalElement = document.getElementById("interactionModal");
          if (modalElement) {
          modalElement.style.display = "none";
          }

          
          if (!gameState.battle.active) {
              document.querySelector('.stats-panel').style.display = 'block';
          }
          
          
          updatePlayerBarsOnMap();
          showTouchControls();
          updateTopNavVisibility();
      }
//ENEMIGOS Y NPC FIJOS
        function ensureFixedEntities() {
          const player = gameState.player;
          let entities = gameState.map.entities;

          let idsParaProcesar = [
            "shop",
            "secta_entrada_principal",
            "npc_secta_guia",
            "npc_secta_admin",
      
            "jabali_colmilludo_alfa",
            "boss_ancient_golem",
            "transition_ruins_entrance",
            "transition_ruins_exit",
            "jabali_alfa_1",
            "jabali_alfa_2",
            "jabali_alfa_3",
            "jabali_alfa_4",
             "jabali_alfa_5",
            "jabali_alfa_6",
            "jabali_alfa_7",
            "jabali_alfa_8",
            "jabali_alfa_9",
            "jabali_alfa_10",
            "jabali_alfa_11",
            "jabali_alfa_12",
            
            // Puedes a√±adir otros IDs de entidades fijas aqu√≠ directamente
          ];

          // L√≥gica para jefes principales (actuales)
          if (
            player.worldState.currentBossToSpawn &&
            entityTypes[player.worldState.currentBossToSpawn]
          ) {
            const bossDef = entityTypes[player.worldState.currentBossToSpawn];
            if (
              bossDef.fixedLocation &&
              !player.worldState.defeatedBosses[
                player.worldState.currentBossToSpawn
              ]
            ) {
              if (
                !idsParaProcesar.includes(player.worldState.currentBossToSpawn)
              ) {
                idsParaProcesar.push(player.worldState.currentBossToSpawn);
              }
            }
          }

          // L√≥gica para rivales de desaf√≠o de secta (actuales)
          player.secta.misionesActivas.forEach((misionActiva) => {
            const misionData = MISIONES_DATA[misionActiva.id];
            if (
              misionData?.objetivo?.tipo === "derrotar_npc_especifico" &&
              misionData.objetivo.npcId
            ) {
              const rivalId = misionData.objetivo.npcId;
              if (
                entityTypes[rivalId]?.fixedLocation &&
                !player.secta.misionesCompletadas[misionActiva.id]
              ) {
                if (!idsParaProcesar.includes(rivalId)) {
                  idsParaProcesar.push(rivalId);
                }
              }
            }
          });

          // Nueva l√≥gica: A√±adir entidades fijas que podr√≠an estar ligadas a misiones activas
          // (si implementas `missionRequirementId`)
          player.secta.misionesActivas.forEach((misionActiva) => {
            // Ejemplo: Si la misi√≥n "mision_cazar_bestia_especifica_1" est√° activa
            // y el jabal√≠ tiene un `missionRequirementId: "mision_cazar_bestia_especifica_1"`
            // y a√∫n no est√° en idsParaProcesar, lo a√±adir√≠as.
            // Este es un ejemplo, necesitar√≠as iterar sobre `entityTypes` para encontrar tales entidades.
            // Por ahora, como lo a√±adiste directamente a `idsParaProcesar`, esto es m√°s simple.
          });

          console.log(
            "[EnsureFixed] IDs a procesar:",
            JSON.parse(JSON.stringify(idsParaProcesar))
          );

          idsParaProcesar.forEach((entityTypeId) => {
            const definition = entityTypes[entityTypeId];
            if (!definition) {
              console.warn(
                `[EnsureFixed] Definici√≥n no encontrada para ${entityTypeId}`
              );
              return;
            }

            if (!definition.fixedLocation) {
              // Si una entidad en idsParaProcesar no tiene fixedLocation, no podemos colocarla as√≠.
              // Esto es un error de configuraci√≥n o la entidad no deber√≠a estar en esta lista.
              console.warn(
                `[EnsureFixed] La entidad ${entityTypeId} est√° en idsParaProcesar pero no tiene 'fixedLocation' en su definici√≥n.`
              );
              return;
            }

            const fixedX = definition.fixedLocation.x;
            const fixedY = definition.fixedLocation.y;

            const existingEntityInstance = entities.find(
              (e) =>
                (e.x === fixedX &&
                  e.y === fixedY &&
                  (e.type === (definition.typeOverride || entityTypeId) ||
                    e.originalEntityTypeId === entityTypeId)) ||
                (definition.npcId && e.npcId === definition.npcId) // Para NPCs
            );

            let debeExistir = true;

            // L√≥gica de si debe existir (para jefes, rivales, o entidades ligadas a misiones)
            if (definition.isSectChallengeRival && definition.npcId) {
              const desafioMision = Object.values(MISIONES_DATA).find(
                (m) =>
                  m.objetivo?.tipo === "derrotar_npc_especifico" &&
                  m.objetivo?.npcId === definition.npcId
              );
              const misionId = desafioMision
                ? Object.keys(MISIONES_DATA).find(
                    (key) => MISIONES_DATA[key] === desafioMision
                  )
                : null;
              if (misionId) {
                if (player.secta.misionesCompletadas[misionId])
                  debeExistir = false;
                else if (
                  !player.secta.misionesActivas.some((m) => m.id === misionId)
                )
                  debeExistir = false;
              } else debeExistir = false;
            } else if (definition.isBoss || definition.isMiniBoss) {
              // Tratar MiniBoss de forma similar a Boss para 'defeated'
              // Usaremos una nueva propiedad en player.worldState para rastrear minibosses fijos derrotados
              // si no quieres que reaparezcan inmediatamente.
              if (
                player.worldState.defeatedFixedEntities &&
                player.worldState.defeatedFixedEntities[entityTypeId]
              ) {
                // Si tiene un tiempo de respawn, podr√≠a reaparecer
                const lastDefeatedTime =
                  player.worldState.defeatedFixedEntities[entityTypeId].time;
                const respawnTimeSeconds = definition.respawnTime; // ej. 300 segundos
                if (
                  respawnTimeSeconds &&
                  (Date.now() - lastDefeatedTime) / 1000 < respawnTimeSeconds
                ) {
                  debeExistir = false; // A√∫n no es tiempo de reaparecer
                } else if (respawnTimeSeconds) {
                  debeExistir = true; // Tiempo de respawn cumplido
                  // Opcional: remover de defeatedFixedEntities para que no se re-evalue el tiempo hasta la pr√≥xima derrota
                  // delete player.worldState.defeatedFixedEntities[entityTypeId];
                } else {
                  debeExistir = false; // No tiene respawnTime, as√≠ que si est√° derrotado, no reaparece.
                }
              }
            } else if (definition.missionRequirementId) {
              // L√≥gica para entidades que dependen de una misi√≥n activa
              if (
                !player.secta.misionesActivas.some(
                  (m) => m.id === definition.missionRequirementId
                )
              ) {
                debeExistir = false; // La misi√≥n requerida no est√° activa
              }
              // Podr√≠as a√±adir una comprobaci√≥n de si la misi√≥n ya fue completada y la entidad debe desaparecer.
              if (
                player.secta.misionesCompletadas[
                  definition.missionRequirementId
                ] &&
                !definition.respawnTime
              ) {
                // Si la misi√≥n est√° completada y la entidad no tiene respawn, no debe existir.
                debeExistir = false;
              }
            }

            if (debeExistir) {
              if (!existingEntityInstance) {
                console.log(
                  `[EnsureFixed] CREANDO nueva instancia para ${entityTypeId} en (${fixedX}, ${fixedY}).`
                );
                const newEntityData = {
                  ...definition,
                  x: fixedX,
                  y: fixedY,
                  type: definition.typeOverride || entityTypeId,
                  symbol: definition.symbol,
                  name: definition.name,
                  interaction: definition.interaction,
                  npcId: definition.npcId,
                  discovered:
                    definition.discovered === true ||
                    definition.isBoss ||
                    definition.isMiniBoss, // Los jefes/minibosses suelen estar descubiertos
                  isFixed: true,
                  id: `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                    .toString(16)
                    .slice(2)}`,
                  originalEntityTypeId: entityTypeId,
                  // Copiar stats de combate y loot
                
                
                };
                if (newEntityData.hp && !newEntityData.maxHp)
                  newEntityData.maxHp = newEntityData.hp;

                // No necesitamos `...definition` aqu√≠ porque ya estamos copiando expl√≠citamente y de entityTypes
                const finalEntity = { ...newEntityData };
                // delete finalEntity.fixedLocation; // No es necesario porque newEntityData no lo incluye

                entities.push(finalEntity);
              } else {
                // Actualizar propiedades de la instancia existente si es necesario
                existingEntityInstance.isFixed = true;
                if (
                  definition.discovered === true ||
                  definition.isBoss ||
                  definition.isMiniBoss
                ) {
                  existingEntityInstance.discovered = true;
                }
                if (!existingEntityInstance.id) {
                  existingEntityInstance.id = `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                    .toString(16)
                    .slice(2)}`;
                }
                if (!existingEntityInstance.originalEntityTypeId) {
                  existingEntityInstance.originalEntityTypeId = entityTypeId;
                }
                // Asegurar que las stats est√©n actualizadas si se recarga el juego
                // (esto puede ser importante si las definiciones cambian entre versiones)
                if (definition.hp) existingEntityInstance.hp = definition.hp;
                if (definition.maxHp)
                  existingEntityInstance.maxHp = definition.maxHp;
                else if (definition.hp && !existingEntityInstance.maxHp)
                  existingEntityInstance.maxHp = definition.hp;
                // ... podr√≠as actualizar otras stats aqu√≠ si es necesario ...
              }
            } else {
              // No debe existir
              if (existingEntityInstance) {
                console.log(
                  `[EnsureFixed] ELIMINANDO instancia existente de ${entityTypeId} en (${fixedX}, ${fixedY}) porque 'debeExistir' es false.`
                );
                entities = entities.filter(
                  (e) => e.id !== existingEntityInstance.id
                );
              }
            }
          });
          gameState.map.entities = entities; // Reasignar por si se filtraron entidades
        }
        //GENERAR MAPA!
        function generateMap(isFullReset = true) {
              calculateAndSetTileSize();

              if (isFullReset) {
                  // Limpiar entidades que no son fijas
                  gameState.map.entities = gameState.map.entities.filter(e => e.isFixed && !e.isDecorative); // Quitamos tambi√©n las decoraciones viejas
                  
                  // Resetear contadores de spawn
                  gameState.map.terrainZones.forEach((zone) => {
                      if (zone.spawnSettings && zone.spawnSettings.targetEntities) {
                          zone.spawnSettings.targetEntities.forEach((target) => {
                              target.currentCount = 0;
                          });
                          zone.spawnSettings.respawnTimer = 0;
                          zone.spawnSettings.lastSpawnCheck = 0;
                      }
                  });

                  // Poblar cada zona con monstruos/recursos y luego con decoraciones
                  gameState.map.terrainZones.forEach((zone) => {
                      if (zone.spawnSettings) {
                          console.log(`generateMap: Poblando spawns para la zona "${zone.name}".`);
                          populateZoneWithObjects(zone, true);
                      }
                      // === L√ìGICA MODIFICADA ===
                      if (zone.decorations) {
                          console.log(`generateMap: Poblando decoraciones para la zona "${zone.name}".`);
                          populateZoneWithDecorations(zone); // Llamamos a la nueva funci√≥n
                      }
                      // === FIN DE LA MODIFICACI√ìN ===
                  });
                  
                  // Ya no necesitamos la funci√≥n global y aleatoria de decoraciones.
                  // populateDecorativeElements(50); // <-- ELIMINA O COMENTA ESTA L√çNEA
                  
              } else {
                  gameState.map.entities = gameState.map.entities.filter(
                      (e) => e.isFixed || e.isDecorative || (!e.zoneOrigin && !e.isFixed)
                  );
              }
              
              updatePlayerPosition();
              showTouchControls();
              ensureFixedEntities();
          }

        function populateZoneWithDecorations(zone) {
          if (!zone.decorations || zone.decorations.length === 0) {
              return; // No hay nada que decorar en esta zona
          }

          console.log(`[Decor] Poblando decoraciones para la zona: ${zone.name}`);

          // Recorremos cada celda de la zona
          for (let y = zone.y1; y <= zone.y2; y++) {
              for (let x = zone.x1; x <= zone.x2; x++) {
                  // Verificamos si la celda ya est√° ocupada por algo importante
                  const isOccupied = gameState.map.entities.some(e => e.x === x && e.y === y);
                  if (isOccupied) {
                      continue; // Si ya hay un monstruo o recurso, no ponemos decoraci√≥n encima
                  }

                  // Iteramos sobre los tipos de decoraci√≥n definidos para la zona
                  for (const deco of zone.decorations) {
                      // Usamos Math.random() para decidir si colocar esta decoraci√≥n
                      if (Math.random() < deco.density) {
                          const decoDefinition = entityTypes[deco.entityTypeId];
                          if (decoDefinition) {
                              const newDeco = {
                                  ...decoDefinition,
                                  x: x,
                                  y: y,
                                  type: deco.entityTypeId,
                                  id: `${deco.entityTypeId}_${x}_${y}_${Math.random()}`,
                                  discovered: true,
                                  isFixed: true,
                                  isDecorative: true,
                              };
                              gameState.map.entities.push(newDeco);
                              // IMPORTANTE: Una vez que ponemos una decoraci√≥n, salimos del bucle
                              // para no poner m√∫ltiples decoraciones (ej. un √°rbol y una roca) en la misma celda.
                              break; 
                          }
                      }
                  }
              }
          }
      }

        function populateDecorativeElements(numberOfElements = 3000) {
          const decorativeKeys = Object.keys(entityTypes).filter(
            (key) => entityTypes[key].isDecorative
          );
          if (decorativeKeys.length === 0) {
            console.log("[Decor] No decorative entity types found."); // LOG
            return;
          }
          // MODIFICACI√ìN: A√±adir las claves encontradas al log
          console.log(
            `[Decor] Attempting to populate ${numberOfElements} decorative elements. Found ${decorativeKeys.length} types:`,
            decorativeKeys.join(", ")
          );

          let addedCount = 0;
          for (let i = 0; i < numberOfElements; i++) {
            let spawnX,
              spawnY,
              attempts = 0;
            let positionFound = false;
            const randomDecoKey =
              decorativeKeys[Math.floor(Math.random() * decorativeKeys.length)];

            while (attempts < 20 && !positionFound) {
              // Intentos para encontrar posici√≥n
              spawnX = Math.floor(Math.random() * gameState.map.width);
              spawnY = Math.floor(Math.random() * gameState.map.height);

              // Para decorativos, la condici√≥n de "caminable" puede ser menos estricta
              // Lo importante es que la celda no est√© ya ocupada.
              const isOccupied = gameState.map.entities.some(
                (e) => e.x === spawnX && e.y === spawnY
              );
              const isPlayerPos =
                spawnX === gameState.player.x && spawnY === gameState.player.y;

              if (!isOccupied && !isPlayerPos) {
                positionFound = true;
              }
              attempts++;
            }

            if (positionFound) {
              const decoDefinition = entityTypes[randomDecoKey];
              if (!decoDefinition || !decoDefinition.symbol) {
                console.warn(
                  `[Decor] Definition or symbol missing for deco key: ${randomDecoKey}`
                );
                continue;
              }
              const newDeco = {
                ...decoDefinition, // Copia todas las propiedades de la definici√≥n
                x: spawnX,
                y: spawnY,
                type: randomDecoKey, // El tipo ES la clave original de entityTypes
                id: `${randomDecoKey}_${Date.now()}_${i}_${Math.random()
                  .toString(16)
                  .slice(2)}`,
                discovered: true, // Importante: los decorativos suelen estar descubiertos
                isFixed: true, // Importante: para que no se limpien f√°cilmente
                isDecorative: true, // Asegura que sea true, incluso si la definici√≥n lo omite
              };

              gameState.map.entities.push(newDeco);
              addedCount++;
              // MODIFICACI√ìN: Log m√°s detallado, incluyendo si isDecorative es true en la instancia
              console.log(
                `[Decor] Added: ${newDeco.name} (Symbol: ${newDeco.symbol}, Type: ${newDeco.type}, IsDecorative: ${newDeco.isDecorative}) at ${spawnX},${spawnY}. ID: ${newDeco.id}`
              );
            } else {
              // console.log(`[Decor] Could not find position for a decorative element of type ${randomDecoKey} after 20 attempts.`);
            }
          }
          console.log(
            `[Decor] Finished populating. Added ${addedCount} decorative elements out of ${numberOfElements} attempts.`
          );
        }

        function populateZoneWithObjects(zone, initialPopulation = false) {
          if (!zone.spawnSettings) {
            console.log(
              `populateZoneWithObjects: Zone "${zone.name}" has no spawnSettings. Skipping.`
            );
            return;
          }

          console.log(
            `populateZoneWithObjects: Called for zone "${zone.name}". InitialPopulation: ${initialPopulation}`
          );

          zone.spawnSettings.targetEntities.forEach((targetSpawnInfo) => {
            console.log(
              `  Zone "${zone.name}": Processing target spawn info for entityTypeId "${targetSpawnInfo.entityTypeId}", count: ${targetSpawnInfo.count}, currentCount: ${targetSpawnInfo.currentCount}`
            );

            const entityTypeDefinition =
              entityTypes[targetSpawnInfo.entityTypeId];
            if (!entityTypeDefinition) {
              console.warn(
                `  Zone "${zone.name}": Definition for entityTypeId "${targetSpawnInfo.entityTypeId}" NOT FOUND in entityTypes.`
              );
              return;
            }

            let attemptSpawns =
              targetSpawnInfo.count - targetSpawnInfo.currentCount;
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Need to spawn ${attemptSpawns} (target: ${targetSpawnInfo.count}, current: ${targetSpawnInfo.currentCount})`
            );

            if (!initialPopulation && zone.spawnSettings.respawnTimer > 0) {
              console.log(
                `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Zone in cooldown (timer: ${zone.spawnSettings.respawnTimer}). Skipping spawn.`
              );
              return;
            }

            if (attemptSpawns <= 0 && !initialPopulation) {
              console.log(
                `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": No spawns needed and not initial population. Skipping.`
              );
              return;
            }
            if (
              attemptSpawns <= 0 &&
              initialPopulation &&
              targetSpawnInfo.currentCount >= targetSpawnInfo.count
            ) {
              console.log(
                `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Initial population, but already at target count. Skipping.`
              );
              return;
            }

            let spawnedThisCycle = 0;
            for (let i = 0; i < attemptSpawns; i++) {
              if (targetSpawnInfo.currentCount >= targetSpawnInfo.count) {
                console.log(
                  `    Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Reached target count (${targetSpawnInfo.currentCount}/${targetSpawnInfo.count}). Stopping spawns for this type.`
                );
                break;
              }

              let spawnX,
                spawnY,
                attempts = 0;
              let positionFound = false;
              while (attempts < 20 && !positionFound) {
                spawnX =
                  zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1 + 1));
                spawnY =
                  zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1 + 1));

                const targetTerrainId = getTerrainTypeAt(spawnX, spawnY);
                const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
                const terrainWalkable =
                  !targetTerrainData || targetTerrainData.walkable !== false;

                const isOccupied = gameState.map.entities.some(
                  (e) => e.x === spawnX && e.y === spawnY
                );
                const isPlayerPos =
                  spawnX === gameState.player.x && spawnY === gameState.player.y;

                if (terrainWalkable && !isOccupied && !isPlayerPos) {
                  positionFound = true;
                }
                attempts++;
              }

              if (positionFound) {
                let newEntity;
                newEntity = {
                  ...entityTypeDefinition, // <--- COPIAR TODAS LAS PROPIEDADES DE LA DEFINICI√ìN PRIMERO
                  x: spawnX,
                  y: spawnY,
                  type:
                    entityTypeDefinition.typeOverride ||
                    targetSpawnInfo.entityTypeId,
                  id: `${
                    targetSpawnInfo.entityTypeId
                  }_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                  zoneOrigin: zone.name,
                  originalEntityTypeId: targetSpawnInfo.entityTypeId,
                  discovered: false,
                  //name: entityTypeDefinition.name,
                  //symbol: entityTypeDefinition.symbol,
                  //interaction: entityTypeDefinition.interaction,
                  //reward: entityTypeDefinition.reward,
                };
                // Asegurar HP/MaxHP para entidades de combate y limpiar para no combatientes
                if (
                  G_COMBAT_ENTITY_TYPES.includes(newEntity.type) ||
                  newEntity.isBoss ||
                  newEntity.isSectChallengeRival
                ) {
                  // Si entityTypeDefinition ya tiene hp/maxHp, el spread ya los copi√≥.
                  // Este bloque es m√°s para asegurar que existan o para poner valores por defecto.
                  newEntity.hp = newEntity.hp ?? entityTypeDefinition.hp ?? 50;
                  newEntity.maxHp = newEntity.maxHp ?? newEntity.hp;
                  // Aqu√≠ 'attack', 'defense', 'exp', 'lootTable' ya deber√≠an estar copiados por el spread de entityTypeDefinition
                } else {
                  // Para recursos u otras entidades no combativas
                  delete newEntity.hp;
                  delete newEntity.maxHp;
                  delete newEntity.attack; // Asegurarse de que no tengan stats de combate
                  delete newEntity.defense;
                  delete newEntity.exp;
                  // lootTable podr√≠a ser relevante para recursos si lo usaras para definir m√∫ltiples items de un nodo.
                }

                // Correcci√≥n espec√≠fica si es un recurso, para que su 'type' en el mapa sea solo 'resource' si as√≠ lo deseas
                // para la l√≥gica de interacci√≥n, o mantener el tipo espec√≠fico si prefieres.
                // La l√≥gica actual en handleEntityInteraction ya maneja bien `targetSpawnInfo.entityTypeId` como type.
                // if (entityTypeDefinition.type === "resource") newEntity.type = "resource";

                gameState.map.entities.push(newEntity);
                targetSpawnInfo.currentCount++;
                spawnedThisCycle++;
                console.log(
                  `    SUCCESS: Spawned "${newEntity.name}" (Attack: ${newEntity.attack}, Final Type: ${newEntity.type}, OrigTypeID: ${newEntity.originalEntityTypeId}) in zone "${zone.name}" at (${spawnX},${spawnY}).`
                );
              } else {
                // console.log(`    FAILED: Could not find position for "${targetSpawnInfo.entityTypeId}" ...`);
                break;
              }
            }
            if (spawnedThisCycle > 0 && !initialPopulation) {
              zone.spawnSettings.respawnTimer =
                zone.spawnSettings.respawnCooldown;
              console.log(
                `  Zone "${zone.name}": Spawned ${spawnedThisCycle} of "${targetSpawnInfo.entityTypeId}". Setting respawn timer to ${zone.spawnSettings.respawnCooldown}s.`
              );
            }
          });
        }

        // Funci√≥n para llamar en el bucle principal del juego o con setInterval
        function gameTickUpdater() {
          const now = Date.now();
          const deltaTime = (now - gameState.lastGameTimeUpdate) / 1000;
          gameState.gameTime += deltaTime;
          gameState.lastGameTimeUpdate = now;
          // === NUEVA L√ìGICA DE REGENERACI√ìN PASIVA ===
        if (player.passiveHpRegen > 0 && player.hp < player.maxHp) {
            player.hp = Math.min(player.maxHp, player.hp + (player.passiveHpRegen * deltaTime));
            updateUI(); // Actualizar la UI para ver la regeneraci√≥n
        }
        // === FIN DE LA NUEVA L√ìGICA ===

          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings) {
              if (zone.spawnSettings.respawnTimer > 0) {
                zone.spawnSettings.respawnTimer -= deltaTime;
                if (zone.spawnSettings.respawnTimer < 0)
                  zone.spawnSettings.respawnTimer = 0;
              }

              // Comprobar si CUALQUIER tipo de entidad en la zona necesita reaparecer
              let needsRespawn = false;
              for (const target of zone.spawnSettings.targetEntities) {
                if (target.currentCount < target.count) {
                  needsRespawn = true;
                  break;
                }
              }
              // Ajustado el cooldown del chequeo de respawn para ser m√°s frecuente (e.g. 5-10s)
              const SPAWN_CHECK_COOLDOWN = 10; // Segundos
              if (
                needsRespawn &&
                zone.spawnSettings.respawnTimer <= 0 &&
                gameState.gameTime - (zone.spawnSettings.lastSpawnCheck || 0) >
                  SPAWN_CHECK_COOLDOWN
              ) {
                console.log(
                  `gameTickUpdater: Zone "${zone.name}" needs respawn and timer is 0. Calling populateZoneWithObjects.`
                ); // LOG
                zone.spawnSettings.lastSpawnCheck = gameState.gameTime; // Actualizar ANTES de llamar para evitar bucles r√°pidos
                populateZoneWithObjects(zone, false); // false porque no es poblaci√≥n inicial
              }
            }
          });
          // ...
        }
        // movePlayer() no necesita grandes cambios, ya que updatePlayerPosition()
        // se encarga ahora del scroll.
        let animationFrameIndex = 0; // Para ciclar a trav√©s de PLAYER_WALK_CYCLE
        let lastPlayerMoveTime = 0; // Para controlar el tiempo de la animaci√≥n

        function movePlayer(dx, dy) {
          movePlayerCallCount++;
          const callId = movePlayerCallCount;
          console.log(`[MovePlayer CALL #${callId}] Intento de mover dx:${dx}, dy:${dy}. Posici√≥n actual: (${gameState.player.x}, ${gameState.player.y})`);

          // Cooldown
          const now = Date.now();
          if (now - lastSuccessfulMoveTime < PLAYER_MOVE_COOLDOWN) {
              // console.log(`[MovePlayer CALL #${callId}] Cooldown activo. Movimiento ignorado.`); // Descomentar si quieres ver esto
              return; 
          }

          const playerState = gameState.player;
          if (playerState.isCultivating || gameState.battle.active) {
              console.log(`[MovePlayer CALL #${callId}] Acci√≥n bloqueada por cultivo/batalla.`);
              return;
          }

          const newX = playerState.x + dx;
          const newY = playerState.y + dy;
          console.log(`[MovePlayer CALL #${callId}] Posici√≥n de destino calculada: (${newX}, ${newY}).`);
          let canMove = true; 

          // 1. L√≠mites del mapa
          if (newX < 0 || newX >= gameState.map.width || newY < 0 || newY >= gameState.map.height) {
              canMove = false;
              console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: L√≠mites del mapa.`);
          }

          // 2. Terreno
          if (canMove) {
              const targetTerrainId = getTerrainTypeAt(newX, newY);
              const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
              if (targetTerrainData && targetTerrainData.walkable === false) {
                  canMove = false;
                  console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Terreno no caminable ('${targetTerrainId}').`);
              }
          }
          
          // 3. Entidades
          if (canMove) {
              const entityAtNewPosition = gameState.map.entities.find(e => e.x === newX && e.y === newY);
              
              if (entityAtNewPosition) {
                  console.log(`[MovePlayer CALL #${callId}] Entidad encontrada en destino:`, JSON.parse(JSON.stringify(entityAtNewPosition)));
                  const entityTypeToCheck = entityAtNewPosition.originalEntityTypeId || entityAtNewPosition.type;
                  console.log(`[MovePlayer CALL #${callId}] Tipo de entidad a verificar: '${entityTypeToCheck}'`);
                  
                  if (G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) || entityAtNewPosition.isBoss || entityAtNewPosition.isSectChallengeRival) {
                      console.log(`[MovePlayer CALL #${callId}] La entidad es hostil. Iniciando batalla...`);
                      startBattle(entityAtNewPosition);
                      return; 
                  }
                  
                  const isBlocking = G_BLOCKING_ENTITY_TYPES.includes(entityTypeToCheck);
                  console.log(`[MovePlayer CALL #${callId}] ¬øEst√° en la lista de bloqueo (G_BLOCKING_ENTITY_TYPES)? -> ${isBlocking}`);
                  
                  if (isBlocking) {
                      canMove = false;
                      console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Entidad Bloqueadora.`);
                  }
              } else {
                  console.log(`[MovePlayer CALL #${callId}] Celda de destino vac√≠a.`);
              }
          }

          console.log(`[MovePlayer CALL #${callId}] Decisi√≥n final. canMove: ${canMove}`);

          if (canMove) {
              console.log(`[MovePlayer CALL #${callId}] RESULTADO: Movimiento a (${newX}, ${newY}) PERMITIDO.`);
              playerState.x = newX;
              playerState.y = newY;
              updatePlayerPosition(`movePlayer_success_call_${callId}`);
              updateUI();
              lastSuccessfulMoveTime = now;
              
          } else {
              console.log(`[MovePlayer CALL #${callId}] RESULTADO: Movimiento a (${newX}, ${newY}) BLOQUEADO.`);
          }
          console.log(`--- Fin de la llamada a movePlayer #${callId} ---`);
        }

        //FIN FUNCION MOVE PLAYER
        function checkForAggressiveEnemies() {
        if (gameState.battle.active || isAnyModalOpen()) {
            return; // No iniciar combate si ya estamos en uno o en un modal.
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;

        // Comprobamos las 8 casillas adyacentes y la casilla actual
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue; // No comprobar la propia casilla del jugador

                const checkX = playerX + dx;
                const checkY = playerY + dy;

                const entity = gameState.map.entities.find(e => e.x === checkX && e.y === checkY);

                if (entity) {
                    const isHostile = G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss || entity.isMiniBoss;
                    
                    // Si la entidad es hostil, iniciamos la batalla
                    if (isHostile) {
                        showModal("¬°Emboscada!", `¬°Un ${entity.name} te ataca al acercarte demasiado!`, true);
                        setTimeout(() => {
                            closeModal();
                            startBattle(entity);
                        }, 1500);
                        return; // Detenemos la funci√≥n para no iniciar m√∫ltiples combates
                    }
                }
            }
        }
      }

        function getEnemyNameColor(playerLevel, enemyLevel) {
          const levelDiff = enemyLevel - playerLevel;

          if (levelDiff >= 5) {
              return { color: '#ff4d4d', fontWeight: 'bold' }; // Rojo (Muy Peligroso)
          } else if (levelDiff >= 3) {
              return { color: '#ff9b57', fontWeight: 'normal' }; // Naranja (Peligroso)
          } else if (levelDiff >= 1) {
              return { color: '#f4d03f', fontWeight: 'normal' }; // Amarillo (M√°s fuerte)
          } else if (levelDiff <= -5) {
              return { color: '#a0a0a0', fontWeight: 'normal' }; // Gris (Trivial)
          } else {
              return { color: '#f4e4bc', fontWeight: 'normal' }; // Blanco (Normal)
          }
        }

        function gameLoop() {
          if (isAnyModalOpen() || gameState.battle.active || gameState.player.isCultivating) {
              gameState.player.isMoving = false; // Detener animaci√≥n si el juego est√° pausado
              return;
          }

          handleMovement(); // Maneja la l√≥gica de movimiento
          checkForAggressiveEnemies();
          // Actualiza el frame de la animaci√≥n basado en el estado
          if (gameState.player.isMoving) {
              // Cicla entre los frames 1, 2, 3...
              const frameCount = gameState.player.animationFrames - 1; // e.g., si hay 4 frames, cicla entre 1,2,3
              gameState.player.currentFrame = (gameState.player.currentFrame % frameCount) + 1;
          } else {
              gameState.player.currentFrame = 0; // Frame 0 es quieto
          }
          
          updatePlayerSpriteVisual(); // Actualiza el sprite visualmente
        }

        // Ajuste menor en window.addEventListener('resize')
        window.addEventListener("resize", () => {
          calculateAndSetTileSize();
          // renderMap(); // updatePlayerPosition se encarga de esto
          updatePlayerPosition();
        });

        function getTerrainTypeAt(x, y) {
          if (
            x < 0 ||
            x >= gameState.map.width ||
            y < 0 ||
            y >= gameState.map.height
          ) {
            return null; // Fuera de los l√≠mites del mapa
          }

          // Opci√≥n A: Si usas terrainGrid directamente
          if (
            gameState.map.terrainGrid &&
            gameState.map.terrainGrid[y] &&
            gameState.map.terrainGrid[y][x]
          ) {
            return gameState.map.terrainGrid[y][x];
          }

          // Opci√≥n B: Usando terrainZones
          for (const zone of gameState.map.terrainZones) {
            if (x >= zone.x1 && x <= zone.x2 && y >= zone.y1 && y <= zone.y2) {
              return zone.type;
            }
          }
          return gameState.map.defaultTerrain; // Devuelve el terreno por defecto
        }

        function renderMap(callerId = "unknown") {
          const mapElement = document.getElementById("gameMap");
          const mapContainerElement = document.querySelector(".map-container");

          if (!mapElement || !mapContainerElement) {
              return;
          }
          // --- INICIO DE LA L√ìGICA DE AISLAMIENTO DE ZONA ---
        const currentZone = getPlayerCurrentZone();
        let currentAmbientColor = '#1a3d2e'; // Color por defecto del mundo principal
        
        if (currentZone && currentZone.isIsolated) {
            // Si estamos en una zona aislada, cambiamos el fondo a un color de "vac√≠o"
            mapContainerElement.style.backgroundColor = currentZone.ambientColor || '#000';
        } else {
            // Si estamos en el mundo principal, el fondo es el definido en el CSS
            mapContainerElement.style.backgroundColor = '#1a3d2e'; // O el color original de tu .map-container
        }
        // --- FIN DE LA L√ìGICA DE AISLAMIENTO DE ZONA ---
          const currentContainerWidth = mapContainerElement.clientWidth;
          const currentContainerHeight = mapContainerElement.clientHeight;

          const playerScreenX = currentContainerWidth / 2 - currentTileSize / 2;
          const playerScreenY = currentContainerHeight / 2 - currentTileSize / 2;
          const mapExpectedScrollX =
              -(gameState.player.x * currentTileSize) + playerScreenX;
          const mapExpectedScrollY =
              -(gameState.player.y * currentTileSize) + playerScreenY;

          const viewWorldXStart = Math.floor(
              -mapExpectedScrollX / currentTileSize
          );
          const viewWorldYStart = Math.floor(
              -mapExpectedScrollY / currentTileSize
          );
          const tilesInViewX =
              Math.ceil(currentContainerWidth / currentTileSize) + 2;
          const tilesInViewY =
              Math.ceil(currentContainerHeight / currentTileSize) + 2;
          const viewWorldXEnd = viewWorldXStart + tilesInViewX;
          const viewWorldYEnd = viewWorldYStart + tilesInViewY;

          mapElement.innerHTML = "";

          // 1. Renderizar TERRENO BASE
        for (let y = viewWorldYStart; y < viewWorldYEnd; y++) {
            for (let x = viewWorldXStart; x < viewWorldXEnd; x++) {
              let shouldDrawVoid = false;

                if (currentZone && currentZone.isIsolated) {
                    if (x < currentZone.x1 || x > currentZone.x2 || y < currentZone.y1 || y > currentZone.y2) {
                        shouldDrawVoid = true;
                    }
                } else {
                    // Si no estamos en una zona aislada, el "vac√≠o" es cualquier cosa fuera de los l√≠mites del mapa.
                    if (x < 0 || x >= gameState.map.width || y < 0 || y >= gameState.map.height) {
                        shouldDrawVoid = true;
                    }
                }
                if (shouldDrawVoid) {
                    const voidTile = document.createElement("div");
                    voidTile.className = "tile void-tile";
                    voidTile.style.left = `${x * currentTileSize}px`;
                    voidTile.style.top = `${y * currentTileSize}px`;
                    voidTile.style.width = `${currentTileSize}px`;
                    voidTile.style.height = `${currentTileSize}px`;
                    voidTile.style.backgroundColor = currentAmbientColor; // Rellena con el color de ambiente
                    voidTile.style.zIndex = "0";
                    const voidTerrainData = G_TERRAIN_TYPES.VOID;
                    if (voidTerrainData && voidTerrainData.textureUrl) {
                        voidTile.style.backgroundImage = `url('${voidTerrainData.textureUrl}')`;
                        voidTile.style.backgroundSize = 'cover';
                    } else {
                        // Si la textura del vac√≠o no se encuentra, vuelve a usar el color ambiental
                        voidTile.style.backgroundColor = currentAmbientColor;
                    }
                    mapElement.appendChild(voidTile);
                    continue; // Pasa al siguiente tile del bucle
                }
                const terrainId = getTerrainTypeAt(x, y);
                const terrainData = G_TERRAIN_TYPES[terrainId];
                if (terrainData) {
                    const terrainTile = document.createElement("div");
                    terrainTile.className = "tile terrain-tile";
                    terrainTile.style.left = `${x * currentTileSize}px`;
                    terrainTile.style.top = `${y * currentTileSize}px`;
                    terrainTile.style.width = `${currentTileSize}px`;
                    terrainTile.style.height = `${currentTileSize}px`;
                    terrainTile.style.zIndex = "1";

                    if (terrainData.textureUrl) {
                        terrainTile.style.backgroundImage = `url('${terrainData.textureUrl}')`;
                        terrainTile.style.backgroundSize = 'cover';
                    } else {
                        terrainTile.style.backgroundColor = terrainData.color;
                    }

                    mapElement.appendChild(terrainTile);
                }
            }
        }
          
          // 2. Renderizar ENTIDADES
          gameState.map.entities.forEach((entity) => {
              if (entity.discovered) {
                  if (
                      entity.x >= viewWorldXStart &&
                      entity.x < viewWorldXEnd &&
                      entity.y >= viewWorldYStart &&
                      entity.y < viewWorldYEnd
                  ) {
                      const entityContainer = document.createElement("div");
                      entityContainer.style.position = 'absolute';
                      entityContainer.style.left = `${entity.x * currentTileSize}px`;
                      entityContainer.style.top = `${entity.y * currentTileSize}px`;
                      entityContainer.style.width = `${currentTileSize}px`;
                      entityContainer.style.height = `${currentTileSize}px`;
                      entityContainer.style.display = 'flex';
                      entityContainer.style.alignItems = 'center';
                      entityContainer.style.justifyContent = 'center';
                      entityContainer.style.zIndex = '5';

                      const definition = entityTypes[entity.originalEntityTypeId] || entityTypes[entity.type];
                      const spriteUrl = entity.spriteUrl || (definition ? definition.spriteUrl : null);

                      if (spriteUrl) {
                          entityContainer.style.backgroundImage = `url('${spriteUrl}')`;
                          
                          if (entity.originalEntityTypeId === 'secta_entrada_principal') {
                              entityContainer.style.backgroundSize = '120%';
                              entityContainer.style.top = `${(entity.y - 1.5) * currentTileSize}px`;
                              entityContainer.style.height = `${currentTileSize * 3}px`;
                              // 1. Aumentamos el ancho del contenedor para que quepa el sprite
                              entityContainer.style.width = `${currentTileSize * 3}px`;

                          // 2. Ajustamos la posici√≥n izquierda para centrar el nuevo contenedor ancho
                          // Posici√≥n original: entity.x * currentTileSize
                          // Nuevo ancho: currentTileSize * 2.5
                          // Para centrarlo, debemos desplazarlo a la izquierda la mitad de su ancho extra.
                          // Ancho extra = (2.5 - 1) = 1.5. Mitad del ancho extra = 0.75.
                          entityContainer.style.left = `${(entity.x - 0.75) * currentTileSize}px`;
                          } else if (entity.originalEntityTypeId === 'shop') {
                              entityContainer.style.backgroundSize = '120%';
                              entityContainer.style.top = `${(entity.y - 1.2) * currentTileSize}px`;
                              entityContainer.style.height = `${currentTileSize * 2}px`;
                              entityContainer.style.width = `${currentTileSize * 2}px`;
                              entityContainer.style.left = `${(entity.x - 0.75) * currentTileSize}px`;
                          } else if (entity.originalEntityTypeId === 'deco_arbol_grande') {
                              entityContainer.style.backgroundSize = '120%';
                              entityContainer.style.top = `${(entity.y - 0.2) * currentTileSize}px`;
                              entityContainer.style.height = `${currentTileSize * 1.2}px`;
                              
                          } 
                          else if (entity.originalEntityTypeId === 'boss_dem') {
                              entityContainer.style.backgroundSize = '100%';
                              entityContainer.style.top = `${(entity.y - 1.5) * currentTileSize}px`;
                              entityContainer.style.width = `${currentTileSize * 3}px`;
                              entityContainer.style.height = `${currentTileSize * 3}px`;
                              
                          }
                          else {
                              entityContainer.style.backgroundSize = '80%';
                          }
                          
                          entityContainer.style.backgroundPosition = 'center bottom';
                          entityContainer.style.backgroundRepeat = 'no-repeat';
                      } else {
                          entityContainer.textContent = entity.symbol || (definition ? definition.symbol : "?");
                          entityContainer.style.fontSize = `${currentTileSize * (entity.isDecorative ? 0.5 : 0.6)}px`;
                      }

                      if (entity.isDecorative) {
                          entityContainer.style.opacity = "0.7";
                          entityContainer.style.zIndex = "3";
                      }

                      mapElement.appendChild(entityContainer);

                      const isHostile = G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss || entity.isMiniBoss;
                      const isImportantNPC = entity.npcId && !isHostile;

                      if (isHostile || isImportantNPC) {
                          const namePlate = document.createElement('div');
                          namePlate.className = 'entity-name-plate';
                          
                          let displayText = entity.name;

                          if (isHostile) {
                            // 1. A√±adir etiqueta de estatus si existe
                            if (entity.isBoss) {
                                displayText += ` (Jefe)`;
                            } else if (entity.isMiniBoss) {
                                displayText += ` (√âlite)`;
                            }

                            // 2. A√±adir SIEMPRE el nivel si la entidad lo tiene
                            if (entity.level) {
                                displayText += ` (Nv. ${entity.level})`;
                            }

                            // 3. Aplicar color
                            if (entity.isBoss) {
                                namePlate.style.color = '#ff4d4d'; // Rojo para Jefes
                                namePlate.style.fontWeight = 'bold';
                            } else {
                                // Para todos los dem√°s enemigos (miniboss y comunes), usar la escala de color
                                const nameStyle = getEnemyNameColor(gameState.player.level, entity.level || 1);
                                namePlate.style.color = nameStyle.color;
                                namePlate.style.fontWeight = nameStyle.fontWeight;
                            }
                        }
                          
                          namePlate.textContent = displayText;
                          entityContainer.appendChild(namePlate);
                      }
                  }
              }
          });

          updatePlayerVisualSize();
      }

        function updatePlayerSpriteVisual() {
          // Aseg√∫rate que el nombre sea este
          const player = gameState.player;
          const playerElement = document.getElementById("player");
          if (!playerElement) return;

          // Verificaci√≥n para depurar el error de la l√≠nea 2263
          if (
            !player.directionRowMap ||
            typeof player.currentDirection === "undefined"
          ) {
            console.error(
              "CRITICAL: player.directionRowMap o player.currentDirection no est√°n definidos en updatePlayerSpriteVisual.",
              player
            );
            // Podr√≠as establecer valores por defecto aqu√≠ como un parche temporal,
            // pero lo ideal es que est√©n bien inicializados en gameState.
            // player.currentDirection = player.currentDirection || 'down';
            // player.directionRowMap = player.directionRowMap || { 'down': 0, 'left': 1, 'right': 2, 'up': 3 };
            // player.currentFrame = player.currentFrame || 0;
            // player.frameWidth = player.frameWidth || 64;
            // player.frameHeight = player.frameHeight || 64;
            return; // Salir si faltan datos cruciales para evitar m√°s errores
          }

          const row = player.directionRowMap[player.currentDirection];
          const col = player.currentFrame;

          // Otra verificaci√≥n
          if (typeof row === "undefined" || typeof col === "undefined") {
            console.error(
              "CRITICAL: 'row' o 'col' son undefined en updatePlayerSpriteVisual.",
              {
                playerDir: player.currentDirection,
                playerFrame: player.currentFrame,
                map: player.directionRowMap,
              }
            );
            return;
          }

          const offsetX = col * player.frameWidth;
          const offsetY = row * player.frameHeight;

          playerElement.style.backgroundPosition = `-${offsetX}px -${offsetY}px`;

          if (gameState.battle.active) {
            const battlePlayerSprite = document.querySelector(
              ".battle-area .character-sprite"
            );
            if (battlePlayerSprite) {
              const battleRow = player.directionRowMap["down"];
              const battleFrame = 0;
              const battleOffsetX = battleFrame * player.frameWidth;
              const battleOffsetY = battleRow * player.frameHeight;
              battlePlayerSprite.style.backgroundPosition = `-${battleOffsetX}px -${battleOffsetY}px`;
            }
          }
        }

        // Aseg√∫rate que G_TILE_SIZE sea igual a las dimensiones de tu frame de sprite
        // Si no, tendr√°s que ajustar c√≥mo se define el tama√±o del jugador.
        // En calculateAndSetTileSize, si currentTileSize se calcula din√°micamente,
        // y quieres que el jugador SIEMPRE tenga el tama√±o del sprite:
        function updatePlayerVisualSize() {
          const playerElement = document.getElementById("player");
          if (playerElement) {
            // ESTO ES CRUCIAL: El tama√±o del div del jugador DEBE ser el tama√±o de UN FRAME
            // Si currentTileSize representa el tama√±o deseado del jugador en pantalla,
            // y tus frames en la hoja de sprites son de un tama√±o fijo (ej. 64x64),
            // entonces el div del jugador tambi√©n debe ser de ese tama√±o fijo para que background-position funcione.
            // O, si quieres que el jugador se reescale con currentTileSize, entonces frameWidth/Height
            // deben ser iguales a currentTileSize, y background-size debe escalar la hoja completa.

            // Opci√≥n A: El jugador mantiene el tama√±o del frame original, y currentTileSize es solo para el mapa.
            playerElement.style.width = `${gameState.player.frameWidth}px`;
            playerElement.style.height = `${gameState.player.frameHeight}px`;
            // En este caso, .player y .character-sprite NO deber√≠an cambiar su width/height en @media queries
            // basados en currentTileSize, sino mantener el tama√±o del frame.

            // Opci√≥n B: El jugador se reescala con los tiles del mapa (m√°s complejo con spritesheets).
            // Si eliges esto, frameWidth y frameHeight en gameState.player deber√≠an ser actualizados
            // por calculateAndSetTileSize() para ser igual a currentTileSize.
            // Y el background-size del spritesheet necesitar√≠a ajustarse para que un "frame virtual"
            // dentro de la hoja escalada coincida con currentTileSize.
            // Ejemplo para Opci√≥n B:
            //playerElement.style.width = `${currentTileSize}px`;
            //playerElement.style.height = `${currentTileSize}px`;
            // Y en updatePlayerSpriteVisual, los c√°lculos de offsetX/Y necesitar√≠an
            // usar este currentTileSize en lugar de player.frameWidth/Height si la hoja
            // tambi√©n se est√° escalando.
            // Por ahora, mantengamos la Opci√≥n A (tama√±o de frame fijo) que es m√°s simple
            // si tu CSS para .player no est√° siendo sobrescrito por las @media queries.
          }
        }

        function updatePlayerPosition(callerId = "unknown") {
          const playerElement = document.getElementById("player");
          const mapElement = document.getElementById("gameMap");
          const mapContainerElement = document.querySelector(".map-container");

          if (!playerElement || !mapElement || !mapContainerElement) {
            console.error(
              "UpdatePlayerPosition: Elemento(s) clave no encontrado(s)."
            );
            return;
          }

          const playerVisualWidth = gameState.player.frameWidth; // Usar el tama√±o real del frame del sprite
          const playerVisualHeight = gameState.player.frameHeight;

          const playerScreenX =
            mapContainerElement.clientWidth / 2 - playerVisualWidth / 2;
          const playerScreenY =
            mapContainerElement.clientHeight / 2 - playerVisualHeight / 2;

          playerElement.style.left = `${playerScreenX}px`;
          playerElement.style.top = `${playerScreenY}px`;

          const mapScrollX =
            -(gameState.player.x * currentTileSize) + playerScreenX;
          const mapScrollY =
            -(gameState.player.y * currentTileSize) + playerScreenY;

          mapElement.style.transform = `translate(${mapScrollX}px, ${mapScrollY}px)`;

          gameState.map.entities.forEach((entity) => {
            const distance =
              Math.abs(entity.x - gameState.player.x) +
              Math.abs(entity.y - gameState.player.y);
            if (distance <= G_PLAYER_DISCOVERY_RANGE) {
              if (!entity.discovered) entity.discovered = true;
            }
          });

          renderMap(callerId);
          updatePlayerSpriteVisual();
          updatePlayerVisualSize();
          updatePlayerBarsOnMap(); 
          updateExtraStatsUI();
        }

        // ... (el resto de tus funciones JS, como updateUI, movePlayer, interact, etc. SIN CAMBIOS IMPORTANTES aqu√≠,
        //      ya que los cambios principales son en el renderizado y tama√±o de tiles)
        function updateUI() {
          const player = gameState.player;
          document.getElementById("playerLevel").textContent = player.level;
          document.getElementById("playerRealm").textContent = player.realm;
          document.getElementById("hpText").textContent = `${Math.floor(
            player.hp
          )}/${player.maxHp}`;
          document.getElementById("manaText").textContent = `${Math.floor(
            player.mana
          )}/${player.maxMana}`;
          document.getElementById("expText").textContent = `${Math.floor(
            player.exp
          )}/${player.expToNext}`;

          // Barras del Sidebar
          const hpBarSidebar = document.getElementById("hpBar");
          const manaBarSidebar = document.getElementById("manaBar");
          const expBarSidebar = document.getElementById("expBar");

          if (hpBarSidebar)
            hpBarSidebar.style.width = `${(player.hp / player.maxHp) * 100}%`;
          if (manaBarSidebar)
            manaBarSidebar.style.width = `${
              (player.mana / player.maxMana) * 100
            }%`;
          if (expBarSidebar)
            expBarSidebar.style.width = `${
              (player.exp / player.expToNext) * 100
            }%`;

          document.getElementById(
            "playerCoords"
          ).textContent = `X: ${player.x}, Y: ${player.y}`;

          updateExtraStatsUI();
          updateInventoryUI(); // Asumo que esta funci√≥n existe y es correcta
          updateSectUI(); // Asumo que esta funci√≥n existe y es correcta

          updatePlayerBarsOnMap(); // <--- LLAMADA A√ëADIDA para las barras sobre el jugador
        }

        function updateInventoryUI() {
          const inventoryDisplay = document.getElementById("inventory");
          inventoryDisplay.innerHTML = "";
          Object.entries(gameState.inventory).forEach(([itemName, count]) => {
            if (count <= 0 && itemName !== "Piedras Espirituales") return;

            const itemDiv = document.createElement("div");
            itemDiv.className = "inventory-item";

            const itemInfo = itemData[itemName];
            const description = itemInfo
              ? itemInfo.description
              : "Un objeto misterioso.";
            itemDiv.innerHTML = `<strong>${itemName}: ${count}</strong><br><small><em>${description}</em></small>`;

            if (count > 0 && itemInfo && itemInfo.effect) {
              const canBeUsedNow = itemInfo.canUse
                ? itemInfo.canUse(gameState.player)
                : true;
              itemDiv.style.cursor = canBeUsedNow ? "pointer" : "not-allowed";
              itemDiv.style.opacity = canBeUsedNow ? 1 : 0.6;
              itemDiv.title = canBeUsedNow
                ? `Usar ${itemName}`
                : `No puedes usar ${itemName} ahora.`;
              if (canBeUsedNow) {
                itemDiv.onclick = () => useItem(itemName);
              }
            } else {
              itemDiv.style.opacity = 0.8;
              itemDiv.style.cursor = "default";
            }
            inventoryDisplay.appendChild(itemDiv);
          });
        }
       
      function updateRefinementUI() {}

        let lastPlayerAnimationUpdateTime = 0; // Renombrado para claridad

        function movePlayer(dx, dy) {
          movePlayerCallCount++;
          const callId = movePlayerCallCount;
          console.log(`[MovePlayer CALL #${callId}] Intento de mover dx:${dx}, dy:${dy}. Posici√≥n actual: (${gameState.player.x}, ${gameState.player.y})`);

          // Cooldown
          const now = Date.now();
          if (now - lastSuccessfulMoveTime < PLAYER_MOVE_COOLDOWN) {
              // console.log(`[MovePlayer CALL #${callId}] Cooldown activo. Movimiento ignorado.`);
              return; 
          }

          const newX = gameState.player.x + dx;
          const newY = gameState.player.y + dy;
          console.log(`[MovePlayer CALL #${callId}] Posici√≥n de destino calculada: (${newX}, ${newY}).`);
          let canMove = true; 

          // 1. L√≠mites del mapa
          if (newX < 0 || newX >= gameState.map.width || newY < 0 || newY >= gameState.map.height) {
              canMove = false;
              console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: L√≠mites del mapa.`);
          }

          // 2. Terreno
          if (canMove) {
              const targetTerrainId = getTerrainTypeAt(newX, newY);
              if (G_TERRAIN_TYPES[targetTerrainId]?.walkable === false) {
                  canMove = false;
                  console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Terreno no caminable ('${targetTerrainId}').`);
              }
          }
          
          // 3. Entidades
          if (canMove) {
              const entityAtNewPosition = gameState.map.entities.find(e => e.x === newX && e.y === newY);
              
              if (entityAtNewPosition) {
                  console.log(`[MovePlayer CALL #${callId}] Entidad encontrada en destino:`, JSON.parse(JSON.stringify(entityAtNewPosition)));
                  const entityTypeToCheck = entityAtNewPosition.originalEntityTypeId || entityAtNewPosition.type;
                  console.log(`[MovePlayer CALL #${callId}] Tipo de entidad a verificar: '${entityTypeToCheck}'`);
                  
                  if (G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) || entityAtNewPosition.isBoss || entityAtNewPosition.isSectChallengeRival) {
                      console.log(`[MovePlayer CALL #${callId}] La entidad es hostil. Iniciando batalla...`);
                      startBattle(entityAtNewPosition);
                      return; 
                  }
                  
                  const isBlocking = G_BLOCKING_ENTITY_TYPES.includes(entityTypeToCheck);
                  console.log(`[MovePlayer CALL #${callId}] ¬øEst√° en la lista de bloqueo (G_BLOCKING_ENTITY_TYPES)? -> ${isBlocking}`);
                  
                  if (isBlocking) {
                      canMove = false;
                      console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Entidad Bloqueadora.`);
                  }
              } else {
                  console.log(`[MovePlayer CALL #${callId}] Celda de destino vac√≠a.`);
              }
          }

          console.log(`[MovePlayer CALL #${callId}] Decisi√≥n final. canMove: ${canMove}`);

          if (canMove) {
              console.log(`[MovePlayer CALL #${callId}] RESULTADO: Movimiento a (${newX}, ${newY}) PERMITIDO.`);
              gameState.player.x = newX;
              gameState.player.y = newY;
              updatePlayerPosition(`movePlayer_success_call_${callId}`);
              updateUI();
              lastSuccessfulMoveTime = now;
          } else {
              console.log(`[MovePlayer CALL #${callId}] RESULTADO: Movimiento a (${newX}, ${newY}) BLOQUEADO.`);
          }
          console.log(`--- Fin de la llamada a movePlayer #${callId} ---`);
        }
        //FIN MOVE PLAYER

        let playerMovementKeysDown = {
          // Para rastrear qu√© teclas de movimiento est√°n presionadas
          up: false,
          down: false,
          left: false,
          right: false,
        };
        function handleMovement() {
          let dx = 0;
          let dy = 0;
          let newDirection = null;

          // Determina la direcci√≥n del movimiento
          if (playerMovementKeysDown.up) { dy = -1; newDirection = 'up'; }
          else if (playerMovementKeysDown.down) { dy = 1; newDirection = 'down'; }
          else if (playerMovementKeysDown.left) { dx = -1; newDirection = 'left'; }
          else if (playerMovementKeysDown.right) { dx = 1; newDirection = 'right'; }

          // Si hay una direcci√≥n presionada, intenta mover al jugador
          if (newDirection) {
              gameState.player.currentDirection = newDirection;
              movePlayer(dx, dy); // La l√≥gica de cooldown y colisi√≥n est√° dentro
          }

          // L√≥gica de animaci√≥n visual (separada de la l√≥gica de movimiento)
          const isActuallyMoving = playerMovementKeysDown.up || playerMovementKeysDown.down || playerMovementKeysDown.left || playerMovementKeysDown.right;
          gameState.player.isMoving = isActuallyMoving;
        }

        function interact() {
          if (gameState.player.isCultivating) {
            showModal(
              "Acci√≥n no permitida",
              "Det√©n tu cultivo antes de interactuar."
            );
            return;
          }
          if (gameState.battle.active) {
            showModal(
              "Acci√≥n no permitida",
              "No puedes interactuar durante el combate."
            );
            return;
          }

          const playerX = gameState.player.x;
          const playerY = gameState.player.y;
          const offsets = [
            { dx: 0, dy: 0 },
            { dx: 0, dy: -1 },
            { dx: 1, dy: 0 },
            { dx: 0, dy: 1 },
            { dx: -1, dy: 0 },
          ];

          for (const offset of offsets) {
            const targetX = playerX + offset.dx;
            const targetY = playerY + offset.dy;
            const entity = gameState.map.entities.find(
              (e) => e.x === targetX && e.y === targetY
            );

            if (entity) {
              if (
                G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
                entity.isBoss ||
                entity.isSectChallengeRival
              ) {
                const desafioMision = gameState.player.secta.misionesActivas.find(
                  (m) =>
                    MISIONES_DATA[m.id]?.objetivo?.tipo ===
                      "derrotar_npc_especifico" &&
                    MISIONES_DATA[m.id]?.objetivo?.npcId === entity.npcId
                );
                if (entity.isSectChallengeRival) {
                  if (desafioMision) {
                    showModal(
                      "¬°Desaf√≠o Aceptado!",
                      `Te preparas para enfrentar a ${entity.name}.`,
                      true
                    );
                    setTimeout(() => {
                      closeModal();
                      startBattle(entity);
                    }, 1500);
                  } else {
                    showModal(
                      "Paz, por ahora...",
                      `${entity.name} te observa, pero no hay raz√≥n para luchar.`
                    );
                  }
                } else {
                  showModal(
                    "¬°A la Batalla!",
                    `Decides enfrentar a ${entity.name}.`,
                    true
                  );
                  setTimeout(() => {
                    closeModal();
                    startBattle(entity);
                  }, 1000);
                }
                return;
              } else if (
                entity.interaction ||
                entityTypes[entity.type]?.interaction ||
                [
                  "resource",
                  "master",
                  "cultivation",
                  "shop",
                  "secta_entrada_principal",
                ].includes(entity.type)
              ) {
                handleEntityInteraction(entity);
                return;
              }
            }
          }
        }

        function handleEntityInteraction(entity) {
          if (!entity) return;

          let interactionType = entity.interaction; // Priorizar la interacci√≥n de la instancia

          // Si no hay interacci√≥n en la instancia, buscar en la definici√≥n de entityTypes
          // usando entity.originalEntityTypeId si est√° disponible, sino entity.type
          const definitionKey = entity.originalEntityTypeId || entity.type;
          if (!interactionType && entityTypes[definitionKey]) {
            interactionType = entityTypes[definitionKey].interaction;
          }
          // === INICIO DE LA NUEVA L√ìGICA DE TRANSICI√ìN ===
          if (interactionType === "transition") {
              const definition = entityTypes[definitionKey];
              if (definition && typeof definition.targetX === 'number' && typeof definition.targetY === 'number') {
                  
                  // Funci√≥n que se ejecutar√° si el jugador confirma
                  const doTransition = () => {
                      gameState.player.x = definition.targetX;
                      gameState.player.y = definition.targetY;
                      updatePlayerPosition(`transition_to_${definitionKey}`); // ¬°Muy importante!
                      showModal("Transici√≥n Completa", `Has llegado a ${definition.name}.`);
                  };

                  // Mostramos el modal de confirmaci√≥n
                  showConfirmationModal(
                      `Entrar a ${entity.name}`,
                      "¬øDeseas pasar a la siguiente zona?",
                      doTransition // Pasamos la funci√≥n como callback
                  );

              } else {
                  console.warn(`La entidad de transici√≥n ${definitionKey} no tiene coordenadas de destino (targetX, targetY).`);
              }
              return; // Detenemos la ejecuci√≥n para no procesar otros switches
          }
          if (interactionType) {
            switch (interactionType) {
              case "browse":
                if (entity.type === "shop") {
                  openShop();
                  return;
                }
                break;
              case "talk_secta_npc":
                if (entity.npcId) {
                  interactWithSectNPC(entity.npcId);
                  return;
                }
                break;
              case "access_sect_hall":
                if (entity.type === "secta_entrada_principal") {
                  openSectHallInterface();
                  return;
                }
                break;
              case "collect_resource":
                const rewardItem =
                  entity.reward ||
                  (entityTypes[entity.originalEntityTypeId]
                    ? entityTypes[entity.originalEntityTypeId].reward
                    : null) ||
                  "Piedras Espirituales"; // √öltimo fallback

                const itemNameDisplay =
                  entity.name ||
                  (entityTypes[entity.originalEntityTypeId]
                    ? entityTypes[entity.originalEntityTypeId].name
                    : entity.type);

                gameState.inventory[rewardItem] =
                  (gameState.inventory[rewardItem] || 0) + 1;
                showModal(
                  "Recurso Encontrado",
                  `Has obtenido: 1 ${rewardItem}! (de ${itemNameDisplay})`
                );
                removeEntity(entity);
                updateInventoryUI();
                return;
              case "learn_from_master":
                const expGain =
                  entity.expGain || entityTypes[entity.type]?.expGain || 50;
                gainExperience(expGain);
                showModal(
                  "Encuentro con Maestro",
                  `El ${entity.name} te ha ense√±ado sabidur√≠a. Ganas ${expGain} EXP!`
                );
                removeEntity(entity);
                return;
              case "meditate_spot":
                const manaGain =
                  entity.manaGain || entityTypes[entity.type]?.manaGain || 20;
                gameState.player.mana = Math.min(
                  gameState.player.maxMana,
                  gameState.player.mana + manaGain
                );
                showModal(
                  "Lugar de Cultivo",
                  `Has meditado en '${entity.name}'. Recuperas ${manaGain} Man√°.`
                );
                removeEntity(entity);
                updateUI();
                return;
              default:
                console.warn(
                  `Interacci√≥n '${interactionType}' desconocida para ${entity.name} (Tipo: ${entity.type}, ID: ${entity.id}).`
                );
                break;
            }
          } else {
            console.log(
              `No hay acci√≥n definida para tipo '${entity.type}' (Entidad: ${entity.name}, ID: ${entity.id}, OrigTypeID: ${entity.originalEntityTypeId}).`
            );
          }
        }

        function interactWithSectNPC(npcId) {
          const npcData = SECTA_DATA.npcs[npcId];
          const player = gameState.player;
          if (!npcData) {
            console.error(
              `[interactWithSectNPC] NPC Data no encontrada para npcId: ${npcId}`
            );
            return;
          }

          console.log(
            `[NPC Interaction] Starting interaction with NPC: ${npcData.nombre} (ID: ${npcId})`
          );
          console.log(
            `[NPC Interaction] Player Active Missions (Raw):`,
            JSON.parse(JSON.stringify(player.secta.misionesActivas))
          );
          console.log(
            `[NPC Interaction] Player Inventory:`,
            JSON.parse(JSON.stringify(gameState.inventory))
          );

          let modalContentHTML = `<h3>${npcData.nombre} (${npcData.rol})</h3>`;
          modalContentHTML += `<p><em>"${npcData.dialogoInicial}"</em></p><hr>`;

          const elementsToProcess = [];

          // --- SECCI√ìN: MISIONES PARA COMPLETAR ---
          modalContentHTML += `<h4>Misiones para Entregar/Reportar:</h4>`;
          let algunaMisionParaCompletar = false;

          player.secta.misionesActivas.forEach((misionActiva) => {
            const misionDef = MISIONES_DATA[misionActiva.id];

            // Log b√°sico para cada misi√≥n activa
            console.log(
              `[NPC Interaction] Evaluating Active Mission: "${misionDef?.titulo}" (ID: ${misionActiva.id})`
            );

            // Comprobaciones cruciales: misionDef, objetivo, y objetivoOriginal deben existir.
            if (
              !misionDef ||
              !misionDef.objetivo ||
              !misionActiva.objetivoOriginal
            ) {
              console.warn(
                `[NPC Interaction] Skipping mission ID ${misionActiva.id}: Missing misionDef, misionDef.objetivo, or misionActiva.objetivoOriginal.`
              );
              return; // Saltar esta misi√≥n si los datos esenciales faltan
            }

            const objetivo = misionActiva.objetivoOriginal; // Usar el objetivo original guardado

            console.log(
              `[NPC Interaction] Mission "${
                misionDef.titulo
              }": Target NPC for delivery/report is "${
                objetivo.npcEntrega
              }". Current NPC is "${npcId}". Match: ${
                objetivo.npcEntrega === npcId
              }`
            );

            // Solo procesar si el NPC actual es el NPC de entrega/reporte de la misi√≥n
            if (objetivo.npcEntrega === npcId) {
              let listaParaEntregar = false;
              let objetivoStatus = "";

              console.log(
                `[NPC Interaction] Mission "${misionDef.titulo}" IS for this NPC. Original objective type: ${objetivo.tipo}`
              );

              switch (objetivo.tipo) {
                case "entregar_item":
                  const playerHasItem = gameState.inventory[objetivo.item] || 0;
                  const needsItem = objetivo.cantidad;
                  console.log(
                    `  - Type 'entregar_item'. Item: "${objetivo.item}", Needs: ${needsItem}, Player Has: ${playerHasItem}`
                  );
                  if (playerHasItem >= needsItem) {
                    listaParaEntregar = true;
                    objetivoStatus = `(Tienes ${playerHasItem}/${needsItem} ${objetivo.item})`;
                  } else {
                    objetivoStatus = `(Necesitas ${
                      needsItem - playerHasItem
                    } m√°s ${objetivo.item})`;
                  }
                  break;

                case "eliminar_enemigo":
                  const currentProgressElim = misionActiva.progreso || 0;
                  const needsElim = objetivo.cantidad;
                  console.log(
                    `  - Type 'eliminar_enemigo'. Target: "${objetivo.nombreDisplay}", Needs: ${needsElim}, Progress: ${currentProgressElim}`
                  );
                  if (currentProgressElim >= needsElim) {
                    listaParaEntregar = true; // Significa que los enemigos fueron eliminados, lista para 'reportar'
                    objetivoStatus = `(${currentProgressElim}/${needsElim} ${objetivo.nombreDisplay} eliminados)`;
                  } else {
                    objetivoStatus = `(Elimina ${
                      needsElim - currentProgressElim
                    } m√°s ${objetivo.nombreDisplay})`;
                  }
                  break;

                case "recolectar_multiples_items":
                  let todosRecolectados = true;
                  let itemsStatusArray = [];
                  console.log(
                    `  - Type 'recolectar_multiples_items'. Items required:`,
                    objetivo.items
                  );
                  for (const itemReq of objetivo.items) {
                    const playerHasMulti =
                      gameState.inventory[itemReq.nombre] || 0;
                    const needsMulti = itemReq.cantidad;
                    console.log(
                      `    - Item: "${itemReq.nombre}", Needs: ${needsMulti}, Player Has: ${playerHasMulti}`
                    );
                    if (playerHasMulti < needsMulti) {
                      todosRecolectados = false;
                    }
                    itemsStatusArray.push(
                      `${playerHasMulti}/${needsMulti} ${itemReq.nombre}`
                    );
                  }
                  if (todosRecolectados) {
                    listaParaEntregar = true;
                  }
                  objetivoStatus = `(${itemsStatusArray.join(", ")})`;
                  break;
                case "derrotar_npc_especifico":
                      // El progreso es 1 si el rival fue derrotado.
                      if (misionActiva.progreso === 1) {
                          listaParaEntregar = true;
                          const rivalName = entityTypes[objetivo.npcId]?.name || "el guardi√°n";
                          objetivoStatus = `(Has derrotado a ${rivalName})`;
                      } else {
                          const rivalName = entityTypes[objetivo.npcId]?.name || "el guardi√°n";
                          objetivoStatus = `(Debes derrotar a ${rivalName} en la arena)`;
                      }
                  break;

                case "cazar_y_recuperar_item_de_loot":
                  const playerHasLootItem =
                    (gameState.inventory[objetivo.itemPrueba] || 0) >=
                    objetivo.cantidadItemPrueba;
                  // El progreso a 1 indica que el tipo de enemigo que suelta el item fue derrotado.
                  const killedCorrectEnemyType = misionActiva.progreso === 1;
                  console.log(
                    `  - Type 'cazar_y_recuperar_item_de_loot'. Item: "${
                      objetivo.itemPrueba
                    }", Needs Qty: ${
                      objetivo.cantidadItemPrueba
                    }, Player Has Qty: ${
                      gameState.inventory[objetivo.itemPrueba] || 0
                    }. Killed enemy type: ${killedCorrectEnemyType}`
                  );
                  if (killedCorrectEnemyType && playerHasLootItem) {
                    // Debe haber matado al enemigo Y tener el √≠tem
                    listaParaEntregar = true;
                    objetivoStatus = `(Tienes ${objetivo.itemPrueba})`;
                  } else if (!killedCorrectEnemyType) {
                    objetivoStatus = `(Caza al ${
                      entityTypes[objetivo.enemigoTipo]?.name ||
                      objetivo.enemigoTipo
                    } y consigue ${objetivo.itemPrueba})`;
                  } else {
                    // Killed enemy, but doesn't have item (sold it? used it? or it never dropped - handle this in loot drop if needed)
                    objetivoStatus = `(Necesitas ${objetivo.itemPrueba}. ¬øLo perdiste o no lo obtuviste?)`;
                  }
                  break;

                // A√±adir m√°s casos aqu√≠ para otros tipos de misi√≥n que se completan con este NPC
                default:
                  console.warn(
                    `[NPC Interaction] Unhandled objective type "${objetivo.tipo}" for mission "${misionDef.titulo}" completion check with NPC.`
                  );
                  objetivoStatus = `(Objetivo: ${objetivo.tipo} - estado no verificado aqu√≠)`;
                  break;
              }

              console.log(
                `[NPC Interaction] Mission "${misionDef.titulo}": listaParaEntregar = ${listaParaEntregar}. Objetivo status display: ${objetivoStatus}`
              );

              // Solo mostrar el bot√≥n de completar si listaParaEntregar es true
              if (listaParaEntregar) {
                const buttonId = `complete-mission-btn-${misionActiva.id.replace(
                  /\W/g,
                  "_"
                )}`;
                modalContentHTML += `<div style="padding: 5px; border: 1px solid #55cc55; margin-bottom: 5px; background-color: rgba(85,204,85,0.1);">
                                              <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                              <button id="${buttonId}">Completar Misi√≥n</button>
                                          </div>`;
                elementsToProcess.push({
                  buttonId: buttonId,
                  action: () => {
                    console.log(
                      `[NPC Interaction] Clicked "Completar Misi√≥n" button for ${misionActiva.id}`
                    );
                    // Pasar npcId como npcIdEntregaManual a completeMission
                    if (completeMission(misionActiva.id, npcId)) {
                      // Si la misi√≥n se complet√≥ con √©xito, el modal del NPC se refrescar√°
                      // porque completeMission llama a showModal y al cerrarlo se actualiza el UI
                      // o, como alternativa, podemos forzar el refresco aqu√≠.
                      // closeModal(); // Cierra el modal de interacci√≥n actual
                      interactWithSectNPC(npcId); // Vuelve a abrir el modal del NPC con el estado actualizado
                    }
                    // Si completeMission devuelve false, generalmente ya muestra un modal de error/info.
                  },
                });
                algunaMisionParaCompletar = true;
                console.log(
                  `[NPC Interaction] SUCCESS: Added "Completar Misi√≥n" button for ${misionDef.titulo}`
                );
              } else {
                // Opcional: Mostrar la misi√≥n pero sin el bot√≥n de completar si no est√° lista
                modalContentHTML += `<div style="padding: 5px; border: 1px solid #777; margin-bottom: 5px; background-color: rgba(100,100,100,0.1);">
                                              <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                              <small><em>(A√∫n no cumples todos los requisitos para entregar/reportar esta misi√≥n)</em></small>
                                          </div>`;
                console.log(
                  `[NPC Interaction] INFO: Mission "${misionDef.titulo}" is for this NPC but not ready for completion. Displaying status.`
                );
              }
            } else {
              // Log si la misi√≥n no es para este NPC
              // console.log(`[NPC Interaction] Mission "${misionDef.titulo}" is not designated for this NPC (Delivery NPC: ${objetivo.npcEntrega}).`);
            }
          });

          if (
            !algunaMisionParaCompletar &&
            !player.secta.misionesActivas.some(
              (m) => MISIONES_DATA[m.id]?.objetivo?.npcEntrega === npcId
            )
          ) {
            // Si no hay misiones para completar con ESTE NPC, y tampoco hay misiones activas que SEAN para este NPC (incluso si no est√°n listas)
            modalContentHTML +=
              "<p>No tienes misiones para entregarme o reportarme en este momento.</p>";
            console.log(
              `[NPC Interaction] No missions found that are completable OR assignable to this NPC for completion.`
            );
          } else if (!algunaMisionParaCompletar) {
            // Hay misiones asignadas a este NPC, pero ninguna est√° lista para completarse.
            modalContentHTML +=
              "<p>Revisa los objetivos de tus misiones activas. Parece que a√∫n no est√°n listas para entregar/reportar.</p>";
            console.log(
              `[NPC Interaction] Missions are assigned to this NPC, but none are ready for completion yet.`
            );
          }
          modalContentHTML += "<hr>";

          // --- SECCI√ìN: MISIONES DISPONIBLES (CON FILTRO DE NIVEL Y RANGO) ---
          // (Esta secci√≥n parece estar bien, la mantengo como estaba en tu c√≥digo anterior con la l√≥gica de requisitos)
          if (npcData.misionesOfrecidas && npcData.misionesOfrecidas.length > 0) {
            modalContentHTML += "<h4>Misiones Disponibles:</h4>";
            modalContentHTML += `<div id="npc-dynamic-content-missions" style="max-height: 200px; overflow-y: auto; border: 1px solid #444; padding: 10px; margin-bottom:10px;">`;
            let algunaMisionDisponibleMostrada = false;
            npcData.misionesOfrecidas.forEach((misionId, index) => {
              const mision = MISIONES_DATA[misionId];
              if (
                mision &&
                !player.secta.misionesActivas.some((m) => m.id === misionId) &&
                !player.secta.misionesCompletadas[misionId]
              ) {
                const nivelRequerido = mision.requisitoNivel || 0;
                const rangoRequeridoNombre = mision.requisitoRango;
                let cumpleRequisitos = true;

                if (player.level < nivelRequerido) {
                  cumpleRequisitos = false;
                }
                if (rangoRequeridoNombre) {
                  const indiceRangoJugador = SECTA_DATA.rangos.findIndex(
                    (r) => r.nombre === player.secta.rango
                  );
                  const indiceRangoRequerido = SECTA_DATA.rangos.findIndex(
                    (r) => r.nombre === rangoRequeridoNombre
                  );
                  if (indiceRangoJugador < indiceRangoRequerido) {
                    cumpleRequisitos = false;
                  }
                }

                if (cumpleRequisitos) {
                  let recompensaTextoResumido = `Recompensa: ${
                    mision.recompensa.pcs || 0
                  } PCS, ${mision.recompensa.exp || 0} EXP`;
                  if (mision.recompensa.items)
                    recompensaTextoResumido += ", Objetos";
                  if (mision.recompensa.nuevoRango)
                    recompensaTextoResumido += `, Ascenso a ${mision.recompensa.nuevoRango}`;

                  const buttonId = `accept-mission-btn-${misionId.replace(
                    /\W/g,
                    "_"
                  )}-${index}`;
                  const botonHTML = `<button id="${buttonId}">Aceptar Misi√≥n</button>`;

                  modalContentHTML += `<div style="padding: 5px; border: 1px solid #555; margin-bottom: 5px;">
                                              <strong>${
                                                mision.titulo
                                              }</strong> (Req. Nv: ${
                    nivelRequerido > 0 ? nivelRequerido : "Ninguno"
                  }${
                    rangoRequeridoNombre ? ", Rango: " + rangoRequeridoNombre : ""
                  })<br><small>${mision.descripcion}</small><br>
                                              <small style="color: #aaa;"><em>${recompensaTextoResumido}</em></small><br>
                                              ${botonHTML} 
                                          </div>`;
                  elementsToProcess.push({
                    buttonId: buttonId,
                    missionIdToAccept: misionId,
                  });
                  algunaMisionDisponibleMostrada = true;
                }
              }
            });
            if (!algunaMisionDisponibleMostrada)
              modalContentHTML +=
                "<p>No hay nuevas misiones para ti en este momento que cumplan tus requisitos.</p>";
            modalContentHTML += `</div>`;
            modalContentHTML += "<hr>";
          } else {
            modalContentHTML +=
              "<p>No tengo misiones para ti en este momento.</p><hr>";
          }

          // --- SECCI√ìN: ENTREGA DE RECURSOS ---
          // (Esta secci√≥n parece estar bien, la mantengo)
          if (npcData.aceptaRecursos && npcData.aceptaRecursos.length > 0) {
            modalContentHTML += `<h4>Entregar Recursos:</h4>`;
            modalContentHTML += `<div id="npc-dynamic-content-resources" style="max-height: 150px; overflow-y: auto;">`;
            let puedeEntregarAlgo = false;
            npcData.aceptaRecursos.forEach((itemName) => {
              const cantidadPlayer = gameState.inventory[itemName] || 0;
              if (cantidadPlayer > 0) {
                const pcsPorItem =
                  itemName === "Hierbas Medicinales"
                    ? 2
                    : itemName === "Cristales de Qi"
                    ? 5
                    : itemName === "N√∫cleo de Bestia Menor"
                    ? 10
                    : 1;
                const buttonIdEntregar1 = `entregar-1-${itemName.replace(
                  /\W/g,
                  "_"
                )}`;
                const buttonIdEntregarAll = `entregar-all-${itemName.replace(
                  /\W/g,
                  "_"
                )}`;
                modalContentHTML += `<p>${itemName} (Tienes: ${cantidadPlayer}): 
                                      <button id="${buttonIdEntregar1}">Entregar 1 (${pcsPorItem} PCS)</button>
                                      ${
                                        cantidadPlayer > 1
                                          ? `<button id="${buttonIdEntregarAll}">Entregar Todo (${
                                              pcsPorItem * cantidadPlayer
                                            } PCS)</button>`
                                          : ""
                                      }
                                  </p>`;
                elementsToProcess.push({
                  buttonId: buttonIdEntregar1,
                  action: () => {
                    entregarRecursoSecta(itemName, 1, pcsPorItem);
                    interactWithSectNPC(npcId);
                  },
                });
                if (cantidadPlayer > 1) {
                  elementsToProcess.push({
                    buttonId: buttonIdEntregarAll,
                    action: () => {
                      entregarRecursoSecta(
                        itemName,
                        cantidadPlayer,
                        pcsPorItem * cantidadPlayer
                      );
                      interactWithSectNPC(npcId);
                    },
                  });
                }
                puedeEntregarAlgo = true;
              }
            });
            if (!puedeEntregarAlgo)
              modalContentHTML +=
                "<p>No tienes recursos que pueda necesitar en este momento.</p>";
            modalContentHTML += `</div><hr>`;
          }

          showModal("Interacci√≥n con " + npcData.nombre, modalContentHTML);

          const modalTextEl = document.getElementById("modalText");
          if (modalTextEl) {
            elementsToProcess.forEach((item) => {
              const buttonElement = modalTextEl.querySelector(
                "#" + item.buttonId
              );
              if (buttonElement) {
                if (item.missionIdToAccept) {
                  buttonElement.addEventListener("click", () => {
                    acceptMission(item.missionIdToAccept);
                    interactWithSectNPC(npcId);
                  });
                } else if (item.action) {
                  buttonElement.addEventListener("click", item.action);
                }
              } else {
                console.warn(
                  "[NPC Interaction] Could not find button with ID:",
                  item.buttonId,
                  "in #modalText to attach listener."
                );
              }
            });
          } else {
            console.error(
              "[NPC Interaction] #modalText element not found for attaching listeners to dynamic buttons."
            );
          }
        }

        function entregarRecursoSecta(itemName, cantidad, pcsGanados) {
          if ((gameState.inventory[itemName] || 0) < cantidad) {
            showModal("Error", "No tienes suficientes objetos.");
            return;
          }
          gameState.inventory[itemName] -= cantidad;
          gameState.player.secta.puntosContribucion += pcsGanados;
          showModal(
            "Recurso Entregado",
            `Entregaste ${cantidad} ${itemName} y ganaste ${pcsGanados} PCS.`
          );
          updateSectUI();
          updateInventoryUI();
          checkAndActivateRankChallengeMissions();
          closeModal();
        }

        function acceptMission(misionId) {
          const misionData = MISIONES_DATA[misionId];
          const player = gameState.player;
          if (!misionData) {
            showModal("Error de Misi√≥n", "Datos no encontrados.");
            return;
          }
          if (
            player.secta.misionesActivas.some((m) => m.id === misionId) ||
            player.secta.misionesCompletadas[misionId]
          ) {
            showModal("Error de Misi√≥n", "Ya activa/completada.");
            return;
          }
          if (!misionData.objetivo) {
            showModal("Error de Misi√≥n", "Objetivo no definido.");
            return;
          }

          let nuevaMisionActiva;
          try {
            nuevaMisionActiva = {
              id: misionId,
              progreso: 0,
              objetivoOriginal: JSON.parse(JSON.stringify(misionData.objetivo)),
            };
          } catch (error) {
            showModal("Error de Misi√≥n", "Problema al procesar objetivo.");
            return;
          }

          player.secta.misionesActivas.push(nuevaMisionActiva);
          showModal("Misi√≥n Aceptada", `Has aceptado: ${misionData.titulo}`);
          updateSectUI();

          const npcInteractionModal = document.getElementById("interactionModal");
          const modalTitleElement = document.getElementById("modalTitle");
          if (
            npcInteractionModal.style.display === "flex" &&
            modalTitleElement &&
            modalTitleElement.textContent.includes("Interacci√≥n con Secta")
          ) {
            closeModal();
          }
        }

        function removeEntity(entityToRemove) {
          const index = gameState.map.entities.findIndex(
            (e) => e.id === entityToRemove.id
          ); // Usar ID √∫nico

          if (index > -1) {
            const removedEntity = gameState.map.entities.splice(index, 1)[0];

            // Si la entidad proven√≠a de una zona de spawn, actualizar el contador de esa zona
            if (removedEntity.zoneOrigin) {
              const originZone = gameState.map.terrainZones.find(
                (z) => z.name === removedEntity.zoneOrigin && z.spawnSettings
              );
              if (originZone) {
                const targetSpawnInfo =
                  originZone.spawnSettings.targetEntities.find(
                    (t) => t.entityTypeId === removedEntity.originalEntityTypeId // <-- USAR ESTO
                  );
                if (targetSpawnInfo && targetSpawnInfo.currentCount > 0) {
                  targetSpawnInfo.currentCount--;
                  // console.log(`Entidad ${removedEntity.name} eliminada de zona ${originZone.name}. Restantes de tipo ${targetSpawnInfo.entityTypeId}: ${targetSpawnInfo.currentCount}`);

                  // Si el contador baja y el timer estaba en cooldown, podemos resetear el timer
                  // para que intente reaparecer antes si la zona est√° por debajo del objetivo.
                  // Opcional: Podr√≠as querer que el cooldown siempre se cumpla.
                  // if (originZone.spawnSettings.respawnTimer > 10) { // Si estaba en cooldown largo
                  //    originZone.spawnSettings.respawnTimer = 10; // Poner un cooldown corto para el pr√≥ximo chequeo
                  // }
                }
              }
            }
            renderMap(); // Actualizar visualizaci√≥n
          }
        }

        function isRespawnNeeded() {
          const player = gameState.player;
          const activeBoss = gameState.map.entities.find(
            (e) =>
              e.isBoss &&
              !player.worldState.defeatedBosses[e.id || e.type] &&
              Math.abs(e.x - player.x) <= 5 &&
              Math.abs(e.y - player.y) <= 5
          );
          return !activeBoss;
        }

        function toggleCultivation() {
          if (gameState.battle.active) {
            showModal("Acci√≥n no permitida", "No puedes cultivar en combate.");
            return;
          }
          if (gameState.player.isCultivating) {
            showActiveCultivationModal();
          } else {
            openCultivationChoiceModal();
          }
        }

        function openCultivationChoiceModal() {
          const player = gameState.player;
          const techniquesListDiv = document.getElementById("cultivableTechniquesList");
          
          // Comprobaci√≥n de seguridad
          if (!techniquesListDiv) {
              console.error("Error: El contenedor 'cultivableTechniquesList' no se encontr√≥ en el HTML.");
              return;
          }
          
          techniquesListDiv.innerHTML = ""; // Limpiar contenido anterior
          let hasCultivableTechniques = false;

          for (const techId in player.learnedTechniques) {
              const playerTech = player.learnedTechniques[techId];
              const techData = techniqueData[techId];
              if (techData && techData.cultivationSettings && playerTech.level < techData.maxLevel) {
                  hasCultivableTechniques = true;
                  const techButton = document.createElement("button");
                  techButton.className = "cultivation-option-btn";
                  techButton.textContent = `${techData.name} (Nv. ${playerTech.level})`;
                  
                  // --- LA CORRECCI√ìN CLAVE EST√Å AQU√ç ---
                  techButton.onclick = () => {
                      // 1. Primero, cerramos el modal actual.
                      closeCultivationChoiceModal();
                      // 2. Despu√©s, iniciamos el nuevo modo de cultivo.
                      startCultivationMode("technique", techId);
                  };
                  // --- FIN DE LA CORRECCI√ìN ---

                  techniquesListDiv.appendChild(techButton);
              }
          }

          if (!hasCultivableTechniques) {
              techniquesListDiv.innerHTML = "<p>No tienes t√©cnicas que requieran m√°s cultivo.</p>";
          }

          document.getElementById("cultivationChoiceModal").style.display = "flex";
          hideTouchControls();
      }

        function closeCultivationChoiceModal() {
          document.getElementById("cultivationChoiceModal").style.display =
            "none";
          updatePlayerBarsOnMap();
          showTouchControls();
        }

        function startCultivationMode(type, targetId = null) {
          console.log(`[Cultivo LOG] ==> INTENTO DE INICIAR CULTIVO (Tipo: '${type}', T√©cnica: '${targetId}')`);
          if (gameState.player.isCultivating || gameState.cultivationInterval) {
              stopCultivation();
          }
          
          gameState.player.isCultivating = true;
          gameState.player.cultivationMode = { type, targetId, startTime: Date.now(), isConversionCultivation: false };
          
          // El intervalo se crea, pero no hacemos nada m√°s que podr√≠a fallar aqu√≠.
          gameState.cultivationInterval = setInterval(processCultivationTick, 1000);
          console.log(`[Cultivo LOG] -> NUEVO INTERVALO CREADO. ID: ${gameState.cultivationInterval}`);
          
          // Llamamos a la actualizaci√≥n de la UI por separado.
          showActiveCultivationModal();
          renderQuickSlotBar();
      }

      function stopCultivation(showFeedbackModal = false, feedbackMessage = {}) {
        const player = gameState.player;
        console.log(`[Cultivo LOG] ==> INTENTO DE DETENER CULTIVO`);

        if (!gameState.cultivationInterval) {
            console.log(`[Cultivo LOG]   -> No hay intervalo que detener. El cultivo ya estaba parado.`);
            // A√∫n as√≠, reseteamos el estado del jugador por si est√° desincronizado.
            player.isCultivating = false;
            player.cultivationMode = { type: null, targetId: null, startTime: 0, isConversionCultivation: false };
            console.log(`[Cultivo LOG]   -> Estado del jugador reseteado por seguridad.`);
            return;
        }

        const intervalToClear = gameState.cultivationInterval;
        console.log(`[Cultivo LOG]   -> Limpiando intervalo con ID: ${intervalToClear}`);
        clearInterval(intervalToClear);
        gameState.cultivationInterval = null;
        console.log(`[Cultivo LOG]   -> Intervalo limpiado. gameState.cultivationInterval ahora es: ${gameState.cultivationInterval}`);

        player.isCultivating = false;
        player.cultivationMode = { type: null, targetId: null, startTime: 0, isConversionCultivation: false };
        console.log(`[Cultivo LOG]   -> Estado del jugador reseteado: isCultivating = ${player.isCultivating}`);

        closeActiveCultivationModal();
        renderQuickSlotBar();
        updateUI();

        if (showFeedbackModal) {
            console.log(`[Cultivo LOG]   -> Mostrando modal de feedback: "${feedbackMessage.title}"`);
            showModal(feedbackMessage.title || "Cultivo Detenido", feedbackMessage.text || "Has dejado de cultivar.");
        }
    }
     
    function showActiveCultivationModal() {
      const player = gameState.player;
      const modal = document.getElementById("activeCultivationModal");
      if (!modal) return; // Salida temprana si el modal no existe.

      // Ocultar todas las secciones primero
      const techUI = document.getElementById("activeCultivationProgressUI");
      const recoveryUI = document.getElementById("recoveryCultivationProgressUI");
      const boostUI = document.getElementById("cultivationBoostSection");
      
      if (techUI) techUI.style.display = "none";
      if (recoveryUI) recoveryUI.style.display = "none";
      if (boostUI) boostUI.style.display = "none";
      
      if (!player.isCultivating) {
          modal.style.display = "none";
          return;
      }

      const mode = player.cultivationMode.type;
      const targetId = player.cultivationMode.targetId;

      const titleEl = document.getElementById("activeCultivationTitle");
      const descEl = document.getElementById("activeCultivationDescription");
      if (!titleEl || !descEl) return;
      
      if (mode === 'technique' && targetId) {
          const techData = techniqueData[targetId];
          const playerTech = player.learnedTechniques[targetId];

          if (techData && playerTech && techUI) {
              techUI.style.display = "block";
              if (boostUI) boostUI.style.display = "block";
              
              titleEl.textContent = `Cultivando: ${techData.name}`;
              descEl.textContent = techData.description;

              // Actualizar UI de la t√©cnica
              const nameSpan = document.getElementById("activeCultivationTargetName");
              const levelSpan = document.getElementById("activeCultivationTargetLevel");
              if (nameSpan) nameSpan.textContent = techData.name;
              if (levelSpan) levelSpan.textContent = playerTech.level;

              // L√≥gica de la barra de progreso
              const progressBar = document.getElementById("activeCultivationProgressBar");
              const progressText = document.getElementById("activeCultivationProgressText");
              if (progressBar && progressText) {
                  const progress = playerTech.currentCultivationProgress || 0;
                  const timeToNext = playerTech.cultivationTimeToNextLevel || Infinity;
                  let percent = (timeToNext > 0 && timeToNext !== Infinity) ? (progress / timeToNext) * 100 : (playerTech.level >= techData.maxLevel ? 100 : 0);
                  
                  progressBar.style.width = `${Math.min(100, percent)}%`;
                  progressText.textContent = (timeToNext === Infinity) ? "Nivel M√°ximo" : `${Math.floor(progress)}s / ${timeToNext}s`;
              }

              // Actualizar secci√≥n de aceleraci√≥n
              const stonesDisplay = document.getElementById("cultivationModalPlayerStones");
              const boostButton = document.getElementById("boostCultivationButton");
              if (stonesDisplay) stonesDisplay.textContent = gameState.inventory["Piedras Espirituales"] || 0;
              if (boostButton) boostButton.disabled = (gameState.inventory["Piedras Espirituales"] || 0) < 1 || playerTech.level >= techData.maxLevel;
          }
      } else if (mode === 'recovery') {
          if (recoveryUI) {
              recoveryUI.style.display = "block";
              titleEl.textContent = "Meditaci√≥n Restauradora";
              descEl.textContent = "Recuperando energ√≠a...";
              
              // Actualizar barras de HP/Man√° del modal
              const hpText = document.getElementById("modalHpText");
              const hpBar = document.getElementById("modalHpBar");
              const manaText = document.getElementById("modalManaText");
              const manaBar = document.getElementById("modalManaBar");
              if (hpText) hpText.textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
              if (hpBar) hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
              if (manaText) manaText.textContent = `${Math.floor(player.mana)}/${player.maxMana}`;
              if (manaBar) manaBar.style.width = `${(player.mana / player.maxMana) * 100}%`;
          }
      }
      
      modal.style.display = "flex";
      hideTouchControls();
  }
        
  function closeActiveCultivationModal() {
          document.getElementById("activeCultivationModal").style.display =
            "none";
          updatePlayerBarsOnMap();
          showTouchControls();
        }


      function processCultivationTick() {
        const player = gameState.player;

        // Medida de seguridad: si el tick se ejecuta cuando no deber√≠a, se detiene.
        if (!player.isCultivating || !gameState.cultivationInterval) {
            stopCultivation();
            return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        // --- CULTIVO DE T√âCNICA (sin cambios, ya funciona bien) ---
        if (mode === 'technique' && targetId) {
            const playerTech = player.learnedTechniques[targetId];
            const techData = techniqueData[targetId];
            if (playerTech && techData && playerTech.level < techData.maxLevel) {
                playerTech.currentCultivationProgress = (playerTech.currentCultivationProgress || 0) + 1;
                const progress = playerTech.currentCultivationProgress;
                const required = playerTech.cultivationTimeToNextLevel || Infinity;

                if (progress >= required) {
                    playerTech.level++;
                    playerTech.currentCultivationProgress = 0;
                    playerTech.cultivationTimeToNextLevel = playerTech.level < techData.maxLevel ? Math.floor(techData.cultivationSettings.baseTimeToLevelUp * Math.pow(techData.cultivationSettings.levelTimeMultiplier, playerTech.level)) : Infinity;
                    applyTechniqueEffect(targetId, playerTech.level);
                    recalculatePlayerStats();
                    stopCultivation(true, { title: "¬°T√©cnica Mejorada!", text: `¬°'${techData.name}' ha subido al Nivel ${playerTech.level}!` });
                    return;
                }
            } else {
                stopCultivation(true, { title: "Cultivo Detenido", text: "La t√©cnica ha alcanzado su m√°ximo potencial." });
                return;
            }

        // --- CULTIVO DE RECUPERACI√ìN ---
        } else if (mode === 'recovery') {
            
            // =========================================================================
            // === CORRECCI√ìN CLAVE: L√≥gica de Conversi√≥n de Qi (SI EST√Å ACTIVA) ===
            // =========================================================================
            if (player.cultivationMode.isConversionCultivation) {
                const conversionTechInfo = techniqueData["qi_to_hp_conversion_1"];
                const playerConversionTech = player.learnedTechniques["qi_to_hp_conversion_1"];
                
                if (conversionTechInfo?.effect && playerConversionTech?.level > 0) {
                    const effectDef = conversionTechInfo.effect;
                    const techLevel = playerConversionTech.level;
                    
                    const manaCost = Math.max(0.1, effectDef.baseManaCostPerSecond - (effectDef.manaCostReductionPerLevel || 0) * (techLevel - 1));
                    const hpGain = effectDef.baseHpGainPerSecond + (effectDef.hpGainIncreasePerLevel || 0) * (techLevel - 1);
                    
                    // Si se puede convertir, se hace y se termina el tick.
                    if (player.mana >= manaCost && player.hp < player.maxHp) {
                        player.mana -= manaCost; // <-- Se resta el man√°.
                        player.hp = Math.min(player.maxHp, player.hp + hpGain);
                        // IMPORTANTE: No se ejecuta nada m√°s de recuperaci√≥n en este tick.
                    } else {
                        // Si no se puede, se detiene el cultivo con un mensaje.
                        stopCultivation(true, { title: "Conversi√≥n Detenida", text: "Man√° insuficiente o vida al m√°ximo." });
                        return; // Salimos del tick para no hacer nada m√°s.
                    }
                } else {
                    // Si por alguna raz√≥n falta la t√©cnica, se detiene para evitar errores.
                    stopCultivation(true, { title: "Error de T√©cnica", text: "No se encontr√≥ la t√©cnica de Conversi√≥n de Qi." });
                    return;
                }
            
            // ==================================================================================
            // === L√≥gica de Meditaci√≥n Restauradora Normal (SOLO SI LA CONVERSI√ìN NO EST√Å ACTIVA) ===
            // ==================================================================================
            } else {
                if (player.hp < player.maxHp) {
                    player.hp = Math.min(player.maxHp, player.hp + player.hpPerSecondBase);
                }
                if (player.mana < player.maxMana) {
                    player.mana = Math.min(player.maxMana, player.mana + player.qiPerSecondBase);
                }
                gainExperience(player.expPerSecondBase);
            }
        }

        // Al final del tick, se actualiza la UI con los nuevos valores.
        updateUI();
        showActiveCultivationModal();
    }

     
      function boostCultivationProgress() {
          const player = gameState.player;
          const mode = player.cultivationMode;

          if (!player.isCultivating || mode.type !== 'technique' || !mode.targetId) return;
          if ((gameState.inventory["Piedras Espirituales"] || 0) < 1) {
              showModal("Piedras Insuficientes", "No tienes suficientes Piedras Espirituales.");
              return;
          }

          const techId = mode.targetId;
          const playerTech = player.learnedTechniques[techId];
          const techData = techniqueData[techId];

          if (!playerTech || !techData || !techData.cultivationSettings || playerTech.level >= techData.maxLevel) {
              showModal("L√≠mite Alcanzado", "Esta t√©cnica ya est√° en su nivel m√°ximo.");
              return;
          }

          gameState.inventory["Piedras Espirituales"]--;
          playerTech.currentCultivationProgress = (playerTech.currentCultivationProgress || 0) + 10;
          
          let leveledUpThisBoost = false;
          let firstLevelUpMessage = "";

          while (
              playerTech.currentCultivationProgress >= playerTech.cultivationTimeToNextLevel &&
              playerTech.level < techData.maxLevel
          ) {
              leveledUpThisBoost = true;
              const progressNeeded = playerTech.cultivationTimeToNextLevel;
              playerTech.currentCultivationProgress -= progressNeeded;
              playerTech.level++;

              if (!firstLevelUpMessage) {
                  firstLevelUpMessage = `¬°Aceleraste '${techData.name}' al Nivel ${playerTech.level}!`;
                  if (playerTech.level >= techData.maxLevel) {
                      firstLevelUpMessage += " (¬°Nivel M√°ximo alcanzado!)";
                  }
              }

              if (playerTech.level < techData.maxLevel) {
                  playerTech.cultivationTimeToNextLevel = Math.floor(
                      techData.cultivationSettings.baseTimeToLevelUp *
                      Math.pow(techData.cultivationSettings.levelTimeMultiplier, playerTech.level)
                  );
              } else {
                  playerTech.cultivationTimeToNextLevel = Infinity;
                  playerTech.currentCultivationProgress = 0;
              }
              applyTechniqueEffect(techId, playerTech.level);
          }
          
          recalculatePlayerStats();
          updateUI();

          if (leveledUpThisBoost) {
              stopCultivation(); // Detener el cultivo
              showModal("¬°T√©cnica Mejorada con Aceleraci√≥n!", firstLevelUpMessage + "\n\nEl cultivo se ha detenido.");
              // ---- CORRECCI√ìN CLAVE ----
              return; // Salir de la funci√≥n para no ejecutar m√°s c√≥digo.
          }

          if (playerTech.level >= techData.maxLevel) {
              stopCultivation();
              showModal("Nivel M√°ximo Alcanzado", `La t√©cnica ${techData.name} ya est√° en su m√°ximo potencial.`);
              return;
          }

          if (document.getElementById("activeCultivationModal").style.display === "flex") {
              showActiveCultivationModal();
          }
          if (document.getElementById("techniqueModal").style.display === "flex") {
              showTechniquePanel();
          }
      }
       
      function toggleQiConversion() {
          const player = gameState.player;

          // Si ya hay un cultivo de CUALQUIER tipo activo...
          if (player.isCultivating) {
              // ...y ese cultivo es espec√≠ficamente el de conversi√≥n...
              if (player.cultivationMode.isConversionCultivation) {
                  // ...entonces lo detenemos.
                  console.log("Deteniendo cultivo de conversi√≥n de Qi activo.");
                  stopCultivation(true, { title: "Conversi√≥n Detenida", text: "Has detenido la conversi√≥n de Man√° a Vida."});
              } else {
                  // Si es otro tipo de cultivo (ej. de t√©cnica), avisamos al jugador.
                  showModal("Acci√≥n no permitida", "Debes detener tu cultivo actual para iniciar la conversi√≥n de Qi.");
              }
              return;
          }

          // Si no hay ning√∫n cultivo activo, iniciamos el de conversi√≥n.
          console.log("Iniciando cultivo con CONVERSI√ìN DE QI.");
          
          // CORRECCI√ìN CLAVE 1:
          // Iniciamos el modo de cultivo de recuperaci√≥n, pero inmediatamente despu√©s,
          // marcamos que es un modo especial de conversi√≥n.
          startCultivationMode('recovery'); 
          player.cultivationMode.isConversionCultivation = true; // <-- Esta es la marca especial.

          // Tambi√©n actualizamos la UI para que el bot√≥n refleje el estado activo.
          renderQuickSlotBar();
      }

        

        function useItem(itemName) {
          if (gameState.battle.active) {
            showModal(
              "Acci√≥n no permitida",
              "No puedes usar objetos del inventario en combate desde aqu√≠."
            );
            return;
          }
          if (
            !gameState.inventory[itemName] ||
            gameState.inventory[itemName] <= 0
          ) {
            showModal("Inventario Vac√≠o", `No tienes ${itemName}.`);
            return;
          }
          const itemInfo = itemData[itemName];
          if (!itemInfo || !itemInfo.effect) {
            showModal(
              "Error",
              `${itemName} no tiene efecto o no se puede usar as√≠.`
            );
            return;
          }
          if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
            let reason = "No puedes usar esto ahora.";
            if (
              itemName === "Hierbas Medicinales" &&
              gameState.player.hp >= gameState.player.maxHp
            )
              reason = "Vida al m√°ximo.";
            if (
              itemName === "Cristales de Qi" &&
              gameState.player.mana >= gameState.player.maxMana
            )
              reason = "Man√° al m√°ximo.";
            showModal("No se puede usar", reason);
            return;
          }
          const message =
            itemName === "Piedras Espirituales" ||
            itemName === "N√∫cleo de Bestia Menor" ||
            (itemInfo.description &&
              (itemInfo.description.includes("Otorga") ||
                itemInfo.description.includes("otorga")))
              ? itemInfo.effect(gameState.player, gainExperience)
              : itemInfo.effect(gameState.player);

          // Solo decrementar si el mensaje no indica un error (por si el efecto mismo retorna un error)
          if (
            message &&
            !message.toLowerCase().includes("error") &&
            !message.toLowerCase().includes("al m√°ximo")
          ) {
            gameState.inventory[itemName]--;
          }
          showModal("Objeto Usado", message);
          updateUI();
        }

        function gainExperience(amount) {
          if (amount <= 0) return;
          gameState.player.exp += amount;
          while (gameState.player.exp >= gameState.player.expToNext) {
            levelUp();
          }
        }

        function levelUp() {
          const player = gameState.player;
          player.exp -= player.expToNext;
          player.level++;

          const hpIncrease = 20 + Math.floor(player.level / 2);
          const manaIncrease = 10 + Math.floor(player.level / 3);
          const attackIncrease = 2 + Math.floor(player.level / 4);
          const defenseIncrease = 1 + Math.floor(player.level / 5);

          player.baseMaxHp += hpIncrease;
          player.baseMaxMana += manaIncrease;
          player.baseAttack += attackIncrease;
          player.baseDefense += defenseIncrease;

          player.hp = player.baseMaxHp; // Rellenar HP y Mana al subir de nivel
          player.mana = player.baseMaxMana;
          player.expToNext = Math.floor(
            player.expToNext * (1.3 + player.level * 0.02)
          );

          const oldRealm = player.realm;
          const realms = [
            "Mortal",
            "Forjado del Cuerpo",
            "Condensaci√≥n de Qi",
            "Fundaci√≥n",
            "N√∫cleo Dorado",
            "Alma Naciente",
            "Esp√≠ritu Primordial",
          ];
          const realmIndex = Math.min(
            Math.floor((player.level - 1) / 5),
            realms.length - 1
          );
          player.realm = realms[realmIndex];
          let realmChangeMessage = "";
          if (player.realm !== oldRealm) {
            realmChangeMessage = `\n\n¬°Has avanzado al Reino de ${player.realm}! Sientes una profunda transformaci√≥n...`;
            generateMap(true);
          }
          recalculatePlayerStats();

          showModal(
            "¬°Nivel Aumentado!",
            `Nivel ${player.level}!\nReino: ${player.realm}\n+${hpIncrease} HP, +${manaIncrease} Man√°\n+${attackIncrease} Atk, +${defenseIncrease} Def${realmChangeMessage}`
          );
        }

        function recalculatePlayerStats() {
          const player = gameState.player;
          // Reiniciar stats a base
          player.maxHp = player.baseMaxHp;
          player.maxMana = player.baseMaxMana;
          player.attack = player.baseAttack;
          player.defense = player.baseDefense;

          // Asegurar que HP y Mana actuales no excedan los m√°ximos recalculados
          player.hp = Math.min(player.hp, player.maxHp);
          player.mana = Math.min(player.mana, player.maxMana);

          gameState.activeCombatAbilities = []; // Reiniciar lista de habilidades de combate activas

          // Procesar t√©cnicas aprendidas para habilidades de combate activas y efectos pasivos directos
          for (const techId in player.learnedTechniques) {
            const playerTech = player.learnedTechniques[techId];
            if (playerTech.level > 0) {
              // Solo si la t√©cnica ha sido cultivada al menos al nivel 1 (o 0 si as√≠ lo defines)
              const techInfo = techniqueData[techId];
              if (
                techInfo?.type === "active_ability" &&
                !gameState.activeCombatAbilities.find(
                  (ab) => ab.id === techInfo.abilityId
                )
              ) {
                gameState.activeCombatAbilities.push({
                  id: techInfo.abilityId,
                  name: techInfo.name,
                  source: "technique",
                  sourceTechniqueId: techId, // Guardar el ID de la t√©cnica fuente es √∫til
                });
              }
              // Si tienes t√©cnicas pasivas que modifican stats como "Fortificaci√≥n Corporal B√°sica",
              // sus efectos ya se aplicaron al player.baseStat cuando se aprendieron/subieron de nivel en applyTechniqueEffect.
              // recalculatePlayerStats se encarga de que maxHp, attack, etc., se actualicen desde baseMaxHp, baseAttack.
            }
          }
          updateUI(); // Actualizar la UI con los stats recalculados
        }

        function startBattle(mapEntity) {
          battleLogHistory = []; 
          const toggleBtn = document.getElementById('toggleMapControlsBtn');
          if (toggleBtn) {
              toggleBtn.classList.add('hidden-during-battle');
          }
          const player = gameState.player;
          if (player.isCultivating) stopCultivation();
          hideTouchControls();

          // Detener animaci√≥n de caminar al entrar en batalla
          player.isMoving = false;
          if (player.animationTimer) {
            clearInterval(player.animationTimer);
            player.animationTimer = null;
          }
          if (player.idleTimeout) {
            clearTimeout(player.idleTimeout);
            player.idleTimeout = null;
          }
          player.currentDirection = "down"; // O la direcci√≥n que quieras en batalla
          player.currentFrame = 0; // Frame idle
          updatePlayerSpriteVisual(); // Actualizar para mostrar el sprite de batalla

          gameState.battle.active = true;
          gameState.battle.enemy = {
            ...mapEntity,
            hp: mapEntity.hp,
            maxHp: mapEntity.maxHp || mapEntity.hp,
            entityRef: mapEntity,
            frozenTurns: 0,
            stunnedTurns: 0,
            burningTurns: 0,
            burnDamage: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            defenseReductionTurns: 0,
            defenseReductionAmount: 0,
            rootedTurns: 0,
            rootDamage: 0,
            attackReductionTurns: 0,
            attackReductionAmount: 0,
            // Nuevos estados para efectos de alto nivel
            silencedTurns: 0, // Turnos en que no puede usar habilidades especiales
            sealedTurns: 0, // Turnos en que no puede realizar ninguna acci√≥n
          };
          gameState.battle.playerTurn = true;

          document.getElementById("battleScreen").style.display = "flex";
          populateBattleActionButtons();
          updateBattleUI();
          logBattle(`¬°Un ${gameState.battle.enemy.name} te enfrenta!`);
          updateTopNavVisibility();
          updatePlayerBarsOnMap();
        }

        function showFloatingText(targetElement, text, type) {
        if (!targetElement) return;

        const battleScreen = document.getElementById('battleScreen');
        
        const popup = document.createElement('div');
        popup.className = `damage-popup ${type}`;
        popup.textContent = text;
        
        // Lo a√±adimos al contenedor de la pantalla de batalla para que position:absolute funcione bien
        battleScreen.appendChild(popup);

        // Calculamos la posici√≥n inicial del popup
        const targetRect = targetElement.getBoundingClientRect();
        const battleRect = battleScreen.getBoundingClientRect();

        // Posici√≥n inicial en el centro-superior del objetivo
        const initialTop = targetRect.top - battleRect.top - 20;
        const initialLeft = targetRect.left - battleRect.left + (targetRect.width / 2) - (popup.offsetWidth / 2);

        popup.style.top = `${initialTop}px`;
        popup.style.left = `${initialLeft}px`;

        // Eliminar el elemento del DOM despu√©s de que termine la animaci√≥n
        popup.addEventListener('animationend', () => {
            popup.remove();
        });
      }

        function populateBattleActionButtons() {
          const battleActionButtons = document.getElementById(
            "battleActionButtons"
          );
          battleActionButtons.innerHTML = `
              <button onclick="battleAction('attack')">‚öîÔ∏è Atacar</button>
              <button onclick="battleAction('defend')">üõ°Ô∏è Defender</button>
              <button onclick="battleAction('qi_fist')">üßò Pu√±o de Qi</button> 
              <button onclick="battleAction('escape')">üèÉ Huir</button>
          `;
          gameState.activeCombatAbilities.forEach((ability) => {
            const abilityButton = document.createElement("button");
            let buttonText = `‚ú® ${ability.name}`;
            let canAfford = true;
            if (ability.source === "technique" && ability.sourceTechniqueId) {
              const techLevel =
                gameState.player.learnedTechniques[ability.sourceTechniqueId]
                  ?.level;
              if (techLevel > 0) buttonText += ` (Nv.${techLevel})`;
              else {
                abilityButton.disabled = true;
                abilityButton.title = "Requiere refinamiento";
              }
            }
            const techDetails =
              ability.source === "technique" && ability.sourceTechniqueId
                ? techniqueData[ability.sourceTechniqueId]
                : null;
            let manaCost = 0;
            if (
              techDetails &&
              techDetails.effect &&
              techDetails.effect.manaCost
            ) {
              manaCost = techDetails.effect.manaCost;
            } else if (ability.id === "qi_blast_minor") {
              manaCost = 15;
            } else if (techDetails && techDetails.manaCost) {
              manaCost = techDetails.manaCost;
            }
            if (manaCost > 0 && gameState.player.mana < manaCost) {
              canAfford = false;
            }

            abilityButton.textContent = buttonText;
            abilityButton.onclick = () => battleAction(ability.id, ability);
            abilityButton.disabled = abilityButton.disabled || !canAfford;
            if (!canAfford && !abilityButton.disabled)
              abilityButton.title = "Man√° insuficiente";

            battleActionButtons.appendChild(abilityButton);
          });
        }
       
        function updateExtraStatsUI() {
        // Actualizar Zona
        const zoneEl = document.getElementById('playerZone');
        if (zoneEl) {
            const currentZone = getPlayerCurrentZone();
            zoneEl.textContent = currentZone ? currentZone.name : 'Tierra Salvaje';
        }

        // Actualizar Piedras Espirituales
        const stonesEl = document.getElementById('playerStonesHud');
        if (stonesEl) {
            stonesEl.textContent = gameState.inventory["Piedras Espirituales"] || 0;
        }
      }
       
      function updateBattleUI() {
          const player = gameState.player;
          const enemy = gameState.battle.enemy;
          const battleScreenActive = document.getElementById('battleScreen').style.display === 'flex';

          // --- Actualizaci√≥n del Jugador (Barras sobre el sprite) ---
          const playerBarsContainer = document.getElementById("playerInBattleSpriteBarsContainer");
          const playerSpriteInBattle = document.querySelector(".battle-area .character .character-sprite");

          if (playerBarsContainer && playerSpriteInBattle && battleScreenActive) {
              playerBarsContainer.style.display = 'flex';
              const spriteTop = playerSpriteInBattle.offsetTop;
              const spriteLeft = playerSpriteInBattle.offsetLeft;
              const spriteWidth = playerSpriteInBattle.offsetWidth;
              const barContainerHeight = playerBarsContainer.offsetHeight;

              playerBarsContainer.style.top = `${spriteTop - barContainerHeight - 3}px`;
              playerBarsContainer.style.left = `${spriteLeft + (spriteWidth / 2)}px`;

              const playerHpFill = document.getElementById("playerInBattleSpriteHpFill");
              const playerManaFill = document.getElementById("playerInBattleSpriteManaFill");
              if(playerHpFill) playerHpFill.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
              if(playerManaFill) playerManaFill.style.width = `${Math.max(0, (player.mana / player.maxMana) * 100)}%`;

          } else if (playerBarsContainer) {
              playerBarsContainer.style.display = 'none';
          }

          // --- Actualizaci√≥n del Enemigo (Info y barras sobre el sprite) ---
          const enemyInfoContainer = document.getElementById('enemyInBattleInfoContainer');
          const enemySpriteEl = document.getElementById('enemySprite');
          
          let enemyHpPercent = 0;
          if (enemy) {
              enemyHpPercent = Math.max(0, (enemy.hp / (enemy.maxHp || enemy.hp)) * 100);
          }

          if (enemy && enemyInfoContainer && enemySpriteEl && battleScreenActive) {
              enemyInfoContainer.style.display = 'flex';

              
              // Calculamos la posici√≥n del contenedor de la barra de vida del enemigo
              const spriteTop = enemySpriteEl.offsetTop;
              const spriteLeft = enemySpriteEl.offsetLeft;
              const spriteWidth = enemySpriteEl.offsetWidth;
              const infoContainerHeight = enemyInfoContainer.offsetHeight;

              // Posicionamos el contenedor encima del sprite del enemigo
              enemyInfoContainer.style.top = `${spriteTop - infoContainerHeight - 5}px`;
              enemyInfoContainer.style.left = `${spriteLeft + (spriteWidth / 2)}px`;
              

              const enemyNameLevelEl = document.getElementById('enemyBattleNameLevel');
              const enemySpriteHpFill = document.getElementById('enemyInBattleSpriteHpFill');

              if (enemyNameLevelEl) {
                let enemyDisplayName = enemy.name;
                
                // Priorizamos la etiqueta de estatus (Jefe/√âlite)
                if (enemy.isBoss) {
                    enemyDisplayName += ` (Jefe)`;
                } else if (enemy.isMiniBoss) {
                    enemyDisplayName += ` (√âlite)`;
                }
                
                // Luego, a√±adimos el nivel si existe
                if (enemy.level) {
                    enemyDisplayName += ` - Nv. ${enemy.level}`;
                }

                enemyNameLevelEl.textContent = enemyDisplayName;
                // Coloreamos el nombre del jefe para que destaque
                if(enemy.isBoss) {
                    enemyNameLevelEl.style.color = '#ff4d4d'; // Rojo
                    enemyNameLevelEl.style.fontWeight = 'bold';
                } else {
                    // Si no es jefe, aplicamos la l√≥gica de color por nivel
                    const nameStyle = getEnemyNameColor(player.level, enemy.level || 1);
                    enemyNameLevelEl.style.color = nameStyle.color;
                    enemyNameLevelEl.style.fontWeight = nameStyle.fontWeight;
                }
            }
              if (enemySpriteHpFill) enemySpriteHpFill.style.width = `${enemyHpPercent}%`;

          } else if (enemyInfoContainer) {
              enemyInfoContainer.style.display = 'none';
          }

          // --- Actualizaci√≥n del resto de la UI de batalla (paneles principales) ---
          if (battleScreenActive) {
              document.getElementById('playerBattleName').textContent = `Cultivador (Nv.${player.level})`;
              document.getElementById('playerBattleHp').textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
              document.getElementById('playerBattleHpBar').style.width = `${(player.hp / player.maxHp) * 100}%`;
              
              if (enemy && enemySpriteEl) {
                  if (enemy.spriteUrl) {
                      enemySpriteEl.style.backgroundImage = `url('${enemy.spriteUrl}')`;
                      enemySpriteEl.textContent = '';
                  } else {
                      enemySpriteEl.style.backgroundImage = 'none';
                      enemySpriteEl.textContent = enemy.symbol || '?';
                  }

                  document.getElementById('enemyName').textContent = enemy.name;
                  document.getElementById('enemyHp').textContent = `${Math.floor(enemy.hp)}/${enemy.maxHp || enemy.hp}`;
                  document.getElementById('enemyHpBar').style.width = `${enemyHpPercent}%`;
              }
          }
      }
        
      function battleAction(action, abilityDetails = null) {
             if (!gameState.battle.playerTurn || !gameState.battle.active) return;
              const player = gameState.player;
              const enemy = gameState.battle.enemy;
              let actionTaken = true;
        
        let playerTechLevel = 0;
        if (abilityDetails && abilityDetails.source === "technique" && abilityDetails.sourceTechniqueId) {
          playerTechLevel = player.learnedTechniques[abilityDetails.sourceTechniqueId]?.level || 0;
        }

          // --- Aplicar DoTs y HoTs al JUGADOR ---
          if (player.burningTurns > 0) {
            player.hp -= player.burnDamage;
            logBattle(`Sufres ${player.burnDamage} da√±o por quemadura.`);
            player.burningTurns--;
            if (player.burningTurns === 0) logBattle("Quemadura se extingue.");
          }
          if (player.poisonedTurns > 0) {
            player.hp -= player.poisonDamage;
            logBattle(`Sufres ${player.poisonDamage} de da√±o por veneno.`);
            player.poisonedTurns--;
            if (player.poisonedTurns === 0) {
                logBattle("El veneno se ha disipado.");
                player.poisonDamage = 0;
            }
        }
        // === NUEVA L√ìGICA PARA PROCESAR DEBUFFS ===
        if (player.defenseReductionTurns > 0) {
            player.defenseReductionTurns--;
            if (player.defenseReductionTurns === 0) {
                player.defense += player.defenseReductionAmount; // Restaurar defensa
                logBattle(`Tu defensa vuelve a la normalidad. (Defensa: ${player.defense})`);
                player.defenseReductionAmount = 0;
            }
        }
        if (player.attackReductionTurns > 0) {
            player.attackReductionTurns--;
            if (player.attackReductionTurns === 0) {
                player.attack += player.attackReductionAmount; // Restaurar ataque
                logBattle(`Tu esp√≠ritu de lucha se recupera. (Ataque: ${player.attack})`);
                player.attackReductionAmount = 0;
            }
        }

          if (player.healingRainTurns > 0) {
            const heal = player.healingRainAmount;
            player.hp = Math.min(player.maxHp, player.hp + heal);
            logBattle(`Lluvia Curativa te sana ${heal} HP.`);
            player.healingRainTurns--;
            if (player.healingRainTurns === 0) logBattle("Lluvia Curativa cesa.");
          }

          // --- Revertir buffs/debuffs temporales del JUGADOR ---
          if (player.defenseBoostTurns > 0) {
            player.defenseBoostTurns--;
            if (player.defenseBoostTurns === 0) {
              player.defense -= player.defenseBoostAmount;
              logBattle(`Piel de Piedra termina. Defensa: ${player.defense}.`);
              player.defenseBoostAmount = 0;
            }
          }
          if (player.bloodRitualTurns > 0 && action !== "blood_ritual") {
            player.bloodRitualTurns--;
            if (player.bloodRitualTurns === 0) {
              player.attack -= player.bloodRitualAttackBoost;
              logBattle(`Ritual de Sangre termina. Ataque: ${player.attack}.`);
              player.bloodRitualAttackBoost = 0;
            }
          }
          if (player.immuneTurns > 0 && action !== "aura_of_purity") {
            player.immuneTurns--;
            if (player.immuneTurns === 0) {
              logBattle(`Inmunidad termina.`);
            }
          }
          if (
            player.cloneActive &&
            player.cloneTurns > 0 &&
            action !== "phantom_clone"
          ) {
            player.cloneTurns--;
            if (player.cloneTurns === 0) {
              player.cloneActive = false;
              logBattle("Clon Fantasma desaparece.");
            }
          }
          if (player.elementalTurns > 0 && action !== "summon_elemental") {
            player.elementalTurns--;
            if (player.elementalTurns === 0) {
              player.attack -= player.tempAttackBonus;
              player.defense -= player.tempDefenseBonus;
              logBattle("Elemental invocado desaparece.");
              player.tempAttackBonus = 0;
              player.tempDefenseBonus = 0;
            }
          }
          if (player.magicShieldTurns > 0 && action !== "mystic_barrier") {
            player.magicShieldTurns--;
            if (player.magicShieldTurns === 0 && player.magicShieldValue > 0) {
              logBattle("Barrera M√≠stica se disipa.");
              player.magicShieldValue = 0;
            }
          }

          if (player.hp <= 0) {
            logBattle("Has sucumbido antes de actuar.");
            player.hp = 0;
            setTimeout(() => {
              player.hp = Math.floor(player.maxHp * 0.1);
              player.mana = Math.floor(player.maxMana * 0.1);
              const expLossPercentage = 0.1;
              const expToLose = Math.floor(player.exp * expLossPercentage);
              player.exp = Math.max(0, player.exp - expToLose);
              logBattle(`Pierdes ${expToLose} EXP.`);
              const safeRespawnCoords = findSafeRespawnLocation(
                G_SAFE_RESPAWN_X,
                G_SAFE_RESPAWN_Y
              );
              player.x = safeRespawnCoords.x;
              player.y = safeRespawnCoords.y;
              updatePlayerPosition();
              endBattle(false);
              showModal("Derrota", "Has sido derrotado...");
            }, 2000);
            return;
          }

          const techDetails = techniqueData[action]; // Obtener detalles de la t√©cnica por su ID
        if (techDetails && techDetails.type === 'active_ability') {
            const manaCost = techDetails.manaCost || 0;
            if (player.mana >= manaCost) {
                player.mana -= manaCost;
                let damageDealt = 0;
                let logMessage = "";
                
                // --- L√≥gica Centralizada para Habilidades ---
                switch(action) {
                    case "sword_t1":
                      const swordTechDetails = techniqueData["sword_t1"];
                      const swordManaCost = swordTechDetails.manaCost || 10; 
                      if (player.mana >= swordManaCost) {
                          player.mana -= swordManaCost;
                          const damageMultiplier = swordTechDetails.effect.baseDamageMultiplier + ((playerTechLevel - 1) * 0.2);
                          const swordDamage = Math.max(1, Math.floor(player.attack * damageMultiplier) - (enemy.defense || 0));
                          enemy.hp -= swordDamage;
                          logBattle(`¬°${swordTechDetails.name} (Nv.${playerTechLevel}) causa ${swordDamage} da√±o!`);
                          showFloatingText(document.querySelector('.character-sprite'), `Tajo Veloz`, 'ability');
                          showFloatingText(document.getElementById('enemySprite'), `-${swordDamage}`, 'damage');
                      } else { logBattle(`Man√° insuficiente para ${swordTechDetails.name}.`); actionTaken = false; }
                      
                      break;
                      
                    case "sword_t3":
                    case "fire_t2":
                        damageDealt = Math.max(1, Math.floor(player.attack * (techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.2)) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;
                        logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} da√±o!`;
                        if (action === 'fire_t2') {
                             enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                             enemy.burnDamage = Math.max(enemy.burnDamage, techDetails.effect.burnDamagePerTurn + (playerTechLevel * 2));
                             logMessage += ` e inflige una quemadura intensa.`;
                        }
                        break;
                   
                 
                    case "fire_t1":
                        damageDealt = Math.max(1, Math.floor(player.attack * (techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.1)) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;
                        enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                        enemy.burnDamage = Math.max(enemy.burnDamage, techDetails.effect.burnDamagePerTurn + playerTechLevel);
                        logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} da√±o y quema al enemigo!`;
                        break;

                    case "lightning_t1":
                    case "sword_t4":
                        damageDealt = Math.max(1, Math.floor(player.attack * (techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.15)) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;
                        logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) golpea con ${damageDealt} de da√±o!`;
                        if (Math.random() < (techDetails.effect.stunChance + (playerTechLevel * 0.02))) {
                            enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                            logMessage += " ¬°El enemigo queda aturdido!";
                        }
                        break;
                    
                    case "sword_t2":
                        const defenseToIgnore = (enemy.defense || 0) * (techDetails.effect.defensePenetration + (playerTechLevel * 0.02));
                        damageDealt = Math.max(1, Math.floor(player.attack * (techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.1)) - ((enemy.defense || 0) - defenseToIgnore));
                        enemy.hp -= damageDealt;
                        logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) ignora parte de la defensa y causa ${damageDealt} da√±o!`;
                        break;

                    case "movement_t2":
                        player.dodgeNextAttack = true;
                        logMessage = `¬°Usas ${techDetails.name} (Nv.${playerTechLevel}) y te preparas para esquivar!`;
                        break;

                    case "formation_t1":
                         player.magicShieldValue = (player.magicShieldValue || 0) + (techDetails.effect.shieldValue + (playerTechLevel * 5));
                         player.magicShieldTurns = Math.max(player.magicShieldTurns, techDetails.effect.duration);
                         logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) crea un escudo que absorbe ${techDetails.effect.shieldValue + (playerTechLevel * 5)} de da√±o!`;
                         break;
                    
                    case "formation_t2":
                         player.magicShieldValue = (player.magicShieldValue || 0) + (techDetails.effect.shieldValue + (playerTechLevel * 5));
                         player.magicShieldTurns = Math.max(player.magicShieldTurns, techDetails.effect.duration);
                         logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) crea un escudo que absorbe ${techDetails.effect.shieldValue + (playerTechLevel * 5)} de da√±o!`;
                         break;
                    case "formation_t3":
                         player.magicShieldValue = (player.magicShieldValue || 0) + (techDetails.effect.shieldValue + (playerTechLevel * 5));
                         player.magicShieldTurns = Math.max(player.magicShieldTurns, techDetails.effect.duration);
                         logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) crea un escudo que absorbe ${techDetails.effect.shieldValue + (playerTechLevel * 20)} de da√±o!`;
                         showFloatingText(document.getElementById('enemySprite'), 'Defensa ‚Üì / Ataque ‚Üì', 'debuff');
                         break;
                    case "sword_t5": // Corte que Divide Cielos y Tierra
                        const baseDmg_t5 = player.attack * techDetails.effect.baseDamageMultiplier;
                        let finalDmg_t5 = baseDmg_t5;
                        logMessage = `¬°${techDetails.name} desata un poder que ignora la defensa!`;
                        if (Math.random() < (techDetails.effect.criticalChance || 0)) {
                           finalDmg_t5 *= 1.5;
                           logMessage += " ¬°Es un golpe cr√≠tico!";
                        }
                        enemy.hp -= Math.floor(finalDmg_t5);
                        logMessage += ` Causa ${Math.floor(finalDmg_t5)} da√±o verdadero.`;
                        break;

                    case "fire_t5": // Llama del F√©nix Renaciente
                        const fireDmg_t5 = Math.floor(player.attack * techDetails.effect.baseDamageMultiplier);
                        enemy.hp -= fireDmg_t5;
                        player.canRevive = true; // Activa la bandera de resurrecci√≥n
                        logMessage = `¬°${techDetails.name} incinera al enemigo con ${fireDmg_t5} de da√±o y te imbuye con la esencia del F√©nix!`;
                        break;
                    
                    case "formation_t5": // Matriz de Reversi√≥n del Cosmos
                        player.damageToHealingTurns = techDetails.effect.damageToHealingDuration;
                        logMessage = `¬°Activaste ${techDetails.name}! Durante ${player.damageToHealingTurns} turnos, el da√±o recibido te curar√°.`;
                        break;

                    case "movement_t5": // Paso del Vac√≠o Infinito
                         player.intangibleTurns = techDetails.effect.intangibleTurns;
                         const hits_t5 = techDetails.effect.multiHit;
                         let totalDmg_t5 = 0;
                         for(let i=0; i<hits_t5; i++){
                            const hitDmg = Math.max(1, Math.floor((player.attack * techDetails.effect.baseDamageMultiplier)/hits_t5) - enemy.defense);
                            enemy.hp -= hitDmg;
                            totalDmg_t5 += hitDmg;
                         }
                         logMessage = `¬°Con ${techDetails.name} te vuelves intangible por ${player.intangibleTurns} turnos y golpeas ${hits_t5} veces, causando un total de ${totalDmg_t5} de da√±o!`;
                         break;

                    case "sword_t6": // Espada del Emperador Celestial
                         logMessage = `¬°${techDetails.name} desata un poder absoluto!`;
                         if (enemy.hp / enemy.maxHp <= (techDetails.effect.executeThreshold || 0.2)) {
                            enemy.hp = 0;
                            logMessage += " ¬°El enemigo es ejecutado por decreto celestial!";
                         } else {
                            const swordDmg_t6 = Math.floor(player.attack * techDetails.effect.baseDamageMultiplier);
                            enemy.hp -= swordDmg_t6;
                            logMessage += ` Causa ${swordDmg_t6} de da√±o que ignora toda protecci√≥n.`;
                         }
                         break;
                    
                    case "formation_t6": // Matriz del Sello del Demonio
                        enemy.sealedTurns = techDetails.effect.sealDuration;
                        logMessage = `¬°${techDetails.name} sella completamente al enemigo por ${enemy.sealedTurns} turnos!`;
                        break;
                    
                    default:
                        logBattle(`T√©cnica ${action} no implementada en batalla.`);
                        actionTaken = false;
                        break;
                }
                if(actionTaken) logBattle(logMessage);

            } else {
              logBattle(`Man√° insuficiente para ${techDetails.name}.`);
              actionTaken = false;
            }
        } else {
            // L√≥gica para acciones b√°sicas (attack, defend, escape)
            switch (action) {
                case "attack":
                    const damage = Math.max(1, player.attack - (enemy.defense || 0) + Math.floor(Math.random() * 5 - 2));
                    enemy.hp -= damage;
                    logBattle(`Atacas causando ${damage} da√±o.`);
                    showFloatingText(document.getElementById('enemySprite'), `-${damage}`, 'damage');
        
                    break;
                case 'qi_fist':
                  const qiFistCost = 10;
                    if (player.mana >= qiFistCost) {
                        player.mana -= qiFistCost;
                        const magicDamage = Math.max(1, Math.floor(player.attack * 0.8 + player.maxMana * 0.2) - (enemy.defense || 0));
                        enemy.hp -= magicDamage;
                        logBattle(`Pu√±o de Qi causa ${magicDamage} da√±o m√°gico.`);
                        showFloatingText(document.querySelector('.character-sprite'), `Pu√±o de QI`, 'ability');
                        showFloatingText(document.getElementById('enemySprite'), `-${magicDamage}`, 'damage');
                        
                    } else { logBattle('Man√° insuficiente para Pu√±o de Qi.'); actionTaken = false; }
                    
                  break;
                case "defend":
                    let healAmount = Math.floor(player.maxHp * 0.1);
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    showFloatingText(document.querySelector('.character-sprite'), `+${healAmount}`, 'heal');
                    logBattle(`Te defiendes y recuperas ${healAmount} HP.`);
                    break;
                case "escape":
                  if (enemy.isBoss) {
                    logBattle(`¬°No puedes huir de un ${enemy.name}!`);
                    showFloatingText(document.querySelector('.character-sprite'), '¬°Imposible!', 'debuff');
                    actionTaken = false; // La acci√≥n fall√≥, no se consume el turno
                  } else if (Math.random() < 0.7) { // Probabilidad de √©xito de huida
                      
                      const escapeTile = findEscapeTile(player, enemy);
                      
                      if (escapeTile) {
                          logBattle("¬°Escapaste con √©xito!");
                          showFloatingText(document.querySelector('.character-sprite'), '¬°Huida!', 'ability');
                          
                          // Mover al jugador a la casilla segura ANTES de terminar la batalla
                          player.x = escapeTile.x;
                          player.y = escapeTile.y;
                          
                          // Esperar un breve momento para que el texto flotante se vea
                          setTimeout(() => {
                              endBattle(false); // false = no fue una victoria
                              updatePlayerPosition("escape_success"); // Actualizar la posici√≥n visual en el mapa
                          }, 500);

                      } else {
                          logBattle("¬°Intentaste huir, pero no hay a d√≥nde ir!");
                          showFloatingText(document.querySelector('.character-sprite'), '¬°Atrapado!', 'debuff');
                          actionTaken = true; // El intento de huir consume el turno
                      }
                      
                      // Como la huida (exitosa o no) ya manej√≥ el flujo, salimos de la funci√≥n
                      return;

                  } else {
                    logBattle("¬°No pudiste escapar!");
                    showFloatingText(document.querySelector('.character-sprite'), '¬°Fall√≥!', 'debuff');
                    actionTaken = true; // El intento fallido tambi√©n consume el turno
                  }
                  break;
                default:
                    logBattle("Acci√≥n desconocida.");
                    actionTaken = false;
                    break;
            }
        }

        if (!actionTaken) {
          updateBattleUI();
          return;
        }

        gameState.battle.playerTurn = false;
        updateBattleUI();

        if (enemy.hp <= 0) {

          
            handleEnemyDefeat();
          } else {
            let enemyDiedToDot = false;
            if (enemy.burningTurns > 0) {
              enemy.hp -= enemy.burnDamage;
              logBattle(
                `${enemy.name} sufre ${
                  enemy.burnDamage
                } por quemadura. HP: ${Math.floor(enemy.hp)}`
              );
              if (enemy.hp <= 0) enemyDiedToDot = true;
            }
            if (!enemyDiedToDot && enemy.poisonedTurns > 0) {
              enemy.hp -= enemy.poisonDamage;
              logBattle(
                `${enemy.name} sufre ${
                  enemy.poisonDamage
                } por veneno. HP: ${Math.floor(enemy.hp)}`
              );
              if (enemy.hp <= 0) enemyDiedToDot = true;
            }
            if (!enemyDiedToDot && enemy.rootedTurns > 0) {
              enemy.hp -= enemy.rootDamage;
              logBattle(
                `${enemy.name} sufre ${
                  enemy.rootDamage
                } por enredo. HP: ${Math.floor(enemy.hp)}`
              );
              if (enemy.hp <= 0) enemyDiedToDot = true;
            }

            if (enemyDiedToDot) {
              handleEnemyDefeat();
            } else {
              setTimeout(enemyTurn, 1000);
            }
          }
        }

        function handleEnemyDefeat() {
          const enemy = gameState.battle.enemy;
          const player = gameState.player;

          logBattle(`¬°Has derrotado al ${enemy.name}!`);
          gainExperience(enemy.exp);

          const misionesActivasDelJugador = [...player.secta.misionesActivas];
          
          misionesActivasDelJugador.forEach((misionActiva) => {
              const misionDataOriginal = MISIONES_DATA[misionActiva.id];
              if (!misionDataOriginal || !misionActiva.objetivoOriginal) return;
              
              const objetivo = misionActiva.objetivoOriginal;

              // L√≥gica para actualizar el progreso de la misi√≥n de desaf√≠o
              if (objetivo.tipo === "derrotar_npc_especifico" && enemy.isSectChallengeRival && enemy.npcId === objetivo.npcId) {
                  misionActiva.progreso = 1; // 1 significa "objetivo cumplido".
                  logBattle(`¬°Has superado la prueba! Reporta tu √©xito en la secta.`);
                  console.log(`[Misi√≥n Desaf√≠o] Progreso de la misi√≥n '${misionActiva.id}' actualizado a 1.`);
              } 
              // L√≥gica para otras misiones de eliminaci√≥n
              else if (objetivo.tipo === "eliminar_enemigo" && (enemy.originalEntityTypeId === objetivo.enemigoTipo || enemy.name === objetivo.nombreDisplay)) {
                  misionActiva.progreso = (misionActiva.progreso || 0) + 1;
                  logBattle(`Progreso '${misionDataOriginal.titulo}': ${misionActiva.progreso}/${objetivo.cantidad}`);
              } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot" && enemy.originalEntityTypeId === objetivo.enemigoTipo) {
                  misionActiva.progreso = 1;
                  logBattle(`Has derrotado a un ${enemy.name}. Busca el ${objetivo.itemPrueba} entre el bot√≠n.`);
              }
          });
          
          updateSectUI();

          // El resto de la funci√≥n (loot, etc.) no cambia...
          let lootObtenidoTexto = "Bot√≠n Obtenido: ";
          let algoObtenido = false;
          if (enemy.lootTable) {
              enemy.lootTable.forEach(loot => {
                  if (Math.random() < loot.chance) {
                      const cantidad = loot.quantity[0] + Math.floor(Math.random() * (loot.quantity[1] - loot.quantity[0] + 1));
                      gameState.inventory[loot.itemName] = (gameState.inventory[loot.itemName] || 0) + cantidad;
                      lootObtenidoTexto += `${cantidad} ${loot.itemName}, `;
                      algoObtenido = true;
                  }
              });
          }
          if (!algoObtenido) lootObtenidoTexto += "Nada.";
          else lootObtenidoTexto = lootObtenidoTexto.slice(0, -2) + ".";

          if (enemy.isBoss && enemy.originalEntityTypeId) {
              player.worldState.defeatedBosses[enemy.originalEntityTypeId] = true;
              if (enemy.nextBossId) {
                  player.worldState.currentBossToSpawn = enemy.nextBossId;
              } else {
                  player.worldState.currentBossToSpawn = null;
              }
          } else if (enemy.isMiniBoss && enemy.isFixed && enemy.originalEntityTypeId) {
              if (!player.worldState.defeatedFixedEntities) player.worldState.defeatedFixedEntities = {};
              player.worldState.defeatedFixedEntities[enemy.originalEntityTypeId] = { time: Date.now() };
          }

          setTimeout(() => {
              endBattle(true);
              showModal("¬°Victoria!", `Has ganado el combate.\n\n${lootObtenidoTexto}\n\nRevisa tu diario de misiones para ver el progreso.`);
          }, 1500);
      }

        function completeMission(misionId, npcIdEntregaManual = null) {
          const player = gameState.player;
          const misionActiva = player.secta.misionesActivas.find((m) => m.id === misionId);
          const misionDataOriginal = MISIONES_DATA[misionId];

          if (!misionActiva || !misionDataOriginal) {
            showModal("Error de Misi√≥n", "Datos de la misi√≥n no encontrados.");
            return false;
          }

          const objetivo = misionActiva.objetivoOriginal;
          let objetivosCumplidos = false;

          switch (objetivo.tipo) {
            case "entregar_item":
              if ((gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad) {
                if (npcIdEntregaManual && npcIdEntregaManual === objetivo.npcEntrega) {
                  gameState.inventory[objetivo.item] -= objetivo.cantidad;
                  updateInventoryUI();
                  objetivosCumplidos = true;
                }
              } else {
                  showModal("Objetivo Incompleto", `A√∫n necesitas ${objetivo.cantidad - (gameState.inventory[objetivo.item] || 0)} ${objetivo.item}.`);
                  return false;
              }
              break;
            case "eliminar_enemigo":
              if (misionActiva.progreso >= objetivo.cantidad) {
                objetivosCumplidos = true;
              }
              break;
            case "derrotar_npc_especifico":
              if (misionActiva.progreso === 1) { 
                objetivosCumplidos = true;
              } else {
                showModal("Objetivo Incompleto", "A√∫n no has derrotado al oponente del desaf√≠o.");
                return false;
              }
              break;
            case "recolectar_multiples_items":
              let todosItemsRecolectados = true;
              for (const itemReq of objetivo.items) {
                if (
                  (gameState.inventory[itemReq.nombre] || 0) < itemReq.cantidad
                ) {
                  todosItemsRecolectados = false;
                  break;
                }
              }
              if (todosItemsRecolectados) {
                  if(npcIdEntregaManual === objetivo.npcEntrega) {
                      for (const itemReq of objetivo.items) {
                          gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                      }
                      updateInventoryUI();
                      objetivosCumplidos = true;
                  }
              }
              break;
            case "cazar_y_recuperar_item_de_loot":
                  if (misionActiva.progreso === 1 && (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba) {
                      if (npcIdEntregaManual === objetivo.npcEntrega) {
                          gameState.inventory[objetivo.itemPrueba] -= objetivo.cantidadItemPrueba;
                          updateInventoryUI();
                          objetivosCumplidos = true;
                      }
                  }
              break;
            default:
              showModal("Error de Misi√≥n", "Tipo de objetivo no reconocido.");
              return false;
          }

          if (!objetivosCumplidos) {
            console.log(`Objetivos no cumplidos para ${misionDataOriginal.titulo} al intentar completar.`);
            return false;
          }

          // --- Dar Recompensas ---
          player.secta.puntosContribucion += misionDataOriginal.recompensa.pcs || 0;
          gainExperience(misionDataOriginal.recompensa.exp || 0);
          let recompensaItemsTexto = "";
          if (misionDataOriginal.recompensa.items) {
            for (const itemName in misionDataOriginal.recompensa.items) {
              gameState.inventory[itemName] = (gameState.inventory[itemName] || 0) + misionDataOriginal.recompensa.items[itemName];
              recompensaItemsTexto += `${misionDataOriginal.recompensa.items[itemName]} ${itemName}, `;
            }
            updateInventoryUI();
            if (recompensaItemsTexto) recompensaItemsTexto = recompensaItemsTexto.slice(0, -2);
          }

          let recompensaTextoGlobal = `Recompensas: ${misionDataOriginal.recompensa.pcs || 0} PCS, ${misionDataOriginal.recompensa.exp || 0} EXP`;
          if (recompensaItemsTexto) recompensaTextoGlobal += `, ${recompensaItemsTexto}`;

          player.secta.misionesActivas = player.secta.misionesActivas.filter((m) => m.id !== misionId);
          player.secta.misionesCompletadas[misionId] = true;

          showModal("¬°Misi√≥n Completada!", `Completaste: ${misionDataOriginal.titulo}.\n${recompensaTextoGlobal}`);

          if (misionDataOriginal.recompensa.nuevoRango) {
            const newRankName = misionDataOriginal.recompensa.nuevoRango;
            player.secta.rango = newRankName;
            
            setTimeout(() => showModal("¬°Ascenso en la Secta!", `¬°Felicidades! Ascendiste a ${player.secta.rango}.`), 2500);
            
            applyRankBenefits(player.secta.rango);

            // === INICIO DE LA MODIFICACI√ìN CLAVE ===
            // Comprobamos si el nuevo rango tiene una elecci√≥n de t√©cnica como recompensa.
            const rankData = SECTA_DATA.rangos.find(r => r.nombre === newRankName);
            if (rankData && rankData.techniqueChoice) {
                // Esperamos un poco m√°s para que no se solape con el modal de ascenso.
                setTimeout(() => {
                    openRankUpRewardModal(newRankName);
                }, 4500); 
            }
            // === FIN DE LA MODIFICACI√ìN CLAVE ===
          }

          updateSectUI();
          checkAndActivateRankChallengeMissions();
          return true;
        }
       
        function openRankUpRewardModal(newRankName) {
          const modal = document.getElementById('rankUpRewardModal');
          const titleEl = document.getElementById('rankUpRewardTitle');
          const optionsContainer = document.getElementById('rankUpRewardOptionsContainer');

          if (!modal || !titleEl || !optionsContainer) {
              console.error("Elementos del modal de recompensa de rango no encontrados.");
              return;
          }

          const rankData = SECTA_DATA.rangos.find(r => r.nombre === newRankName);
          if (!rankData || !rankData.techniqueChoice || rankData.techniqueChoice.length === 0) {
              console.log(`No hay recompensas de t√©cnica para el rango ${newRankName}.`);
              return;
          }

          titleEl.textContent = `Recompensa por ascender a ${newRankName}`;
          optionsContainer.innerHTML = ''; // Limpiar opciones anteriores

          rankData.techniqueChoice.forEach(techId => {
              const techInfo = techniqueData[techId];
              if (techInfo) {
                  const button = document.createElement('button');
                  button.className = 'cultivation-option-btn';
                  button.innerHTML = `
                      <strong>${techInfo.icon || 'üìú'} ${techInfo.name}</strong>
                      <br>
                      <small style="opacity: 0.8;">${techInfo.description}</small>
                  `;
                  button.onclick = () => claimRankUpReward(techId);
                  optionsContainer.appendChild(button);
              }
          });

          modal.style.display = 'flex';
          hideTouchControls();
        }

        function claimRankUpReward(techId) {
            // Buscamos el nombre del "Rollo" que ense√±a esta t√©cnica
            let scrollItemName = null;
            const techDefinition = techniqueData[techId];

            // Este bucle asume que el nombre de la t√©cnica en la definici√≥n y en el nombre del rollo coinciden.
            // Ej: techniqueData.sword_slash_1.name es "Corte de Espada B√°sico"
            // y el item se llama "Rollo: Corte de Espada B√°sico"
            if(techDefinition) {
                const expectedScrollName = `Rollo: ${techDefinition.name}`;
                if(itemData[expectedScrollName]) {
                    scrollItemName = expectedScrollName;
                }
            }
            
            if (scrollItemName) {
                gameState.inventory[scrollItemName] = (gameState.inventory[scrollItemName] || 0) + 1;
                updateInventoryUI();
                closeRankUpRewardModal();
                showModal("¬°Recompensa Obtenida!", `Has recibido el "${scrollItemName}".\nRevisa tu inventario para aprender la t√©cnica.`);
            } else {
                console.error(`No se pudo encontrar el objeto 'Rollo' para la t√©cnica con ID: ${techId}`);
                showModal("Error de Recompensa", "No se pudo otorgar la recompensa. Contacta a un Anciano de la Secta (o al desarrollador).");
            }
        }

        function closeRankUpRewardModal() {
          const modal = document.getElementById('rankUpRewardModal');
          if(modal) modal.style.display = 'none';
          showTouchControls();
        }
        
        function updateSectUI() {
          const player = gameState.player;
          document.getElementById("sectaNombreDisplay").textContent =
            player.secta.nombre;
          document.getElementById("playerSectRank").textContent =
            player.secta.rango;
          document.getElementById("playerPCS").textContent =
            player.secta.puntosContribucion;

          const missionsListDiv = document.getElementById("activeMissionsList");
          missionsListDiv.innerHTML = "";

          if (player.secta.misionesActivas.length === 0) {
            missionsListDiv.innerHTML = "<p>Ninguna misi√≥n activa.</p>";
          } else {
            player.secta.misionesActivas.forEach((misionActiva) => {
              const misionDataOriginal = MISIONES_DATA[misionActiva.id];
              if (misionDataOriginal && misionActiva.objetivoOriginal) {
                // Asegurar que objetivoOriginal exista
                let progresoTexto = "";
                const objetivo = misionActiva.objetivoOriginal;
                const npcEntregaNombre =
                  SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre ||
                  "NPC correspondiente";

                if (objetivo.tipo === "eliminar_enemigo") {
                  progresoTexto = ` (${misionActiva.progreso || 0}/${
                    objetivo.cantidad
                  } ${objetivo.nombreDisplay || "objetivos"})`;
                  if ((misionActiva.progreso || 0) >= objetivo.cantidad) {
                    progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                  }
                } else if (objetivo.tipo === "entregar_item") {
                  const tiene = gameState.inventory[objetivo.item] || 0;
                  const necesita = objetivo.cantidad;
                  progresoTexto = ` (Tienes ${tiene}/${necesita} ${objetivo.item})`;
                  if (tiene >= necesita) {
                    progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                  }
                } else if (objetivo.tipo === "recolectar_multiples_items") {
                  let todosListos = true;
                  let itemsStatusArray = objetivo.items.map((itemReq) => {
                    const tiene = gameState.inventory[itemReq.nombre] || 0;
                    const necesita = itemReq.cantidad;
                    if (tiene < necesita) todosListos = false;
                    return `${tiene}/${necesita} ${itemReq.nombre}`;
                  });
                  progresoTexto = ` (${itemsStatusArray.join(", ")})`;
                  if (todosListos) {
                    progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                  }
                } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot") {
                  const tieneItem =
                    (gameState.inventory[objetivo.itemPrueba] || 0) >=
                    objetivo.cantidadItemPrueba;
                  progresoTexto =
                    misionActiva.progreso === 1 && tieneItem
                      ? ` (Prueba '${objetivo.itemPrueba}' obtenida)`
                      : ` (Cazar ${objetivo.enemigoTipo} y obtener ${objetivo.itemPrueba})`;
                  if (misionActiva.progreso === 1 && tieneItem) {
                    progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                  }
                } else if (objetivo.tipo === "derrotar_npc_especifico") {
                  // Estas se autocompletan, as√≠ que no aparecer√°n mucho aqu√≠ si se completan r√°pido
                  progresoTexto = ` (Derrotar a ${
                    entityTypes[objetivo.npcId]?.name || "objetivo"
                  })`;
                }
                const p = document.createElement("p");
                p.innerHTML = `<strong>${misionDataOriginal.titulo}</strong><small>${progresoTexto}</small>`;
                missionsListDiv.appendChild(p);
              }
            });
          }
        }

        function checkAndActivateRankChallengeMissions() {
          const player = gameState.player;
          const currentRankIndex = SECTA_DATA.rangos.findIndex(
            (r) => r.nombre === player.secta.rango
          );

          if (currentRankIndex === -1) {
            console.error(
              "Error: Rango actual del jugador no encontrado en SECTA_DATA.rangos"
            );
            return;
          }

          // Si ya est√° en el rango m√°ximo, no hay m√°s desaf√≠os
          if (currentRankIndex + 1 >= SECTA_DATA.rangos.length) {
            // console.log("Jugador en el rango m√°ximo o no hay m√°s rangos definidos.");
            return;
          }

          const nextRankData = SECTA_DATA.rangos[currentRankIndex + 1];

          // Verificar si el jugador cumple los PCS para el siguiente rango
          if (player.secta.puntosContribucion >= nextRankData.pcsRequeridos) {
            // Verificar si hay un ID de rival para el desaf√≠o de este pr√≥ximo rango
            if (nextRankData.desafioRivalId) {
              const desafioMisionId = Object.keys(MISIONES_DATA).find((mId) => {
                const mision = MISIONES_DATA[mId];
                return (
                  mision.objetivo?.tipo === "derrotar_npc_especifico" &&
                  mision.objetivo?.npcId === nextRankData.desafioRivalId &&
                  (mision.autoActivarAlCumplirRequisitos === true ||
                    mision.recompensa?.nuevoRango === nextRankData.nombre)
                ); // Condici√≥n para identificar la misi√≥n de desaf√≠o
              });

              if (desafioMisionId) {
                // Verificar si la misi√≥n de desaf√≠o NO est√° ya activa o completada
                const isMissionActive = player.secta.misionesActivas.some(
                  (m) => m.id === desafioMisionId
                );
                const isMissionCompleted =
                  player.secta.misionesCompletadas[desafioMisionId];

                if (!isMissionActive && !isMissionCompleted) {
                  acceptMission(desafioMisionId);
                  const misionData = MISIONES_DATA[desafioMisionId];
                  showModal(
                    "¬°Nuevo Desaf√≠o de Rango!",
                    `Has alcanzado los requisitos de PCS para el rango de ${nextRankData.nombre}.\n` +
                      `Se ha activado la misi√≥n de desaf√≠o: "${misionData.titulo}".\n` +
                      `¬°Prep√°rate y busca a tu oponente en la arena de la secta!`
                  );

                  // Asegurar que el NPC del desaf√≠o (el rival) aparezca en el mapa si tiene fixedLocation
                  // ensureFixedEntities() deber√≠a encargarse de esto si el rival est√° en la lista de entidades fijas
                  // y no ha sido derrotado (lo cual es el caso si la misi√≥n se acaba de activar).
                  // Si el rival no es una entidad fija por defecto, podr√≠as a√±adirlo aqu√≠ din√°micamente,
                  // pero es m√°s limpio manejarlo con ensureFixedEntities.
                  ensureFixedEntities();
                  renderMap(); // Para asegurar que el rival (si es nuevo) se muestre
                } else {
                  // console.log(`Misi√≥n de desaf√≠o ${desafioMisionId} para ${nextRankData.nombre} ya est√° activa o completada.`);
                }
              } else {
                console.warn(
                  `No se encontr√≥ una misi√≥n de desaf√≠o auto-activable para el rival ${nextRankData.desafioRivalId} del rango ${nextRankData.nombre}.`
                );
              }
            } else {
              // console.log(`El siguiente rango ${nextRankData.nombre} no tiene un desafioRivalId definido. Podr√≠a ser un rango sin desaf√≠o.`);
            }
          } else {
            // console.log(`Jugador no tiene suficientes PCS para el siguiente rango ${nextRankData.nombre}. Necesita: ${nextRankData.pcsRequeridos}, Tiene: ${player.secta.puntosContribucion}`);
          }
          updateSectUI(); // Actualizar la UI de la secta por si algo cambi√≥
        }

        function applyRankBenefits(newRankName) {
          const rankData = SECTA_DATA.rangos.find(
            (r) => r.nombre === newRankName
          );
          if (rankData) {
            showModal(
              "Beneficios de Rango",
              `Has obtenido beneficios de ${newRankName}: ${rankData.beneficios}`
            );
          }
          updateUI();
        }

        function enemyTurn() {
        if (!gameState.battle.active || gameState.battle.playerTurn) return;
        
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const playerSprite = document.querySelector('.character-sprite');
        const enemySprite = document.getElementById('enemySprite');
        
        // 1. Procesar estados y DoTs del enemigo
        // (Esta parte no cambia, se mantiene como estaba)
        if (enemy.sealedTurns > 0 || enemy.frozenTurns > 0 || enemy.stunnedTurns > 0) {
            // ... (L√≥gica para saltar turno)
            const statusMessage = enemy.sealedTurns > 0 ? '¬°Sellado!' : (enemy.frozenTurns > 0 ? '¬°Congelado!' : '¬°Aturdido!');
            showFloatingText(enemySprite, statusMessage, 'debuff');
            logBattle(`¬°${enemy.name} est√° ${statusMessage.toLowerCase().replace('¬°','')} y no puede actuar!`);
            
            if(enemy.sealedTurns > 0) enemy.sealedTurns--;
            if(enemy.frozenTurns > 0) enemy.frozenTurns--;
            if(enemy.stunnedTurns > 0) enemy.stunnedTurns--;
            
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
        }

        // 2. Decidir la acci√≥n del enemigo (Habilidad o Ataque B√°sico)
        let chosenAbilityData = null;
        let usedAbility = false;

        if (enemy.abilities && enemy.silencedTurns <= 0) {
            for (const ability of enemy.abilities) {
                if (Math.random() < ability.chance) {
                    chosenAbilityData = enemyAbilityData[ability.abilityId];
                    if (chosenAbilityData) {
                        usedAbility = true;
                        showFloatingText(enemySprite, chosenAbilityData.name, 'ability');
                        break;
                    }
                }
            }
        }

        let damageToDeal = 0;
        let effectsToApply = {};

        if (usedAbility && chosenAbilityData) {
            // Preparar el ataque de la habilidad
            damageToDeal = Math.floor(enemy.attack * (chosenAbilityData.effect.baseDamageMultiplier || 1.0));
            effectsToApply = chosenAbilityData.effect;
        } else {
            // Preparar un ataque b√°sico
            damageToDeal = enemy.attack;
        }

        // 3. Comprobar las defensas del jugador ANTES de aplicar el da√±o
        if (player.intangibleTurns > 0) {
            logBattle(`¬°Eres intangible! El ataque de ${enemy.name} te atraviesa sin causar da√±o.`);
            showFloatingText(playerSprite, 'Intangible', 'ability');
            player.intangibleTurns--;
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
        }
        if (player.dodgeNextAttack) {
            player.dodgeNextAttack = false;
            logBattle(`¬°Esquivas el ataque de ${enemy.name}!`);
            showFloatingText(playerSprite, 'Esquivado', 'ability');
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
        }
        
        // 4. Aplicar el da√±o y los efectos si el ataque no fue anulado
        const finalDamage = Math.max(0, damageToDeal - player.defense);
        
        if (finalDamage > 0) {
            player.hp -= finalDamage;
            showFloatingText(playerSprite, `-${finalDamage}`, 'damage');
        } else {
            showFloatingText(playerSprite, 'Bloqueado', 'ability');
        }

        // Aplicar efectos de la habilidad (veneno, debuffs, etc.)
        if (usedAbility && effectsToApply) {
            if (effectsToApply.poison && !player.isImmuneToStatus) {
                player.poisonedTurns = Math.max(player.poisonedTurns, effectsToApply.poison.duration);
                player.poisonDamage = Math.max(player.poisonDamage, effectsToApply.poison.damagePerTurn);
                showFloatingText(playerSprite, 'Envenenado', 'debuff');
            }
            if (effectsToApply.debuff && !player.isImmuneToStatus) {
                const debuff = effectsToApply.debuff;
                if (debuff.stat === 'defense' && player.defenseReductionTurns === 0) {
                    player.defenseReductionAmount = debuff.amount;
                    player.defense -= debuff.amount;
                    player.defenseReductionTurns = debuff.duration;
                    showFloatingText(playerSprite, 'Defensa ‚Üì', 'debuff');
                }
                // ... (a√±adir otros debuffs aqu√≠)
            }
            if (effectsToApply.lifesteal) {
                const healAmount = Math.floor(finalDamage * effectsToApply.lifesteal);
                enemy.hp = Math.min(enemy.maxHp, enemy.hp + healAmount);
                showFloatingText(enemySprite, `+${healAmount}`, 'heal');
            }
            logBattle(chosenAbilityData.logMessage(enemy.name, finalDamage, effectsToApply.poison?.damagePerTurn || effectsToApply.debuff?.amount, effectsToApply.poison?.duration || effectsToApply.debuff?.duration));
        } else {
            // Log para el ataque b√°sico
            if (finalDamage > 0) {
                logBattle(`${enemy.name} te ataca y te causa ${finalDamage} de da√±o.`);
            } else {
                logBattle(`${enemy.name} te ataca pero tu defensa absorbe todo el impacto.`);
            }
        }
        
        // 5. Comprobar si el jugador fue derrotado
        if (player.hp <= 0) {
            player.hp = 0;
            // ... (l√≥gica de salvaci√≥n por habilidades y derrota no cambia) ...
            let hasBeenSaved = false;
            if (player.canRevive) { // Simplificado para el ejemplo
                 player.hp = Math.floor(player.maxHp * 0.5);
                 player.canRevive = false;
                 logBattle("¬°La Llama del F√©nix te devuelve a la vida!");
                 showFloatingText(playerSprite, '¬°Revivido!', 'heal');
                 hasBeenSaved = true;
            }
            
            if (!hasBeenSaved) {
                
               logBattle("¬°Has sido derrotado!");
                const expLoss = Math.floor(gameState.player.exp * 0.1);
                setTimeout(() => {
                    gameState.player.hp = Math.floor(gameState.player.maxHp * 0.1);
                    gameState.player.mana = Math.floor(gameState.player.maxMana * 0.1);
                    gameState.player.exp = Math.max(0, gameState.player.exp - expLoss);
                    const safeCoords = findSafeRespawnLocation(G_SAFE_RESPAWN_X, G_SAFE_RESPAWN_Y);
                    gameState.player.x = safeCoords.x;
                    gameState.player.y = safeCoords.y;
                    updatePlayerPosition("player_defeat_respawn");
                    endBattle(false);
                    showModal("Derrota", `Regresas a un lugar seguro, mermado. Pierdes ${expLoss} EXP.`);
                }, 2000);
                return; // Fin de la funci√≥n si el jugador es derrotado
                return;
            }
        }

        // 6. Finalizar el turno
        gameState.battle.playerTurn = true;
        populateBattleActionButtons();
        updateBattleUI();
        updateUI();
      }

          function showBattleReview() {
              const reviewLog = document.getElementById("battleReviewLog");
              reviewLog.innerHTML = ""; // Limpiar contenido anterior

              // Unimos todos los mensajes del historial con un salto de l√≠nea
              const formattedLog = battleLogHistory.join("<br>");
              reviewLog.innerHTML = formattedLog;

              document.getElementById("battleReviewModal").style.display = "flex";
          }

      function closeBattleReviewModal() {
          document.getElementById("battleReviewModal").style.display = "none";
      }

        function endBattle(victory) {
          const player = gameState.player;
          gameState.battle.active = false;
          document.getElementById("battleScreen").style.display = "none";
          document.getElementById("battleLog").innerHTML = "";
          // Ocultar las barras sobre el sprite en batalla expl√≠citamente al finalizar
          const barsInBattleContainer = document.getElementById(
            "playerInBattleSpriteBarsContainer"
          );
          if (barsInBattleContainer) {
            barsInBattleContainer.style.display = "none";
          }
          if (victory && gameState.battle.enemy?.entityRef) {
            removeEntity(gameState.battle.enemy.entityRef);
          }
          gameState.battle.enemy = null;

          // Restaurar sprite a idle despu√©s de la batalla
          player.currentDirection = "down"; // O la √∫ltima direcci√≥n antes de la batalla
          player.currentFrame = 0;
          player.isMoving = false; // Asegurarse de que no est√© en estado de movimiento
          updatePlayerSpriteVisual();

          recalculatePlayerStats();
          updateUI();
          updateTopNavVisibility();
          showTouchControls();
          updatePlayerBarsOnMap();
        }

     
      function findEscapeTile(player, enemy) {
        const playerX = player.x;
        const playerY = player.y;
        
        // Calcular la direcci√≥n opuesta al enemigo
        const dx = playerX - enemy.x;
        const dy = playerY - enemy.y;

        // Normalizar la direcci√≥n para obtener un vector unitario (aproximado)
        let escapeX = playerX + Math.sign(dx);
        let escapeY = playerY + Math.sign(dy);

        const checkTile = (x, y) => {
            if (x < 0 || x >= gameState.map.width || y < 0 || y >= gameState.map.height) return false;
            const terrain = G_TERRAIN_TYPES[getTerrainTypeAt(x, y)];
            if (terrain && terrain.walkable === false) return false;
            const isOccupied = gameState.map.entities.some(e => e.x === x && e.y === y);
            return !isOccupied;
        };

        // 1. Intentar moverse a la casilla directamente opuesta
        if (checkTile(escapeX, escapeY)) {
            return { x: escapeX, y: escapeY };
        }

        // 2. Si no es posible, buscar en las 8 casillas adyacentes una que est√© vac√≠a
        const possibleMoves = [
            { x: playerX, y: playerY - 1 }, { x: playerX, y: playerY + 1 }, // Arriba, Abajo
            { x: playerX - 1, y: playerY }, { x: playerX + 1, y: playerY }, // Izquierda, Derecha
            { x: playerX - 1, y: playerY - 1 }, { x: playerX + 1, y: playerY - 1 }, // Diagonales
            { x: playerX - 1, y: playerY + 1 }, { x: playerX + 1, y: playerY + 1 },
        ];

        for (const move of possibleMoves) {
            if (checkTile(move.x, move.y)) {
                return move;
            }
        }
        
        return null; // No se encontr√≥ ninguna casilla segura para huir
      }

        function findSafeRespawnLocation(preferredX, preferredY) {
          const isHostile = (entity) =>
            G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss;
          let preferredSpotOccupiedByHostile = gameState.map.entities.some(
            (e) => e.x === preferredX && e.y === preferredY && isHostile(e)
          );
          if (!preferredSpotOccupiedByHostile)
            return { x: preferredX, y: preferredY };
          for (let r = 1; r <= G_SAFE_RESPAWN_SEARCH_RADIUS; r++) {
            for (let dy = -r; dy <= r; dy++) {
              for (let dx = -r; dx <= r; dx++) {
                if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
                const cx = preferredX + dx;
                const cy = preferredY + dy;
                if (
                  cx < 0 ||
                  cx >= gameState.map.width ||
                  cy < 0 ||
                  cy >= gameState.map.height
                )
                  continue;
                const isCompletelyEmpty = !gameState.map.entities.some(
                  (e) => e.x === cx && e.y === cy
                );
                if (isCompletelyEmpty) return { x: cx, y: cy };
              }
            }
          }
          return { x: preferredX, y: preferredY };
        }

        function logBattle(message) {
          battleLogHistory.push(message);
      }

        function showTechniquePanel() {
          const container = document.getElementById("learnedTechniquesContainer");
          container.innerHTML = "";
          const player = gameState.player;
          if (Object.keys(player.learnedTechniques).length === 0) {
            container.innerHTML = "<p>A√∫n no has aprendido ninguna t√©cnica.</p>";
          }
          for (const techId in player.learnedTechniques) {
            const techInfo = techniqueData[techId];
            const playerTech = player.learnedTechniques[techId];
            if (!techInfo) continue;
            const div = document.createElement("div");
            div.className = "technique-item";
            let levelText =
              playerTech.level >= techInfo.maxLevel
                ? `Nivel: ${playerTech.level} (MAX)`
                : `Nivel: ${playerTech.level} / ${techInfo.maxLevel}`;
            let description = techInfo.description;
            // Podr√≠as a√±adir l√≥gica aqu√≠ para mostrar el efecto actual basado en el nivel
            // Ejemplo: if (techInfo.effect.baseDamageMultiplier) description += ` (Da√±o actual: ${...})`;
            div.innerHTML = `<strong>${techInfo.name} ${
              techInfo.icon || ""
            }</strong> (${levelText})<br><small>${description}</small><br>`;
            if (
              techInfo.cultivationSettings &&
              playerTech.level < techInfo.maxLevel
            ) {
              const progress = playerTech.currentCultivationProgress || 0;
              const timeToNext =
                playerTech.cultivationTimeToNextLevel ||
                (techInfo.cultivationSettings
                  ? techInfo.cultivationSettings.baseTimeToLevelUp
                  : Infinity);
              div.innerHTML += `<small>Progreso Cultivo: ${Math.floor(
                progress
              )}s / ${timeToNext}s para Nv. ${playerTech.level + 1}</small><br>`;
            }
            container.appendChild(div);
          }
          document.getElementById("techniqueModal").style.display = "flex";
          hideTouchControls();
        }

        function startTechniqueRefinement(techId) {}

        function stopTechniqueRefinement() {}

        function applyTechniqueEffect(techId, newLevel) {
          const techInfo = techniqueData[techId];
          const player = gameState.player;
          if (!techInfo) return;
          
          const effect = techInfo.effect;
          switch (techInfo.type) {
              case "passive_cultivation":
                  if (player.hasOwnProperty(effect.statToBoost)) {
                      // Asumimos que el efecto es por nivel, as√≠ que solo a√±adimos el valor del nuevo nivel
                      player[effect.statToBoost] += effect.value;
                  }
                  break;
              case "passive_stat":
                    if (effect.statToBoost === "passiveHpRegen") {
                        player.passiveHpRegen = (player.passiveHpRegen || 0) + effect.value;
                    } else if (effect.statToBoost === "statusImmunity" && effect.value === true) {
                        player.isImmuneToStatus = true;
                    } else if (effect.statToBoost === "deathSaveChance") {
                        player.deathSaveChance = (player.deathSaveChance || 0) + effect.value;
                    } else if (player.hasOwnProperty(effect.statToBoost)) {
                        player[effect.statToBoost] += effect.value;
                    }
              case "active_ability":
                  // Cuando una habilidad activa sube de nivel, solo necesitamos refrescar los stats
                  // por si acaso, y la UI de batalla se actualizar√° la pr√≥xima vez que empiece un combate.
                  recalculatePlayerStats(); 
                  break;
              case "active_refinement_effect":
                  if (techId === "qi_to_hp_conversion_1") {
                      if (newLevel >= 1) {
                          player.canUseQiConversion = true;
                          // ---- LA CORRECCI√ìN EST√Å AQU√ç ----
                          // La siguiente l√≠nea causaba el error y ha sido eliminada:
                          // updateToggleQiConversionButtonVisibility(); 
                          
                          // En su lugar, la visibilidad del bot√≥n se maneja correctamente
                          // por la funci√≥n renderQuickSlotBar(), que se llama cuando
                          // se actualiza la UI general.
                      }
                  }
                  break;
                  recalculatePlayerStats(); 
        updateUI();
          }
          // No es necesario llamar a updateUI() aqu√≠, ya que se llamar√° despu√©s
          // de que el cultivo se detenga o en el siguiente tick.
      }

        function closeTechniqueModal() {
          document.getElementById("techniqueModal").style.display = "none";
          updatePlayerBarsOnMap();
          showTouchControls();
        }

        let currentShopPage = 1;
        const shopItemsPerPage = 6;

        function openShop() {
          document.getElementById(
            "playerSpiritualStones"
          ).textContent = `Piedras Espirituales: ${
            gameState.inventory["Piedras Espirituales"] || 0
          }`;
          document.getElementById("shopModal").style.display = "flex";
          renderShopProducts();
          hideTouchControls();
        }

        function renderShopProducts() {
          const shopProductsEl = document.getElementById("shopProducts");
          shopProductsEl.innerHTML = "";
          const activeCategory =
            document.querySelector("#shopCategories .active")?.dataset.category ||
            "all";
          const searchTerm = document
            .getElementById("shopSearch")
            .value.toLowerCase();
          const priceVal = parseInt(document.getElementById("priceRange").value);
          document.getElementById(
            "priceRangeValue"
          ).textContent = `${priceVal} PS`;

          let filteredItems = shopData.inventory.filter((item) => {
            const itemNameLower = item.itemName.toLowerCase();
            const itemCategory = item.category || "other";
            const itemTypeForFilter =
              item.type ||
              (itemNameLower.includes("rollo:") ? "scroll" : "other");

            if (
              searchTerm &&
              !itemNameLower.includes(searchTerm) &&
              !(
                item.description &&
                item.description.toLowerCase().includes(searchTerm)
              )
            )
              return false;
            if (item.price > priceVal) return false;

            if (activeCategory !== "all") {
              if (activeCategory === "combat" && !techIsCombat(item.itemName))
                return false;
              if (
                activeCategory === "cultivation" &&
                !techIsCultivation(item.itemName)
              )
                return false;
              if (
                activeCategory === "scroll" &&
                !itemNameLower.startsWith("rollo: ")
              )
                return false;
              if (
                activeCategory === "consumable" &&
                itemTypeForFilter !== "consumable" &&
                ![
                  "Hierbas Medicinales",
                  "Cristales de Qi",
                  "P√≠ldora de Recuperaci√≥n Menor",
                ].includes(item.itemName)
              )
                return false;
              if (activeCategory === "weapon" && itemCategory !== "weapon")
                return false;
              if (activeCategory === "armor" && itemCategory !== "armor")
                return false;
              if (activeCategory === "material" && !isMaterial(item.itemName))
                return false;
            }
            return true;
          });

          const totalPages = Math.ceil(filteredItems.length / shopItemsPerPage);
          const startIndex = (currentShopPage - 1) * shopItemsPerPage;
          const pageItems = filteredItems.slice(
            startIndex,
            startIndex + shopItemsPerPage
          );

          pageItems.forEach((item) => {
            const itemInfo = itemData[item.itemName] || {};
            const productCard = document.createElement("div");
            productCard.className = "product-card";
            let itemIcon = getItemIcon(item.itemName, item.category);
            let itemType = getItemShopType(
              item.itemName,
              item.category,
              item.type
            );

            productCard.innerHTML = `
                  <div class="product-header">
                      <div>
                          <div class="product-name">${itemIcon} ${
              item.itemName
            }</div>
                          <span class="product-type">${itemType}</span>
                      </div>
                      <div class="product-price">${item.price} PS</div>
                  </div>
                  <div class="product-description">${
                    itemInfo.description ||
                    item.description ||
                    "Un objeto misterioso."
                  }</div>
                  ${
                    item.levelRequirement
                      ? `<div><strong>Req:</strong> Nv ${item.levelRequirement}</div>`
                      : ""
                  }
                  ${
                    typeof item.stock === "number"
                      ? `<div><strong>Disp:</strong> ${item.stock}</div>`
                      : ""
                  }
                  <div class="product-actions">
                      <button class="buy-btn" data-item="${
                        item.itemName
                      }" data-price="${item.price}">Comprar</button>
                  </div>`;
            const buyBtn = productCard.querySelector(".buy-btn");
            if (
              (gameState.inventory["Piedras Espirituales"] || 0) < item.price ||
              item.stock === 0
            ) {
              buyBtn.disabled = true;
              buyBtn.title =
                item.stock === 0 ? "Agotado" : "Piedras insuficientes";
            }
            buyBtn.addEventListener("click", () => buyFromShop(item.itemName));
            shopProductsEl.appendChild(productCard);
          });
          renderShopPagination(totalPages);
        }

        function techIsCombat(itemName) {
          if (!itemName.startsWith("Rollo: ")) return false;
          const techName = itemName.substring(7);
          const techId = Object.keys(techniqueData).find(
            (id) => techniqueData[id].name === techName
          );
          return (
            techId &&
            (techniqueData[techId].type === "active_ability" ||
              techniqueData[techId].abilityId)
          );
        }
        
        function techIsCultivation(itemName) {
          if (!itemName.startsWith("Rollo: ")) return false;
          const techName = itemName.substring(7);
          const techId = Object.keys(techniqueData).find(
            (id) => techniqueData[id].name === techName
          );
          return (
            techId &&
            (techniqueData[techId].type === "passive_cultivation" ||
              techniqueData[techId].type === "passive_stat" ||
              techniqueData[techId].type === "active_refinement_effect")
          );
        }
        
        function isMaterial(itemName) {
          const knownMaterials = [
            "Cristal de Hielo",
            "Esencia de Fuego",
            "N√∫cleo de Tormenta",
            "Venenos Mortales",
            "Fragmentos de Jade",
            "Esencia Oscura",
            "Almas Condenadas",
            "N√∫cleo de V√≥rtice",
            "Roc√≠o Celestial",
            "Cristales Ps√≠quicos",
            "Mineral de Hierro Espiritual",
            "Plumas de F√©nix",
            "Semillas Ancestrales",
            "Escamas de Drag√≥n",
            "Espejos Astrales",
            "Relojes de Arena",
            "Sangre de Demonio",
            "L√°grimas de Unicornio",
            "N√∫cleo Elemental",
            "Polvo de Arcano",
            "Piedras Espirituales",
            "Cristales de Qi",
            "Hierbas Medicinales",
          ];
          return knownMaterials.includes(itemName);
        }

        function getItemIcon(itemName, category) {
          if (itemName.includes("Espada") || category === "weapon") return "‚öîÔ∏è";
          if (itemName.includes("Armadura") || category === "armor") return "üõ°Ô∏è";
          if (itemName.includes("Hierba")) return "üåø";
          if (itemName.includes("Cristal")) return "üíé";
          if (itemName.includes("Piedra")) return "üíé";
          if (itemName.startsWith("Rollo:")) return "üìú";
          return "üì¶";
        }

        function getItemShopType(itemName, category, type) {
          if (itemName.startsWith("Rollo: ")) return "T√©cnica";
          if (category === "weapon") return "Arma";
          if (category === "armor") return "Armadura";
          if (
            type === "consumable" ||
            [
              "Hierbas Medicinales",
              "Cristales de Qi",
              "P√≠ldora de Recuperaci√≥n Menor",
            ].includes(itemName)
          )
            return "Consumible";
          if (isMaterial(itemName)) return "Material";
          return "Objeto";
        }

        function renderShopPagination(totalPages) {
          const pagination = document.getElementById("shopPagination");
          pagination.innerHTML = "";
          if (totalPages <= 1) return;
          const prevBtn = document.createElement("button");
          prevBtn.className = "page-btn";
          prevBtn.textContent = "¬´";
          prevBtn.addEventListener("click", () => {
            if (currentShopPage > 1) {
              currentShopPage--;
              renderShopProducts();
            }
          });
          pagination.appendChild(prevBtn);
          const startPage = Math.max(1, currentShopPage - 1);
          const endPage = Math.min(totalPages, currentShopPage + 1);
          for (let i = startPage; i <= endPage; i++) {
            const pageBtn = document.createElement("button");
            pageBtn.className = `page-btn ${
              i === currentShopPage ? "active" : ""
            }`;
            pageBtn.textContent = i;
            pageBtn.addEventListener("click", () => {
              currentShopPage = i;
              renderShopProducts();
            });
            pagination.appendChild(pageBtn);
          }
          const nextBtn = document.createElement("button");
          nextBtn.className = "page-btn";
          nextBtn.textContent = "¬ª";
          nextBtn.addEventListener("click", () => {
            if (currentShopPage < totalPages) {
              currentShopPage++;
              renderShopProducts();
            }
          });
          pagination.appendChild(nextBtn);
        }

        function closeShopModal() {
          document.getElementById("shopModal").style.display = "none";
          updatePlayerBarsOnMap();
          showTouchControls();
        }

        function buyFromShop(itemName) {
          const itemToBuy = shopData.inventory.find(
            (i) => i.itemName === itemName
          );
          const playerStones = gameState.inventory["Piedras Espirituales"] || 0;
          if (
            !itemToBuy ||
            itemToBuy.stock === 0 ||
            playerStones < itemToBuy.price
          ) {
            showModal(
              "Error Compra",
              "No se puede comprar (fondos insuficientes, agotado o no existe)."
            );
            return;
          }
          gameState.inventory["Piedras Espirituales"] -= itemToBuy.price;
          if (itemToBuy.type === "equipment" && itemToBuy.attackBonus) {
            gameState.player.baseAttack += itemToBuy.attackBonus;
            recalculatePlayerStats();
            showModal(
              "¬°Equipo Comprado!",
              `Compraste ${itemName}. Ataque base +${itemToBuy.attackBonus}.`
            );
          } else {
            gameState.inventory[itemName] =
              (gameState.inventory[itemName] || 0) + 1;
            if (
              itemData[itemName] &&
              itemData[itemName].effect &&
              itemName.startsWith("Rollo: ")
            ) {
              showModal(
                "¬°Rollo Comprado!",
                `Has comprado ${itemName}. √ösalo desde tu inventario para aprender la t√©cnica.`
              );
            } else {
              showModal("¬°Objeto Comprado!", `Has comprado ${itemName}.`);
            }
          }
          if (typeof itemToBuy.stock === "number" && itemToBuy.stock > 0)
            itemToBuy.stock--;
          openShop();
          updateUI();
        }

        function sellToShop(itemName, quantityToSell, totalStonesEarned) {}

        function saveGame() {
          try {
            const gameStateToSave = JSON.parse(JSON.stringify(gameState));
            const gameDataJson = JSON.stringify(gameStateToSave, null, 2);
            const blob = new Blob([gameDataJson], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "camino_del_cultivador_save.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showModal("Partida Guardada", "Progreso guardado como archivo JSON.");
          } catch (error) {
            showModal("Error al Guardar", `Hubo un problema: ${error.message}`);
          }
        }
        function triggerFileUpload() {
          document.getElementById("fileInput").click();
        }

        // --- CARGA DE PARTIDA ---

      function loadGameFromFile(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function(e) {
              try {
                  // Detener procesos activos antes de cargar
                  if (gameState.player.isCultivating) stopCultivation();
                  if (gameState.battle.active) endBattle(false);

                  const loadedGameState = JSON.parse(e.target.result);

                  if (!loadedGameState.player || !loadedGameState.map || !loadedGameState.inventory) {
                      throw new Error("Formato de guardado incorrecto o datos esenciales faltantes.");
                  }

                  // Copia profunda y segura de los datos principales
                  gameState.player = JSON.parse(JSON.stringify(loadedGameState.player));
                  gameState.inventory = JSON.parse(JSON.stringify(loadedGameState.inventory));
                  gameState.map.entities = loadedGameState.map.entities ? JSON.parse(JSON.stringify(loadedGameState.map.entities)) : [];

                  // --- INICIO DE LA REPARACI√ìN DE MISIONES ACTIVAS ---
                  // Esta rutina asegura que las misiones cargadas de una partida antigua
                  // tengan la informaci√≥n de objetivo m√°s reciente del c√≥digo del juego.
                  if (gameState.player.secta && gameState.player.secta.misionesActivas) {
                      console.log("Ejecutando rutina de reparaci√≥n de misiones en partida guardada...");
                      gameState.player.secta.misionesActivas.forEach(misionActiva => {
                          const masterMisionData = MISIONES_DATA[misionActiva.id];
                          if (masterMisionData && masterMisionData.objetivo) {
                              // Si el objetivo original guardado no existe, o si no tiene la propiedad npcEntrega
                              // mientras que la definici√≥n maestra s√≠ la tiene, lo reparamos.
                              // La forma m√°s segura es simplemente volver a clonar el objeto de objetivo maestro.
                              if (!misionActiva.objetivoOriginal || misionActiva.objetivoOriginal.npcEntrega !== masterMisionData.objetivo.npcEntrega) {
                                  console.log(`Reparando objetivo de la misi√≥n activa '${misionActiva.id}'. Se a√±adir√°/actualizar√° la informaci√≥n del objetivo.`);
                                  misionActiva.objetivoOriginal = JSON.parse(JSON.stringify(masterMisionData.objetivo));
                              }
                          }
                      });
                  }
                  // --- FIN DE LA REPARACI√ìN DE MISIONES ---

                  // --- INICIO DE LA REPARACI√ìN DE T√âCNICAS (ya la ten√≠as) ---
                  if (gameState.player.learnedTechniques) {
                      console.log("Ejecutando rutina de reparaci√≥n de t√©cnicas en partida guardada...");
                      for (const techId in gameState.player.learnedTechniques) {
                          const playerTech = gameState.player.learnedTechniques[techId];
                          const techDef = techniqueData[techId]; 

                          if (playerTech && techDef && techDef.cultivationSettings) {
                              if (playerTech.level < techDef.maxLevel) {
                                  const expectedTime = Math.floor(
                                      techDef.cultivationSettings.baseTimeToLevelUp *
                                      Math.pow(techDef.cultivationSettings.levelTimeMultiplier, playerTech.level)
                                  );
                                  if (playerTech.cultivationTimeToNextLevel !== expectedTime) {
                                      console.log(`Corrigiendo 'cultivationTimeToNextLevel' para la t√©cnica '${techDef.name}' (Nivel ${playerTech.level}). Valor antiguo: ${playerTech.cultivationTimeToNextLevel}, Nuevo valor: ${expectedTime}`);
                                      playerTech.cultivationTimeToNextLevel = expectedTime;
                                  }
                              } else {
                                  if (playerTech.cultivationTimeToNextLevel !== Infinity) {
                                      playerTech.cultivationTimeToNextLevel = Infinity;
                                  }
                              }
                          }
                      }
                  }
                  // --- FIN DE LA REPARACI√ìN DE T√âCNICAS ---

                  // Resetear estados transitorios que no deben guardarse
                  gameState.player.isCultivating = false;
                  if (gameState.cultivationInterval) {
                      clearInterval(gameState.cultivationInterval);
                      gameState.cultivationInterval = null;
                  }
                  
                  // Reconstruir y refrescar el juego
                  generateMap(true);
                  recalculatePlayerStats();
                  renderQuickSlotBar();
                  updatePlayerPosition("loadGameFromFile_end");
                  
                  showModal("Partida Cargada", "¬°Partida restaurada con √©xito! (Se aplicaron correcciones de compatibilidad)");

              } catch (error) {
                  showModal("Error al Cargar", `Hubo un problema: ${error.message}`);
                  console.error("Error loading game:", error);
              } finally {
                  event.target.value = null;
              }
          };
          reader.onerror = () => {
              showModal("Error de Lectura", "No se pudo leer el archivo de guardado.");
              event.target.value = null;
          };
          reader.readAsText(file);
      }
        
      function renderQuickSlotBar() {
          const bar = document.getElementById("quickSlotBar");
          if (!bar) return;
          bar.innerHTML = ""; // Limpiar la barra

          // Renderizar los 5 slots de √≠tems (sin cambios aqu√≠)
          gameState.player.quickSlots.forEach((itemName, index) => {
              const slot = document.createElement("div");
              slot.className = "quick-slot";
              
              const keyHint = document.createElement("span");
              keyHint.className = "slot-key-hint";
              keyHint.textContent = index + 1;
              slot.appendChild(keyHint);

              if (itemName && itemData[itemName]) {
                  const itemCount = gameState.inventory[itemName] || 0;
                  slot.innerHTML += getItemIcon(itemName);
                  const countDisplay = document.createElement("span");
                  countDisplay.className = "slot-item-count";
                  countDisplay.textContent = itemCount;
                  slot.appendChild(countDisplay);

                  if (itemCount === 0) {
                      slot.style.opacity = 0.5;
                      slot.title = `${itemName} (Agotado)`;
                  } else {
                      slot.title = `Usar ${itemName} (x${itemCount})`;
                      slot.onclick = () => useQuickSlotItem(index);
                  }
              } else {
                  slot.classList.add("empty");
                  slot.title = "Haz clic para asignar un objeto";
                  slot.onclick = () => openItemAssignmentModal(index);
              }
              bar.appendChild(slot);
          });

          // Renderizar el bot√≥n de Cultivar (sin cambios aqu√≠)
          const cultivateSlot = document.createElement("div");
          cultivateSlot.className = "quick-slot cultivate-slot";
          cultivateSlot.title = "Cultivar (üßò)";
          cultivateSlot.innerHTML = 'üßò';
          cultivateSlot.onclick = () => toggleCultivation();
          if (gameState.player.isCultivating) {
              cultivateSlot.classList.add('active-cultivation');
              cultivateSlot.title = "Ver/Detener Cultivo";
          }
          bar.appendChild(cultivateSlot);

          // === INICIO DE LA NUEVA L√ìGICA PARA EL BOT√ìN DE CONVERSI√ìN ===
          // Solo mostramos el bot√≥n si el jugador puede usar la conversi√≥n de Qi
          if (gameState.player.canUseQiConversion) {
              const conversionSlot = document.createElement("div");
              conversionSlot.className = "quick-slot conversion-slot";
              
              conversionSlot.innerHTML = '‚òØÔ∏è';
              conversionSlot.onclick = () => toggleQiConversion();

              // La apariencia "activa" ahora depende de si el modo de cultivo es de conversi√≥n.
              if (gameState.player.isCultivating && gameState.player.cultivationMode.isConversionCultivation) {
                  conversionSlot.classList.add('active-conversion');
                  conversionSlot.title = "Conversi√≥n de Man√° a Vida ACTIVA (clic para detener)";
              } else {
                  conversionSlot.title = "Iniciar Conversi√≥n de Man√° a Vida";
              }

              bar.appendChild(conversionSlot);
          }
          // === FIN DE LA NUEVA L√ìGICA ===
      }

      function useQuickSlotItem(slotIndex) {
          const itemName = gameState.player.quickSlots[slotIndex];
          if (!itemName) {
              console.log(`Slot ${slotIndex + 1} est√° vac√≠o.`);
              // Si el slot est√° vac√≠o, podr√≠amos abrir el modal de asignaci√≥n. ¬°Es una buena mejora!
              openItemAssignmentModal(slotIndex);
              return;
          }

          const item = itemData[itemName];
          const itemCount = gameState.inventory[itemName] || 0;

          if (itemCount <= 0) {
              showModal("Agotado", `No te quedan m√°s ${itemName}.`);
              // Si el inventario dice 0 pero el slot a√∫n tiene el √≠tem, lo limpiamos por seguridad.
              gameState.player.quickSlots[slotIndex] = null;
              renderQuickSlotBar(); // Actualizar la UI
              return;
          }

          if (item && item.canUse && !item.canUse(gameState.player)) {
              showModal("No se puede usar", `No puedes usar ${itemName} ahora.`);
              return;
          }

          // Usar el objeto
          const message = (item.effect) ? item.effect(gameState.player, gainExperience) : `No se puede usar ${itemName}.`;
          
          if (message && !message.toLowerCase().includes("error") && !message.toLowerCase().includes("al m√°ximo")) {
              gameState.inventory[itemName]--;
              showModal("Objeto Usado", message);
              updateUI(); 

              // === INICIO DE LA CORRECCI√ìN CLAVE ===
              // Despu√©s de usar el √≠tem, verificamos si se agot√≥.
              const newCount = gameState.inventory[itemName] || 0;
              if (newCount <= 0) {
                  // Si la cantidad es 0, vaciamos el slot.
                  gameState.player.quickSlots[slotIndex] = null;
                  console.log(`√çtem ${itemName} agotado. Vaciando slot ${slotIndex + 1}.`);
              }
              // === FIN DE LA CORRECCI√ìN CLAVE ===

              renderQuickSlotBar(); // Vuelve a renderizar la barra para actualizar la cantidad o mostrar el slot vac√≠o.
          } else {
              showModal("Acci√≥n no posible", message);
          }
      }
        function showHelp() {
          showModal(
            "Ayuda - Camino del Cultivador",
            "Explora y convi√©rtete en un cultivador poderoso.\n\n" +
              'üßò Cultiva (Bot√≥n "Cultivar") para mejorar HP/Man√°/EXP y tus T√©cnicas.\n' +
              "üìñ Aprende y Refina T√©cnicas para obtener nuevas habilidades y mejoras pasivas.\n" +
              "‚¨ÜÔ∏è Sube de Nivel para aumentar tus estad√≠sticas base.\n" + // Actualizado
              "üëπ Combate demonios y rivales.\n" +
              "üíé Recolecta recursos y tesoros.\n" +
              "üìú Busca o compra rollos de t√©cnicas para volverte m√°s fuerte\n\n" + // Eliminada menci√≥n al √°rbol de habilidades
              "Controles (Teclado):\n" +
              "  WASD/Flechas: Moverse\n" +
              "  ESPACIO: Interactuar\n\n" +
              "Controles (T√°ctil):\n" +
              "  Joystick: Moverse\n" +
              '  Bot√≥n "Acci√≥n": Interactuar'
          );
        }
        //ACTUALIZAR BARRAS DEL JUGADOR
        function updatePlayerBarsOnMap() {
          const player = gameState.player;
          const barsContainer = document.getElementById(
            "playerOnMapBarsContainer"
          );
          const hpFill = document.getElementById("playerOnMapHpFill");
          const manaFill = document.getElementById("playerOnMapManaFill");
          const playerElement = document.getElementById("player"); // El sprite del jugador

          if (!barsContainer || !hpFill || !manaFill || !playerElement) {
            // console.warn("Elementos de barras sobre el jugador no encontrados en el DOM.");
            return;
          }

          // Ocultar barras si el jugador est√° en batalla o si alg√∫n modal principal est√° abierto.
          if (gameState.battle.active || isAnyModalOpen()) {
            barsContainer.style.display = "none";
            return;
          }
          barsContainer.style.display = "flex";

          // La posici√≥n del playerElement (sprite) ya est√° calculada y centrada en updatePlayerPosition.
          // Usamos su 'top' y 'left' (que son relativos al map-container) como referencia.
          const playerVisualTop = parseFloat(playerElement.style.top) || 0;
          const playerVisualLeft = parseFloat(playerElement.style.left) || 0;
          const playerVisualWidth = playerElement.offsetWidth;

          // Posicionar las barras ligeramente encima del sprite del jugador.
          const barHeightWithGap = barsContainer.offsetHeight || 13; // Alto total aprox. de las 2 barras + gap
          barsContainer.style.top = `${playerVisualTop - barHeightWithGap - 5}px`; // 5px de espacio sobre el sprite

          // Centrar horizontalmente con el sprite del jugador.
          // El 'transform: translateX(-50%)' en el CSS ayuda con esto si 'left' es el centro.
          barsContainer.style.left = `${
            playerVisualLeft + playerVisualWidth / 2
          }px`;

          // Actualizar el relleno de las barras.
          const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
          const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

          hpFill.style.width = `${hpPercent}%`;
          manaFill.style.width = `${manaPercent}%`;
        }

        function updatePlayerBarsInBattle() {
          const player = gameState.player;
          const barsContainer = document.getElementById(
            "playerInBattleSpriteBarsContainer"
          );
          const hpFill = document.getElementById("playerInBattleSpriteHpFill");
          const manaFill = document.getElementById(
            "playerInBattleSpriteManaFill"
          );
          const playerSpriteInBattle = document.querySelector(
            ".battle-area .character .character-sprite"
          );

          if (!barsContainer || !hpFill || !manaFill || !playerSpriteInBattle) {
            // console.warn("Elementos de barras sobre el sprite del jugador en batalla no encontrados.");
            if (barsContainer) barsContainer.style.display = "none"; // Ocultar si faltan elementos
            return;
          }

          // Solo mostrar si la pantalla de batalla est√° activa
          if (
            !gameState.battle.active ||
            document.getElementById("battleScreen").style.display !== "flex"
          ) {
            barsContainer.style.display = "none";
            return;
          }
          barsContainer.style.display = "flex";

          // Posicionar las barras ligeramente encima del sprite del jugador en batalla.
          // El sprite (.character-sprite) es un div, necesitamos su offsetTop y offsetLeft
          // relativo a su padre (.character) que ahora es 'position: relative'.

          const spriteTop = playerSpriteInBattle.offsetTop; // Distancia desde el borde superior del .character
          const spriteLeft = playerSpriteInBattle.offsetLeft; // Distancia desde el borde izquierdo del .character
          const spriteWidth = playerSpriteInBattle.offsetWidth;

          const barHeightWithGap = barsContainer.offsetHeight || 12; // Alto total aprox. de las 2 barras + gap

          // El 'top' de las barras ser√° el 'top' del sprite menos la altura de las barras y un peque√±o margen.
          barsContainer.style.top = `${spriteTop - barHeightWithGap - 3}px`; // 3px de espacio sobre el sprite

          // Centrar horizontalmente con el sprite del jugador.
          // 'left' ser√° el 'left' del sprite m√°s la mitad del ancho del sprite.
          // El 'transform: translateX(-50%)' en CSS centra el contenedor de barras.
          barsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

          // Actualizar el relleno de las barras.
          const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
          const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

          hpFill.style.width = `${hpPercent}%`;
          manaFill.style.width = `${manaPercent}%`;
        }

        const joystickContainer = document.getElementById("joystick-container");
        const joystickPad = document.getElementById("joystick-pad");
        const joystickHandle = document.getElementById("joystick-handle");
        const actionButtonTouch = document.getElementById("action-button-touch");
        let joystickActive = false;
        let joystickCurrentDx = 0; // Guardar la direcci√≥n actual del joystick
        let joystickCurrentDy = 0;

        const JOYSTICK_THRESHOLD = 15;
        const JOYSTICK_GAME_MOVE_INTERVAL = 300;
        let joystickGameMoveTimerId = null;
        let lastJoystickMoveTime = 0;
        let joystickLoopId = null;
        let joystickTouchIdentifier = null; // <!-- CAMBIO JOYSTICK: Para seguir el dedo correcto -->

        function initJoystick() {
          if (
            !joystickContainer ||
            !joystickPad ||
            !joystickHandle ||
            !actionButtonTouch
          ) {
            console.error(
              "Error inicializando joystick: Elementos no encontrados."
            );
            return;
          }
          resetJoystickHandle();

          joystickPad.addEventListener(
            "touchstart",
            (event) => {
              if (
                gameState.player.isCultivating ||
                gameState.battle.active ||
                joystickActive
              )
                return;
              const touch = event.changedTouches[0];
              if (!touch) return;
              const padRect = joystickPad.getBoundingClientRect();
              if (
                touch.clientX < padRect.left ||
                touch.clientX > padRect.right ||
                touch.clientY < padRect.top ||
                touch.clientY > padRect.bottom
              ) {
                return;
              }
              event.preventDefault();
              joystickActive = true;
              joystickTouchIdentifier = touch.identifier;
              document.addEventListener("touchmove", handleJoystickMove, {
                passive: false,
              });
              document.addEventListener("touchend", handleJoystickEnd, {
                passive: false,
              });
              document.addEventListener("touchcancel", handleJoystickEnd, {
                passive: false,
              });

              // No iniciar el gameMoveTimer aqu√≠, la animaci√≥n la maneja handlePlayerMovementInput
              // updateJoystickHandlePosition y determinar direcci√≥n inicial
              updateJoystickHandlePosition(touch, true); // true para indicar que es el inicio
            },
            { passive: false }
          );

          actionButtonTouch.addEventListener("click", () => {
            if (!gameState.player.isCultivating && !gameState.battle.active) {
              interact();
            }
          });
        }
        function resetJoystickHandle() {
          if (joystickHandle)
            joystickHandle.style.transform = "translate(0px, 0px)";
          joystickCurrentDx = 0;
          joystickCurrentDy = 0;
        }
        // <!-- CAMBIO JOYSTICK: Modificaciones en los manejadores -->
        function handleJoystickStart(event) {
          
          if (
            gameState.player.isCultivating ||
            gameState.battle.active ||
            joystickActive
          )
            return;

          // Solo procesar el primer toque en el pad
          const touch = event.changedTouches[0];
          if (!touch) return;

          // Comprobar si el toque est√° realmente dentro del joystickPad (opcional, pero bueno para evitar activaciones accidentales)
          const padRect = joystickPad.getBoundingClientRect();
          if (
            touch.clientX < padRect.left ||
            touch.clientX > padRect.right ||
            touch.clientY < padRect.top ||
            touch.clientY > padRect.bottom
          ) {
            return;
          }

          event.preventDefault(); // Prevenir scroll/zoom si el toque es para el joystick

          joystickActive = true;
          joystickTouchIdentifier = touch.identifier; // Guardar el ID del dedo

          // A√±adir listeners de movimiento y fin al documento para seguir el dedo fuera del pad
          document.addEventListener("touchmove", handleJoystickMove, {
            passive: false,
          });
          document.addEventListener("touchend", handleJoystickEnd, {
            passive: false,
          });
          document.addEventListener("touchcancel", handleJoystickEnd, {
            passive: false,
          });

          // if (!joystickGameMoveTimerId) {
          //   joystickGameMoveTimerId = setInterval(
          //     processJoystickGameMove,
          //     JOYSTICK_GAME_MOVE_INTERVAL
          //   );
          // }
          updateJoystickHandlePosition(touch);
          // console.log("Joystick Start, ID:", joystickTouchIdentifier);
        }
        function handleJoystickMove(event) {
          if (!joystickActive) return;

          // Encontrar el toque correcto
          let touch = null;
          for (let i = 0; i < event.changedTouches.length; i++) {
            if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
              touch = event.changedTouches[i];
              break;
            }
          }

          if (touch) {
            event.preventDefault(); // Prevenir scroll si el movimiento es del dedo del joystick
            updateJoystickHandlePosition(touch);
            // console.log("Joystick Move");
          }
        }

        function updateJoystickHandlePosition(touch) {
          const padRect = joystickPad.getBoundingClientRect();
          if (padRect.width === 0) return;

          const joystickCenterX = padRect.left + padRect.width / 2;
          const joystickCenterY = padRect.top + padRect.height / 2;

          const currentX = touch.clientX - joystickCenterX;
          const currentY = touch.clientY - joystickCenterY;

          const angle = Math.atan2(currentY, currentX);
          const maxDistance = joystickPad.offsetWidth / 2 - joystickHandle.offsetWidth / 2;
          if (maxDistance <= 0) return;

          const distance = Math.min(maxDistance, Math.hypot(currentX, currentY));
          const limitedX = distance * Math.cos(angle);
          const limitedY = distance * Math.sin(angle);
          if (joystickHandle) {
              joystickHandle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
          }

          // --- L√ìGICA DE CONTROL SIMPLIFICADA ---
          // Primero, reseteamos todas las direcciones del joystick.
          playerMovementKeysDown.up = false;
          playerMovementKeysDown.down = false;
          playerMovementKeysDown.left = false;
          playerMovementKeysDown.right = false;

          // Ahora, activamos la direcci√≥n correcta si el joystick est√° lo suficientemente inclinado.
          const magnitude = Math.hypot(currentX, currentY);
          if (magnitude > JOYSTICK_THRESHOLD) {
              if (Math.abs(currentX) > Math.abs(currentY)) {
                  // Movimiento horizontal (izquierda o derecha)
                  if (currentX > 0) {
                      playerMovementKeysDown.right = true;
                  } else {
                      playerMovementKeysDown.left = true;
                  }
              } else {
                  // Movimiento vertical (arriba o abajo)
                  if (currentY > 0) {
                      playerMovementKeysDown.down = true;
                  } else {
                      playerMovementKeysDown.up = true;
                  }
              }
          }
        }

        function handleJoystickEnd(event) {
          if (!joystickActive) return;
          
          let touchEndedIsOurs = false;
          for (let i = 0; i < event.changedTouches.length; i++) {
            if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
              touchEndedIsOurs = true;
              break;
            }
          }

          if (touchEndedIsOurs) {
            joystickActive = false;
            joystickTouchIdentifier = null;
            resetJoystickHandle();
            
            // --- LIMPIEZA DE BANDERAS ---
            // Al soltar el joystick, nos aseguramos de que ninguna tecla de movimiento quede "presionada"
            playerMovementKeysDown.up = false;
            playerMovementKeysDown.down = false;
            playerMovementKeysDown.left = false;
            playerMovementKeysDown.right = false;

            document.removeEventListener("touchmove", handleJoystickMove);
            document.removeEventListener("touchend", handleJoystickEnd);
            document.removeEventListener("touchcancel", handleJoystickEnd);
          }
        }
        // processJoystickGameMove se mantiene igual
        // <!-- FIN CAMBIO JOYSTICK -->
        function processJoystickGameMove() {
          // Esta funci√≥n se llama cada JOYSTICK_GAME_MOVE_INTERVAL
          if (
            joystickActive &&
            (joystickCurrentDx !== 0 || joystickCurrentDy !== 0)
          ) {
            // console.log(`[processJoystickGameMove] Effective move: dx=${joystickCurrentDx}, dy=${joystickCurrentDy}. Calling movePlayer.`);
            movePlayer(joystickCurrentDx, joystickCurrentDy);
          }
        }
        function joystickLoop() {
          if (!joystickActive) {
            joystickLoopId = null;
            return;
          }
          const now = Date.now();
          if (now - lastJoystickMoveTime > JOYSTICK_MOVE_INTERVAL) {
            let dx = 0,
              dy = 0;
            const magnitude = Math.hypot(joystickCurrentX, joystickCurrentY);
            if (magnitude > JOYSTICK_THRESHOLD) {
              if (Math.abs(joystickCurrentX) > Math.abs(joystickCurrentY)) {
                dx = joystickCurrentX > 0 ? 1 : -1;
              } else {
                dy = joystickCurrentY > 0 ? 1 : -1;
              }
            }
            if (dx !== 0 || dy !== 0) {
              movePlayer(dx, dy);
              lastJoystickMoveTime = now;
            }
          }
          joystickLoopId = requestAnimationFrame(joystickLoop);
        }
        // --- NUEVAS FUNCIONES PARA LOS MODALES DE INVENTARIO Y PERSONAJE (EJEMPLOS) ---

        // Modal para Inventario Detallado (si decides usar un modal en lugar del sidebar)
        function openInventoryModal() {
          let inventoryContent = `
              <h2 style="text-align: center; margin-bottom: 20px;">Inventario</h2>
              <div id="inventory-modal-list" style="text-align: left;">
          `;

          // Filtrar para mostrar solo los √≠tems que el jugador posee
          const itemsToShow = Object.entries(gameState.inventory).filter(([itemName, count]) => count > 0);

          if (itemsToShow.length === 0) {
              inventoryContent += "<p style='text-align: center; opacity: 0.7;'>No tienes ning√∫n objeto.</p>";
          } else {
              itemsToShow.forEach(([itemName, count]) => {
                  const itemInfo = itemData[itemName] || {};
                  const canBeUsed = itemInfo.canUse ? itemInfo.canUse(gameState.player) : false;
                  
                  inventoryContent += `
                      <div class="inventory-modal-item">
                          <div class="item-details">
                              <div class="item-name">${getItemIcon(itemName, '')} ${itemName} (x${count})</div>
                              <div class="item-description">${itemInfo.description || "Un objeto misterioso."}</div>
                          </div>
                          <div class="item-actions">
                              ${itemInfo.effect ? `<button class="use-item-btn" data-itemname="${itemName}" ${canBeUsed ? '' : 'disabled'} title="${canBeUsed ? 'Usar objeto' : 'No se puede usar ahora'}">Usar</button>` : ''}
                      
                          </div>
                      </div>
                  `;
              });
          }

          inventoryContent += '</div>';

          // Usamos el modal gen√©rico para mostrar el contenido
          showModal("Detalles del Inventario", inventoryContent);
          // Ocultamos el t√≠tulo por defecto del modal gen√©rico, ya que hemos puesto el nuestro.
          document.getElementById('modalTitle').style.display = 'none';

          // A√ëADIMOS LOS LISTENERS DESPU√âS DE QUE EL MODAL ES VISIBLE
          document.querySelectorAll('.use-item-btn').forEach(button => {
              button.addEventListener('click', function() {
                  const itemName = this.dataset.itemname;
                  // Usamos la funci√≥n de uso de √≠tem, que ya da feedback y actualiza la UI
                  useItem(itemName); 
                  // Cerramos y reabrimos el modal para reflejar los cambios (ej. item gastado)
                  closeModal();
                  openInventoryModal();
              });
          });

          document.querySelectorAll('.assign-slot-btn').forEach(button => {
              button.addEventListener('click', function() {
                  const itemName = this.dataset.itemname;
                  assignItemToQuickSlot(itemName);
              });
          });
      }

      function openItemAssignmentModal(slotIndex) {
          let assignmentContent = `
              <h2 style="text-align: center; margin-bottom: 20px;">Asignar al Slot ${slotIndex + 1}</h2>
              <p style="text-align: center; opacity: 0.8; margin-bottom: 15px;">Selecciona un objeto consumible para este acceso r√°pido.</p>
              <div id="assignment-modal-list" style="text-align: left;">
          `;

          // Filtrar para mostrar solo los √≠tems consumibles que el jugador posee
          const assignableItems = Object.entries(gameState.inventory).filter(([itemName, count]) => {
              const itemInfo = itemData[itemName];
              return count > 0 && itemInfo && itemInfo.canUse; // 'canUse' es nuestro indicador de consumible
          });

          if (assignableItems.length === 0) {
              assignmentContent += "<p style='text-align: center; opacity: 0.7;'>No tienes objetos consumibles para asignar.</p>";
          } else {
              assignableItems.forEach(([itemName, count]) => {
                  const itemInfo = itemData[itemName];
                  assignmentContent += `
                      <div class="inventory-modal-item assignable-item" data-itemname="${itemName}">
                          <div class="item-details">
                              <div class="item-name">${getItemIcon(itemName, '')} ${itemName} (x${count})</div>
                              <div class="item-description">${itemInfo.description}</div>
                          </div>
                      </div>
                  `;
              });
          }

          assignmentContent += `</div><button onclick="unassignQuickSlot(${slotIndex})" style="margin-top:20px; background-color: #883333;">Quitar Objeto del Slot</button>`;
          
          // Mostramos el modal
          showModal("Asignar Objeto", assignmentContent);
          document.getElementById('modalTitle').style.display = 'none';

          // A√±adimos listeners a los √≠tems clicables
          document.querySelectorAll('.assignable-item').forEach(itemDiv => {
              itemDiv.addEventListener('click', function() {
                  const itemName = this.dataset.itemname;
                  // Asignar el √≠tem al slot correspondiente
                  gameState.player.quickSlots[slotIndex] = itemName;
                  // Cerrar el modal y actualizar la barra
                  closeModal();
                  renderQuickSlotBar();
              });
          });
      }
      function unassignQuickSlot(slotIndex) {
          gameState.player.quickSlots[slotIndex] = null;
          closeModal();
          renderQuickSlotBar();
      }

        // Modal para Personaje (Stats, Equipo, etc.)
        function openCharacterModal() {
          const player = gameState.player;
          let characterContent = `
                  <h2>${player.realm} - Nivel ${player.level}</h2>
                  <div style="text-align: left; margin-top: 15px;">
                  <p><strong>Vida:</strong> ${Math.floor(player.hp)} / ${
            player.maxHp
          }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill hp-fill" style="width: ${
                    (player.hp / player.maxHp) * 100
                  }%;"></div></div>
                  <p><strong>Man√°:</strong> ${Math.floor(player.mana)} / ${
            player.maxMana
          }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill mana-fill" style="width: ${
                    (player.mana / player.maxMana) * 100
                  }%;"></div></div>
                  <p><strong>Experiencia:</strong> ${Math.floor(player.exp)} / ${
            player.expToNext
          }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill exp-fill" style="width: ${
                    (player.exp / player.expToNext) * 100
                  }%;"></div></div>
                  <hr style="margin: 15px 0;">
                  <p><strong>Ataque:</strong> ${player.attack}</p>
                  <p><strong>Defensa:</strong> ${player.defense}</p>
                  <p><strong>Piedras Espirituales:</strong> ${
                    gameState.inventory["Piedras Espirituales"] || 0
                  }</p>
                  <hr style="margin: 15px 0;">
                  <h4>Secta: ${player.secta.nombre}</h4>
                  <p><strong>Rango:</strong> ${player.secta.rango}</p>
                  <p><strong>Puntos de Contribuci√≥n:</strong> ${
                    player.secta.puntosContribucion
                  } PCS</p>
                  </div>
                  `;
          // Aqu√≠ podr√≠as a√±adir una secci√≥n para el equipo si lo implementas.
          showModal("Detalles del Personaje", characterContent);
        }

        // Placeholder para un futuro modal de men√∫ principal
        function openMainMenuModal() {
          let menuContent = `
                  <h2>Men√∫ Principal</h2>
                  <button class="cultivation-option-btn" onclick="saveGame(); closeModal();">üíæ Guardar Partida</button>
                  <button class="cultivation-option-btn" onclick="triggerFileUpload(); closeModal();">üìÅ Cargar Partida</button>
                  <button class="cultivation-option-btn" onclick="showHelp();">‚ùì Ayuda</button>
                  <button class="cultivation-option-btn" onclick="closeModal();">‚Ü©Ô∏è Volver al Juego</button>
              `;
          // Usamos el showModal gen√©rico pero sin el bot√≥n de cierre por defecto, ya que "Volver al Juego" hace esa funci√≥n.
          // Para ello, tu showModal necesitar√≠a una forma de ocultar su propio bot√≥n de cierre.
          // Si showModal no lo permite, necesitar√≠as un modal espec√≠fico para el men√∫.
          // Por ahora, asumir√© que el showModal gen√©rico tiene un bot√≥n de cierre que se ocultar√°
          // o que el usuario usar√° el bot√≥n "Volver al Juego".

          // Modificamos el modal gen√©rico para que no muestre su propio bot√≥n "Cerrar" si se lo indicamos
          const modalElement = document.getElementById("interactionModal");
          const modalTitleEl = document.getElementById("modalTitle");
          const modalTextEl = document.getElementById("modalText");
          const closeButton = modalElement.querySelector(
            "button.close-modal-btn"
          );

          modalTitleEl.textContent = "Men√∫ Principal"; // El H2 ya est√° en menuContent
          modalTextEl.innerHTML = menuContent.replace(
            "<h2>Men√∫ Principal</h2>",
            ""
          ); // Quitar el H2 duplicado
          if (closeButton) closeButton.style.display = "none"; // Ocultar el bot√≥n de cierre por defecto del modal

          modalElement.style.display = "flex";
          hideTouchControls();
          updateTopNavVisibility();
        }

        function openSectHallInterface() {
          const player = gameState.player;
          const sectData = SECTA_DATA;
          console.log(
            "[SectHall] Abrir interfaz. Rango actual:",
            player.secta.rango,
            "PCS:",
            player.secta.puntosContribucion
          ); // LOG INICIAL

          document.getElementById(
            "sectHallModalTitle"
          ).textContent = `Sal√≥n ${player.secta.nombre}`;
          document.getElementById("sectHallPlayerRank").textContent =
            player.secta.rango;
          document.getElementById("sectHallPlayerPCS").textContent =
            player.secta.puntosContribucion;

          const availableMissionsDiv = document.getElementById(
            "sectHallAvailableMissions"
          );
          availableMissionsDiv.innerHTML =
            "<p>Habla con Gu√≠a Lin o Admin Yao para asignaciones generales.</p>";

          const rankChallengesDiv = document.getElementById(
            "sectHallRankChallenges"
          );
          rankChallengesDiv.innerHTML = "";

          const currentRankIndex = sectData.rangos.findIndex(
            (r) => r.nombre === player.secta.rango
          );
          console.log("[SectHall] currentRankIndex:", currentRankIndex); // LOG currentRankIndex

          let challengeButtonAdded = false;

          // Condici√≥n principal para mostrar el bot√≥n de consulta
          if (
            currentRankIndex !== -1 &&
            currentRankIndex + 1 < sectData.rangos.length
          ) {
            console.log(
              "[SectHall] Condici√≥n para mostrar bot√≥n CUMPLIDA. Hay un siguiente rango."
            ); // LOG
            const nextRankData = sectData.rangos[currentRankIndex + 1];
            console.log(
              "[SectHall] Siguiente rango:",
              nextRankData.nombre,
              "PCS Req:",
              nextRankData.pcsRequeridos
            ); // LOG nextRankData

            const challengeButton = document.createElement("button");
            challengeButton.textContent = `Consultar Desaf√≠o para ${nextRankData.nombre}`;
            challengeButton.className = "cultivation-option-btn";
            challengeButton.style.marginBottom = "10px";

            challengeButton.onclick = () => {
              // ... (l√≥gica del onclick que ya tienes, puedes a√±adir logs internos aqu√≠ tambi√©n si es necesario) ...
              console.log("[SectHall] Bot√≥n 'Consultar Desaf√≠o' CLICADO.");
              const pcsNecesarios = nextRankData.pcsRequeridos;
              const tieneSuficientesPCS =
                player.secta.puntosContribucion >= pcsNecesarios;
              const rivalIdParaDesafio = nextRankData.desafioRivalId;
              let mensajeDesafio = `<strong>Desaf√≠o para ascender a ${nextRankData.nombre}:</strong><br>`;
              let misionDesafioActiva = null;
              let misionDesafioDataObj = null;
              let idDeLaMisionAsociada = null;

              console.log(
                `[SectHall - OnClick] PCS Necesarios: ${pcsNecesarios}, Tiene PCS: ${tieneSuficientesPCS}, Rival ID: ${rivalIdParaDesafio}`
              );

              if (rivalIdParaDesafio) {
                const misionEntry = Object.entries(MISIONES_DATA).find(
                  ([mKey, mVal]) =>
                    mVal.objetivo?.tipo === "derrotar_npc_especifico" &&
                    mVal.objetivo?.npcId === rivalIdParaDesafio &&
                    mVal.recompensa?.nuevoRango === nextRankData.nombre
                );
                console.log(
                  "[SectHall - OnClick] Mision Entry encontrada:",
                  misionEntry
                );

                if (misionEntry) {
                  idDeLaMisionAsociada = misionEntry[0];
                  misionDesafioDataObj = misionEntry[1];
                  misionDesafioActiva = player.secta.misionesActivas.find(
                    (m) => m.id === idDeLaMisionAsociada
                  );
                  console.log(
                    "[SectHall - OnClick] ID Misi√≥n Asociada:",
                    idDeLaMisionAsociada,
                    "Misi√≥n Activa?:",
                    !!misionDesafioActiva
                  );

                  mensajeDesafio += `<em>"${misionDesafioDataObj.descripcion}"</em><br>`;
                  mensajeDesafio += `Oponente: <strong>${
                    entityTypes[rivalIdParaDesafio]?.name ||
                    "Guardi√°n Desconocido"
                  }</strong>.<br>`;
                  mensajeDesafio += `Recompensas: ${
                    misionDesafioDataObj.recompensa.pcs || 0
                  } PCS, ${misionDesafioDataObj.recompensa.exp || 0} EXP, Rango ${
                    nextRankData.nombre
                  }.<br><hr>`;
                } else {
                  mensajeDesafio += `Informaci√≥n del desaf√≠o espec√≠fico no encontrada (error de configuraci√≥n o la misi√≥n no est√° definida correctamente).<br><hr>`;
                }
              } else {
                mensajeDesafio += `Este rango no parece requerir un desaf√≠o de combate para ascender.<br><hr>`;
              }

              mensajeDesafio += `<strong>Requisitos Actuales:</strong><br>`;
              mensajeDesafio += `Puntos de Contribuci√≥n (PCS): ${player.secta.puntosContribucion} / ${pcsNecesarios} PCS. `;
              mensajeDesafio += tieneSuficientesPCS
                ? "<span style='color: #66ff66;'>(Cumplido)</span><br>"
                : `<span style='color: #ffcc66;'>(Faltan ${
                    pcsNecesarios - player.secta.puntosContribucion
                  } PCS)</span><br>`;

              if (misionDesafioActiva) {
                mensajeDesafio +=
                  "<br><strong style='color: #66ff66;'>¬°El desaf√≠o est√° ACTIVO!</strong> Dir√≠gete a la arena.";
              } else if (
                idDeLaMisionAsociada &&
                player.secta.misionesCompletadas[idDeLaMisionAsociada]
              ) {
                mensajeDesafio +=
                  "<br><strong style='color: #aaa;'>Ya has completado este desaf√≠o.</strong>";
              } else if (
                tieneSuficientesPCS &&
                rivalIdParaDesafio &&
                misionDesafioDataObj &&
                idDeLaMisionAsociada
              ) {
                const activarDesafioBtnId = "activar-desafio-btn-specific";
                mensajeDesafio += `<br><button id="${activarDesafioBtnId}">Activar Misi√≥n de Desaf√≠o Ahora</button>`;

                window.tempChallengeActivationInfo = {
                  misionId: idDeLaMisionAsociada,
                  nextRankName: nextRankData.nombre,
                };
              } else if (!tieneSuficientesPCS) {
                mensajeDesafio +=
                  "<br>A√∫n no cumples los requisitos de PCS para activar este desaf√≠o.";
              } else if (!rivalIdParaDesafio || !misionDesafioDataObj) {
                mensajeDesafio +=
                  "<br>No hay un desaf√≠o de combate claramente definido para este rango o falta informaci√≥n de la misi√≥n.";
              }

              showModal("Informaci√≥n del Desaf√≠o de Rango", mensajeDesafio);

              if (
                window.tempChallengeActivationInfo &&
                document.getElementById("activar-desafio-btn-specific")
              ) {
                document.getElementById("activar-desafio-btn-specific").onclick =
                  () => {
                    console.log(
                      "[SectHall - OnClick] Bot√≥n 'Activar Misi√≥n Ahora' CLICADO."
                    );
                    const info = window.tempChallengeActivationInfo;
                    const misionDataParaActivar = MISIONES_DATA[info.misionId];
                    const playerRef = gameState.player;
                    const nextRankDataRef = SECTA_DATA.rangos.find(
                      (r) => r.nombre === info.nextRankName
                    );

                    if (
                      misionDataParaActivar &&
                      nextRankDataRef &&
                      playerRef.secta.puntosContribucion >=
                        nextRankDataRef.pcsRequeridos
                    ) {
                      if (
                        !playerRef.secta.misionesActivas.some(
                          (m) => m.id === info.misionId
                        ) &&
                        !playerRef.secta.misionesCompletadas[info.misionId]
                      ) {
                        acceptMission(info.misionId);
                        closeModal();
                        openSectHallInterface();
                        ensureFixedEntities();
                        renderMap();
                      } else {
                        showModal(
                          "Desaf√≠o ya Gestionado",
                          "Este desaf√≠o ya est√° activo o ha sido completado."
                        );
                      }
                    } else {
                      showModal(
                        "Requisitos No Cumplidos",
                        "Ya no cumples los requisitos para activar este desaf√≠o."
                      );
                    }
                    delete window.tempChallengeActivationInfo;
                  };
              } else if (
                document.getElementById("activar-desafio-btn-specific")
              ) {
                console.warn(
                  "[SectHall - OnClick] Bot√≥n 'activar-desafio-btn-specific' existe, pero window.tempChallengeActivationInfo no est√° definido."
                );
              }
            };
            rankChallengesDiv.appendChild(challengeButton);
            challengeButtonAdded = true;
            console.log("[SectHall] Bot√≥n 'Consultar Desaf√≠o' A√ëADIDO al DOM."); // LOG si se a√±ade
          } else {
            // Este bloque se ejecuta si la condici√≥n if (currentRankIndex !== -1 && currentRankIndex + 1 < sectData.rangos.length) NO se cumple
            console.log("[SectHall] Condici√≥n para mostrar bot√≥n NO CUMPLIDA."); // LOG
            if (currentRankIndex === -1) {
              console.log(
                "[SectHall] Raz√≥n: currentRankIndex es -1 (rango del jugador no encontrado)."
              ); // LOG
            } else {
              console.log(
                "[SectHall] Raz√≥n: Jugador en rango m√°ximo o no hay m√°s rangos (currentRankIndex + 1 >= sectData.rangos.length)."
              ); // LOG
            }
          }

          // Mensajes de fallback si el bot√≥n no se a√±adi√≥
          if (!challengeButtonAdded) {
            console.log(
              "[SectHall] challengeButtonAdded es FALSE. Mostrando mensaje de fallback."
            ); // LOG
            if (currentRankIndex === -1) {
              rankChallengesDiv.innerHTML =
                "<p>Error al determinar tu rango actual.</p>";
            } else if (currentRankIndex + 1 >= sectData.rangos.length) {
              rankChallengesDiv.innerHTML =
                "<p>¬°Has alcanzado el rango m√°s alto o no hay m√°s desaf√≠os definidos!</p>";
            } else {
              // Esta situaci√≥n es menos com√∫n si la l√≥gica anterior es correcta,
              // pero podr√≠a ocurrir si hay un `nextRankData` pero por alguna raz√≥n no se crea el bot√≥n.
              rankChallengesDiv.innerHTML =
                "<p>No hay informaci√≥n de desaf√≠o disponible en este momento (situaci√≥n de fallback inesperada).</p>";
            }
          }

          document.getElementById("sectHallModal").style.display = "flex";
          hideTouchControls();
        }
        function acceptMissionFromSectHall(misionId) {
          acceptMission(misionId);
          if (document.getElementById("sectHallModal").style.display === "flex") {
            openSectHallInterface();
          }
        }
        function closeSectHallModal() {
          document.getElementById("sectHallModal").style.display = "none";
          showTouchControls();
          updatePlayerBarsOnMap();
          showTouchControls();
        }
        function openSectShop() {
          showModal("Tienda de Secta", "El Dep√≥sito a√∫n est√° siendo abastecido.");
        }
        // Variable global para almacenar la acci√≥n a confirmar
      let onConfirmAction = null;
      

      function getPlayerCurrentZone() {
        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        for (const zone of gameState.map.terrainZones) {
          if (playerX >= zone.x1 && playerX <= zone.x2 && playerY >= zone.y1 && playerY <= zone.y2) {
            return zone;
          }
        }
        return null; // El jugador no est√° en ninguna zona definida (est√° en el "mundo abierto")
      }
      function showConfirmationModal(title, text, onConfirm) {
        document.getElementById('confirmationModalTitle').textContent = title;
        document.getElementById('confirmationModalText').innerHTML = text;
        
        onConfirmAction = onConfirm; // Guardamos la funci√≥n que se ejecutar√° si se confirma

        const confirmButton = document.getElementById('confirmBtn');
        // Usamos .onclick para reemplazar cualquier listener anterior
        confirmButton.onclick = () => {
            if (typeof onConfirmAction === 'function') {
                onConfirmAction();
            }
            closeConfirmationModal();
        };

        document.getElementById('confirmationModal').style.display = 'flex';
        hideTouchControls();
      }

      function closeConfirmationModal() {
        document.getElementById('confirmationModal').style.display = 'none';
        onConfirmAction = null; // Limpiamos la acci√≥n
        showTouchControls();
      }
        // --- INICIALIZACI√ìN ---
        document.addEventListener("DOMContentLoaded", () => {
          const mobileMenuButton = document.getElementById('mobileMenuBtn');
          const topNavBar = document.getElementById('topNavBar'); // Ya deber√≠as tener esta variable
          if (mobileMenuButton && topNavBar) {
              mobileMenuButton.addEventListener('click', (e) => {
                  e.stopPropagation(); // Evita que otros clicks se disparen
                  topNavBar.classList.toggle('open');
              });
          }
          
          // A√±adir un listener para cerrar el men√∫ si se hace clic fuera de √©l
          document.addEventListener('click', (e) => {
              if (topNavBar.classList.contains('open') && !topNavBar.contains(e.target)) {
                  topNavBar.classList.remove('open');
              }
          });
          renderQuickSlotBar();
          const navBtnMissions = document.getElementById('navBtnMissions');
          if (navBtnMissions) {
              navBtnMissions.addEventListener('click', openMissionsModal);
          }
          const navBtnInventory = document.getElementById('navBtnInventory');
          console.log("Dentro de DOMContentLoaded, navBtnInventory:", navBtnInventory);
          if (navBtnInventory) {
            navBtnInventory.addEventListener("click", () => {
              openInventoryModal(); // Llama a nuestra nueva y mejorada funci√≥n
              if(isMobileView() && topNavBar.classList.contains('open')) {
                  topNavBar.classList.remove('open');
              }
            });
          }

          if (navBtnCharacter) {
            navBtnCharacter.addEventListener("click", () => {
              // Necesitas una funci√≥n para abrir un MODAL de personaje
              openCharacterModal(); // Tendr√≠as que crear esta funci√≥n y el modal
            });
          }

          if (navBtnCultivate) {
            navBtnCultivate.addEventListener("click", () => {
              toggleCultivation(); // Tu funci√≥n existente para iniciar/detener cultivo
            });
          }

          if (navBtnTechniques) {
            navBtnTechniques.addEventListener("click", () => {
              showTechniquePanel(); // Tu funci√≥n existente para mostrar el modal de t√©cnicas
            });
          }

          if (navBtnMenu) {
              navBtnMenu.addEventListener("click", () => {
                  // Siempre abre el modal del men√∫ principal.
                  openMainMenuModal(); 
                  
                  // Adicional: En m√≥vil, cierra el men√∫ desplegable despu√©s de hacer clic.
                  if (isMobileView() && topNavBar.classList.contains('open')) {
                      topNavBar.classList.remove('open');
                  }
              });
          }

          // Llamada inicial para asegurar el estado correcto de la barra
          updateTopNavVisibility();

          // --- INICIO DEL REEMPLAZO DE EVENT LISTENERS ---
          document.addEventListener("keydown", (e) => {
              if (isAnyModalOpen() || gameState.battle.active || gameState.player.isCultivating) {
                  Object.keys(playerMovementKeysDown).forEach(k => playerMovementKeysDown[k] = false);
                  return;
              }
              // --- INICIO DE LA MODIFICACI√ìN PARA ACCESO R√ÅPIDO ---
              if (e.code.startsWith("Digit")) {
                  const slotIndex = parseInt(e.code.replace("Digit", ""), 10) - 1;
                  if (slotIndex >= 0 && slotIndex < 5) {
                      e.preventDefault();
                      useQuickSlotItem(slotIndex);
                      return; // Importante para que no procese el movimiento
                  }
              }
              // --- FIN DE LA MODIFICACI√ìN ---
              let direction = null;
              switch (e.code) {
                  case "KeyW": case "ArrowUp":    direction = "up"; break;
                  case "KeyS": case "ArrowDown":  direction = "down"; break;
                  case "KeyA": case "ArrowLeft":  direction = "left"; break;
                  case "KeyD": case "ArrowRight": direction = "right"; break;
                  case "Space":
                      e.preventDefault();
                      interact();
                      return;
              }

              if (direction) {
                  e.preventDefault();
                  playerMovementKeysDown[direction] = true;
              }
          });

          document.addEventListener("keyup", (e) => {
              let direction = null;
              switch (e.code) {
                  case "KeyW": case "ArrowUp":    direction = "up"; break;
                  case "KeyS": case "ArrowDown":  direction = "down"; break;
                  case "KeyA": case "ArrowLeft":  direction = "left"; break;
                  case "KeyD": case "ArrowRight": direction = "right"; break;
              }

              if (direction) {
                  e.preventDefault();
                  playerMovementKeysDown[direction] = false;
              }
          });
          

          // Helper para convertir direcci√≥n a dx/dy para movePlayer
          function dxFromDirection(direction) {
            if (direction === "left") return -1;
            if (direction === "right") return 1;
            return 0;
          }

          function dyFromDirection(direction) {
            if (direction === "up") return -1;
            if (direction === "down") return 1;
            return 0;
          }

          const fileInput = document.getElementById("fileInput");
          if (fileInput) fileInput.addEventListener("change", loadGameFromFile);

          const toggleControlsBtn = document.getElementById(
            "toggleMapControlsBtn"
          );
          if (toggleControlsBtn)
            toggleControlsBtn.addEventListener(
              "click",
              toggleMapControlsVisibility
            );

          // Listener para redimensionar y recalcular el tama√±o de los tiles
          window.addEventListener("resize", () => {
            calculateAndSetTileSize();
            renderMap(); // Vuelve a dibujar con el nuevo tama√±o
            updatePlayerPosition(); // Asegura que el jugador est√© bien posicionado
          });

          // Iniciar el bucle de actualizaci√≥n del juego
          setInterval(gameTickUpdater, 1000); // Llama cada segundo, ajusta seg√∫n necesidad
          initJoystick();
          setInterval(gameLoop, 100);
          calculateAndSetTileSize();
          // generateMap() ahora es m√°s simple, isRespawn = false para carga inicial completa
          gameState.lastGameTimeUpdate = Date.now(); // Inicializar antes del primer tick
         
          generateMap(true); // Usar true para la generaci√≥n inicial completa, incluyendo decorativos
          
          recalculatePlayerStats();
          updatePlayerVisualSize(); // Asegura el tama√±o correcto del div del jugador
          updatePlayerSpriteVisual(); // Establece el sprite inicial
          updatePlayerPosition("DOMContentLoaded_init"); // Llama despu√©s de sprite visual

          updatePlayerSpriteVisual(); // Llamar una vez para establecer el sprite inicial

          showTouchControls();

          showModal(
            "Despertar del Cultivador",
            "Has despertado en un mundo de cultivadores buscando poder supremo. " +
              "Te encuentras cerca de la <strong>Secta del Viento Azure</strong>. Quiz√°s all√≠ encuentres tu camino.\n\n" +
              "<strong>Objetivo:</strong> Asciende en la secta, domina t√©cnicas, derrota enemigos y desvela secretos.\n\n" +
              "Busca al <strong>Gu√≠a Lin</strong> en la secta (‚õ©Ô∏è) para comenzar.\n\n" +
              'Usa Controles (Teclado/T√°ctil) para moverte e interactuar. Presiona "?" para ayuda.'
          );
          document
            .querySelectorAll("#shopCategories .category-item")
            .forEach((item) => {
              item.addEventListener("click", function () {
                document
                  .querySelectorAll("#shopCategories .category-item")
                  .forEach((i) => i.classList.remove("active"));
                this.classList.add("active");
                currentShopPage = 1;
                renderShopProducts();
              });
            });
          document.getElementById("shopSearch").addEventListener("input", () => {
            currentShopPage = 1;
            renderShopProducts();
          });
          document.getElementById("priceRange").addEventListener("input", (e) => {
            document.getElementById(
              "priceRangeValue"
            ).textContent = `${e.target.value} PS`;
            currentShopPage = 1;
            renderShopProducts();
          });
        });
      </script>
      <!-- BARRA DE ACCESO R√ÅPIDO INFERIOR -->
      <div class="quick-slot-bar" id="quickSlotBar">
          <!-- Los slots se generar√°n con JavaScript -->
        </div>
  </body>
</html>
