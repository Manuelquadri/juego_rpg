<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Camino del Cultivador</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", monospace;
        background: linear-gradient(135deg, #2c1810, #8b4513);
        color: #f4e4bc;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .game-container {
        display: flex;
        flex-grow: 1; /* Para que ocupe el espacio que body le da */
        /* height: 100vh; /* Se gestiona mejor con flex-grow y min-height en body */
      }

      .map-container {
        flex: 1;
        position: relative;
        background: #1a3d2e;
        border: 3px solid #d4af37;
        overflow: hidden; /* MANTENER ESTO para que el mapa no se desborde si los tiles son muy grandes */
      }

      .map {
        width: 100%; /* El div del mapa interno ocupa todo el contenedor */
        height: 100%;
        position: relative; /* Tiles se posicionan relativos a este */
        /* ... el resto de tus estilos para .map ... */
      }

      .tile {
        /* Estilos comunes para todos los tiles, si los tienes */
        position: absolute;

        display: flex;
        align-items: center;
        justify-content: center;
      }

      .player {
        z-index: 10;
        color: transparent;
        font-size: 0;
        border-radius: 0;

        background-image: url("img/tu_sprite_sheet.png"); /* ¡TU RUTA! */
        background-repeat: no-repeat;
        background-position: 0 0; /* Se actualizará por JS */

        background-size: 256px 256px; /* <--- AJUSTA ESTO AL TAMAÑO TOTAL DE TU SPRITE SHEET */

        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;

        /* El width y height del div se controlan por JS con updatePlayerVisualSize */
        /* La posición se controla por JS con updatePlayerSpriteVisual */
      }
      /* === ESTILOS PARA BARRAS SOBRE EL JUGADOR EN EL MAPA === */
      #playerOnMapBarsContainer {
        position: absolute; /* Se posicionará relativo a la ubicación calculada del jugador en pantalla */
        width: 48px; /* Ancho de las barras (ajusta según el tamaño de tu sprite) */
        display: flex;
        flex-direction: column;
        gap: 1px; /* Pequeño espacio entre barras */
        z-index: 15; /* Encima del jugador, pero debajo de modales y UI principal */
        pointer-events: none; /* Para que no interfieran con clics al mapa */
        /* El top y left se ajustarán por JS. Inicialmente pueden estar ocultas o fuera de pantalla */
        transform: translateX(
          -50%
        ); /* Ayuda a centrar si left es el centro del jugador */
        display: none; /* Inicialmente ocultas, JS las mostrará */
      }

      .on-map-stat-bar {
        width: 100%;
        height: 6px; /* Altura de cada barra */
        background-color: rgba(
          50,
          50,
          50,
          0.7
        ); /* Fondo oscuro para la parte vacía */
        border: 1px solid rgba(0, 0, 0, 0.5);
        border-radius: 2px;
        overflow: hidden;
      }

      .on-map-stat-fill {
        height: 100%;
        transition: width 0.2s linear; /* Transición suave para cambios de valor */
      }

      #playerOnMapHpFill {
        background-color: #f44336; /* Rojo para HP */
      }

      #playerOnMapManaFill {
        background-color: #2196f3; /* Azul para Mana */
      }
      .stat-fill {
        height: 100%;
        transition: width 0.3s;
      }
      .hp-fill {
        background: linear-gradient(90deg, #ff4444, #ff6666);
      }
      .mana-fill {
        background: linear-gradient(90deg, #4444ff, #6666ff);
      }
      .exp-fill {
        background: linear-gradient(90deg, #44ff44, #66ff66);
      }
      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      /* === ESTILOS PARA BARRAS SOBRE EL SPRITE DEL JUGADOR EN BATALLA === */
      #playerInBattleSpriteBarsContainer {
        position: absolute; /* Relativo al div.character que lo contiene */
        width: 60px; /* Un poco menos que el sprite (80px) para que no sobresalga mucho */
        display: flex;
        flex-direction: column;
        gap: 1px;
        z-index: 5; /* Encima del sprite, pero no necesariamente de otros elementos del modal */
        pointer-events: none;
        /* top y left se ajustarán por JS. Inicialmente pueden estar ocultas o fuera de pantalla */
        transform: translateX(-50%); /* Ayuda a centrar horizontalmente */
        /* Se mostrarán/ocultarán con la pantalla de batalla */
      }

      .in-battle-sprite-stat-bar {
        width: 100%;
        height: 5px; /* Más delgadas que las del mapa quizás */
        background-color: rgba(50, 50, 50, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.6);
        border-radius: 2px;
        overflow: hidden;
      }

      .in-battle-sprite-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerInBattleSpriteHpFill {
        background-color: #e53935; /* Rojo más intenso para batalla */
      }

      #playerInBattleSpriteManaFill {
        background-color: #1e88e5; /* Azul más intenso para batalla */
      }

      /* Ajuste para que .character sea el contexto de posicionamiento */
      .battle-area .character {
        position: relative; /* Necesario para que position:absolute de las barras funcione correctamente */
      }
      .character-sprite {
        /* Sprite del jugador en batalla */
        width: 80px;
        height: 80px;
        background-image: url("img/tu_sprite_sheet.png"); /* También usa la hoja de sprites */
        background-size: auto; /* O ajusta si es necesario */
        background-position: 0 0; /* Por defecto, mirando hacia abajo, frame 0 */
        background-repeat: no-repeat;
        display: inline-block;
        color: transparent;
        font-size: 0;
      }
      .sidebar {
        width: 300px;
        background: linear-gradient(180deg, #2c1810, #1a1a1a);
        border-left: 3px solid #d4af37;
        padding: 20px;
        overflow-y: auto;
      }

      .stats-panel,
      .inventory-panel,
      .controls-panel,
      .secta-panel {
        /* Añadido secta-panel aquí */
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid #d4af37;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
      }
      /* === CORRECCIÓN/ADICIÓN PARA BARRAS EN EL SIDEBAR === */
      .stats-panel .stat-bar {
        /* Asegúrate de que este selector sea específico si es necesario */
        width: 100%;
        height: 15px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 7px;
        margin-top: 3px;
        margin-bottom: 12px;
        overflow: hidden;
        border: 1px solid rgba(212, 175, 55, 0.3);
        position: relative;
      }
      .inventory-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 8px;
        margin-top: 10px;
        max-height: 120px;
        overflow-y: auto;
        padding-right: 5px;
      }

      .inventory-item {
        font-size: 11px;
        padding: 5px;
        background: rgba(212, 175, 55, 0.2);
        border: 1px solid #d4af37;
        border-radius: 5px;
        text-align: center;
      }

      .hp-fill {
        background: linear-gradient(90deg, #ff4444, #ff6666);
      }
      .mana-fill {
        background: linear-gradient(90deg, #4444ff, #6666ff);
      }
      .exp-fill {
        background: linear-gradient(90deg, #44ff44, #66ff66);
      }

      /* === PANTALLA DE BATALLA === */
        .battle-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: none; /* Se cambia a flex por JS */
            flex-direction: column;
            z-index: 200;
            overflow: hidden; /* IMPORTANTE: Evitar que el contenido desborde la pantalla */
        }

        .battle-area {
            flex: 1; /* Que ocupe el espacio vertical disponible */
            display: flex;
            align-items: center;
            justify-content: space-around; /* O space-evenly */
            padding: 20px 10px; /* Reducir padding horizontal en general, especialmente para móvil */
            gap: 10px; /* Espacio entre personaje y enemigo */
            overflow-y: auto; /* Si el contenido vertical es demasiado, permitir scroll DENTRO del área */
        }

        .character,
        .enemy {

            padding-top: 60px;
            padding-bottom: 60px;

           /* border: 2px solid #d4af37; /* Borde más delgado */
           /* border-radius: 10px;*/
            /*background: rgba(212, 175, 55, 0.1);*/
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;

            /* MODIFICACIÓN CLAVE: Hacerlos flexibles y con tamaño máximo */
            flex-basis: 45%; /* Que cada uno intente ocupar cerca de la mitad del espacio disponible */
            max-width: 280px; /* Pero no más de este ancho, incluso en escritorio si se prefiere */
            min-width: 120px; /* Un mínimo para que no se colapsen demasiado */
            box-sizing: border-box; /* Asegurar que padding y border estén dentro del width/height */
        }


        .character-sprite,
        .enemy-sprite {
            font-size: 60px; /* Reducir tamaño del sprite por defecto */
            margin-bottom: 10px; /* Reducir margen */
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .battle-actions {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px; /* Reducir padding */
            border-top: 2px solid #d4af37;
            flex-shrink: 0; /* Evitar que se encoja si el contenido del battle-area es grande */
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); /* Botones más pequeños */
            gap: 5px; /* Menos espacio entre botones */
            margin-bottom: 10px;
        }
        .battle-actions button { /* Estilos para los botones de acción específicos */
            padding: 8px 10px; /* Botones más pequeños */
            font-size: 0.8em;
        }

      button {
        background: linear-gradient(135deg, #d4af37, #b8941f);
        color: #2c1810;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      button:hover {
        background: linear-gradient(135deg, #f4d03f, #d4af37);
        transform: translateY(-2px);
      }

      button:disabled {
        background: #666;
        color: #999;
        cursor: not-allowed;
        transform: none;
      }
      #toggleMapControlsBtn.hidden-during-battle {
        display: none !important; /* !important para asegurar que sobreescriba el display: block de la media query */
        }
      .log {
        background: rgba(0, 0, 0, 0.7);
        padding: 8px;
        border-radius: 8px;
        max-height: 100px;
        overflow-y: auto;
        font-size: 0.8rem;
        line-height: 1.4;
      }

      .resource {
        background: #228b22;
      }
      .monster {
        background: #8b0000;
      }
      .master {
        background: #4169e1;
      }
      .cultivation-spot {
        background: #daa520;
      }

      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 300;
        padding: 10px; /* Espacio para que el modal content no pegue a los bordes */
      }

      .modal-content {
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        border: 3px solid #d4af37;
        border-radius: 15px;
        padding: 20px; /* Reducido de 30px */
        max-width: 95%; /* Para móviles */
        width: 500px; /* Ancho base */
        text-align: center;
        max-height: 90vh; /* Para modales largos */
        overflow-y: auto; /* Para modales largos */
      }

      /* Ajuste específico para inventory-grid dentro de un modal si es necesario, */
      /* pero ya tiene su propio overflow y max-height. */

      /* Para pantallas más pequeñas, ej. menos de 768px */
      @media (max-width: 768px) {
        .game-container {
          flex-direction: column;
          height: 100vh; /* Ocupa toda la altura de la ventana gráfica */
        }

        .sidebar {
          width: 100%;
          height: 40vh; /* Sidebar ocupa el 40% inferior */
          border-left: none;
          border-top: 3px solid #d4af37;
          overflow-y: auto;
          flex-shrink: 0; /* Evita que se encoja */
        }

        .map-container {
          height: 60vh; /* Mapa ocupa el 60% superior */
          border-bottom: none;
          flex-shrink: 0; /* Evita que se encoja */
        }

        .tile {
          width: 30px;
          height: 30px;
          font-size: 18px;
        }

        .action-buttons {
          /* Botones de batalla más adaptables */
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        }
        .battle-area {
            padding: 15px 5px;
            gap: 5px;
          flex: 1;
          display: flex;
          align-items: center; /* Para centrar verticalmente los contenedores .character y .enemy */
          justify-content: space-around; /* CAMBIADO: 'space-around' distribuye el espacio
                                            uniformemente alrededor de los elementos.
                                            Prueba también con 'space-evenly' si el resultado no te gusta.
                                            'space-between' los pegará a los bordes y dejará todo el espacio solo en el medio. */
       /*    padding: 50px; Mantenemos el padding general del área de batalla */
        }
      }
      @media (max-width: 768px) {
        .character-sprite {
          width: 60px;
          height: 60px;
          /* Si la imagen del spritesheet es grande, podrías necesitar ajustar background-size aquí también */
          /* background-size: 192px 192px; /* Ejemplo si cada frame en móvil es 48x48 y hay 4x4 */
        }
      }

      @media (max-width: 480px) {
        .sidebar {
          height: 45vh; /* Un poco más de espacio para el sidebar en pantallas muy pequeñas */
        }
        .map-container {
          height: 55vh;
        }
        .tile {
          width: 25px;
          height: 25px;
          font-size: 16px;
        }
        .modal-content {
          padding: 15px;
        }
        button {
          padding: 10px 15px;
          font-size: 0.9em;
        } /* Botones más pequeños */

        .battle-area {
            padding: 10px 5px;
            /* Considerar seriamente apilarlos verticalmente aquí si no caben */
            /* flex-direction: column; */
            /* align-items: center; Si se apilan, centrarlos */
        }

        .character, .enemy {
            flex-basis: 48%; /* Si se mantienen lado a lado, darles un poco más de espacio */
            min-width: 100px; /* Mínimo aún más pequeño */
            padding: 5px;
        }
        /* Si se apilan verticalmente con flex-direction: column en .battle-area: */
        /*
        .character, .enemy {
            width: 90%;
            max-width: 280px;
            margin-bottom: 10px;
        }
        */

        .character-sprite, .enemy-sprite {
            font-size: 50px; /* Sprites más pequeños */
            width: 50px;
            height: 50px;
        }
    


        .character h3, .enemy h3 {
            font-size: 0.1rem;
        }
        .character div, .enemy div {
            font-size: 50px;
        }
        .character .stat-bar, .enemy .stat-bar {
            height: 8px;
        }

        .action-buttons {
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); /* Botones aún más adaptables */
        }
        .battle-actions button {
            padding: 6px 8px;
            font-size: 0.75em;
        }
        .log {
            max-height: 80px;
            font-size: 0.75rem;
        }
      }

      #joystick-container {
        position: fixed;
        bottom: 20px; /* Ajustado para no superponer tanto con sidebar en vista móvil */
        left: 20px;
        width: 120px; /* Más pequeño */
        height: 120px;
        z-index: 999; /* Un poco menos que el botón de acción y el de menu */
        display: none;
        opacity: 0.7;
      }

      #joystick-pad {
        width: 100%;
        height: 100%;
        background-color: rgba(128, 128, 128, 0.5);
        border-radius: 50%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid rgba(255, 255, 255, 0.7);
      }

      #joystick-handle {
        width: 50px; /* Más pequeño */
        height: 50px;
        background-color: rgba(80, 80, 80, 0.8);
        border-radius: 50%;
        position: absolute;
        border: 2px solid rgba(200, 200, 200, 0.9);
      }

      #action-button-touch {
        position: fixed;
        bottom: 20px; /* Ajustado */
        right: 20px;
        width: 70px; /* Más pequeño */
        height: 70px;
        border-radius: 50%;
        z-index: 1000;
        display: none;
        font-size: 0.8em; /* Texto más pequeño si lo tiene */
      }

      /* Mostrar el joystick y botón de acción solo en pantallas táctiles o pequeñas */
      /* La visibilidad real se controla por JS, esta query es una guía */
      @media (hover: none) and (pointer: coarse), (max-width: 768px) {
        /* #joystick-container, #action-button-touch { } */
      }

      /* Botón para alternar visibilidad de controles del mapa en móvil */
      #toggleMapControlsBtn {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1005;
        padding: 8px 12px;
        background-color: rgba(44, 24, 16, 0.8);
        color: #f4e4bc;
        border: 1px solid #d4af37;
        border-radius: 5px;
        font-family: "Courier New", monospace;
        font-size: 14px;
        cursor: pointer;
        display: none;
      }
      /* Mostrar botón de alternar controles solo en móvil (misma query que joystick) */
      @media (hover: none) and (pointer: coarse), (max-width: 768px) {
        #toggleMapControlsBtn {
          display: block;
        }
      }

      /* NUEVOS ESTILOS PARA LA TIENDA (ya existentes y adaptados) */
      #shopModal .modal-content {
        max-width: 95%;
        width: auto; /* Permitir que se ajuste, el max-width lo limita */
        min-width: 300px; /* Para que no se colapse demasiado */
        max-height: 90vh;
        overflow-y: auto;
        padding: 20px;
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        border: 3px solid #d4af37;
        border-radius: 15px;
        display: flex;
        flex-direction: column;
      }

      .shop-container {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        flex-grow: 1;
        overflow: hidden;
      }

      .products-grid {
        display: grid;
        grid-template-columns: repeat(
          auto-fill,
          minmax(250px, 1fr)
        ); /* Reducido minmax para móvil */
        gap: 15px;
        max-height: 50vh; /* Altura del scroll de productos */
        overflow-y: auto;
        padding-right: 10px;
        flex-grow: 1; /* Para que use el espacio en shop-products */
      }

      #shopModal .modal-content > div:last-child {
        /* Botón de Salir */
        margin-top: auto;
        padding-top: 20px;
        position: sticky;
        bottom: 0;
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        z-index: 10;
      }

      @media (max-width: 768px) {
        #shopModal .modal-content {
          padding: 10px;
        }

        .shop-container {
          flex-direction: column;
          overflow: visible;
        }

        .shop-filters {
          min-width: unset; /* Quitar min-width en móvil */
          width: 100%;
        }
        .shop-products {
          min-width: unset;
        }

        .products-grid {
          grid-template-columns: 1fr;
          max-height: 40vh; /* Ajustar altura en móviles */
        }

        #shopModal .modal-content > div:last-child {
          padding-top: 15px;
        }
        .character, .enemy {
            /* Aquí podrías necesitar ajustar flex-basis si quieres que uno sea más pequeño,
            o si decides ponerlos uno encima del otro. Por ahora, se mantiene el 45% */
            padding: 8px;
        }

        /* Los sprites y sus barras sobre ellos ya tienen estilos para móvil, pero podemos revisar */
        #playerInBattleSpriteBarsContainer { /* Barras SOBRE el sprite del jugador */
            width: 50px; /* Ajustar al tamaño del sprite móvil */
            /* top y left se ajustan por JS, pero el width es importante */
        }
        .in-battle-sprite-stat-bar { /* Barras individuales SOBRE sprites */
            height: 4px;
        }

        #enemyInBattleInfoContainer { /* Info SOBRE el sprite del enemigo */
            min-width: 50px;
            max-width: 100px; /* Reducir el ancho máximo */
        }
        #enemyInBattleInfoContainer .enemy-battle-name-level {
            font-size: 0.1em;
        }
        #enemyInBattleInfoContainer .in-battle-sprite-stat-bar { /* Barra de vida SOBRE sprite enemigo */
            max-width: 50px; /* Ajustar al sprite */
            height: 4px;
        }
      }
      .shop-header {
        text-align: center;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid #d4af37;
        border-radius: 10px;
      }

      .shop-stats {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 10px;
        font-size: 1.1rem;
      }

      .shop-stats span {
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 15px;
        border-radius: 20px;
        border: 1px solid #d4af37;
      }

      .shop-filters {
        flex: 1;
        min-width: 250px;
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid #d4af37;
        border-radius: 10px;
        padding: 20px;
        height: fit-content;
      }

      .shop-products {
        flex: 3;
        min-width: 300px;
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid #d4af37;
        border-radius: 10px;
        padding: 20px;
        display: flex; /* Para que products-grid pueda crecer */
        flex-direction: column;
      }

      .section-title {
        color: #f4d03f;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 1px solid #d4af37;
        font-size: 1.2rem;
      }

      .search-box {
        width: 100%;
        padding: 10px 15px;
        margin-bottom: 20px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid #d4af37;
        border-radius: 5px;
        color: #f4e4bc;
        font-size: 1rem;
      }

      .search-box::placeholder {
        color: #a99a7a;
      }

      .filter-group {
        margin-bottom: 20px;
      }
      .filter-title {
        margin-bottom: 10px;
        font-weight: bold;
      }
      .category-list {
        list-style: none;
      }
      .category-item {
        padding: 8px 12px;
        margin-bottom: 5px;
        cursor: pointer;
        border-radius: 5px;
        transition: all 0.2s;
      }
      .category-item:hover {
        background: rgba(212, 175, 55, 0.2);
      }
      .category-item.active {
        background: rgba(212, 175, 55, 0.4);
        font-weight: bold;
      }

      .products-grid::-webkit-scrollbar {
        width: 8px;
      }
      .products-grid::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
      }
      .products-grid::-webkit-scrollbar-thumb {
        background: #d4af37;
        border-radius: 10px;
      }

      .product-card {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid #d4af37;
        border-radius: 8px;
        padding: 15px;
        transition: all 0.3s;
      }
      .product-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(212, 175, 55, 0.2);
      }
      .product-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .product-name {
        font-weight: bold;
        font-size: 1.1rem;
        color: #f4d03f;
      }
      .product-price {
        font-size: 1.1rem;
        color: #f4d03f;
      }
      .product-type {
        display: inline-block;
        padding: 3px 8px;
        font-size: 0.8rem;
        border-radius: 10px;
        background: rgba(212, 175, 55, 0.3);
        margin-top: 5px;
      }
      .product-description {
        margin: 10px 0;
        font-size: 0.9rem;
        color: #e6d8b5;
        min-height: 60px;
      }
      .product-stats {
        margin: 10px 0;
        padding: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        font-size: 0.9rem;
      }
      .product-stats div {
        margin-bottom: 5px;
      }
      .product-actions {
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }
      .buy-btn {
        flex-grow: 1;
        padding: 8px 15px;
        background: linear-gradient(135deg, #d4af37, #b8941f);
        color: #2c1810;
        border: none;
        border-radius: 5px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
      }
      .buy-btn:hover {
        background: linear-gradient(135deg, #f4d03f, #d4af37);
      }
      .buy-btn:disabled {
        background: #666;
        color: #999;
        cursor: not-allowed;
      }
      .pagination {
        display: flex;
        justify-content: center;
        margin-top: 20px;
        gap: 10px;
      }
      .page-btn {
        padding: 8px 15px;
        background: rgba(212, 175, 55, 0.2);
        border: 1px solid #d4af37;
        border-radius: 5px;
        color: #f4e4bc;
        cursor: pointer;
        transition: all 0.2s;
      }
      .page-btn:hover {
        background: rgba(212, 175, 55, 0.4);
      }
      .page-btn.active {
        background: rgba(212, 175, 55, 0.6);
        font-weight: bold;
      }

      .cultivation-option-btn {
        display: block;
        width: 100%;
        padding: 10px;
        margin-bottom: 8px;
        text-align: left;
      }
      /* === ESTILOS PARA INFORMACIÓN Y BARRAS SOBRE EL SPRITE DEL ENEMIGO EN BATALLA === */
      #enemyInBattleInfoContainer {
        position: absolute; /* Relativo al div.enemy que lo contiene */
        left: 0;
        width: auto; /* Se ajustará al contenido, o puedes fijarlo como las del jugador */
        min-width: 70px; /* Ancho mínimo para que quepa algo de texto */
        max-width: 150px; /* Evitar que sea demasiado ancho para nombres largos */
        display: flex;
        flex-direction: column;
        align-items: center; /* Centrar la barra de vida si el texto es más ancho */
        gap: 2px; /* Espacio entre el nombre/nivel y la barra */
        z-index: 5; /* Encima del sprite del enemigo */
        pointer-events: none;
        transform: translateX(-50%); /* Ayuda a centrar horizontalmente */
        /* top y left se ajustarán por JS. Inicialmente pueden estar ocultas o fuera de pantalla */
        display: none; /* Inicialmente oculto, JS lo mostrará */
        padding: 2px 4px; /* Pequeño padding interno */
        background-color: rgba(
          10,
          10,
          10,
          0.6
        ); /* Fondo semitransparente opcional */
        border-radius: 3px;
        border: 1px solid rgba(212, 175, 55, 0.3); /* Borde sutil */
      }

      .enemy-battle-name-level {
        font-size: 0.5em; /* Más pequeño que el H3 principal */
        color: #f4e4bc;
        font-weight: bold;
        text-align: center;
        white-space: nowrap; /* Evitar que el nombre se parta en dos líneas si es corto */
        overflow: hidden; /* Ocultar si el nombre es muy largo y excede max-width */
        text-overflow: ellipsis; /* Añadir "..." si el nombre es muy largo */
      }

      /* Reutilizar estilos de barra si es posible, o copiar y ajustar IDs */
      #enemyInBattleInfoContainer .in-battle-sprite-stat-bar {
        /* Selector más específico */
        width: 100%; /* La barra de vida ocupa todo el ancho del contenedor de info */
        max-width: 60px; /* Pero no más ancha que las barras del jugador, por ejemplo */
        height: 5px;
        background-color: rgba(50, 50, 50, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.6);
        border-radius: 2px;
        overflow: hidden;
      }

      #enemyInBattleInfoContainer .in-battle-sprite-stat-fill {
        /* Selector más específico */
        height: 100%;
        transition: width 0.2s linear;
      }

      /* Específico para la barra de vida del enemigo sobre el sprite */
      #enemyInBattleSpriteHpFill {
        background-color: #c62828; /* Rojo un poco más oscuro o diferente para el enemigo */
      }

      /* Asegúrate que .enemy también sea position: relative */
      .battle-area .enemy {
        position: relative; /* Necesario para que position:absolute de #enemyInBattleInfoContainer funcione */
        /* El padding que ya tenías en .enemy ayuda a dar espacio para estas barras si se salen un poco */
      }

      /* === ESTILOS PARA LA BARRA DE NAVEGACIÓN INFERIOR === */
      .bottom-nav-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: linear-gradient(
          180deg,
          #1a1a1a,
          #2c1810
        ); /* Invertido para que la parte más oscura esté arriba */
        border-top: 2px solid #d4af37;
        display: flex;
        justify-content: space-around; /* Distribuye los botones equitativamente */
        align-items: center;
        padding: 5px 0; /* Un poco de padding vertical */
        z-index: 150; /* Encima del mapa pero debajo de modales */
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5); /* Sombra sutil hacia arriba */
        transition: transform 0.3s ease-in-out; /* Para animar si se oculta/muestra */
      }

      /* Ocultar la barra cuando un modal o la pantalla de batalla estén activos */
      .bottom-nav-bar.hidden {
        transform: translateY(100%); /* Desliza hacia abajo para ocultar */
      }

      .nav-button {
        background: transparent;
        border: none;
        color: #f4e4bc;
        display: flex;
        flex-direction: column; /* Icono arriba, texto abajo */
        align-items: center;
        justify-content: center;
        padding: 8px 5px; /* Padding interno del botón */
        cursor: pointer;
        font-family: "Courier New", monospace;
        font-size: 0.75rem; /* Tamaño del texto */
        flex-grow: 1; /* Para que los botones ocupen el espacio disponible */
        max-width: 20%; /* Para 5 botones, cada uno toma hasta el 20% */
        transition: background-color 0.2s, color 0.2s;
      }

      .nav-button:hover,
      .nav-button.active {
        /* Para resaltar el botón activo */
        background-color: rgba(212, 175, 55, 0.15);
        color: #f4d03f;
      }

      .nav-icon {
        font-size: 1.5rem; /* Tamaño del icono */
        margin-bottom: 3px;
      }

      /* En pantallas muy pequeñas, podríamos querer ocultar el texto */
      @media (max-width: 380px) {
        .nav-text {
          display: none;
        }
        .nav-icon {
          font-size: 1.8rem; /* Hacer iconos un poco más grandes si no hay texto */
          margin-bottom: 0;
        }
        .nav-button {
          padding: 10px 5px;
        }
      }
      /* === AJUSTES ESPECÍFICOS PARA MÓVILES EN BATALLA (REVISIÓN) === */
        @media (max-width: 768px) {
        /* Sprites en tablet */
        .character-sprite, .enemy-sprite {
            font-size: 55px; /* Ligeramente más pequeño que el default de 60px */
            width: 55px;
            height: 55px;
            margin-bottom: 8px;
        }

        #playerInBattleSpriteBarsContainer {
            width: 50px; /* Coincidir o ser un poco menor que el sprite */
        }
        .in-battle-sprite-stat-bar {
            height: 4px;
        }
        #enemyInBattleInfoContainer {
            min-width: 50px;
            max-width: 100px;
        }
        #enemyInBattleInfoContainer .enemy-battle-name-level {
            font-size: 0.7em;
        }
        #enemyInBattleInfoContainer .in-battle-sprite-stat-bar {
            max-width: 45px; /* Un poco menor que el width de playerInBattleSpriteBarsContainer */
            height: 4px;
        }
        }

        @media (max-width: 480px) { /* Pantallas muy pequeñas */
        .character-sprite, .enemy-sprite {
            font-size: 50px;
            width: 50px;
            height: 50px;
            margin-bottom: 6px;
        }

        #playerInBattleSpriteBarsContainer {
            width: 45px; /* Ajustar al tamaño del sprite */
        }
        .in-battle-sprite-stat-bar {
            height: 3px; /* Barras más delgadas */
        }

        #enemyInBattleInfoContainer {
            min-width: 45px;
            max-width: 90px;
            padding: 1px 3px;
        }
        #enemyInBattleInfoContainer .enemy-battle-name-level {
            font-size: 0.65em;
        }
        #enemyInBattleInfoContainer .in-battle-sprite-stat-bar {
            max-width: 40px;
            height: 3px;
        }
        }
    </style>
  </head>
  <body>
    <!-- PANEL LATERAL -->
    <input type="file" id="fileInput" accept=".json" style="display: none" />
    <button id="toggleMapControlsBtn">Ocultar Controles</button>
    <!-- Botón para ocultar/mostrar controles -->

    <div class="game-container">
      <div class="map-container">
        <div class="map" id="gameMap"></div>
        <div class="tile player" id="player">🧘</div>
        <div id="playerOnMapBarsContainer">
          <div class="on-map-stat-bar">
            <!-- Barra de Vida -->
            <div class="on-map-stat-fill" id="playerOnMapHpFill"></div>
          </div>
          <div class="on-map-stat-bar">
            <!-- Barra de Maná -->
            <div class="on-map-stat-fill" id="playerOnMapManaFill"></div>
          </div>
        </div>
      </div>
      <div id="joystick-container">
        <div id="joystick-pad">
          <div id="joystick-handle"></div>
        </div>
      </div>
      <button id="action-button-touch">Acción</button>

      <div class="sidebar">
        <div class="stats-panel">
          <h3>Cultivador</h3>
          <p>Coords: <span id="playerCoords">X: 0, Y: 0</span></p>
          <!-- NUEVA LÍNEA -->
          <p>Nivel: <span id="playerLevel">1</span></p>
          <p>Reino: <span id="playerRealm">Mortal</span></p>

          <div>Vida: <span id="hpText">100/100</span></div>
          <div class="stat-bar">
            <div class="stat-fill hp-fill" id="hpBar" style="width: 100%"></div>
          </div>

          <div>Maná: <span id="manaText">50/50</span></div>
          <div class="stat-bar">
            <div
              class="stat-fill mana-fill"
              id="manaBar"
              style="width: 100%"
            ></div>
          </div>

          <div>Experiencia: <span id="expText">0/100</span></div>
          <div class="stat-bar">
            <div class="stat-fill exp-fill" id="expBar" style="width: 0%"></div>
          </div>
        </div>

        <div class="inventory-panel">
          <h3>Inventario</h3>
          <div class="inventory-grid" id="inventory"></div>
        </div>

        <div class="controls-panel">
          <h3>Controles</h3>
          <p><strong>Escritorio:</strong></p>
          <p>WASD/Flechas: Moverse</p>
          <p>ESPACIO: Interactuar</p>
          <p style="margin-top: 5px"><strong>Móvil:</strong></p>
          <p>Joystick: Moverse</p>
          <p>Botón Acción: Interactuar</p>
          <p>
            "Ocultar/Mostrar Controles": Alterna visibilidad de controles
            táctiles.
          </p>

          <button id="cultivateButton" onclick="toggleCultivation()">
            🧘‍♀️ Cultivar
          </button>
          <button onclick="showTechniquePanel()">📖 Técnicas</button>
          <button
            id="toggleQiConversionButton"
            onclick="toggleQiConversionMode()"
            style="display: none"
          >
            ☯️ Activar Conversión Qi
          </button>
          <button onclick="saveGame()">💾 Guardar Partida</button>
          <button onclick="triggerFileUpload()">📁 Cargar Partida</button>
          <button onclick="showHelp()">❓ Ayuda</button>
        </div>
        <div class="secta-panel">
          <h3><span id="sectaNombreDisplay">Secta</span></h3>
          <p>Rango: <span id="playerSectRank">Discípulo Externo</span></p>
          <p>Puntos de Contribución: <span id="playerPCS">0</span> PCS</p>
          <h4>Misiones Activas:</h4>
          <div
            id="activeMissionsList"
            style="font-size: 0.9em; max-height: 150px; overflow-y: auto"
          >
            <p>Ninguna misión activa.</p>
          </div>
        </div>
      </div>
    </div>
    <!-- FIN PANEL LATERAL -->
    <!-- Pantalla de Combate -->
    <div class="battle-screen" id="battleScreen">
      <div class="battle-area">
        <div class="character">
          <!-- NUEVO: Contenedor para barras SOBRE el sprite en batalla -->
          <div id="playerInBattleSpriteBarsContainer">
            <div class="in-battle-sprite-stat-bar">
              <!-- Barra de Vida -->
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteHpFill"
              ></div>
            </div>
            <div class="in-battle-sprite-stat-bar">
              <!-- Barra de Maná -->
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteManaFill"
              ></div>
            </div>
          </div>
          <!-- FIN NUEVO -->
          <div class="character-sprite">🧘</div>
          <h3 id="playerBattleName">Cultivador</h3>
          <div>Vida: <span id="playerBattleHp">100/100</span></div>
          <div class="stat-bar">
            <div
              class="stat-fill hp-fill"
              id="playerBattleHpBar"
              style="width: 100%"
            ></div>
          </div>
        </div>

        <div class="enemy">
          <!-- === NUEVO: Contenedor para información y barras SOBRE el sprite del ENEMIGO === -->
          <div id="enemyInBattleInfoContainer">
            <div class="enemy-battle-name-level" id="enemyBattleNameLevel">
              Enemigo (Nv. X)
            </div>
            <div class="in-battle-sprite-stat-bar enemy-hp-bar">
              <!-- Barra de Vida del Enemigo -->
              <div
                class="in-battle-sprite-stat-fill"
                id="enemyInBattleSpriteHpFill"
              ></div>
            </div>
          </div>
          <!-- === FIN NUEVO === -->
          <div class="enemy-sprite" id="enemySprite">👹</div>
          <h3 id="enemyName">Demonio</h3>
          <div>Vida: <span id="enemyHp">80/80</span></div>
          <div class="stat-bar">
            <div
              class="stat-fill hp-fill"
              id="enemyHpBar"
              style="width: 100%"
            ></div>
            <div
              class="stat-fill hp-fill"
              id="enemyHpBar"
              style="width: 100%"
            ></div>
          </div>
        </div>
      </div>

      <div class="battle-actions">
        <div class="action-buttons" id="battleActionButtons">
          {/* Botones de batalla se generan por JS */}
        </div>
        <div class="log" id="battleLog"></div>
      </div>
    </div>

    <!-- Modal para Cultivo Activo  -->
    <div class="modal" id="activeCultivationModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="activeCultivationTitle">Cultivando...</h3>
        <p id="activeCultivationDescription">Concentrando tu energía...</p>

        <div id="activeCultivationProgressUI" style="display: none">
          <p>
            Progreso:
            <span id="activeCultivationTargetName">Técnica X</span> (Nv.
            <span id="activeCultivationTargetLevel">Y</span>)
          </p>
          <div class="stat-bar" style="background: #444; margin: 10px 0">
            <div
              class="stat-fill exp-fill"
              id="activeCultivationProgressBar"
              style="
                width: 0%;
                background: linear-gradient(90deg, #ffd700, #ffae42);
              "
            ></div>
          </div>
          <p id="activeCultivationProgressText">0s / 0s</p>
        </div>

        <div
          id="recoveryCultivationProgressUI"
          style="display: none; margin-top: 15px"
        >
          <p>Absorbiendo Qi del entorno...</p>
          <div
            class="stat-bar"
            style="background: #2c1810; margin: 10px 0; border-color: #66ccff"
          >
            <div
              class="stat-fill"
              id="recoveryProgressBar"
              style="
                width: 0%;
                background: linear-gradient(90deg, #66ccff, #99ddff);
                transition: width 0.9s linear;
              "
            ></div>
          </div>
          <p><span id="recoveryCycleText"></span></p>

          <!-- SECCIÓN DE BARRAS DE HP Y MANÁ PARA RECUPERACIÓN (ya existente, la usaremos) -->
          <div style="margin-top: 15px; font-size: 0.9em">
            <div>Vida: <span id="modalHpText">100/100</span></div>
            <div class="stat-bar">
              <!-- Barra de HP en Modal -->
              <div
                class="stat-fill hp-fill"
                id="modalHpBar"
                style="width: 100%"
              ></div>
            </div>

            <div>Maná: <span id="modalManaText">50/50</span></div>
            <div class="stat-bar">
              <!-- Barra de Maná en Modal -->
              <div
                class="stat-fill mana-fill"
                id="modalManaBar"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <!-- FIN SECCIÓN BARRAS -->
        </div>
        <!-- NUEVA SECCIÓN PARA ACELERACIÓN -->
        <div
          id="cultivationBoostSection"
          style="
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #555;
          "
        >
          <p>
            Piedras Espirituales:
            <span id="cultivationModalPlayerStones">0</span>
          </p>
          <button
            id="boostCultivationButton"
            onclick="boostCultivationProgress()"
            style="margin-top: 8px; width: 100%"
          >
            ⚡ Acelerar Cultivo (1 Piedra = 10s)
          </button>
        </div>

        <button onclick="stopCultivation()" style="margin-top: 20px">
          🚫 Detener Cultivo
        </button>
      </div>
    </div>

    <!-- Modal para tienda -->
    <div class="modal" id="shopModal">
      <div class="modal-content">
        {/* Estilos de ancho/alto ya definidos en CSS */ }
        <div class="shop-header">
          <h2 id="shopName">Pabellón de Tesoros del Dragón Oculto</h2>
          <div class="shop-stats">
            <span id="playerSpiritualStones">Piedras Espirituales: 0</span>
          </div>
        </div>
        <div class="shop-container">
          <div class="shop-filters">
            <h3 class="section-title">Filtros</h3>
            <input
              type="text"
              class="search-box"
              id="shopSearch"
              placeholder="Buscar..."
            />
            <div class="filter-group">
              <div class="filter-title">Categorías</div>
              <ul class="category-list" id="shopCategories">
                <li class="category-item active" data-category="all">Todas</li>
                <li class="category-item" data-category="combat">T. Combate</li>
                <li class="category-item" data-category="cultivation">
                  T. Cultivo
                </li>
                <li class="category-item" data-category="weapon">Armas</li>
                <li class="category-item" data-category="armor">Armaduras</li>
                <li class="category-item" data-category="consumable">
                  Consumibles
                </li>
                <li class="category-item" data-category="material">
                  Materiales
                </li>
                <li class="category-item" data-category="scroll">Rollos</li>
              </ul>
            </div>
            <div class="filter-group">
              <div class="filter-title">Rango de Precio</div>
              <div>
                <input
                  type="range"
                  id="priceRange"
                  min="0"
                  max="1000"
                  value="1000"
                  style="width: 100%"
                />
              </div>
              <div
                style="
                  display: flex;
                  justify-content: space-between;
                  font-size: 0.8em;
                "
              >
                <span>0 PS</span><span id="priceRangeValue">1000 PS</span>
              </div>
            </div>
          </div>
          <div class="shop-products">
            <h3 class="section-title">Técnicas y Objetos</h3>
            <div class="products-grid" id="shopProducts"></div>
            <div class="pagination" id="shopPagination"></div>
          </div>
        </div>
        <div>
          <button onclick="closeShopModal()" style="margin-top: 20px">
            Salir de la Tienda
          </button>
        </div>
      </div>
    </div>

    <!-- Modal para Secta -->
    <div class="modal" id="sectHallModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 id="sectHallModalTitle">Salón de la Secta del Viento Azure</h3>
        <div id="sectHallOptions">
          <p>
            Bienvenido, Discípulo <span id="sectHallPlayerRank">Externo</span>.
          </p>
          <p>Puntos de Contribución: <span id="sectHallPlayerPCS">0</span></p>
          <hr />
          <h4>Tablón de Misiones</h4>
          <div
            id="sectHallAvailableMissions"
            style="
              max-height: 150px;
              overflow-y: auto;
              margin-bottom: 10px;
              border: 1px solid #444;
              padding: 5px;
            "
          >
            <p>Habla con el Guía Lin para nuevas asignaciones.</p>
          </div>
          <h4>Contribuciones a la Secta</h4>
          <div id="sectHallContributions" style="margin-bottom: 10px">
            <p>Visita al Administrador Yao para entregar recursos.</p>
          </div>
          <h4>Desafíos de Rango</h4>
          <div id="sectHallRankChallenges" style="margin-bottom: 10px">
            <p id="sectHallChallengeStatus">
              Consulta con el Maestro de la Arena.
            </p>
          </div>
          <h4>Tienda de la Secta</h4>
          <button onclick="openSectShop()">Visitar Depósito de la Secta</button>
          <hr />
        </div>
        <button
          onclick="closeSectHallModal()"
          style="display: block; margin: 20px auto 0"
        >
          Salir del Salón
        </button>
      </div>
    </div>

    <!-- Modal para Selección de Cultivo -->
    <div class="modal" id="cultivationChoiceModal">
      <div class="modal-content" style="max-width: 500px; text-align: left">
        <h3>¿Qué deseas cultivar?</h3>
        <div id="cultivationOptionsContainer">
          <button
            class="cultivation-option-btn"
            onclick="startCultivationMode('recovery')"
          >
            🧘 Meditación Restauradora
          </button>
          <hr />
          <h4>Cultivar Técnica:</h4>
          <div
            id="cultivableTechniquesList"
            style="max-height: 200px; overflow-y: auto"
          ></div>
        </div>
        <button
          onclick="closeCultivationChoiceModal()"
          style="margin-top: 20px"
        >
          Cancelar
        </button>
      </div>
    </div>

    <!-- Modal genérico para interacciones y notificaciones -->
    <div class="modal" id="interactionModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="modalTitle">Título del Modal</h3>
        <p
          id="modalText"
          style="margin-top: 15px; margin-bottom: 20px; line-height: 1.5"
        >
          Texto.
        </p>
        <button onclick="closeModal()" class="close-modal-btn">Cerrar</button>
      </div>
    </div>

    <!-- Modal para Técnicas -->
    <div class="modal" id="techniqueModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">Técnicas Aprendidas</h3>
        <div
          id="learnedTechniquesContainer"
          style="
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
          "
        ></div>
        <button
          onclick="closeTechniqueModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>
    <!-- BARRA DE NAVEGACIÓN INFERIOR FIJA -->
    <nav class="bottom-nav-bar" id="bottomNavBar">
      <button class="nav-button" id="navBtnInventory">
        <span class="nav-icon">🎒</span>
        <span class="nav-text">Inventario</span>
      </button>
      <button class="nav-button" id="navBtnCharacter">
        <span class="nav-icon">👤</span>
        <span class="nav-text">Personaje</span>
      </button>
      <button class="nav-button" id="navBtnCultivate">
        <span class="nav-icon">🧘</span>
        <span class="nav-text">Cultivar</span>
      </button>
      <button class="nav-button" id="navBtnTechniques">
        <span class="nav-icon">📖</span>
        <span class="nav-text">Técnicas</span>
      </button>
      <button class="nav-button" id="navBtnMenu">
        <span class="nav-icon">☰</span>
        <span class="nav-text">Menú</span>
      </button>
    </nav>
    <script>
      const bottomNavBar = document.getElementById("bottomNavBar");
      const navBtnInventory = document.getElementById('navBtnInventory');
        console.log("Botón de Inventario (navBtnInventory):", navBtnInventory);     
      const navBtnCharacter = document.getElementById("navBtnCharacter");
      const navBtnCultivate = document.getElementById("navBtnCultivate");
      const navBtnTechniques = document.getElementById("navBtnTechniques");
      const navBtnMenu = document.getElementById("navBtnMenu");
      // --- ESTADO DEL JUEGO ---
      // --- ESTADO DEL JUEGO ---
      let gameState = {
        /* ... (tu gameState existente sin cambios) ... */
      };
      // Estado del juego y datos principales
      gameState = {
        player: {
          x: 11,
          y: 15,
          level: 1,
          baseMaxHp: 100,
          baseMaxMana: 50,
          baseAttack: 15,
          baseDefense: 5,
          hp: 100,
          maxHp: 100,
          mana: 50,
          maxMana: 50,
          attack: 15,
          defense: 5,
          exp: 0,
          expToNext: 100,
          realm: "Mortal",
          isCultivating: false,
          cultivationMode: {
            type: null,
            targetId: null,
            startTime: 0,
          },
          cultivationStartTime: 0,
          qiPerSecondBase: 1,
          expPerSecondBase: 0.5,
          hpPerSecondBase: 1,
          learnedTechniques: {},
          activeRefiningTechniqueId: null,
          canUseQiConversion: false,
          isQiConversionActive: false,
          worldState: {
            defeatedBosses: {},
            currentBossToSpawn: "boss_demon_general",
            defeatedFixedEntities: {},
          },
          secta: {
            nombre: "Secta del Viento Azure",
            rango: "Discípulo Externo",
            puntosContribucion: 0,
            misionesActivas: [],
            misionesCompletadas: {},
            rivalesDerrotadosClave: {},
          },
          // ---- PROPIEDADES DE ANIMACIÓN DEL SPRITE - ASEGÚRATE QUE ESTÉN AQUÍ Y CORRECTAS ----
          spriteSheetUrl: "img/personaje_cultivador_spritesheet.png",
          frameWidth: 64, // Ancho de un solo frame del sprite
          frameHeight: 64, // Alto de un solo frame del sprite
          directionRowMap: {
            // Mapeo de dirección a la fila Y en la hoja de sprites (0-indexed)
            down: 0, // Fila 0 para mirar/caminar hacia abajo
            left: 1, // Fila 1 para mirar/caminar hacia la izquierda
            right: 2, // Fila 2 para mirar/caminar hacia la derecha
            up: 3, // Fila 3 para mirar/caminar hacia arriba
          },
          animationFrames: 4, // Número de frames por dirección en la hoja
          currentFrame: 0, // Frame actual de la animación (0 a animationFrames - 1)
          currentDirection: "down", // Dirección inicial: 'up', 'down', 'left', 'right'
          isMoving: false,
          animationTimer: null, // Para el intervalo de la animación de caminar
          idleTimeout: null, // Para volver al estado idle después de moverse
          animationSpeed: 150, // Milisegundos entre frames de animación
          // ---- FIN PROPIEDADES DE ANIMACIÓN ----
          // NUEVO: Para animación de sprites
          sprites: {
            idle: "img/personaje_cultivador_idle.png", // O 'img/personaje_cultivador_down.png' si es tu frontal
            up: "img/personaje_cultivador_up.png",
            down: "img/personaje_cultivador_down.png",
            left: "img/personaje_cultivador_left.png",
            right: "img/personaje_cultivador_right.png",
          },
          currentSpriteKey: "idle", // 'idle', 'up', 'down', 'left', 'right'
          movementAnimationTimeout: null,
          // FIN NUEVO
          burningTurns: 0,
          burnDamage: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          defenseBoostTurns: 0,
          defenseBoostAmount: 0,
          dodgeNextAttack: false,
          healingRainTurns: 0,
          healingRainAmount: 0,
          // Para Ritual de Sangre
          bloodRitualTurns: 0,
          bloodRitualAttackBoost: 0,
          // Para Aura de Pureza
          immuneTurns: 0,
          // Para Clon Fantasma
          cloneActive: false,
          cloneHealth: 0,
          cloneTurns: 0,
          // Para Elemental
          elementalTurns: 0,
          tempAttackBonus: 0,
          tempDefenseBonus: 0,
          // Para Barrera Mística
          magicShieldValue: 0,
          magicShieldTurns: 0,
          // Para Cambio Temporal (si se implementa un efecto directo)
          temporalShiftTurns: 0,
        },
        cultivationInterval: null,
        inventory: {
          "Piedras Espirituales": 0,
          "Hierbas Medicinales": 0,
          "Cristales de Qi": 0,
        },
        map: {
          width: 200, // Más pequeño para pruebas iniciales
          height: 200,
          defaultTerrain: "GRASSLAND",
          terrainZones: [
            // Ejemplo de Zona de Inicio cerca de la Secta (PRADERA)
            {
              x1: 10,
              y1: 10,
              x2: 29,
              y2: 29,
              type: "GRASSLAND",
              name: "Praderas de la Secta",
              spawnSettings: {
                targetEntities: [
                  // Lista de objetivos de spawn para esta zona
                  {
                    entityTypeId: "monster_secta_debil",
                    count: 10,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster", count: 10, currentCount: 0 },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "cristal_qi", count: 3, currentCount: 0 },
                  {
                    entityTypeId: "cultivator_rival_low",
                    count: 5,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0, // Cuando llegue a 0, puede reaparecer
                respawnCooldown: 300, // Segundos para reaparecer después de vaciarse o parcialmente
                lastSpawnCheck: 0, // Timestamp del último intento de spawn
              },
            },
            // Bosque Esmeralda
            {
              x1: 30,
              y1: 10,
              x2: 59,
              y2: 39,
              type: "FOREST",
              name: "Bosque Esmeralda",
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_bosque_lobo",
                    count: 8,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_bosque_arana",
                    count: 5,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster_alpha", count: 5, currentCount: 0 },
                ],
                respawnTimer: 0,
                respawnCooldown: 450, // Más lento para recursos quizá
                lastSpawnCheck: 0,
              },
            },
            // Desierto Abrasador
            {
              x1: 10,
              y1: 40,
              x2: 89,
              y2: 69,
              type: "DESERT",
              name: "Desierto Abrasador",
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_desierto_escorpion",
                    count: 7,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_desierto_golem_arena",
                    count: 2,
                    currentCount: 0,
                    isElite: true,
                  }, // Golem como elite
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },
            // RUINAS
            {
              x1: 10,
              y1: 100,
              x2: 45,
              y2: 250,
              type: "RUINS",
              name: "Ruinas antiguas",
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "boss_ancient_golem",
                    count: 20,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "esqueleto_podrido",
                    count: 25,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // Ciénaga Sombría
            {
              x1: 35,
              y1: 15,
              x2: 45,
              y2: 25,
              type: "SWAMP",
              name: "Ciénaga Sombría",
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_cienaga_serpiente",
                    count: 4,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // ... otras zonas (montañas, ruinas, agua sin spawns de monstruos terrestres)
            {
              x1: 0,
              y1: 0,
              x2: 199,
              y2: 9,
              type: "MOUNTAIN",
              name: "Montañas del Norte",
            }, // Sin spawnSettings = no spawns
            // ...
            // ARENA DE LA SECTA
            {
              x1: 2,
              y1: 12,
              x2: 8,
              y2: 17, // Ejemplo de coordenadas (ajusta según tu mapa)
              type: "ARENA", // Puedes usar 'DESERT' o crear un G_TERRAIN_TYPES.ARENA
              name: "Arena de la Secta",
              // No necesita spawnSettings por ahora, a menos que quieras pequeños mobs decorativos allí.
            },
          ],
          terrainGrid: null,
          entities: [],
        },
        battle: {
          active: false,
          enemy: null,
          playerTurn: true,
        },
        gameTime: 0, // Un simple contador de segundos del juego para los temporizadores
        lastGameTimeUpdate: Date.now(),
        activeCombatAbilities: [],
      };

      // --- CONSTANTES Y DATOS DEL JUEGO --- (sin cambios, deben estar aquí)
      let G_TILE_SIZE = 100; // Valor por defecto para escritorio
      const G_PLAYER_DISCOVERY_RANGE = 3;
      // --- VARIABLES GLOBALES ADICIONALES PARA CONTROL UI MÓVIL ---
      let mapControlsManuallyHidden = false;
      let currentTileSize = G_TILE_SIZE; // Usaremos este para los cálculos de renderizado
      let recoveryProgress = 0;
      let recoveryDirection = 1; // 1 para aumentar, -1 para disminuir
      const RECOVERY_CYCLE_DURATION = 2;
      const G_COMBAT_ENTITY_TYPES = [
        "monster",
        "esqueleto_podrido",
        "bandido_desfiladero",
        "monster_desierto_escorpion",
        "monster_secta_debil",
        "monster_alpha",
        "cultivator_rival_low",
        "cultivator_adept_hostile",
        "boss_demon_general",
        "boss_ancient_golem",
        "monster_cienaga_serpiente",
        "monster_bosque_lobo",
        "monster_bosque_arana",
        "monster_desierto_golem_arena",
        "jabali_colmilludo_alfa",
      ];
      const G_MAX_MAP_ENTITIES = 30;
      const G_RESPAWN_THRESHOLD = 15;
      const G_SAFE_RESPAWN_X = 10;
      const G_SAFE_RESPAWN_Y = 10;
      const G_SAFE_RESPAWN_SEARCH_RADIUS = 3;
      const G_TERRAIN_TYPES = {
        GRASSLAND: { symbol: "🟩", color: "#34A853", name: "Pradera" }, // Verde para pastizales
        FOREST: { symbol: "🌲", color: "#1E824C", name: "Bosque" }, // Verde oscuro para bosques
        MOUNTAIN: { symbol: "⛰️", color: "#A9A9A9", name: "Montaña" }, // Gris para montañas
        WATER: { symbol: "🟦", color: "#4A86E8", name: "Agua" }, // Azul para agua (intransitable)
        RUINS: { symbol: "🏛️", color: "#706050", name: "Ruinas" }, // Marrón/Gris para ruinas
        DESERT: { symbol: "🟨", color: "#F9E79F", name: "Desierto" }, // Amarillo claro para desierto
        SWAMP: { symbol: "🟪", color: "#5D3A9A", name: "Pantano" }, // Púrpura/Verde oscuro para pantano
        ARENA: { symbol: "🏟️", color: "#D2B48C", name: "Arena" },
        // Añade más según necesites
      };

      const PLAYER_SPRITE_FRAME_WIDTH = 64; // <--- ¡AJUSTA ESTO AL ANCHO DE UN FRAME DE TU SPRITE!
      const PLAYER_SPRITE_FRAME_HEIGHT = 64; // <--- ¡AJUSTA ESTO AL ALTO DE UN FRAME DE TU SPRITE!
      const PLAYER_ANIMATION_SPEED = 150; // Milisegundos entre frames de caminata (ajusta a gusto)
      const PLAYER_WALK_CYCLE = [0, 1, 0, 2]; // Los frames de columna a ciclar para caminar.
      // Si tu animación es 0-1-2-1, sería [0,1,2,1]
      // Si es 0-1-0-2 sería [0,1,0,2] (para un efecto de pie y luego paso)
      // Para tu sprite de 4 frames por dirección: [0, 1, 2, 3] y el frame 0 es el de "quieto"
      // o puedes usar [1,2,3,0] si el 0 es un frame de paso
      // Una animación común es "quieto" -> paso1 -> "quieto" -> paso2
      // O para ciclo continuo: paso1 -> paso2 -> paso3 -> paso4 -> paso1 ...
      // Para el sprite que mostraste, parece ser:
      // Frame 0: Quieto
      // Frame 1: Paso A
      // Frame 2: Quieto (o un frame intermedio)
      // Frame 3: Paso B
      // Entonces un ciclo podría ser [0, 1, 0, 3] o [1,0,3,0] para animación mientras se mueve
      // O si todos son frames de paso: [0,1,2,3]
      // VAMOS A USAR UN CICLO [1,0,3,0] (asumiendo frame 0 es el base/quieto y 1,3 son pasos)
      // Si el frame 0 es un paso y el personaje se "desliza" al estar quieto, cambia esto.
      // Definir las posiciones Y del sprite sheet para cada dirección
      const PLAYER_SPRITE_DIRECTIONS_Y = {
        down: 0 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 1 (índice 0) para caminar hacia abajo
        left: 1 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 2 (índice 1) para caminar hacia la izquierda
        right: 2 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 3 (índice 2) para caminar hacia la derecha
        up: 3 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 4 (índice 3) para caminar hacia arriba
      };
      // Podríamos añadir una propiedad 'walkable' a cada tipo de terreno
      G_TERRAIN_TYPES.MOUNTAIN.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.WATER.walkable = false;
      // Por defecto, asumimos que son transitables si no se especifica 'walkable: false'
      const G_BLOCKING_ENTITY_TYPES = [
        "shop",
        "secta_entrada_principal",
        "npc_secta_guia",
        "npc_secta_admin",

        // Añade aquí otros 'originalEntityTypeId' o 'type' de entidades que deben bloquear
        // Por ejemplo, si tus NPCs tienen un 'type' específico o los identificas por 'npcId'
      ];
      const SECTA_DATA = {
        nombre: "Secta del Viento Azure",
        rangos: [
          {
            nombre: "Discípulo Externo",
            pcsRequeridos: 0,
            beneficios: "Acceso básico a la secta.",
          },
          {
            nombre: "Discípulo Interno",
            pcsRequeridos: 50,
            desafioRivalId: "rival_interno_1",
            beneficios:
              "Acceso al Patio Interno, misiones de mayor nivel, +5% ganancia de Qi al cultivar en la secta.",
          },
          {
            nombre: "Discípulo Principal",
            pcsRequeridos: 200,
            desafioRivalId: "rival_principal_1",
            beneficios:
              "Acceso a la Biblioteca de Técnicas (nuevas técnicas), +10% ganancia de EXP en misiones de secta.",
          },
          {
            nombre: "Diácono",
            pcsRequeridos: 500,
            desafioRivalId: "guardian_diacono_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir pequeños grupos de discípulos (mecánica futura).",
          },
          {
            nombre: "Anciano",
            pcsRequeridos: 1500,
            desafioRivalId: "guardian_anciano_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir medianos grupos de discípulos (mecánica futura).",
          },
          {
            nombre: "Gran Anciano",
            pcsRequeridos: 2500,
            desafioRivalId: "guardian_gran_anciano_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir grandes grupos de discípulos (mecánica futura).",
          },
          {
            nombre: "Maestro de Secta",
            pcsRequeridos: 5000,
            desafioRivalId: "guardian_maestro_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir la secta completa (mecánica futura).",
          },
        ],
        npcs: {
          guia_lin: {
            nombre: "Guía Lin",
            rol: "Maestro de Reclutas",
            dialogoInicial:
              "Bienvenido, joven aspirante... ¿Estás listo para empezar?",
            misionesOfrecidas: [
              "mision_recolectar_hierbas_1", // Aunque la entrega sea a Yao, Lin puede ofrecerla
              "mision_eliminar_demonios_1",
              "mision_lobos_bosque_1", // Nueva misión ofrecida por Lin
              "mision_cultivador_hostil_1", // Nueva misión ofrecida por Lin
              "mision_componentes_alquimia_1",
              "mision_investigar_anomalia_1",
              "mision_cazar_bestia_especifica_1",
              "mision_escolta_mercader_1",
              "mision_recuperar_artefacto_1",
              // ... añade más ID de misiones que Lin ofrezca
            ],
          },
          admin_yao: {
            nombre: "Administrador Yao",
            rol: "Intendente de la Secta",
            dialogoInicial:
              "Entrega recursos valiosos o completa encargos para ganar Puntos de Contribución. También puedes adquirir algunos suministros aquí.",
            aceptaRecursos: [
              "Hierbas Medicinales",
              "Cristales de Qi",
              "Núcleo de Bestia Menor",
            ], // ...etc.
            tiendaSectaId: "tienda_secta_basica",
            misionesOfrecidas: [
              "mision_escorpiones_desierto_1", // Nueva misión ofrecida por Yao
              // ... añade más ID de misiones que Yao ofrezca
            ],
          },
        },
      };
      const MISIONES_DATA = {
        mision_recolectar_hierbas_1: {
          titulo: "Suministros para la Enfermería",
          descripcion:
            "La hermana mayor Mei necesita 10 Hierbas Medicinales para reponer las existencias de la enfermería. Recolecta Hierbas Medicinales y entrégaselas al Administrador Yao.",
          objetivo: {
            tipo: "entregar_item",
            item: "Hierbas Medicinales",
            cantidad: 10,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 50,
            exp: 100,
            items: { "Piedras Espirituales": 20 },
          },
          npcInicio: "guia_lin",
        },
        mision_eliminar_demonios_1: {
          titulo: "Limpiando el Bosque Periférico",
          descripcion:
            "Pequeños demonios han estado merodeando el bosque cercano a la secta. Elimina 5 Demonios Menores para asegurar el área.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster",
            cantidad: 5,
            nombreDisplay: "Demonio Menor",
          },
          recompensa: {
            pcs: 75,
            exp: 150,
            items: { "Piedras Espirituales": 30 },
          },
          progreso: 0,
          npcInicio: "guia_lin",
        },
        mision_componentes_alquimia_1: {
          titulo: "Medicina Urgente",
          descripcion:
            "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Raíces de Fuego Terrenal' para una píldora vital. Se dice que crecen en zonas con fluctuaciones elementales.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "Flor de Luna Escarchada", cantidad: 3 },
              { nombre: "Raíz de Fuego Terrenal", cantidad: 2 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 250,
            items: {
              "Píldora de Recuperación Menor": 2,
              "Piedras Espirituales": 50,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
        },
        mision_investigar_anomalia_1: {
          titulo: "Anomalía en el Bosque Susurrante",
          descripcion:
            "Se han reportado extraños susurros y una energía inquietante proveniente del Bosque Susurrante al este. Investiga la fuente de la perturbación y reporta tus hallazgos.",
          objetivo: {
            tipo: "explorar_y_reportar",
            areaClave: "BosqueSusurranteAnomalia",
            npcReporte: "guia_lin",
          },
          recompensa: {
            pcs: 100,
            exp: 200,
            items: { "Talismán de Percepción": 1 },
          },
          npcInicio: "guia_lin",
        },
        mision_cazar_bestia_especifica_1: {
          titulo: "La Amenaza del Jabalí Colmilludo",
          descripcion:
            "Un Jabalí Colmilludo particolarmente agresivo ha estado atacando a los recolectores de la secta cerca del Cañón Rocoso. Caza a esta bestia y trae su 'Colmillo intacto' como prueba.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "jabali_colmilludo_alfa",
            itemPrueba: "Colmillo de Jabalí Alfa",
            cantidadItemPrueba: 1,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 300,
            items: { "Piedras Espirituales": 70, "Carne de Bestia Exótica": 3 },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 5,
        },
        mision_escolta_mercader_1: {
          titulo: "Protección Mercantil",
          descripcion:
            "Un mercader aliado de la secta necesita una escolta para atravesar el Desfiladero Sombrío, conocido por sus bandidos. Asegúrate de que llegue a salvo al Puesto Comercial del Oeste.",
          objetivo: {
            tipoSimplificado: "eliminar_enemigos_en_area",
            enemigoTipo: "bandido_desfiladero",
            cantidad: 5,
            areaNombre: "Desfiladero Sombrío",
            npcReporte: "admin_yao",
          },
          recompensa: {
            pcs: 250,
            exp: 500,
            items: {
              "Mapa del Tesoro Fragmentado": 1,
              "Piedras Espirituales": 150,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
        },
        mision_recuperar_artefacto_1: {
          titulo: "El Compás Espiritual Perdido",
          descripcion:
            "Un antiguo Compás Espiritual, vital para la navegación en las Ruinas Olvidadas, fue robado por cultores renegados. Infíltrate en su campamento en las colinas y recupera el artefacto.",
          objetivo: {
            tipo: "derrotar_mini_boss_y_recuperar_item",
            enemigoMiniBossId: "lider_renegado_1",
            itemArtefacto: "Compás Espiritual Antiguo",
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 300,
            exp: 600,
            items: {
              "Manual de Formación Básica": 1,
              "Piedras Espirituales": 200,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
          requisitoNivel: 8,
        },
        mision_desafio_interno_1: {
          titulo: "Prueba de Discípulo Interno",
          descripcion:
            "Para ser reconocido como Discípulo Interno, debes demostrar tu fuerza venciendo al Guardián de la Prueba, Han Li. Encuéntralo en la arena de desafíos de la secta.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_interno_1",
          },
          recompensa: { pcs: 200, exp: 300, nuevoRango: "Discípulo Interno" },
          autoActivarAlCumplirRequisitos: true,
        },
        mision_desafio_principal_1: {
          titulo: "Prueba de Discípulo Principal",
          descripcion:
            "La Anciana Shui espera en la arena. Demuestra que eres digno del rango de Discípulo Principal.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_principal_1",
          },
          recompensa: { pcs: 500, exp: 800, nuevoRango: "Discípulo Principal" },
          autoActivarAlCumplirRequisitos: true,
        },
        // Misiones de Ejemplo por Nivel:
        mision_lobos_bosque_1: {
          titulo: "Amenaza Lupina",
          descripcion:
            "Una manada de Lobos del Bosque se ha vuelto agresiva. El Guía Lin te pide que elimines 3 de ellos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_bosque_lobo",
            cantidad: 3,
            nombreDisplay: "Lobo del Bosque",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 100,
            exp: 200,
            items: { "Piedras Espirituales": 50, "Colmillo de Lobo": 1 },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 5, // Se desbloquea al nivel 5
        },
        mision_escorpiones_desierto_1: {
          titulo: "Aguijones Peligrosos",
          descripcion:
            "Los Escorpiones de las Dunas están causando problemas a las caravanas. Elimina 5 y reporta al Administrador Yao.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_desierto_escorpion",
            cantidad: 5,
            nombreDisplay: "Escorpión de las Dunas",
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 150,
            exp: 350,
            items: { "Piedras Espirituales": 70, "Aguijón de Escorpión": 2 },
          },
          npcInicio: "admin_yao", // Puede ser otro NPC
          requisitoNivel: 10, // Se desbloquea al nivel 10
        },
        mision_cultivador_hostil_1: {
          titulo: "Rivalidad Temprana",
          descripcion:
            "Un Cultivador Novato Hostil ha estado desafiando a discípulos de nuestra secta. El Guía Lin quiere que le des una lección. Derrótalo.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivator_rival_low",
            cantidad: 1,
            nombreDisplay: "Cultivador Novato Hostil",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 200,
            exp: 400,
            items: {
              "Píldora de Recuperación Menor": 1,
              "Piedras Espirituales": 100,
            },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 8,
        },
        // Asegúrate de que las misiones que quieres que se entreguen a un NPC tengan `npcEntrega` en su `objetivo`.
        mision_componentes_alquimia_1: {
          titulo: "Medicina Urgente",
          descripcion:
            "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Raíces de Fuego Terrenal' para una píldora vital. Se dice que crecen en zonas con fluctuaciones elementales. Entrégalas al Administrador Yao.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "Flor de Luna Escarchada", cantidad: 3 },
              { nombre: "Raíz de Fuego Terrenal", cantidad: 2 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 250,
            items: {
              "Píldora de Recuperación Menor": 2,
              "Piedras Espirituales": 50,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
        },
        mision_cazar_bestia_especifica_1: {
          titulo: "La Amenaza del Jabalí Colmilludo",
          descripcion:
            "Un Jabalí Colmilludo particolarmente agresivo ha estado atacando a los recolectores de la secta cerca del Cañón Rocoso. Caza a esta bestia y trae su 'Colmillo intacto' como prueba al Guía Lin.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "jabali_colmilludo_alfa",
            itemPrueba: "Colmillo de Jabalí Alfa",
            cantidadItemPrueba: 1,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 300,
            items: { "Piedras Espirituales": 70, "Carne de Bestia Exótica": 3 },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 5,
        },
      };

      const shopData = {
        name: "Pabellón de Tesoros del Dragón Oculto",
        inventory: [
          { itemName: "Hierbas Medicinales", price: 1, stock: 100 },
          { itemName: "Cristales de Qi", price: 1, stock: 100 },
          {
            itemName: "Espada de Hierro",
            type: "equipment",
            category: "weapon",
            attackBonus: 5,
            price: 50,
            stock: 1,
            description: "Una espada básica pero fiable. (+5 Ataque)",
          },
          { itemName: "Rollo: Absorción de Qi Menor", price: 15, stock: 10 },
          { itemName: "Rollo: Corte de Espada Básico", price: 50, stock: 10 },
          { itemName: "Rollo: Conversión de Qi", price: 25, stock: 10 },
          { itemName: "Rollo: Prisión de Hielo", price: 180, stock: 5 },
          { itemName: "Rollo: Golpe de Llamas", price: 170, stock: 5 },
          { itemName: "Rollo: Furia del Trueno", price: 190, stock: 5 },
          { itemName: "Rollo: Dardo Venenoso", price: 150, stock: 5 },
          { itemName: "Rollo: Piel de Piedra", price: 175, stock: 5 },
          { itemName: "Rollo: Paso de las Sombras", price: 220, stock: 3 },
          { itemName: "Rollo: Drenaje de Alma", price: 200, stock: 3 },
          { itemName: "Rollo: Golpe Ciclón", price: 250, stock: 3 },
          { itemName: "Rollo: Lluvia Curativa", price: 210, stock: 3 },
          { itemName: "Rollo: Explosión Mental", price: 230, stock: 3 },
          { itemName: "Rollo: Voluntad de Hierro", price: 200, stock: 3 },
          { itemName: "Rollo: Flecha Celestial", price: 280, stock: 2 },
          { itemName: "Rollo: Abrazo de la Naturaleza", price: 190, stock: 3 },
          { itemName: "Rollo: Rugido de Dragón", price: 300, stock: 2 },
          { itemName: "Rollo: Clon Fantasma", price: 240, stock: 2 },
          { itemName: "Rollo: Cambio Temporal", price: 260, stock: 2 },
          { itemName: "Rollo: Ritual de Sangre", price: 210, stock: 3 },
          { itemName: "Rollo: Aura de Pureza", price: 230, stock: 3 },
          { itemName: "Rollo: Invocar Elemental", price: 320, stock: 1 },
          { itemName: "Rollo: Barrera Mística", price: 220, stock: 3 },
        ],
      };
      const techniqueData = {
        qi_absorption_boost_1: {
          id: "qi_absorption_boost_1",
          name: "Técnica de Absorción de Qi Menor",
          description:
            "Aumenta la cantidad de Qi ganado por segundo al cultivar en 0.5.",
          type: "passive_cultivation",
          effect: { statToBoost: "qiPerSecondBase", value: 0.5 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 60,
            levelTimeMultiplier: 1.5,
          },
          refinementCost: {
            baseTime: 30,
            materials: { "Piedras Espirituales": 20 },
            levelRequirement: 1,
          },
          icon: "📜",
        },
        body_fortification_1: {
          id: "body_fortification_1",
          name: "Fortificación Corporal Básica",
          description:
            "Aumenta tu Defensa base permanentemente en 1 por nivel de refinamiento.",
          type: "passive_stat",
          effect: { statToBoost: "baseDefense", value: 1 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 2,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Hierbas Medicinales": 3, "Piedras Espirituales": 10 },
            levelRequirement: 3,
          },
          icon: "💪",
        },
        sword_slash_1: {
          id: "sword_slash_1",
          name: "Corte de Espada Básico",
          description:
            "Desbloquea la habilidad de combate 'Corte de Espada'. Causa daño físico adicional. Mejora con refinamiento.",
          type: "active_ability",
          abilityId: "sword_slash",
          effect: { baseDamageMultiplier: 1.2 },
          manaCost: 10,
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          refinementCost: {
            baseTime: 45,
            materials: { "Cristales de Qi": 2, "Piedras Espirituales": 20 },
            levelRequirement: 5,
          },
          icon: "⚔️",
        },
        qi_to_hp_conversion_1: {
          id: "qi_to_hp_conversion_1",
          name: "Técnica de Conversión de Qi",
          description:
            "Permite activar/desactivar la conversión de Maná en HP al cultivar. Mejora la tasa de conversión y eficiencia con cada nivel de refinamiento.",
          type: "active_refinement_effect",
          effect: {
            baseManaCostPerSecond: 2.0,
            baseHpGainPerSecond: 1.0,
            hpGainIncreasePerLevel: 2,
            manaCostReductionPerLevel: 0.1,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Cristales de Qi": 5, "Piedras Espirituales": 10 },
            levelRequirement: 1,
          },
          icon: "☯️",
        },
        ice_prison_1: {
          id: "ice_prison_1",
          name: "Prisión de Hielo",
          description: "Congela al enemigo, inmovilizándolo por 1-2 turnos.",
          type: "active_ability",
          abilityId: "ice_prison",
          effect: { freezeDuration: 1, freezeChance: 0.7, manaCost: 25 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 120,
            levelTimeMultiplier: 1.7,
          },
          refinementCost: {
            baseTime: 40,
            materials: { "Cristal de Hielo": 3, "Piedras Espirituales": 40 },
            levelRequirement: 8,
          },
          icon: "❄️",
        },
        flame_strike_1: {
          id: "flame_strike_1",
          name: "Golpe de Llamas",
          description:
            "Ataque de fuego que causa daño inicial y quemadura continua.",
          type: "active_ability",
          abilityId: "flame_strike",
          effect: {
            baseDamageMultiplier: 0.9,
            burnDamagePerTurn: 5,
            burnDuration: 3,
            manaCost: 30,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 120,
            levelTimeMultiplier: 1.7,
          },
          refinementCost: {
            baseTime: 45,
            materials: { "Esencia de Fuego": 2, "Piedras Espirituales": 35 },
            levelRequirement: 10,
          },
          icon: "🔥",
        },
        thunder_fury_1: {
          id: "thunder_fury_1",
          name: "Furia del Trueno",
          description: "Ataque eléctrico que aturde al enemigo por 1 turno.",
          type: "active_ability",
          abilityId: "thunder_fury",
          effect: { baseDamageMultiplier: 1.1, stunChance: 0.6, manaCost: 35 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 130,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 50,
            materials: { "Núcleo de Tormenta": 1, "Piedras Espirituales": 45 },
            levelRequirement: 12,
          },
          icon: "⚡",
        },
        poison_dart_1: {
          id: "poison_dart_1",
          name: "Dardo Venenoso",
          description: "Envenena al enemigo causando daño por varios turnos.",
          type: "active_ability",
          abilityId: "poison_dart",
          effect: {
            baseDamageMultiplier: 0.4,
            poisonDamagePerTurn: 8,
            poisonDuration: 4,
            manaCost: 20,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 110,
            levelTimeMultiplier: 1.6,
          },
          refinementCost: {
            baseTime: 35,
            materials: { "Venenos Mortales": 4, "Piedras Espirituales": 30 },
            levelRequirement: 6,
          },
          icon: "☠️",
        },
        stone_skin_1: {
          id: "stone_skin_1",
          name: "Piel de Piedra",
          description: "Aumenta tu defensa temporalmente durante el combate.",
          type: "active_ability",
          abilityId: "stone_skin",
          effect: { defenseBoost: 15, duration: 3, manaCost: 25 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 125,
            levelTimeMultiplier: 1.7,
          },
          refinementCost: {
            baseTime: 40,
            materials: { "Fragmentos de Jade": 5, "Piedras Espirituales": 35 },
            levelRequirement: 9,
          },
          icon: "🪨",
        },
        shadow_step_1: {
          id: "shadow_step_1",
          name: "Paso de las Sombras",
          description: "Teletransportación corta que evita el próximo ataque.",
          type: "active_ability",
          abilityId: "shadow_step",
          effect: { dodgeChance: 0.8, manaCost: 40 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 140,
            levelTimeMultiplier: 1.9,
          },
          refinementCost: {
            baseTime: 55,
            materials: { "Esencia Oscura": 3, "Piedras Espirituales": 50 },
            levelRequirement: 14,
          },
          icon: "👣",
        },
        soul_drain_1: {
          id: "soul_drain_1",
          name: "Drenaje de Alma",
          description: "Roba vida del enemigo y cura al usuario.",
          type: "active_ability",
          abilityId: "soul_drain",
          effect: {
            baseDamageMultiplier: 0.7,
            lifeStealPercent: 0.5,
            manaCost: 30,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 130,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 45,
            materials: { "Almas Condenadas": 2, "Piedras Espirituales": 40 },
            levelRequirement: 11,
          },
          icon: "💀",
        },
        cyclone_strike_1: {
          id: "cyclone_strike_1",
          name: "Golpe Ciclón",
          description: "Ataque de área que daña a todos los enemigos.",
          type: "active_ability",
          abilityId: "cyclone_strike",
          effect: { baseDamageMultiplier: 0.8, aoeDamage: true, manaCost: 45 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 150,
            levelTimeMultiplier: 2.0,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Núcleo de Vórtice": 1, "Piedras Espirituales": 55 },
            levelRequirement: 15,
          },
          icon: "🌪️",
        },
        healing_rain_1: {
          id: "healing_rain_1",
          name: "Lluvia Curativa",
          description: "Cura al usuario y a aliados cercanos cada turno.",
          type: "active_ability",
          abilityId: "healing_rain",
          effect: { healPerTurn: 20, duration: 3, manaCost: 35 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 135,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 50,
            materials: { "Rocío Celestial": 4, "Piedras Espirituales": 40 },
            levelRequirement: 12,
          },
          icon: "🌧️",
        },
        mind_blast_1: {
          id: "mind_blast_1",
          name: "Explosión Mental",
          description: "Daño basado en maná y reduce la defensa del enemigo.",
          type: "active_ability",
          abilityId: "mind_blast",
          effect: {
            baseDamageMultiplier: 0.6,
            manaDamageMultiplier: 0.3,
            defenseReduction: 5,
            manaCost: 40,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 145,
            levelTimeMultiplier: 1.9,
          },
          refinementCost: {
            baseTime: 55,
            materials: { "Cristales Psíquicos": 3, "Piedras Espirituales": 45 },
            levelRequirement: 13,
          },
          icon: "🧠",
        },
        iron_will_1: {
          id: "iron_will_1",
          name: "Voluntad de Hierro",
          description:
            "Reduce el daño recibido y aumenta la resistencia a efectos.",
          type: "passive_stat",
          effect: { statToBoost: "damageReduction", value: 0.05 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 160,
            levelTimeMultiplier: 2.1,
          },
          refinementCost: {
            baseTime: 50,
            materials: {
              "Mineral de Hierro Espiritual": 5,
              "Piedras Espirituales": 40,
            },
            levelRequirement: 10,
          },
          icon: "🛡️",
        },
        celestial_arrow_1: {
          id: "celestial_arrow_1",
          name: "Flecha Celestial",
          description:
            "Ataque de largo alcance que ignora la defensa del enemigo.",
          type: "active_ability",
          abilityId: "celestial_arrow",
          effect: {
            baseDamageMultiplier: 1.2,
            ignoreDefense: true,
            manaCost: 50,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 170,
            levelTimeMultiplier: 2.2,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Plumas de Fénix": 2, "Piedras Espirituales": 60 },
            levelRequirement: 16,
          },
          icon: "🏹",
        },
        nature_grasp_1: {
          id: "nature_grasp_1",
          name: "Abrazo de la Naturaleza",
          description:
            "Enreda al enemigo reduciendo su velocidad y causando daño continuo.",
          type: "active_ability",
          abilityId: "nature_grasp",
          effect: {
            baseDamageMultiplier: 0.5,
            rootDuration: 2,
            damagePerTurn: 7,
            manaCost: 30,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 120,
            levelTimeMultiplier: 1.7,
          },
          refinementCost: {
            baseTime: 45,
            materials: {
              "Semillas Ancestrales": 4,
              "Piedras Espirituales": 35,
            },
            levelRequirement: 9,
          },
          icon: "🌿",
        },
        dragon_roar_1: {
          id: "dragon_roar_1",
          name: "Rugido de Dragón",
          description: "Aturde y asusta a los enemigos, reduciendo su ataque.",
          type: "active_ability",
          abilityId: "dragon_roar",
          effect: {
            aoeStunChance: 0.4,
            attackReduction: 10,
            duration: 2,
            manaCost: 55,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 180,
            levelTimeMultiplier: 2.3,
          },
          refinementCost: {
            baseTime: 65,
            materials: { "Escamas de Dragón": 3, "Piedras Espirituales": 70 },
            levelRequirement: 18,
          },
          icon: "🐉",
        },
        phantom_clone_1: {
          id: "phantom_clone_1",
          name: "Clon Fantasma",
          description: "Crea un clon que distrae a los enemigos.",
          type: "active_ability",
          abilityId: "phantom_clone",
          effect: {
            cloneHealth: 30,
            duration: 2,
            aggroChance: 0.8,
            manaCost: 40,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 150,
            levelTimeMultiplier: 2.0,
          },
          refinementCost: {
            baseTime: 50,
            materials: { "Espejos Astrales": 2, "Piedras Espirituales": 45 },
            levelRequirement: 12,
          },
          icon: "👤",
        },
        temporal_shift_1: {
          id: "temporal_shift_1",
          name: "Cambio Temporal",
          description: "Ralentiza a los enemigos y aumenta tu velocidad.",
          type: "active_ability",
          abilityId: "temporal_shift",
          effect: {
            enemySlow: 0.3,
            playerSpeedBoost: 0.4,
            duration: 3,
            manaCost: 45,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 160,
            levelTimeMultiplier: 2.1,
          },
          refinementCost: {
            baseTime: 55,
            materials: { "Relojes de Arena": 3, "Piedras Espirituales": 50 },
            levelRequirement: 14,
          },
          icon: "⏳",
        },
        blood_ritual_1: {
          id: "blood_ritual_1",
          name: "Ritual de Sangre",
          description: "Sacrifica vida para aumentar drásticamente tu ataque.",
          type: "active_ability",
          abilityId: "blood_ritual",
          effect: { hpCost: 20, attackBoost: 30, duration: 3, manaCost: 25 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 130,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 40,
            materials: { "Sangre de Demonio": 3, "Piedras Espirituales": 35 },
            levelRequirement: 11,
          },
          icon: "🩸",
        },
        aura_of_purity_1: {
          id: "aura_of_purity_1",
          name: "Aura de Pureza",
          description: "Elimina efectos negativos y otorga inmunidad temporal.",
          type: "active_ability",
          abilityId: "aura_of_purity",
          effect: { cleanseEffects: true, immunityDuration: 2, manaCost: 35 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 140,
            levelTimeMultiplier: 1.9,
          },
          refinementCost: {
            baseTime: 45,
            materials: {
              "Lágrimas de Unicornio": 2,
              "Piedras Espirituales": 40,
            },
            levelRequirement: 13,
          },
          icon: "✨",
        },
        summon_elemental_1: {
          id: "summon_elemental_1",
          name: "Invocar Elemental",
          description:
            "Invoca un elemental que lucha a tu lado durante el combate.",
          type: "active_ability",
          abilityId: "summon_elemental",
          effect: {
            elementalType: "fire",
            elementalHealth: 50,
            elementalAttack: 20,
            duration: 4,
            manaCost: 60,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 190,
            levelTimeMultiplier: 2.4,
          },
          refinementCost: {
            baseTime: 65,
            materials: { "Núcleo Elemental": 1, "Piedras Espirituales": 65 },
            levelRequirement: 17,
          },
          icon: "🌋",
        },
        mystic_barrier_1: {
          id: "mystic_barrier_1",
          name: "Barrera Mística",
          description: "Crea un escudo que absorbe daño mágico.",
          type: "active_ability",
          abilityId: "mystic_barrier",
          effect: { magicShield: 40, duration: 3, manaCost: 35 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 135,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 45,
            materials: { "Polvo de Arcano": 4, "Piedras Espirituales": 40 },
            levelRequirement: 12,
          },
          icon: "🔮",
        },
      };
      const entityTypes = {
        //FIJOS
        shop: {
          symbol: "🏪",
          name: "Tienda Misteriosa",
          interaction: "browse",
          type: "shop", // 'type' es importante para la interacción
          // fixedX: 12, // Podrías tener esto
          // fixedY: 13, // O esto
          fixedLocation: { x: 12, y: 13 }, // O esto (preferiblemente esto)
          discovered: true, // ¡IMPORTANTE para que se muestre desde el inicio!
        },

        secta_entrada_principal: {
          symbol: "⛩️",
          name: "Salón Principal de la Secta",
          interaction: "access_sect_hall",
          // fixedX: 12, // Si tenías esto antes
          // fixedY: 15, // Si tenías esto antes
          // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 15, y: 15 }, // O las coordenadas correctas para tu secta
        },

        // --- ELEMENTOS DECORATIVOS ---
        deco_arbol_grande: {
          symbol: "🌳",
          name: "Arbol Ancestral",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_pequeño: {
          symbol: "🌳",
          name: "Pino",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_normal: {
          symbol: "🌳",
          name: "Otro arbol",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_roca_musgosa: {
          symbol: "🪨",
          name: "Roca Musgosa",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_ruina_pilar: {
          symbol: "🏛",
          name: "Pilar Caído",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        }, // Usar un símbolo diferente si '🏛️' ya está en uso
        deco_flor_rara: {
          symbol: "🌸",
          name: "Flor Luminiscente",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        }, // Diferente de tu lugar de cultivo
        // ... añade más según necesites
        //NPCS
        master: {
          symbol: "👴",
          name: "Maestro Anciano",
          teaching: "técnica",
          expGain: 50,
          interaction: "learn_from_master",
        },
        npc_secta_guia: {
          symbol: "👨‍🏫",
          name: "Guía Lin",
          interaction: "talk_secta_npc",
          npcId: "guia_lin",
          fixedLocation: { x: 13, y: 15 },
        },
        npc_secta_admin: {
          symbol: " 👴",
          name: "Administrador Yao",
          interaction: "talk_secta_npc",
          npcId: "admin_yao",
          fixedLocation: { x: 13, y: 16 },
        },
        rival_interno_1: {
          symbol: "😠",
          name: "Han Li (Guardián Interno)",
          typeOverride: "monster",
          hp: 250,
          attack: 60,
          defense: 15,
          exp: 150,
          maxHp: 250,
          isSectChallengeRival: true,
          npcId: "rival_interno_1",
          fixedLocation: { x: 5, y: 12 },
        },
        rival_principal_1: {
          symbol: "😡",
          name: "Anciana Shui (Prueba Principal)",
          typeOverride: "monster",
          hp: 600,
          attack: 90,
          defense: 25,
          exp: 400,
          maxHp: 600,
          isSectChallengeRival: true,
          npcId: "rival_principal_1",
          fixedLocation: { x: 4, y: 12 },
          specialChance: 0.2,
          specialAttackMultiplier: 1.6,
        },
        //== FIN NPC===
        //RECURSOS
        cristal_qi: {
          symbol: "💎",
          name: "Cristal de Qi",
          reward: "Cristales de Qi",
          interaction: "collect_resource",
        },
        cultivation: {
          symbol: "🌸",
          name: "Lugar de Cultivo",
          benefit: "mana",
          manaGain: 20,
          interaction: "meditate_spot",
        },
        resource_hierbas_bosque: {
          symbol: "🌿", // <--- ¡ASEGÚRATE DE QUE ESTO ESTÉ!
          name: "Hierbas del Bosque Profundo",
          type: "resource",
          reward: "Hierbas Medicinales",
          interaction: "collect_resource",
        },
        //ENEMIGOS
        monster: {
          symbol: "👹",
          name: "Demonio Menor",
          hp: 60,
          attack: 30,
          defense: 2,
          exp: 25,
          maxHp: 60,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_secta_debil: {
          symbol: "🐾",
          name: "Bestia Menor de Pradera",
          hp: 40,
          attack: 30,
          defense: 1,
          exp: 12,
          maxHp: 40,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_bosque_lobo: {
          symbol: "🐺",
          name: "Lobo del Bosque",
          hp: 70,
          attack: 40,
          defense: 3,
          exp: 20,
          maxHp: 70,
          lootTable: [
            { itemName: "Colmillo de Lobo", quantity: [1, 1], chance: 0.4 },
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.6,
            },
            { itemName: "Carne Fresca", quantity: [1, 2], chance: 0.6 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_bosque_arana: {
          symbol: "🕷️",
          name: "Araña Tejesombras",
          hp: 50,
          attack: 45,
          defense: 5,
          exp: 18,
          maxHp: 50,
          lootTable: [
            { itemName: "Seda de Araña", quantity: [1, 3], chance: 0.7 },
            { itemName: "Veneno Débil", quantity: [1, 1], chance: 0.2 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },

        monster_desierto_escorpion: {
          symbol: "🦂",
          name: "Escorpión de las Dunas",
          hp: 90,
          attack: 30,
          defense: 8,
          exp: 35,
          maxHp: 90,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              name: "Aguijón venenoso",
              damageMultiplier: 2.0,
              chance: 0.2,
              type: "area_attack_simulated",
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Aguijón de Escorpión", quantity: [1, 1], chance: 0.5 },
            { itemName: "Quitina Resistente", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [2, 4], chance: 1 },
          ],
        },
        monster_desierto_golem_arena: {
          symbol: "🧱",
          name: "Golem de Tormenta de Arena",
          hp: 200,
          attack: 35,
          defense: 15,
          exp: 80,
          maxHp: 200,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              name: "Tornado de arena",
              damageMultiplier: 2.0,
              chance: 0.2,
              type: "area_attack_simulated",
            },
            {
              name: "stone_skin_1",
              effect: { defenseBoost: 15, duration: 3, manaCost: 25 },
              chance: 0.2,
              type: "area_attack_simulated",
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Núcleo de Arena", quantity: [1, 1], chance: 0.6 },
            { itemName: "Fragmento Desértico", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
          ],
        },
        monster_cienaga_serpiente: {
          symbol: "🐍",
          name: "Serpiente de Ciénaga",
          hp: 60,
          attack: 28,
          defense: 2,
          exp: 22,
          maxHp: 60,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              name: "Mordida Venenosa",
              damageMultiplier: 2.0,
              chance: 0.4,
              type: "area_attack_simulated",
            },
          ],
          lootTable: [
            { itemName: "Escama de Serpiente", quantity: [1, 2], chance: 0.5 },
            {
              itemName: "Raíz de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.3,
            },
            { itemName: "Veneno de Ciénaga", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [2, 4], chance: 1 },
          ],
        },
        cultivator_rival_low: {
          symbol: "😠",
          name: "Cultivador Novato Hostil",
          hp: 150,
          attack: 50,
          defense: 5,
          exp: 80,
          maxHp: 150,
          specialChance: 0.2,
          specialAttackMultiplier: 1.5,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
          ],
        },
        monster_alpha: {
          symbol: "🐺",
          name: "Demonio Alfa",
          hp: 200,
          attack: 60,
          defense: 4,
          exp: 35,
          maxHp: 200,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            {
              itemName: "Núcleo de Bestia Menor",
              quantity: [1, 1],
              chance: 0.25,
            },
            { itemName: "Cristal de Hielo", quantity: [1, 2], chance: 0.1 },
            { itemName: "Esencia de Fuego", quantity: [1, 2], chance: 0.1 },
            { itemName: "Piedras Espirituales", quantity: [4, 10], chance: 1 },
          ],
        },
        cultivator_adept_hostile: {
          symbol: "😡",
          name: "Cultivador Adepto Agresivo",
          hp: 400,
          attack: 80,
          defense: 10,
          exp: 250,
          maxHp: 400,
          specialChance: 0.25,
          specialAttackMultiplier: 1.7,
          healChance: 0.1,
          lootTable: [
            { itemName: "Piedras Espirituales", quantity: [1, 10], chance: 1 },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Venenos Mortales", quantity: [1, 3], chance: 0.05 },
            { itemName: "Fragmentos de Jade", quantity: [1, 2], chance: 0.02 },
            { itemName: "Esencia Oscura", quantity: [1, 1], chance: 0.05 },
            {
              itemName: "Rollo: Dardo Venenoso",
              quantity: [1, 1],
              chance: 0.05,
            },
            {
              itemName: "Rollo: Piel de Piedra",
              quantity: [1, 1],
              chance: 0.05,
            },
            {
              itemName: "Rollo: Voluntad de Hierro",
              quantity: [1, 1],
              chance: 0.015,
            },
            {
              itemName: "Rollo: Flecha Celestial",
              quantity: [1, 1],
              chance: 0.05,
            },
            {
              itemName: "Rollo: Abrazo de la Naturaleza",
              quantity: [1, 1],
              chance: 0.01,
            },
            {
              itemName: "Rollo: Rugido de Dragón",
              quantity: [1, 1],
              chance: 0.01,
            },
            {
              itemName: "Rollo: Clon Fantasma",
              quantity: [1, 1],
              chance: 0.01,
            },
          ],
        },

        flor_luna_escarchada_guardian: {
          symbol: "❄️",
          name: "Espíritu de Hielo Protector",
          typeOverride: "monster",
          hp: 120,
          attack: 35,
          defense: 10,
          exp: 40,
          maxHp: 120,
          lootTable: [
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.8,
            },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
          ],
        },
        raiz_fuego_terrenal_elemental: {
          symbol: "🔥",
          name: "Elemental de Magma Menor",
          typeOverride: "monster",
          hp: 150,
          attack: 40,
          defense: 5,
          exp: 45,
          maxHp: 150,
          lootTable: [
            {
              itemName: "Raíz de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.7,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [5, 10],
              chance: 0.5,
            },
          ],
        },
        bandido_desfiladero: {
          symbol: "😠",
          name: "Bandido del Desfiladero",
          typeOverride: "monster",
          hp: 180,
          attack: 45,
          defense: 10,
          exp: 60,
          maxHp: 180,
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 30],
              chance: 0.5,
            },
            { itemName: "Daga Oxidada", quantity: [1, 1], chance: 0.2 },
          ],
        },

        esqueleto_podrido: {
          symbol: "💀",
          name: "Esqueleto podrido",
          typeOverride: "monster",
          hp: 180,
          attack: 45,
          defense: 10,
          exp: 60,
          maxHp: 180,
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 30],
              chance: 0.5,
            },
            { itemName: "Daga Oxidada", quantity: [1, 1], chance: 0.2 },
          ],
        },
        //MINIBOSSES
        jabali_colmilludo_alfa: {
          symbol: "🐗",
          name: "Jabalí Colmilludo Alfa",
          typeOverride: "monster",
          hp: 300,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,
          isMiniBoss: true,
          lootTable: [
            {
              itemName: "Colmillo de Jabalí Alfa",
              quantity: [1, 1],
              chance: 0.9,
            },
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },
            { itemName: "Piel Resistente", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [4, 10], chance: 1 },
          ],
          fixedLocation: { x: 5, y: 23 },
        },

        lider_renegado_1: {
          symbol: "👤",
          name: "Líder Cultor Renegado Kai",
          typeOverride: "monster",
          hp: 500,
          attack: 70,
          defense: 25,
          exp: 250,
          maxHp: 500,
          isMiniBoss: true,
          specialChance: 0.25,
          specialAttackMultiplier: 1.6,
          lootTable: [
            {
              itemName: "Compás Espiritual Antiguo",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Píldora de Qi Condensado",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [100, 200],
              chance: 0.8,
            },
          ],
          fixedLocation: { x: 17, y: 12 },
        },

        //BOSSES

        boss_demon_general: {
          symbol: "👿",
          name: "General Demonio de la Sombra",
          typeOverride: "monster",
          hp: 500,
          attack: 45,
          defense: 20,
          exp: 300,
          maxHp: 500,
          isBoss: true,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          healChance: 0.15,
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [150, 300],
              chance: 1.0,
            },
            {
              itemName: "Núcleo Demoníaco Mayor",
              quantity: [1, 1],
              chance: 0.8,
            },
            {
              itemName: "Rollo: Palma Destructora de Montañas",
              quantity: [1, 1],
              chance: 0.25,
            },
            {
              itemName: "Fragmento de Arma Celestial",
              quantity: [1, 1],
              chance: 0.1,
            },
            {
              itemName: "Rollo: Cambio Temporal",
              quantity: [1, 1],
              chance: 0.25,
            },
            {
              itemName: "Rollo: Ritual de Sangre",
              quantity: [1, 1],
              chance: 0.2,
            },
            {
              itemName: "Rollo: Aura de Pureza",
              quantity: [1, 1],
              chance: 0.22,
            },
            {
              itemName: "Rollo: Invocar Elemental",
              quantity: [1, 1],
              chance: 0.18,
            },
            {
              itemName: "Rollo: Barrera Mística",
              quantity: [1, 1],
              chance: 0.25,
            },
          ],
          nextBossId: "boss_ancient_golem",
          fixedLocation: { x: 18, y: 25 },
        },

        boss_ancient_golem: {
          symbol: "🗿",
          name: "Golem Ancestral de Jade",
          typeOverride: "monster",
          hp: 800,
          attack: 35,
          defense: 50,
          exp: 500,
          maxHp: 800,
          isBoss: true,
          abilities: [
            {
              name: "Golpe Sísmico",
              damageMultiplier: 2.0,
              chance: 0.2,
              type: "area_attack_simulated",
            },
            { name: "Restauración Pétrea", healPercentage: 0.2, chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [300, 500],
              chance: 1.0,
            },
            {
              itemName: "Corazón de Golem de Jade",
              quantity: [1, 1],
              chance: 0.9,
            },
            {
              itemName: "Rollo: Armadura de Tierra Impenetrable",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Fragmento de Arma Celestial",
              quantity: [1, 1],
              chance: 0.15,
            },
            {
              itemName: "Mineral de Hierro Espiritual",
              quantity: [5, 10],
              chance: 0.6,
            },
            { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
            {
              itemName: "Núcleo Elemental",
              quantity: [1, 2],
              chance: 0.3,
              extraData: { elementalType: "earth" },
            },
            {
              itemName: "Rollo: Piel de Piedra",
              quantity: [1, 1],
              chance: 0.25,
            },
          ],
          nextBossId: null,
          fixedLocation: { x: 20, y: 13 },
        },
      };

      const itemData = {
        "Hierbas Medicinales": {
          description: "Restaura un 30% de tu HP Máximo.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al máximo.";
            const h = Math.floor(ps.maxHp * 0.3);
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Cristales de Qi": {
          description: "Restaura un 30% de tu Maná Máximo.",
          effect: (ps) => {
            if (ps.mana >= ps.maxMana) return "Maná al máximo.";
            const h = Math.floor(ps.maxMana * 0.3);
            const o = ps.mana;
            ps.mana = Math.min(ps.maxMana, ps.mana + h);
            return `Recuperado ${ps.mana - o} Maná.`;
          },
          canUse: (ps) => ps.mana < ps.maxMana,
        },
        "Piedras Espirituales": {
          description: "Imbuida de energía. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Piedra Espiritual y ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Flor de Luna Escarchada": {
          description: "Flor brillante usada en alquimia.",
          canUse: () => false,
        },
        "Raíz de Fuego Terrenal": {
          description: "Raíz que irradia calor, ingrediente alquímico.",
          canUse: () => false,
        },
        "Píldora de Recuperación Menor": {
          description: "Píldora alquímica que restaura 50 HP.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al máximo.";
            const h = 50;
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Usada Píldora, recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Talismán de Percepción": {
          description: "Agudiza sentidos. Otorga EXP.",
          effect: (ps, gex) => {
            gex(100);
            return `Estudiado Talismán, ganado 100 EXP.`;
          },
          canUse: () => true,
        },
        "Colmillo de Jabalí Alfa": {
          description: "Colmillo intacto de Jabalí Alfa. Prueba de caza.",
          canUse: () => false,
        },
        "Carne de Bestia Exótica": {
          description: "Nutritiva. Restaura 25% HP y 10% Maná.",
          effect: (ps) => {
            let m = "";
            const hA = Math.floor(ps.maxHp * 0.25);
            if (ps.hp < ps.maxHp) {
              const o = ps.hp;
              ps.hp = Math.min(ps.maxHp, ps.hp + hA);
              m += `Recuperado ${ps.hp - o} HP. `;
            }
            const mA = Math.floor(ps.maxMana * 0.1);
            if (ps.mana < ps.maxMana) {
              const o = ps.mana;
              ps.mana = Math.min(ps.maxMana, ps.mana + mA);
              m += `Recuperado ${ps.mana - o} Maná.`;
            }
            return m || "HP y Maná al máximo.";
          },
          canUse: (ps) => ps.hp < ps.maxHp || ps.mana < ps.maxMana,
        },
        "Mapa del Tesoro Fragmentado": {
          description: "Fragmento de mapa antiguo. ¿Otras partes?",
          effect: (ps, gex) => {
            gex(50);
            return `Examinado fragmento, ganado 50 EXP. Indica zona montañosa...`;
          },
          canUse: () => true,
        },
        "Compás Espiritual Antiguo": {
          description: "Artefacto de secta que resuena con energías.",
          canUse: () => false,
        },
        "Manual de Formación Básica": {
          description: "Enseña principios de formaciones defensivas.",
          effect: (ps) => {
            ps.baseDefense += 2;
            recalculatePlayerStats();
            return `Estudiado Manual. Defensa base +2.`;
          },
          canUse: () => true,
        },
        "Núcleo de Bestia Menor": {
          description: "Núcleo de bestia demoníaca. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido Núcleo, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Rollo: Absorción de Qi Menor": {
          description: "Enseña 'Técnica de Absorción de Qi Menor'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_absorption_boost_1"),
          canUse: () => true,
        },
        "Rollo: Fortificación Corporal Básica": {
          description: "Enseña 'Fortificación Corporal Básica'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_fortification_1"),
          canUse: () => true,
        },
        "Rollo: Corte de Espada Básico": {
          description: "Enseña 'Corte de Espada Básico'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_slash_1"),
          canUse: () => true,
        },
        "Rollo: Conversión de Qi": {
          description: "Enseña 'Técnica de Conversión de Qi'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_to_hp_conversion_1"),
          canUse: () => true,
        },
        "Rollo: Prisión de Hielo": {
          description: "Enseña 'Prisión de Hielo'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "ice_prison_1"),
          canUse: () => true,
        },
        "Rollo: Golpe de Llamas": {
          description: "Enseña 'Golpe de Llamas'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "flame_strike_1"),
          canUse: () => true,
        },
        "Rollo: Furia del Trueno": {
          description: "Enseña 'Furia del Trueno'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "thunder_fury_1"),
          canUse: () => true,
        },
        "Rollo: Dardo Venenoso": {
          description: "Enseña 'Dardo Venenoso'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "poison_dart_1"),
          canUse: () => true,
        },
        "Rollo: Piel de Piedra": {
          description: "Enseña 'Piel de Piedra'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "stone_skin_1"),
          canUse: () => true,
        },
        "Rollo: Paso de las Sombras": {
          description: "Enseña 'Paso de las Sombras'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "shadow_step_1"),
          canUse: () => true,
        },
        "Rollo: Drenaje de Alma": {
          description: "Enseña 'Drenaje de Alma'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "soul_drain_1"),
          canUse: () => true,
        },
        "Rollo: Golpe Ciclón": {
          description: "Enseña 'Golpe Ciclón'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "cyclone_strike_1"),
          canUse: () => true,
        },
        "Rollo: Lluvia Curativa": {
          description: "Enseña 'Lluvia Curativa'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "healing_rain_1"),
          canUse: () => true,
        },
        "Rollo: Explosión Mental": {
          description: "Enseña 'Explosión Mental'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "mind_blast_1"),
          canUse: () => true,
        },
        "Rollo: Voluntad de Hierro": {
          description: "Enseña 'Voluntad de Hierro'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "iron_will_1"),
          canUse: () => true,
        },
        "Rollo: Flecha Celestial": {
          description: "Enseña 'Flecha Celestial'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "celestial_arrow_1"),
          canUse: () => true,
        },
        "Rollo: Abrazo de la Naturaleza": {
          description: "Enseña 'Abrazo de la Naturaleza'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "nature_grasp_1"),
          canUse: () => true,
        },
        "Rollo: Rugido de Dragón": {
          description: "Enseña 'Rugido de Dragón'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "dragon_roar_1"),
          canUse: () => true,
        },
        "Rollo: Clon Fantasma": {
          description: "Enseña 'Clon Fantasma'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "phantom_clone_1"),
          canUse: () => true,
        },
        "Rollo: Cambio Temporal": {
          description: "Enseña 'Cambio Temporal'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "temporal_shift_1"),
          canUse: () => true,
        },
        "Rollo: Ritual de Sangre": {
          description: "Enseña 'Ritual de Sangre'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "blood_ritual_1"),
          canUse: () => true,
        },
        "Rollo: Aura de Pureza": {
          description: "Enseña 'Aura de Pureza'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "aura_of_purity_1"),
          canUse: () => true,
        },
        "Rollo: Invocar Elemental": {
          description: "Enseña 'Invocar Elemental'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "summon_elemental_1"),
          canUse: () => true,
        },
        "Rollo: Barrera Mística": {
          description: "Enseña 'Barrera Mística'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "mystic_barrier_1"),
          canUse: () => true,
        },
        "Cristal de Hielo": {
          description: "Cristal gélido. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Cristal de Hielo, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia de Fuego": {
          description: "Energía ígnea concentrada. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Esencia de Fuego, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Núcleo de Tormenta": {
          description: "Corazón de tormenta. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Núcleo de Tormenta, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Venenos Mortales": {
          description: "Venenos potentes. Otorga 15 EXP.",
          effect: (ps, gex) => {
            gex(15);
            return `Estudiado Venenos Mortales, ganado 15 EXP.`;
          },
          canUse: () => true,
        },
        "Fragmentos de Jade": {
          description: "Jade imbuido de energía. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido Fragmentos de Jade, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia Oscura": {
          description: "Energía de sombras. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Absorbido Esencia Oscura, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Almas Condenadas": {
          description: "Ecos de almas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Liberado Almas Condenadas, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "Núcleo de Vórtice": {
          description: "Energía caótica. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Núcleo de Vórtice, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Rocío Celestial": {
          description: "Gotas de energía celestial. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Bebido Rocío Celestial, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "Cristales Psíquicos": {
          description: "Resuenan con poder mental. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Meditado con Cristales Psíquicos, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "Mineral de Hierro Espiritual": {
          description: "Hierro imbuido con Qi. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Refinado Mineral, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Plumas de Fénix": {
          description: "Imbuidas con esencia de renovación. Otorga 60 EXP.",
          effect: (ps, gex) => {
            gex(60);
            return `Meditado con Plumas de Fénix, ganado 60 EXP.`;
          },
          canUse: () => true,
        },
        "Semillas Ancestrales": {
          description: "Llenas de vitalidad. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Plantado Semillas en dantian, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Escamas de Dragón": {
          description: "Imbuidas con poder dracónico. Otorga 70 EXP.",
          effect: (ps, gex) => {
            gex(70);
            return `Estudiado Escamas de Dragón, ganado 70 EXP.`;
          },
          canUse: () => true,
        },
        "Espejos Astrales": {
          description: "Reflejan otros planos. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Meditado con Espejos Astrales, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "Relojes de Arena": {
          description: "Manipulan flujo del tiempo. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Estudiado Relojes de Arena, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Sangre de Demonio": {
          description: "Sangre corrupta pero potente. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Analizado Sangre de Demonio, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "Lágrimas de Unicornio": {
          description:
            "Purificadoras con propiedades curativas. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Usado Lágrimas para purificar Qi, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "Núcleo Elemental": {
          description: "Esencia de poder elemental. Otorga 65 EXP.",
          effect: (ps, gex) => {
            gex(65);
            return `Absorbido Núcleo Elemental, ganado 65 EXP.`;
          },
          canUse: () => true,
        },
        "Polvo de Arcano": {
          description: "Brillante con propiedades mágicas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Utilizado Polvo de Arcano en ritual, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
      };

      // --- FUNCIONES HELPER PARA UI MÓVIL ---
      function isMobileView() {
        return (
          window.matchMedia("(max-width: 768px)").matches ||
          window.matchMedia("(hover: none) and (pointer: coarse)").matches
        );
      }

      /// <!-- CAMBIO TAMAÑO MAPA MÓVIL -->
      function calculateAndSetTileSize() {
        const mapContainerElement = document.querySelector(".map-container");
        if (!mapContainerElement) {
          console.warn(
            "calculateAndSetTileSize: mapContainerElement no encontrado, usando G_TILE_SIZE por defecto."
          );
          currentTileSize = G_TILE_SIZE;
          return G_TILE_SIZE;
        }

        if (isMobileView()) {
          const availableWidth = mapContainerElement.clientWidth;
          const availableHeight = mapContainerElement.clientHeight;

          // Decidir cuántos tiles queremos ver en pantalla en móvil (aproximado)
          // Ajusta estos valores según tus preferencias visuales.
          const TILES_VISIBLE_X_MOBILE = 5; // Por ejemplo, queremos ver unos 15 tiles de ancho
          const TILES_VISIBLE_Y_MOBILE = 3; // Y unos 10 de alto

          const tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_MOBILE;
          const tileSizeBasedOnHeight =
            availableHeight / TILES_VISIBLE_Y_MOBILE;

          currentTileSize = Math.floor(
            Math.min(tileSizeBasedOnWidth, tileSizeBasedOnHeight)
          );
          currentTileSize = Math.max(20, currentTileSize); // Asegurar un tamaño mínimo razonable (ej. 20px)

          console.log(
            `Mobile View: Container W: ${availableWidth}, H: ${availableHeight}. Calculated Tile Size: ${currentTileSize}`
          );
        } else {
          currentTileSize = G_TILE_SIZE; // Usar el tamaño fijo para escritorio
          console.log(`Desktop View: Using G_TILE_SIZE: ${currentTileSize}`);
        }
        return currentTileSize;
      }
      // <!-- FIN CAMBIO TAMAÑO MAPA MÓVIL -->

      function isAnyModalOpen() {
        const modals = [
          "interactionModal",
          "activeCultivationModal",
          "shopModal",
          "sectHallModal",
          "cultivationChoiceModal",
          "techniqueModal",
        ];
        for (const modalId of modals) {
          const modalElement = document.getElementById(modalId);
          if (modalElement && modalElement.style.display === "flex") {
            return true;
          }
        }
        return false;
      }

      // NUEVA FUNCIÓN para controlar la visibilidad de la barra inferior
      function updateBottomNavVisibility() {
        if (!bottomNavBar) return;

        if (gameState.battle.active || isAnyModalOpen()) {
          bottomNavBar.classList.add("hidden");
        } else {
          bottomNavBar.classList.remove("hidden");
        }
      }

      function showTouchControls() {
        const joystick = document.getElementById("joystick-container");
        const actionBtn = document.getElementById("action-button-touch");

        if (
          isMobileView() &&
          !mapControlsManuallyHidden &&
          !gameState.battle.active &&
          !isAnyModalOpen()
        ) {
          if (joystick) joystick.style.display = "block";
          if (actionBtn) actionBtn.style.display = "block";
        } else {
          if (joystick) joystick.style.display = "none";
          if (actionBtn) actionBtn.style.display = "none";
        }
      }

      function hideTouchControls() {
        const joystick = document.getElementById("joystick-container");
        const actionBtn = document.getElementById("action-button-touch");
        if (joystick) joystick.style.display = "none";
        if (actionBtn) actionBtn.style.display = "none";
      }

      function toggleMapControlsVisibility() {
        mapControlsManuallyHidden = !mapControlsManuallyHidden;
        const btn = document.getElementById("toggleMapControlsBtn");
        if (mapControlsManuallyHidden) {
          hideTouchControls();
          btn.textContent = "Mostrar Controles";
        } else {
          showTouchControls();
          btn.textContent = "Ocultar Controles";
        }
      }

      // --- FUNCIONES DEL JUEGO (MODIFICADAS Y EXISTENTES) ---

      function learnTechniqueFromRoll(playerState, techId) {
        if (!techniqueData[techId]) return "Error: Técnica desconocida.";
        if (playerState.learnedTechniques[techId]) {
          return `Ya conoces esta técnica: ${techniqueData[techId].name}.`;
        }
        const techCultivationSettings =
          techniqueData[techId].cultivationSettings;
        playerState.learnedTechniques[techId] = {
          level: 0,
          currentCultivationProgress: 0,
          cultivationTimeToNextLevel: techCultivationSettings
            ? techCultivationSettings.baseTimeToLevelUp
            : 60,
        };
        if (techId === "qi_to_hp_conversion_1") {
          playerState.canUseQiConversion = true;
          updateToggleQiConversionButtonVisibility();
        }
        return `Has aprendido '${techniqueData[techId].name}'. Puedes cultivarla para mejorarla.`;
      }

      function showModal(title, text, nonInteractive = false) {
        const modalElement = document.getElementById("interactionModal");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalTextEl = document.getElementById("modalText");

        if (!modalElement || !modalTitleEl || !modalTextEl) {
          console.error(
            "CRITICAL: Modal o sus elementos internos no encontrados."
          );
          alert(`Error UI: Modal no encontrado.\nMensaje: ${title} - ${text}`);
          return;
        }

        modalTitleEl.textContent = title;
        modalTextEl.innerHTML = text.replace(/\n/g, "<br>");

        const closeButton = modalElement.querySelector(
          "button.close-modal-btn"
        ); // Busca por clase

        if (closeButton) {
          if (nonInteractive) {
            closeButton.style.display = "none"; // Ocultar si es no interactivo
          } else {
            closeButton.style.display = "block"; // Asegurar que sea visible si es interactivo
            // El onclick="closeModal()" ya está en el HTML, por lo que no necesitamos reasignarlo.
          }
        } else if (!nonInteractive) {
          console.warn(
            "#interactionModal no tiene un botón de cierre con clase .close-modal-btn y no es nonInteractive."
          );
        }

        modalElement.style.display = "flex";
        hideTouchControls();
        updateBottomNavVisibility();
      }

      function closeModal() {
        const modalElement = document.getElementById("interactionModal");
        if (modalElement) {
          modalElement.style.display = "none";
        }
        updatePlayerBarsOnMap();
        showTouchControls(); // Restaurar controles táctiles (si aplica)
        updateBottomNavVisibility();
      }

      function ensureFixedEntities() {
        const player = gameState.player;
        let entities = gameState.map.entities;

        let idsParaProcesar = [
          "shop",
          "secta_entrada_principal",
          "npc_secta_guia",
          "npc_secta_admin",
          // ===> AÑADE TU JABALÍ AQUÍ <===
          "jabali_colmilludo_alfa",
          // ===> FIN DE LA ADICIÓN <===
          // Puedes añadir otros IDs de entidades fijas aquí directamente
        ];

        // Lógica para jefes principales (actuales)
        if (
          player.worldState.currentBossToSpawn &&
          entityTypes[player.worldState.currentBossToSpawn]
        ) {
          const bossDef = entityTypes[player.worldState.currentBossToSpawn];
          if (
            bossDef.fixedLocation &&
            !player.worldState.defeatedBosses[
              player.worldState.currentBossToSpawn
            ]
          ) {
            if (
              !idsParaProcesar.includes(player.worldState.currentBossToSpawn)
            ) {
              idsParaProcesar.push(player.worldState.currentBossToSpawn);
            }
          }
        }

        // Lógica para rivales de desafío de secta (actuales)
        player.secta.misionesActivas.forEach((misionActiva) => {
          const misionData = MISIONES_DATA[misionActiva.id];
          if (
            misionData?.objetivo?.tipo === "derrotar_npc_especifico" &&
            misionData.objetivo.npcId
          ) {
            const rivalId = misionData.objetivo.npcId;
            if (
              entityTypes[rivalId]?.fixedLocation &&
              !player.secta.misionesCompletadas[misionActiva.id]
            ) {
              if (!idsParaProcesar.includes(rivalId)) {
                idsParaProcesar.push(rivalId);
              }
            }
          }
        });

        // Nueva lógica: Añadir entidades fijas que podrían estar ligadas a misiones activas
        // (si implementas `missionRequirementId`)
        player.secta.misionesActivas.forEach((misionActiva) => {
          // Ejemplo: Si la misión "mision_cazar_bestia_especifica_1" está activa
          // y el jabalí tiene un `missionRequirementId: "mision_cazar_bestia_especifica_1"`
          // y aún no está en idsParaProcesar, lo añadirías.
          // Este es un ejemplo, necesitarías iterar sobre `entityTypes` para encontrar tales entidades.
          // Por ahora, como lo añadiste directamente a `idsParaProcesar`, esto es más simple.
        });

        console.log(
          "[EnsureFixed] IDs a procesar:",
          JSON.parse(JSON.stringify(idsParaProcesar))
        );

        idsParaProcesar.forEach((entityTypeId) => {
          const definition = entityTypes[entityTypeId];
          if (!definition) {
            console.warn(
              `[EnsureFixed] Definición no encontrada para ${entityTypeId}`
            );
            return;
          }

          if (!definition.fixedLocation) {
            // Si una entidad en idsParaProcesar no tiene fixedLocation, no podemos colocarla así.
            // Esto es un error de configuración o la entidad no debería estar en esta lista.
            console.warn(
              `[EnsureFixed] La entidad ${entityTypeId} está en idsParaProcesar pero no tiene 'fixedLocation' en su definición.`
            );
            return;
          }

          const fixedX = definition.fixedLocation.x;
          const fixedY = definition.fixedLocation.y;

          const existingEntityInstance = entities.find(
            (e) =>
              (e.x === fixedX &&
                e.y === fixedY &&
                (e.type === (definition.typeOverride || entityTypeId) ||
                  e.originalEntityTypeId === entityTypeId)) ||
              (definition.npcId && e.npcId === definition.npcId) // Para NPCs
          );

          let debeExistir = true;

          // Lógica de si debe existir (para jefes, rivales, o entidades ligadas a misiones)
          if (definition.isSectChallengeRival && definition.npcId) {
            const desafioMision = Object.values(MISIONES_DATA).find(
              (m) =>
                m.objetivo?.tipo === "derrotar_npc_especifico" &&
                m.objetivo?.npcId === definition.npcId
            );
            const misionId = desafioMision
              ? Object.keys(MISIONES_DATA).find(
                  (key) => MISIONES_DATA[key] === desafioMision
                )
              : null;
            if (misionId) {
              if (player.secta.misionesCompletadas[misionId])
                debeExistir = false;
              else if (
                !player.secta.misionesActivas.some((m) => m.id === misionId)
              )
                debeExistir = false;
            } else debeExistir = false;
          } else if (definition.isBoss || definition.isMiniBoss) {
            // Tratar MiniBoss de forma similar a Boss para 'defeated'
            // Usaremos una nueva propiedad en player.worldState para rastrear minibosses fijos derrotados
            // si no quieres que reaparezcan inmediatamente.
            if (
              player.worldState.defeatedFixedEntities &&
              player.worldState.defeatedFixedEntities[entityTypeId]
            ) {
              // Si tiene un tiempo de respawn, podría reaparecer
              const lastDefeatedTime =
                player.worldState.defeatedFixedEntities[entityTypeId].time;
              const respawnTimeSeconds = definition.respawnTime; // ej. 300 segundos
              if (
                respawnTimeSeconds &&
                (Date.now() - lastDefeatedTime) / 1000 < respawnTimeSeconds
              ) {
                debeExistir = false; // Aún no es tiempo de reaparecer
              } else if (respawnTimeSeconds) {
                debeExistir = true; // Tiempo de respawn cumplido
                // Opcional: remover de defeatedFixedEntities para que no se re-evalue el tiempo hasta la próxima derrota
                // delete player.worldState.defeatedFixedEntities[entityTypeId];
              } else {
                debeExistir = false; // No tiene respawnTime, así que si está derrotado, no reaparece.
              }
            }
          } else if (definition.missionRequirementId) {
            // Lógica para entidades que dependen de una misión activa
            if (
              !player.secta.misionesActivas.some(
                (m) => m.id === definition.missionRequirementId
              )
            ) {
              debeExistir = false; // La misión requerida no está activa
            }
            // Podrías añadir una comprobación de si la misión ya fue completada y la entidad debe desaparecer.
            if (
              player.secta.misionesCompletadas[
                definition.missionRequirementId
              ] &&
              !definition.respawnTime
            ) {
              // Si la misión está completada y la entidad no tiene respawn, no debe existir.
              debeExistir = false;
            }
          }

          if (debeExistir) {
            if (!existingEntityInstance) {
              console.log(
                `[EnsureFixed] CREANDO nueva instancia para ${entityTypeId} en (${fixedX}, ${fixedY}).`
              );
              const newEntityData = {
                x: fixedX,
                y: fixedY,
                type: definition.typeOverride || entityTypeId,
                symbol: definition.symbol,
                name: definition.name,
                interaction: definition.interaction,
                npcId: definition.npcId,
                discovered:
                  definition.discovered === true ||
                  definition.isBoss ||
                  definition.isMiniBoss, // Los jefes/minibosses suelen estar descubiertos
                isFixed: true,
                id: `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                  .toString(16)
                  .slice(2)}`,
                originalEntityTypeId: entityTypeId,
                // Copiar stats de combate y loot
                ...(definition.hp && {
                  hp: definition.hp,
                  maxHp: definition.maxHp || definition.hp,
                }),
                ...(definition.attack && { attack: definition.attack }),
                ...(definition.defense && { defense: definition.defense }),
                ...(definition.exp && { exp: definition.exp }),
                ...(definition.lootTable && {
                  lootTable: JSON.parse(JSON.stringify(definition.lootTable)),
                }), // Copia profunda del lootTable
                ...(definition.isBoss && { isBoss: true }),
                ...(definition.isMiniBoss && { isMiniBoss: true }), // Añadido
                ...(definition.specialChance && {
                  specialChance: definition.specialChance,
                }),
                ...(definition.specialAttackMultiplier && {
                  specialAttackMultiplier: definition.specialAttackMultiplier,
                }),
                ...(definition.healChance && {
                  healChance: definition.healChance,
                }),
                ...(definition.abilities && {
                  abilities: JSON.parse(JSON.stringify(definition.abilities)),
                }),
              };
              if (newEntityData.hp && !newEntityData.maxHp)
                newEntityData.maxHp = newEntityData.hp;

              // No necesitamos `...definition` aquí porque ya estamos copiando explícitamente y de entityTypes
              const finalEntity = { ...newEntityData };
              // delete finalEntity.fixedLocation; // No es necesario porque newEntityData no lo incluye

              entities.push(finalEntity);
            } else {
              // Actualizar propiedades de la instancia existente si es necesario
              existingEntityInstance.isFixed = true;
              if (
                definition.discovered === true ||
                definition.isBoss ||
                definition.isMiniBoss
              ) {
                existingEntityInstance.discovered = true;
              }
              if (!existingEntityInstance.id) {
                existingEntityInstance.id = `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                  .toString(16)
                  .slice(2)}`;
              }
              if (!existingEntityInstance.originalEntityTypeId) {
                existingEntityInstance.originalEntityTypeId = entityTypeId;
              }
              // Asegurar que las stats estén actualizadas si se recarga el juego
              // (esto puede ser importante si las definiciones cambian entre versiones)
              if (definition.hp) existingEntityInstance.hp = definition.hp;
              if (definition.maxHp)
                existingEntityInstance.maxHp = definition.maxHp;
              else if (definition.hp && !existingEntityInstance.maxHp)
                existingEntityInstance.maxHp = definition.hp;
              // ... podrías actualizar otras stats aquí si es necesario ...
            }
          } else {
            // No debe existir
            if (existingEntityInstance) {
              console.log(
                `[EnsureFixed] ELIMINANDO instancia existente de ${entityTypeId} en (${fixedX}, ${fixedY}) porque 'debeExistir' es false.`
              );
              entities = entities.filter(
                (e) => e.id !== existingEntityInstance.id
              );
            }
          }
        });
        gameState.map.entities = entities; // Reasignar por si se filtraron entidades
      }
      //GENERAR MAPA!
      function generateMap(isFullReset = true) {
        calculateAndSetTileSize();

        if (isFullReset) {
          console.log(
            "generateMap: Full reset. Entities BEFORE filtering for isFixed:"
          );
          gameState.map.entities.forEach((e) => {
            if (
              e.type === "secta_entrada_principal" ||
              e.type === "npc_secta_guia" ||
              e.type === "npc_secta_admin"
            ) {
              console.log(
                `  - ${e.name || e.type} at (${e.x},${e.y}), isFixed: ${
                  e.isFixed
                }, ID: ${e.id}`
              );
            }
          });

          // Limpiar entidades que no son fijas si es un reseteo completo
          // Esto es importante para que populateZoneWithObjects no cuente entidades viejas
          gameState.map.entities = gameState.map.entities.filter(
            (e) => e.isFixed
          );
          console.log(
            "generateMap: Full reset. Entities AFTER filtering for isFixed:"
          );
          gameState.map.entities.forEach((e) => {
            if (
              e.type === "secta_entrada_principal" ||
              e.type === "npc_secta_guia" ||
              e.type === "npc_secta_admin"
            ) {
              console.log(
                `  - KEPT: ${e.name || e.type} at (${e.x},${e.y}), isFixed: ${
                  e.isFixed
                }, ID: ${e.id}`
              );
            }
          });
          // Resetear currentCount en las spawnSettings de las zonas
          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings && zone.spawnSettings.targetEntities) {
              zone.spawnSettings.targetEntities.forEach((target) => {
                target.currentCount = 0;
              });
              zone.spawnSettings.respawnTimer = 0; // Asegurar que el timer esté a 0 para el llenado inicial
              zone.spawnSettings.lastSpawnCheck = 0; // Resetear lastSpawnCheck también
            }
          });

          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings) {
              console.log(
                `generateMap: Processing zone "${zone.name}" for initial population.`
              );
              populateZoneWithObjects(zone, true); // true para forzar el llenado inicial completo
              console.log(
                "generateMap: Full reset. Populating decorative elements."
              );
              populateDecorativeElements(50); // Añade, por ejemplo, 50 elementos decorativos
            }
          });
        } else {
          // Para una "reaparición" más ligera (si aún necesitas este concepto fuera de las zonas)
          // Filtra solo las entidades que NO son gestionadas por zonas y NO son fijas

          gameState.map.entities = gameState.map.entities.filter(
            (e) => e.isFixed || e.isDecorative || (!e.zoneOrigin && !e.isFixed)
          );
        }
        updatePlayerPosition(); // Esto llamará a renderMap()
        showTouchControls();
        // Siempre asegurar que las entidades fijas estén presentes y correctas
        ensureFixedEntities();
        console.log("generateMap: Entities AFTER ensureFixedEntities has run:");
        gameState.map.entities.forEach((e) => {
          if (
            e.type === "secta_entrada_principal" ||
            e.type === "npc_secta_guia" ||
            e.type === "npc_secta_admin"
          ) {
            console.log(
              `  - FINAL: ${e.name || e.type} at (${e.x},${e.y}), isFixed: ${
                e.isFixed
              }, ID: ${e.id}`
            );
          }
        });
      }

      function populateDecorativeElements(numberOfElements = 3000) {
        const decorativeKeys = Object.keys(entityTypes).filter(
          (key) => entityTypes[key].isDecorative
        );
        if (decorativeKeys.length === 0) {
          console.log("[Decor] No decorative entity types found."); // LOG
          return;
        }
        // MODIFICACIÓN: Añadir las claves encontradas al log
        console.log(
          `[Decor] Attempting to populate ${numberOfElements} decorative elements. Found ${decorativeKeys.length} types:`,
          decorativeKeys.join(", ")
        );

        let addedCount = 0;
        for (let i = 0; i < numberOfElements; i++) {
          let spawnX,
            spawnY,
            attempts = 0;
          let positionFound = false;
          const randomDecoKey =
            decorativeKeys[Math.floor(Math.random() * decorativeKeys.length)];

          while (attempts < 20 && !positionFound) {
            // Intentos para encontrar posición
            spawnX = Math.floor(Math.random() * gameState.map.width);
            spawnY = Math.floor(Math.random() * gameState.map.height);

            // Para decorativos, la condición de "caminable" puede ser menos estricta
            // Lo importante es que la celda no esté ya ocupada.
            const isOccupied = gameState.map.entities.some(
              (e) => e.x === spawnX && e.y === spawnY
            );
            const isPlayerPos =
              spawnX === gameState.player.x && spawnY === gameState.player.y;

            if (!isOccupied && !isPlayerPos) {
              positionFound = true;
            }
            attempts++;
          }

          if (positionFound) {
            const decoDefinition = entityTypes[randomDecoKey];
            if (!decoDefinition || !decoDefinition.symbol) {
              console.warn(
                `[Decor] Definition or symbol missing for deco key: ${randomDecoKey}`
              );
              continue;
            }
            const newDeco = {
              ...decoDefinition, // Copia todas las propiedades de la definición
              x: spawnX,
              y: spawnY,
              type: randomDecoKey, // El tipo ES la clave original de entityTypes
              id: `${randomDecoKey}_${Date.now()}_${i}_${Math.random()
                .toString(16)
                .slice(2)}`,
              discovered: true, // Importante: los decorativos suelen estar descubiertos
              isFixed: true, // Importante: para que no se limpien fácilmente
              isDecorative: true, // Asegura que sea true, incluso si la definición lo omite
            };

            gameState.map.entities.push(newDeco);
            addedCount++;
            // MODIFICACIÓN: Log más detallado, incluyendo si isDecorative es true en la instancia
            console.log(
              `[Decor] Added: ${newDeco.name} (Symbol: ${newDeco.symbol}, Type: ${newDeco.type}, IsDecorative: ${newDeco.isDecorative}) at ${spawnX},${spawnY}. ID: ${newDeco.id}`
            );
          } else {
            // console.log(`[Decor] Could not find position for a decorative element of type ${randomDecoKey} after 20 attempts.`);
          }
        }
        console.log(
          `[Decor] Finished populating. Added ${addedCount} decorative elements out of ${numberOfElements} attempts.`
        );
      }

      function populateZoneWithObjects(zone, initialPopulation = false) {
        if (!zone.spawnSettings) {
          console.log(
            `populateZoneWithObjects: Zone "${zone.name}" has no spawnSettings. Skipping.`
          );
          return;
        }

        console.log(
          `populateZoneWithObjects: Called for zone "${zone.name}". InitialPopulation: ${initialPopulation}`
        );

        zone.spawnSettings.targetEntities.forEach((targetSpawnInfo) => {
          console.log(
            `  Zone "${zone.name}": Processing target spawn info for entityTypeId "${targetSpawnInfo.entityTypeId}", count: ${targetSpawnInfo.count}, currentCount: ${targetSpawnInfo.currentCount}`
          );

          const entityTypeDefinition =
            entityTypes[targetSpawnInfo.entityTypeId];
          if (!entityTypeDefinition) {
            console.warn(
              `  Zone "${zone.name}": Definition for entityTypeId "${targetSpawnInfo.entityTypeId}" NOT FOUND in entityTypes.`
            );
            return;
          }

          let attemptSpawns =
            targetSpawnInfo.count - targetSpawnInfo.currentCount;
          console.log(
            `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Need to spawn ${attemptSpawns} (target: ${targetSpawnInfo.count}, current: ${targetSpawnInfo.currentCount})`
          );

          if (!initialPopulation && zone.spawnSettings.respawnTimer > 0) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Zone in cooldown (timer: ${zone.spawnSettings.respawnTimer}). Skipping spawn.`
            );
            return;
          }

          if (attemptSpawns <= 0 && !initialPopulation) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": No spawns needed and not initial population. Skipping.`
            );
            return;
          }
          if (
            attemptSpawns <= 0 &&
            initialPopulation &&
            targetSpawnInfo.currentCount >= targetSpawnInfo.count
          ) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Initial population, but already at target count. Skipping.`
            );
            return;
          }

          let spawnedThisCycle = 0;
          for (let i = 0; i < attemptSpawns; i++) {
            if (targetSpawnInfo.currentCount >= targetSpawnInfo.count) {
              console.log(
                `    Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Reached target count (${targetSpawnInfo.currentCount}/${targetSpawnInfo.count}). Stopping spawns for this type.`
              );
              break;
            }

            let spawnX,
              spawnY,
              attempts = 0;
            let positionFound = false;
            while (attempts < 20 && !positionFound) {
              spawnX =
                zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1 + 1));
              spawnY =
                zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1 + 1));

              const targetTerrainId = getTerrainTypeAt(spawnX, spawnY);
              const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
              const terrainWalkable =
                !targetTerrainData || targetTerrainData.walkable !== false;

              const isOccupied = gameState.map.entities.some(
                (e) => e.x === spawnX && e.y === spawnY
              );
              const isPlayerPos =
                spawnX === gameState.player.x && spawnY === gameState.player.y;

              if (terrainWalkable && !isOccupied && !isPlayerPos) {
                positionFound = true;
              }
              attempts++;
            }

            if (positionFound) {
              let newEntity;
              newEntity = {
                ...entityTypeDefinition, // <--- COPIAR TODAS LAS PROPIEDADES DE LA DEFINICIÓN PRIMERO
                x: spawnX,
                y: spawnY,
                type:
                  entityTypeDefinition.typeOverride ||
                  targetSpawnInfo.entityTypeId,
                id: `${
                  targetSpawnInfo.entityTypeId
                }_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                zoneOrigin: zone.name,
                originalEntityTypeId: targetSpawnInfo.entityTypeId,
                discovered: false,
                //name: entityTypeDefinition.name,
                //symbol: entityTypeDefinition.symbol,
                //interaction: entityTypeDefinition.interaction,
                //reward: entityTypeDefinition.reward,
              };
              // Asegurar HP/MaxHP para entidades de combate y limpiar para no combatientes
              if (
                G_COMBAT_ENTITY_TYPES.includes(newEntity.type) ||
                newEntity.isBoss ||
                newEntity.isSectChallengeRival
              ) {
                // Si entityTypeDefinition ya tiene hp/maxHp, el spread ya los copió.
                // Este bloque es más para asegurar que existan o para poner valores por defecto.
                newEntity.hp = newEntity.hp ?? entityTypeDefinition.hp ?? 50;
                newEntity.maxHp = newEntity.maxHp ?? newEntity.hp;
                // Aquí 'attack', 'defense', 'exp', 'lootTable' ya deberían estar copiados por el spread de entityTypeDefinition
              } else {
                // Para recursos u otras entidades no combativas
                delete newEntity.hp;
                delete newEntity.maxHp;
                delete newEntity.attack; // Asegurarse de que no tengan stats de combate
                delete newEntity.defense;
                delete newEntity.exp;
                // lootTable podría ser relevante para recursos si lo usaras para definir múltiples items de un nodo.
              }

              // Corrección específica si es un recurso, para que su 'type' en el mapa sea solo 'resource' si así lo deseas
              // para la lógica de interacción, o mantener el tipo específico si prefieres.
              // La lógica actual en handleEntityInteraction ya maneja bien `targetSpawnInfo.entityTypeId` como type.
              // if (entityTypeDefinition.type === "resource") newEntity.type = "resource";

              gameState.map.entities.push(newEntity);
              targetSpawnInfo.currentCount++;
              spawnedThisCycle++;
              console.log(
                `    SUCCESS: Spawned "${newEntity.name}" (Attack: ${newEntity.attack}, Final Type: ${newEntity.type}, OrigTypeID: ${newEntity.originalEntityTypeId}) in zone "${zone.name}" at (${spawnX},${spawnY}).`
              );
            } else {
              // console.log(`    FAILED: Could not find position for "${targetSpawnInfo.entityTypeId}" ...`);
              break;
            }
          }
          if (spawnedThisCycle > 0 && !initialPopulation) {
            zone.spawnSettings.respawnTimer =
              zone.spawnSettings.respawnCooldown;
            console.log(
              `  Zone "${zone.name}": Spawned ${spawnedThisCycle} of "${targetSpawnInfo.entityTypeId}". Setting respawn timer to ${zone.spawnSettings.respawnCooldown}s.`
            );
          }
        });
      }

      // Función para llamar en el bucle principal del juego o con setInterval
      function gameTickUpdater() {
        const now = Date.now();
        const deltaTime = (now - gameState.lastGameTimeUpdate) / 1000;
        gameState.gameTime += deltaTime;
        gameState.lastGameTimeUpdate = now;

        gameState.map.terrainZones.forEach((zone) => {
          if (zone.spawnSettings) {
            if (zone.spawnSettings.respawnTimer > 0) {
              zone.spawnSettings.respawnTimer -= deltaTime;
              if (zone.spawnSettings.respawnTimer < 0)
                zone.spawnSettings.respawnTimer = 0;
            }

            // Comprobar si CUALQUIER tipo de entidad en la zona necesita reaparecer
            let needsRespawn = false;
            for (const target of zone.spawnSettings.targetEntities) {
              if (target.currentCount < target.count) {
                needsRespawn = true;
                break;
              }
            }
            // Ajustado el cooldown del chequeo de respawn para ser más frecuente (e.g. 5-10s)
            const SPAWN_CHECK_COOLDOWN = 10; // Segundos
            if (
              needsRespawn &&
              zone.spawnSettings.respawnTimer <= 0 &&
              gameState.gameTime - (zone.spawnSettings.lastSpawnCheck || 0) >
                SPAWN_CHECK_COOLDOWN
            ) {
              console.log(
                `gameTickUpdater: Zone "${zone.name}" needs respawn and timer is 0. Calling populateZoneWithObjects.`
              ); // LOG
              zone.spawnSettings.lastSpawnCheck = gameState.gameTime; // Actualizar ANTES de llamar para evitar bucles rápidos
              populateZoneWithObjects(zone, false); // false porque no es población inicial
            }
          }
        });
        // ...
      }
      // movePlayer() no necesita grandes cambios, ya que updatePlayerPosition()
      // se encarga ahora del scroll.
      let animationFrameIndex = 0; // Para ciclar a través de PLAYER_WALK_CYCLE
      let lastPlayerMoveTime = 0; // Para controlar el tiempo de la animación

      function movePlayer(dx, dy) {
        movePlayerCallCount++;
        const callId = movePlayerCallCount;
        // console.log(`[MovePlayer CALL #${callId}] dx:${dx}, dy:${dy}. Current Player: (${gameState.player.x}, ${gameState.player.y})`);

        if (gameState.player.isCultivating || gameState.battle.active) return;

        const newX = gameState.player.x + dx;
        const newY = gameState.player.y + dy;
        // console.log(`[MovePlayer CALL #${callId}] Calculated New Pos: (${newX},${newY})`);

        // 1. Comprobar límites del MUNDO
        if (
          newX < 0 ||
          newX >= gameState.map.width ||
          newY < 0 ||
          newY >= gameState.map.height
        ) {
          console.log(
            `[MovePlayer CALL #${callId}] Movimiento bloqueado: Fuera de límites.`
          );
          return;
        }

        // 2. Comprobar si el TERRENO en newX, newY es transitable
        const targetTerrainId = getTerrainTypeAt(newX, newY);
        const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
        if (targetTerrainData && targetTerrainData.walkable === false) {
          console.log(
            `[MovePlayer CALL #${callId}] Movimiento bloqueado: Terreno no transitable (${targetTerrainData.name}).`
          );
          showModal(
            "Camino Bloqueado",
            `No puedes moverte sobre ${targetTerrainData.name}.`
          );
          return;
        }

        // 3. Comprobar ENTIDADES en newX, newY
        const entityAtNewPosition = gameState.map.entities.find(
          (e) => e.x === newX && e.y === newY
        );

        if (entityAtNewPosition) {
          console.log(
            `[MovePlayer CALL #${callId}] Entidad encontrada en (${newX},${newY}):`,
            JSON.parse(JSON.stringify(entityAtNewPosition))
          ); // Log profundo de la entidad

          const entityTypeToCheck =
            entityAtNewPosition.originalEntityTypeId ||
            entityAtNewPosition.type;
          console.log(
            `[MovePlayer CALL #${callId}] Tipo de entidad a verificar para bloqueo: '${entityTypeToCheck}'`
          );

          const entityDef = entityTypes[entityTypeToCheck]; // Usar el tipo correcto para buscar la definición
          if (entityDef) {
            console.log(
              `[MovePlayer CALL #${callId}] Definición de entidad encontrada:`,
              JSON.parse(JSON.stringify(entityDef))
            );
          } else {
            console.log(
              `[MovePlayer CALL #${callId}] ADVERTENCIA: No se encontró definición para el tipo '${entityTypeToCheck}'.`
            );
          }

          // 3.1. Si es una entidad de combate, iniciar batalla
          if (
            G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) ||
            entityAtNewPosition.isBoss ||
            entityAtNewPosition.isSectChallengeRival
          ) {
            console.log(
              `[MovePlayer CALL #${callId}] Movimiento resulta en batalla con: ${entityAtNewPosition.name}`
            );
            startBattle(entityAtNewPosition);
            return;
          }

          // 3.2. NUEVA LÓGICA: Comprobar si es una entidad que bloquea el paso
          let isBlockingByType =
            G_BLOCKING_ENTITY_TYPES.includes(entityTypeToCheck);
          let isBlockingByNpcId = entityDef && entityDef.npcId;

          console.log(
            `[MovePlayer CALL #${callId}] Verificando bloqueo: isBlockingByType (${entityTypeToCheck} en G_BLOCKING_ENTITY_TYPES) -> ${isBlockingByType}`
          );
          console.log(
            `[MovePlayer CALL #${callId}] Verificando bloqueo: isBlockingByNpcId (entidadDef tiene npcId) -> ${isBlockingByNpcId}`
          );

          if (isBlockingByType || isBlockingByNpcId) {
            console.log(
              `[MovePlayer CALL #${callId}] MOVIMIENTO BLOQUEADO por entidad: ${entityAtNewPosition.name}`
            );
            // showModal("Camino Bloqueado", `No puedes caminar sobre ${entityAtNewPosition.name}.`); // Opcional
            return;
          }

          console.log(
            `[MovePlayer CALL #${callId}] Entidad ${entityAtNewPosition.name} no es de combate ni bloqueante por tipo/npcId. Se permite pasar (interacción con Espacio).`
          );
        } else {
          console.log(
            `[MovePlayer CALL #${callId}] No hay entidad en (${newX},${newY}).`
          );
        }

        // Si llegamos aquí, la celda es transitable
        console.log(
          `[MovePlayer CALL #${callId}] Movimiento permitido a (${newX},${newY}).`
        );
        gameState.player.x = newX;
        gameState.player.y = newY;
        updatePlayerPosition(`movePlayer_call_${callId}`);
        // Lógica de emboscada (sin cambios)
        const adjacentOffsets = [
          { dx: 0, dy: -1 },
          { dx: 0, dy: 1 },
          { dx: -1, dy: 0 },
          { dx: 1, dy: 0 },
        ];
        for (const offset of adjacentOffsets) {
          const adjX = newX + offset.dx;
          const adjY = newY + offset.dy;
          if (
            adjX >= 0 &&
            adjX < gameState.map.width &&
            adjY >= 0 &&
            adjY < gameState.map.height
          ) {
            const adjEntity = gameState.map.entities.find(
              (e) => e.x === adjX && e.y === adjY
            );
            if (
              adjEntity &&
              (G_COMBAT_ENTITY_TYPES.includes(adjEntity.type) ||
                adjEntity.isBoss ||
                adjEntity.isSectChallengeRival)
            ) {
              if (!adjEntity.discovered) {
                adjEntity.discovered = true;
                renderMap();
              }
              showModal(
                "¡Emboscada!",
                `¡Un ${adjEntity.name} te ha visto y ataca!`,
                true
              );
              setTimeout(() => {
                closeModal();
                startBattle(adjEntity);
              }, 1500);
              return;
            }
          }
        }
        updateUI();
      }

      // Ajuste menor en window.addEventListener('resize')
      window.addEventListener("resize", () => {
        calculateAndSetTileSize();
        // renderMap(); // updatePlayerPosition se encarga de esto
        updatePlayerPosition();
      });

      function getTerrainTypeAt(x, y) {
        if (
          x < 0 ||
          x >= gameState.map.width ||
          y < 0 ||
          y >= gameState.map.height
        ) {
          return null; // Fuera de los límites del mapa
        }

        // Opción A: Si usas terrainGrid directamente
        if (
          gameState.map.terrainGrid &&
          gameState.map.terrainGrid[y] &&
          gameState.map.terrainGrid[y][x]
        ) {
          return gameState.map.terrainGrid[y][x];
        }

        // Opción B: Usando terrainZones
        for (const zone of gameState.map.terrainZones) {
          if (x >= zone.x1 && x <= zone.x2 && y >= zone.y1 && y <= zone.y2) {
            return zone.type;
          }
        }
        return gameState.map.defaultTerrain; // Devuelve el terreno por defecto
      }

      function renderMap(callerId = "unknown") {
        // Añadido callerId para depuración
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!mapElement || !mapContainerElement) {
          return;
        }

        const currentContainerWidth = mapContainerElement.clientWidth;
        const currentContainerHeight = mapContainerElement.clientHeight;

        const playerScreenX = currentContainerWidth / 2 - currentTileSize / 2;
        const playerScreenY = currentContainerHeight / 2 - currentTileSize / 2;
        const mapExpectedScrollX =
          -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapExpectedScrollY =
          -(gameState.player.y * currentTileSize) + playerScreenY;

        const viewWorldXStart = Math.floor(
          -mapExpectedScrollX / currentTileSize
        );
        const viewWorldYStart = Math.floor(
          -mapExpectedScrollY / currentTileSize
        );
        const tilesInViewX =
          Math.ceil(currentContainerWidth / currentTileSize) + 2; // +2 para margen
        const tilesInViewY =
          Math.ceil(currentContainerHeight / currentTileSize) + 2; // +2 para margen
        const viewWorldXEnd = viewWorldXStart + tilesInViewX;
        const viewWorldYEnd = viewWorldYStart + tilesInViewY;

        mapElement.innerHTML = "";

        // 1. Renderizar TERRENO BASE
        for (let y = viewWorldYStart; y < viewWorldYEnd; y++) {
          for (let x = viewWorldXStart; x < viewWorldXEnd; x++) {
            if (
              x < 0 ||
              x >= gameState.map.width ||
              y < 0 ||
              y >= gameState.map.height
            ) {
              continue; // No dibujar fuera de los límites del mundo
            }
            const terrainId = getTerrainTypeAt(x, y);
            const terrainData = G_TERRAIN_TYPES[terrainId];
            if (terrainData) {
              const terrainTile = document.createElement("div");
              terrainTile.className = "tile terrain-tile";
              terrainTile.style.left = `${x * currentTileSize}px`;
              terrainTile.style.top = `${y * currentTileSize}px`;
              terrainTile.style.width = `${currentTileSize}px`;
              terrainTile.style.height = `${currentTileSize}px`;

              // --- INICIO VARIEDAD VISUAL TERRENO ---
              let tileColor = terrainData.color;
              let detailSymbol = "";
              let detailOpacity = 0.15; // Opacidad para símbolos de detalle

              // Generar un valor pseudoaleatorio basado en coordenadas para consistencia
              const noiseVal = ((x * 31 + y * 13) % 100) / 100.0; // Simple hash

              if (terrainId === "GRASSLAND") {
                if (noiseVal < 0.1) {
                  // 10% de tiles un poco más oscuros
                  tileColor = "#2A8C4A"; // Un verde ligeramente más oscuro
                } else if (noiseVal < 0.15) {
                  // 5% con un "matojo"
                  detailSymbol = "٬"; // Coma o apóstrofe como pequeño detalle
                } else if (noiseVal < 0.2) {
                  detailSymbol = "·";
                }
              } else if (terrainId === "FOREST") {
                if (noiseVal < 0.15) {
                  tileColor = "#166F3C"; // Más oscuro
                } else if (noiseVal < 0.25) {
                  detailSymbol = "∗"; // Un pequeño asterisco
                }
              } else if (terrainId === "DESERT") {
                if (noiseVal < 0.08) {
                  tileColor = "#FAD7A0"; // Ligeramente diferente
                } else if (noiseVal < 0.15) {
                  detailSymbol = "·";
                }
              }
              // Añadir más reglas para otros tipos de terreno

              terrainTile.style.backgroundColor = tileColor;
              // --- FIN VARIEDAD VISUAL TERRENO ---

              terrainTile.style.fontSize = `${currentTileSize * 0.6}px`;
              terrainTile.style.display = "flex";
              terrainTile.style.alignItems = "center";
              terrainTile.style.justifyContent = "center";
              terrainTile.style.zIndex = "1";

              // Símbolo principal del terreno (más opaco)
              const mainSymbolSpan = document.createElement("span");
              mainSymbolSpan.textContent = terrainData.symbol;
              mainSymbolSpan.style.opacity = "0.3";
              terrainTile.appendChild(mainSymbolSpan);

              // Símbolo de detalle (si existe, más transparente)
              if (detailSymbol) {
                const detailSymbolSpan = document.createElement("span");
                detailSymbolSpan.textContent = detailSymbol;
                detailSymbolSpan.style.position = "absolute"; // Para superponerlo
                // Posicionarlo aleatoriamente dentro del tile de forma sutil
                detailSymbolSpan.style.left = `${noiseVal * 50 + 25}%`; // entre 25% y 75%
                detailSymbolSpan.style.top = `${((y * 7 + x * 3) % 50) + 25}%`; // diferente variación aleatoria
                detailSymbolSpan.style.opacity = `${detailOpacity}`;
                detailSymbolSpan.style.fontSize = `${currentTileSize * 0.4}px`; // Más pequeño
                detailSymbolSpan.style.transform = "translate(-50%, -50%)"; // Centrar el símbolo de detalle
                terrainTile.appendChild(detailSymbolSpan);
              }
              mapElement.appendChild(terrainTile);
            }
          }
        }

        // 2. Renderizar ENTIDADES (Monstruos, NPCs, Recursos, Decorativos)
        gameState.map.entities.forEach((entity) => {
          // LOG para ver todas las entidades que se intentan renderizar y sus propiedades
          // console.log(`[RenderMap] Checking entity: ${entity.name || entity.type}, X:${entity.x}, Y:${entity.y}, Discovered: ${entity.discovered}, Decorative: ${entity.isDecorative}, Fixed: ${entity.isFixed}, Symbol: ${entity.symbol}`);

          if (entity.discovered) {
            if (
              entity.x >= viewWorldXStart &&
              entity.x < viewWorldXEnd &&
              entity.y >= viewWorldYStart &&
              entity.y < viewWorldYEnd
            ) {
              const tile = document.createElement("div");

              const displayTypeKey = entity.type;
              tile.className = `tile entity-on-map ${displayTypeKey.replace(
                /\s/g,
                "_"
              )}`;

              tile.style.left = `${entity.x * currentTileSize}px`;
              tile.style.top = `${entity.y * currentTileSize}px`;
              tile.style.width = `${currentTileSize}px`;
              tile.style.height = `${currentTileSize}px`;
              tile.style.fontSize = `${
                currentTileSize * (entity.isDecorative ? 0.5 : 0.6)
              }px`;

              // Esta lógica para obtener el símbolo ya es robusta en tu código:
              const definitionForSymbol =
                entityTypes[entity.originalEntityTypeId] ||
                entityTypes[entity.type];
              tile.textContent =
                entity.symbol ||
                (definitionForSymbol ? definitionForSymbol.symbol : "?");

              if (!tile.textContent || tile.textContent === "?") {
                console.warn(
                  `[RenderMap] Entity ${entity.name || entity.type} at (${
                    entity.x
                  },${
                    entity.y
                  }) has NO SYMBOL or symbol is '?'! Definition key for fallback: ${
                    entity.originalEntityTypeId || entity.type
                  }. Entity instance:`,
                  JSON.parse(JSON.stringify(entity))
                );
              }

              tile.style.zIndex = entity.isDecorative ? "3" : "5";
              tile.style.backgroundColor = "transparent";
              if (entity.isDecorative) {
                tile.style.opacity = "0.7";
                // MODIFICACIÓN: Log específico cuando se va a dibujar un decorativo
                // console.log(`[RenderMap] Drawing DECORATIVE entity: ${entity.name || entity.type} (Symbol: ${tile.textContent}) at ${entity.x},${entity.y} with zIndex ${tile.style.zIndex} and opacity ${tile.style.opacity}`);
              }

              mapElement.appendChild(tile);
            }
          }
        });
        updatePlayerVisualSize(); // Asegura que el tamaño del jugador también se actualice
      }

      function updatePlayerSpriteVisual() {
        // Asegúrate que el nombre sea este
        const player = gameState.player;
        const playerElement = document.getElementById("player");
        if (!playerElement) return;

        // Verificación para depurar el error de la línea 2263
        if (
          !player.directionRowMap ||
          typeof player.currentDirection === "undefined"
        ) {
          console.error(
            "CRITICAL: player.directionRowMap o player.currentDirection no están definidos en updatePlayerSpriteVisual.",
            player
          );
          // Podrías establecer valores por defecto aquí como un parche temporal,
          // pero lo ideal es que estén bien inicializados en gameState.
          // player.currentDirection = player.currentDirection || 'down';
          // player.directionRowMap = player.directionRowMap || { 'down': 0, 'left': 1, 'right': 2, 'up': 3 };
          // player.currentFrame = player.currentFrame || 0;
          // player.frameWidth = player.frameWidth || 64;
          // player.frameHeight = player.frameHeight || 64;
          return; // Salir si faltan datos cruciales para evitar más errores
        }

        const row = player.directionRowMap[player.currentDirection];
        const col = player.currentFrame;

        // Otra verificación
        if (typeof row === "undefined" || typeof col === "undefined") {
          console.error(
            "CRITICAL: 'row' o 'col' son undefined en updatePlayerSpriteVisual.",
            {
              playerDir: player.currentDirection,
              playerFrame: player.currentFrame,
              map: player.directionRowMap,
            }
          );
          return;
        }

        const offsetX = col * player.frameWidth;
        const offsetY = row * player.frameHeight;

        playerElement.style.backgroundPosition = `-${offsetX}px -${offsetY}px`;

        if (gameState.battle.active) {
          const battlePlayerSprite = document.querySelector(
            ".battle-area .character-sprite"
          );
          if (battlePlayerSprite) {
            const battleRow = player.directionRowMap["down"];
            const battleFrame = 0;
            const battleOffsetX = battleFrame * player.frameWidth;
            const battleOffsetY = battleRow * player.frameHeight;
            battlePlayerSprite.style.backgroundPosition = `-${battleOffsetX}px -${battleOffsetY}px`;
          }
        }
      }

      // Asegúrate que G_TILE_SIZE sea igual a las dimensiones de tu frame de sprite
      // Si no, tendrás que ajustar cómo se define el tamaño del jugador.
      // En calculateAndSetTileSize, si currentTileSize se calcula dinámicamente,
      // y quieres que el jugador SIEMPRE tenga el tamaño del sprite:
      function updatePlayerVisualSize() {
        const playerElement = document.getElementById("player");
        if (playerElement) {
          // ESTO ES CRUCIAL: El tamaño del div del jugador DEBE ser el tamaño de UN FRAME
          // Si currentTileSize representa el tamaño deseado del jugador en pantalla,
          // y tus frames en la hoja de sprites son de un tamaño fijo (ej. 64x64),
          // entonces el div del jugador también debe ser de ese tamaño fijo para que background-position funcione.
          // O, si quieres que el jugador se reescale con currentTileSize, entonces frameWidth/Height
          // deben ser iguales a currentTileSize, y background-size debe escalar la hoja completa.

          // Opción A: El jugador mantiene el tamaño del frame original, y currentTileSize es solo para el mapa.
          playerElement.style.width = `${gameState.player.frameWidth}px`;
          playerElement.style.height = `${gameState.player.frameHeight}px`;
          // En este caso, .player y .character-sprite NO deberían cambiar su width/height en @media queries
          // basados en currentTileSize, sino mantener el tamaño del frame.

          // Opción B: El jugador se reescala con los tiles del mapa (más complejo con spritesheets).
          // Si eliges esto, frameWidth y frameHeight en gameState.player deberían ser actualizados
          // por calculateAndSetTileSize() para ser igual a currentTileSize.
          // Y el background-size del spritesheet necesitaría ajustarse para que un "frame virtual"
          // dentro de la hoja escalada coincida con currentTileSize.
          // Ejemplo para Opción B:
          //playerElement.style.width = `${currentTileSize}px`;
          //playerElement.style.height = `${currentTileSize}px`;
          // Y en updatePlayerSpriteVisual, los cálculos de offsetX/Y necesitarían
          // usar este currentTileSize en lugar de player.frameWidth/Height si la hoja
          // también se está escalando.
          // Por ahora, mantengamos la Opción A (tamaño de frame fijo) que es más simple
          // si tu CSS para .player no está siendo sobrescrito por las @media queries.
        }
      }

      function updatePlayerPosition(callerId = "unknown") {
        const playerElement = document.getElementById("player");
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!playerElement || !mapElement || !mapContainerElement) {
          console.error(
            "UpdatePlayerPosition: Elemento(s) clave no encontrado(s)."
          );
          return;
        }

        const playerVisualWidth = gameState.player.frameWidth; // Usar el tamaño real del frame del sprite
        const playerVisualHeight = gameState.player.frameHeight;

        const playerScreenX =
          mapContainerElement.clientWidth / 2 - playerVisualWidth / 2;
        const playerScreenY =
          mapContainerElement.clientHeight / 2 - playerVisualHeight / 2;

        playerElement.style.left = `${playerScreenX}px`;
        playerElement.style.top = `${playerScreenY}px`;

        const mapScrollX =
          -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapScrollY =
          -(gameState.player.y * currentTileSize) + playerScreenY;

        mapElement.style.transform = `translate(${mapScrollX}px, ${mapScrollY}px)`;

        gameState.map.entities.forEach((entity) => {
          const distance =
            Math.abs(entity.x - gameState.player.x) +
            Math.abs(entity.y - gameState.player.y);
          if (distance <= G_PLAYER_DISCOVERY_RANGE) {
            if (!entity.discovered) entity.discovered = true;
          }
        });

        renderMap(callerId);
        updatePlayerSpriteVisual();
        updatePlayerVisualSize();
        updatePlayerBarsOnMap(); // <--- LLAMADA AÑADIDA
      }

      // ... (el resto de tus funciones JS, como updateUI, movePlayer, interact, etc. SIN CAMBIOS IMPORTANTES aquí,
      //      ya que los cambios principales son en el renderizado y tamaño de tiles)
      function updateUI() {
        const player = gameState.player;
        document.getElementById("playerLevel").textContent = player.level;
        document.getElementById("playerRealm").textContent = player.realm;
        document.getElementById("hpText").textContent = `${Math.floor(
          player.hp
        )}/${player.maxHp}`;
        document.getElementById("manaText").textContent = `${Math.floor(
          player.mana
        )}/${player.maxMana}`;
        document.getElementById("expText").textContent = `${Math.floor(
          player.exp
        )}/${player.expToNext}`;

        // Barras del Sidebar
        const hpBarSidebar = document.getElementById("hpBar");
        const manaBarSidebar = document.getElementById("manaBar");
        const expBarSidebar = document.getElementById("expBar");

        if (hpBarSidebar)
          hpBarSidebar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        if (manaBarSidebar)
          manaBarSidebar.style.width = `${
            (player.mana / player.maxMana) * 100
          }%`;
        if (expBarSidebar)
          expBarSidebar.style.width = `${
            (player.exp / player.expToNext) * 100
          }%`;

        document.getElementById(
          "playerCoords"
        ).textContent = `X: ${player.x}, Y: ${player.y}`;

        updateToggleQiConversionButtonVisibility(); // Asumo que esta función existe y es correcta
        updateInventoryUI(); // Asumo que esta función existe y es correcta
        updateSectUI(); // Asumo que esta función existe y es correcta

        updatePlayerBarsOnMap(); // <--- LLAMADA AÑADIDA para las barras sobre el jugador
      }

      function updateInventoryUI() {
        const inventoryDisplay = document.getElementById("inventory");
        inventoryDisplay.innerHTML = "";
        Object.entries(gameState.inventory).forEach(([itemName, count]) => {
          if (count <= 0 && itemName !== "Piedras Espirituales") return;

          const itemDiv = document.createElement("div");
          itemDiv.className = "inventory-item";

          const itemInfo = itemData[itemName];
          const description = itemInfo
            ? itemInfo.description
            : "Un objeto misterioso.";
          itemDiv.innerHTML = `<strong>${itemName}: ${count}</strong><br><small><em>${description}</em></small>`;

          if (count > 0 && itemInfo && itemInfo.effect) {
            const canBeUsedNow = itemInfo.canUse
              ? itemInfo.canUse(gameState.player)
              : true;
            itemDiv.style.cursor = canBeUsedNow ? "pointer" : "not-allowed";
            itemDiv.style.opacity = canBeUsedNow ? 1 : 0.6;
            itemDiv.title = canBeUsedNow
              ? `Usar ${itemName}`
              : `No puedes usar ${itemName} ahora.`;
            if (canBeUsedNow) {
              itemDiv.onclick = () => useItem(itemName);
            }
          } else {
            itemDiv.style.opacity = 0.8;
            itemDiv.style.cursor = "default";
          }
          inventoryDisplay.appendChild(itemDiv);
        });
      }

      function updateToggleQiConversionButtonVisibility() {
        const button = document.getElementById("toggleQiConversionButton");
        if (gameState.player.canUseQiConversion) {
          button.style.display = "inline-block";
          button.textContent = gameState.player.isQiConversionActive
            ? "☯️ Detener Conversión Qi"
            : "☯️ Activar Conversión Qi";
        } else {
          button.style.display = "none";
        }
      }

      function updateRefinementUI() {}

      let movePlayerCallCount = 0;

      let lastPlayerAnimationUpdateTime = 0; // Renombrado para claridad

      function movePlayer(dx, dy) {
        const playerState = gameState.player; // Acceso más corto

        if (playerState.isCultivating || gameState.battle.active) {
          if (playerState.isMoving) {
            // Si se estaba moviendo y se interrumpe
            playerState.isMoving = false;
            updatePlayerSpriteVisual();
          }
          return;
        }

        const prevDirection = playerState.spriteFacingDirection;
        let newDirection = prevDirection;

        if (dx > 0) newDirection = "right";
        else if (dx < 0) newDirection = "left";
        else if (dy > 0) newDirection = "down";
        else if (dy < 0) newDirection = "up";

        // console.log(`[MovePlayer] Attempt move. dx:${dx}, dy:${dy}. NewDir: ${newDirection}`);

        playerState.isMoving = true; // Intención de moverse

        if (prevDirection !== newDirection) {
          playerState.spriteFacingDirection = newDirection;
          animationFrameIndex = 0; // Reiniciar animación al cambiar de dirección
          playerState.spriteWalkFrame = PLAYER_WALK_CYCLE[animationFrameIndex];
          // console.log(`[MovePlayer] Direction changed to ${newDirection}. Reset animFrameIdx to 0.`);
        }

        const now = Date.now();
        if (now - lastPlayerAnimationUpdateTime > PLAYER_ANIMATION_SPEED) {
          animationFrameIndex =
            (animationFrameIndex + 1) % PLAYER_WALK_CYCLE.length;
          playerState.spriteWalkFrame = PLAYER_WALK_CYCLE[animationFrameIndex];
          lastPlayerAnimationUpdateTime = now;
          // console.log(`[MovePlayer] Animation tick. animFrameIdx: ${animationFrameIndex}, spriteWalkFrame set to col: ${playerState.spriteWalkFrame}`);
        }

        const newX = playerState.x + dx;
        const newY = playerState.y + dy;
        let canMove = true;

        if (
          newX < 0 ||
          newX >= gameState.map.width ||
          newY < 0 ||
          newY >= gameState.map.height
        ) {
          canMove = false;
        } else {
          const targetTerrainId = getTerrainTypeAt(newX, newY);
          const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
          if (targetTerrainData && targetTerrainData.walkable === false) {
            // showModal("Camino Bloqueado", `No puedes moverte sobre ${targetTerrainData.name}.`); // Puede ser muy verboso
            canMove = false;
          } else {
            const entityAtNewPosition = gameState.map.entities.find(
              (e) =>
                e.x === newX &&
                e.y === newY &&
                e.type !== "shop" &&
                e.type !== "secta_entrada_principal" &&
                !(entityTypes[e.type] && entityTypes[e.type].npcId)
            );
            if (entityAtNewPosition) {
              if (
                G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) ||
                entityAtNewPosition.isBoss ||
                entityAtNewPosition.isSectChallengeRival
              ) {
                playerState.isMoving = false; // Detener animación antes de la batalla
                updatePlayerSpriteVisual();
                startBattle(entityAtNewPosition);
                return;
              }
            }
          }
        }

        if (canMove) {
          playerState.x = newX;
          playerState.y = newY;
          updatePlayerPosition(`movePlayer_success`);
          updateUI();
        } else {
          playerState.isMoving = false; // No se pudo mover, no está "moviéndose"
          // console.log("[MovePlayer] Movement blocked.");
        }

        updatePlayerSpriteVisual(); // Actualizar el sprite con la dirección y estado de movimiento actuales

        clearTimeout(playerState.stopMoveAnimTimer);
        playerState.stopMoveAnimTimer = setTimeout(() => {
          // console.log("[MovePlayer] Stop animation timer fired.");
          playerState.isMoving = false;
          // playerState.spriteWalkFrame = PLAYER_WALK_CYCLE[0]; // Volver al frame definido como "quieto"
          updatePlayerSpriteVisual(); // Asegurar que se muestre el frame de quieto
        }, PLAYER_ANIMATION_SPEED + 50); // Un poco más que la velocidad de animación del frame
      }

      let playerMovementKeysDown = {
        // Para rastrear qué teclas de movimiento están presionadas
        up: false,
        down: false,
        left: false,
        right: false,
      };
      function handlePlayerMovementInput(direction, isKeyDown) {
        const player = gameState.player;

        if (isKeyDown) {
          playerMovementKeysDown[direction] = true;
          player.currentDirection = direction;
          player.isMoving = true;

          if (player.idleTimeout) {
            clearTimeout(player.idleTimeout);
            player.idleTimeout = null;
          }

          if (!player.animationTimer) {
            player.currentFrame = 1;
            updatePlayerSpriteVisual(); // <--- CORREGIR AQUÍ
            player.animationTimer = setInterval(() => {
              if (player.isMoving) {
                player.currentFrame =
                  (player.currentFrame + 1) % player.animationFrames;
                if (player.currentFrame === 0) player.currentFrame = 1;
                updatePlayerSpriteVisual(); // <--- CORREGIR AQUÍ
              }
            }, player.animationSpeed);
          }
        } else {
          playerMovementKeysDown[direction] = false;
          const stillMoving = Object.values(playerMovementKeysDown).some(
            (status) => status === true
          );

          if (!stillMoving) {
            player.isMoving = false;
            if (player.animationTimer) {
              clearInterval(player.animationTimer);
              player.animationTimer = null;
            }
            player.idleTimeout = setTimeout(() => {
              if (!player.isMoving) {
                player.currentFrame = 0;
                updatePlayerSpriteVisual(); // <--- CORREGIR AQUÍ
              }
            }, player.animationSpeed);
          } else {
            if (playerMovementKeysDown["up"]) player.currentDirection = "up";
            else if (playerMovementKeysDown["down"])
              player.currentDirection = "down";
            else if (playerMovementKeysDown["left"])
              player.currentDirection = "left";
            else if (playerMovementKeysDown["right"])
              player.currentDirection = "right";
            updatePlayerSpriteVisual(); // <--- CORREGIR AQUÍ
          }
        }
      }

      function interact() {
        if (gameState.player.isCultivating) {
          showModal(
            "Acción no permitida",
            "Detén tu cultivo antes de interactuar."
          );
          return;
        }
        if (gameState.battle.active) {
          showModal(
            "Acción no permitida",
            "No puedes interactuar durante el combate."
          );
          return;
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        const offsets = [
          { dx: 0, dy: 0 },
          { dx: 0, dy: -1 },
          { dx: 1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: -1, dy: 0 },
        ];

        for (const offset of offsets) {
          const targetX = playerX + offset.dx;
          const targetY = playerY + offset.dy;
          const entity = gameState.map.entities.find(
            (e) => e.x === targetX && e.y === targetY
          );

          if (entity) {
            if (
              G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
              entity.isBoss ||
              entity.isSectChallengeRival
            ) {
              const desafioMision = gameState.player.secta.misionesActivas.find(
                (m) =>
                  MISIONES_DATA[m.id]?.objetivo?.tipo ===
                    "derrotar_npc_especifico" &&
                  MISIONES_DATA[m.id]?.objetivo?.npcId === entity.npcId
              );
              if (entity.isSectChallengeRival) {
                if (desafioMision) {
                  showModal(
                    "¡Desafío Aceptado!",
                    `Te preparas para enfrentar a ${entity.name}.`,
                    true
                  );
                  setTimeout(() => {
                    closeModal();
                    startBattle(entity);
                  }, 1500);
                } else {
                  showModal(
                    "Paz, por ahora...",
                    `${entity.name} te observa, pero no hay razón para luchar.`
                  );
                }
              } else {
                showModal(
                  "¡A la Batalla!",
                  `Decides enfrentar a ${entity.name}.`,
                  true
                );
                setTimeout(() => {
                  closeModal();
                  startBattle(entity);
                }, 1000);
              }
              return;
            } else if (
              entity.interaction ||
              entityTypes[entity.type]?.interaction ||
              [
                "resource",
                "master",
                "cultivation",
                "shop",
                "secta_entrada_principal",
              ].includes(entity.type)
            ) {
              handleEntityInteraction(entity);
              return;
            }
          }
        }
      }

      function handleEntityInteraction(entity) {
        if (!entity) return;

        let interactionType = entity.interaction; // Priorizar la interacción de la instancia

        // Si no hay interacción en la instancia, buscar en la definición de entityTypes
        // usando entity.originalEntityTypeId si está disponible, sino entity.type
        const definitionKey = entity.originalEntityTypeId || entity.type;
        if (!interactionType && entityTypes[definitionKey]) {
          interactionType = entityTypes[definitionKey].interaction;
        }

        if (interactionType) {
          switch (interactionType) {
            case "browse":
              if (entity.type === "shop") {
                openShop();
                return;
              }
              break;
            case "talk_secta_npc":
              if (entity.npcId) {
                interactWithSectNPC(entity.npcId);
                return;
              }
              break;
            case "access_sect_hall":
              if (entity.type === "secta_entrada_principal") {
                openSectHallInterface();
                return;
              }
              break;
            case "collect_resource":
              const rewardItem =
                entity.reward ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].reward
                  : null) ||
                "Piedras Espirituales"; // Último fallback

              const itemNameDisplay =
                entity.name ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].name
                  : entity.type);

              gameState.inventory[rewardItem] =
                (gameState.inventory[rewardItem] || 0) + 1;
              showModal(
                "Recurso Encontrado",
                `Has obtenido: 1 ${rewardItem}! (de ${itemNameDisplay})`
              );
              removeEntity(entity);
              updateInventoryUI();
              return;
            case "learn_from_master":
              const expGain =
                entity.expGain || entityTypes[entity.type]?.expGain || 50;
              gainExperience(expGain);
              showModal(
                "Encuentro con Maestro",
                `El ${entity.name} te ha enseñado sabiduría. Ganas ${expGain} EXP!`
              );
              removeEntity(entity);
              return;
            case "meditate_spot":
              const manaGain =
                entity.manaGain || entityTypes[entity.type]?.manaGain || 20;
              gameState.player.mana = Math.min(
                gameState.player.maxMana,
                gameState.player.mana + manaGain
              );
              showModal(
                "Lugar de Cultivo",
                `Has meditado en '${entity.name}'. Recuperas ${manaGain} Maná.`
              );
              removeEntity(entity);
              updateUI();
              return;
            default:
              console.warn(
                `Interacción '${interactionType}' desconocida para ${entity.name} (Tipo: ${entity.type}, ID: ${entity.id}).`
              );
              break;
          }
        } else {
          console.log(
            `No hay acción definida para tipo '${entity.type}' (Entidad: ${entity.name}, ID: ${entity.id}, OrigTypeID: ${entity.originalEntityTypeId}).`
          );
        }
      }

      function interactWithSectNPC(npcId) {
        const npcData = SECTA_DATA.npcs[npcId];
        const player = gameState.player;
        if (!npcData) {
          console.error(
            `[interactWithSectNPC] NPC Data no encontrada para npcId: ${npcId}`
          );
          return;
        }

        console.log(
          `[NPC Interaction] Starting interaction with NPC: ${npcData.nombre} (ID: ${npcId})`
        );
        console.log(
          `[NPC Interaction] Player Active Missions (Raw):`,
          JSON.parse(JSON.stringify(player.secta.misionesActivas))
        );
        console.log(
          `[NPC Interaction] Player Inventory:`,
          JSON.parse(JSON.stringify(gameState.inventory))
        );

        let modalContentHTML = `<h3>${npcData.nombre} (${npcData.rol})</h3>`;
        modalContentHTML += `<p><em>"${npcData.dialogoInicial}"</em></p><hr>`;

        const elementsToProcess = [];

        // --- SECCIÓN: MISIONES PARA COMPLETAR ---
        modalContentHTML += `<h4>Misiones para Entregar/Reportar:</h4>`;
        let algunaMisionParaCompletar = false;

        player.secta.misionesActivas.forEach((misionActiva) => {
          const misionDef = MISIONES_DATA[misionActiva.id];

          // Log básico para cada misión activa
          console.log(
            `[NPC Interaction] Evaluating Active Mission: "${misionDef?.titulo}" (ID: ${misionActiva.id})`
          );

          // Comprobaciones cruciales: misionDef, objetivo, y objetivoOriginal deben existir.
          if (
            !misionDef ||
            !misionDef.objetivo ||
            !misionActiva.objetivoOriginal
          ) {
            console.warn(
              `[NPC Interaction] Skipping mission ID ${misionActiva.id}: Missing misionDef, misionDef.objetivo, or misionActiva.objetivoOriginal.`
            );
            return; // Saltar esta misión si los datos esenciales faltan
          }

          const objetivo = misionActiva.objetivoOriginal; // Usar el objetivo original guardado
          console.log(
            `[NPC Interaction] Mission "${
              misionDef.titulo
            }": Target NPC for delivery/report is "${
              objetivo.npcEntrega
            }". Current NPC is "${npcId}". Match: ${
              objetivo.npcEntrega === npcId
            }`
          );

          // Solo procesar si el NPC actual es el NPC de entrega/reporte de la misión
          if (objetivo.npcEntrega === npcId) {
            let listaParaEntregar = false;
            let objetivoStatus = "";

            console.log(
              `[NPC Interaction] Mission "${misionDef.titulo}" IS for this NPC. Original objective type: ${objetivo.tipo}`
            );

            switch (objetivo.tipo) {
              case "entregar_item":
                const playerHasItem = gameState.inventory[objetivo.item] || 0;
                const needsItem = objetivo.cantidad;
                console.log(
                  `  - Type 'entregar_item'. Item: "${objetivo.item}", Needs: ${needsItem}, Player Has: ${playerHasItem}`
                );
                if (playerHasItem >= needsItem) {
                  listaParaEntregar = true;
                  objetivoStatus = `(Tienes ${playerHasItem}/${needsItem} ${objetivo.item})`;
                } else {
                  objetivoStatus = `(Necesitas ${
                    needsItem - playerHasItem
                  } más ${objetivo.item})`;
                }
                break;

              case "eliminar_enemigo":
                const currentProgressElim = misionActiva.progreso || 0;
                const needsElim = objetivo.cantidad;
                console.log(
                  `  - Type 'eliminar_enemigo'. Target: "${objetivo.nombreDisplay}", Needs: ${needsElim}, Progress: ${currentProgressElim}`
                );
                if (currentProgressElim >= needsElim) {
                  listaParaEntregar = true; // Significa que los enemigos fueron eliminados, lista para 'reportar'
                  objetivoStatus = `(${currentProgressElim}/${needsElim} ${objetivo.nombreDisplay} eliminados)`;
                } else {
                  objetivoStatus = `(Elimina ${
                    needsElim - currentProgressElim
                  } más ${objetivo.nombreDisplay})`;
                }
                break;

              case "recolectar_multiples_items":
                let todosRecolectados = true;
                let itemsStatusArray = [];
                console.log(
                  `  - Type 'recolectar_multiples_items'. Items required:`,
                  objetivo.items
                );
                for (const itemReq of objetivo.items) {
                  const playerHasMulti =
                    gameState.inventory[itemReq.nombre] || 0;
                  const needsMulti = itemReq.cantidad;
                  console.log(
                    `    - Item: "${itemReq.nombre}", Needs: ${needsMulti}, Player Has: ${playerHasMulti}`
                  );
                  if (playerHasMulti < needsMulti) {
                    todosRecolectados = false;
                  }
                  itemsStatusArray.push(
                    `${playerHasMulti}/${needsMulti} ${itemReq.nombre}`
                  );
                }
                if (todosRecolectados) {
                  listaParaEntregar = true;
                }
                objetivoStatus = `(${itemsStatusArray.join(", ")})`;
                break;

              case "cazar_y_recuperar_item_de_loot":
                const playerHasLootItem =
                  (gameState.inventory[objetivo.itemPrueba] || 0) >=
                  objetivo.cantidadItemPrueba;
                // El progreso a 1 indica que el tipo de enemigo que suelta el item fue derrotado.
                const killedCorrectEnemyType = misionActiva.progreso === 1;
                console.log(
                  `  - Type 'cazar_y_recuperar_item_de_loot'. Item: "${
                    objetivo.itemPrueba
                  }", Needs Qty: ${
                    objetivo.cantidadItemPrueba
                  }, Player Has Qty: ${
                    gameState.inventory[objetivo.itemPrueba] || 0
                  }. Killed enemy type: ${killedCorrectEnemyType}`
                );
                if (killedCorrectEnemyType && playerHasLootItem) {
                  // Debe haber matado al enemigo Y tener el ítem
                  listaParaEntregar = true;
                  objetivoStatus = `(Tienes ${objetivo.itemPrueba})`;
                } else if (!killedCorrectEnemyType) {
                  objetivoStatus = `(Caza al ${
                    entityTypes[objetivo.enemigoTipo]?.name ||
                    objetivo.enemigoTipo
                  } y consigue ${objetivo.itemPrueba})`;
                } else {
                  // Killed enemy, but doesn't have item (sold it? used it? or it never dropped - handle this in loot drop if needed)
                  objetivoStatus = `(Necesitas ${objetivo.itemPrueba}. ¿Lo perdiste o no lo obtuviste?)`;
                }
                break;

              // Añadir más casos aquí para otros tipos de misión que se completan con este NPC
              default:
                console.warn(
                  `[NPC Interaction] Unhandled objective type "${objetivo.tipo}" for mission "${misionDef.titulo}" completion check with NPC.`
                );
                objetivoStatus = `(Objetivo: ${objetivo.tipo} - estado no verificado aquí)`;
                break;
            }

            console.log(
              `[NPC Interaction] Mission "${misionDef.titulo}": listaParaEntregar = ${listaParaEntregar}. Objetivo status display: ${objetivoStatus}`
            );

            // Solo mostrar el botón de completar si listaParaEntregar es true
            if (listaParaEntregar) {
              const buttonId = `complete-mission-btn-${misionActiva.id.replace(
                /\W/g,
                "_"
              )}`;
              modalContentHTML += `<div style="padding: 5px; border: 1px solid #55cc55; margin-bottom: 5px; background-color: rgba(85,204,85,0.1);">
                                            <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                            <button id="${buttonId}">Completar Misión</button>
                                        </div>`;
              elementsToProcess.push({
                buttonId: buttonId,
                action: () => {
                  console.log(
                    `[NPC Interaction] Clicked "Completar Misión" button for ${misionActiva.id}`
                  );
                  // Pasar npcId como npcIdEntregaManual a completeMission
                  if (completeMission(misionActiva.id, npcId)) {
                    // Si la misión se completó con éxito, el modal del NPC se refrescará
                    // porque completeMission llama a showModal y al cerrarlo se actualiza el UI
                    // o, como alternativa, podemos forzar el refresco aquí.
                    // closeModal(); // Cierra el modal de interacción actual
                    interactWithSectNPC(npcId); // Vuelve a abrir el modal del NPC con el estado actualizado
                  }
                  // Si completeMission devuelve false, generalmente ya muestra un modal de error/info.
                },
              });
              algunaMisionParaCompletar = true;
              console.log(
                `[NPC Interaction] SUCCESS: Added "Completar Misión" button for ${misionDef.titulo}`
              );
            } else {
              // Opcional: Mostrar la misión pero sin el botón de completar si no está lista
              modalContentHTML += `<div style="padding: 5px; border: 1px solid #777; margin-bottom: 5px; background-color: rgba(100,100,100,0.1);">
                                            <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                            <small><em>(Aún no cumples todos los requisitos para entregar/reportar esta misión)</em></small>
                                        </div>`;
              console.log(
                `[NPC Interaction] INFO: Mission "${misionDef.titulo}" is for this NPC but not ready for completion. Displaying status.`
              );
            }
          } else {
            // Log si la misión no es para este NPC
            // console.log(`[NPC Interaction] Mission "${misionDef.titulo}" is not designated for this NPC (Delivery NPC: ${objetivo.npcEntrega}).`);
          }
        });

        if (
          !algunaMisionParaCompletar &&
          !player.secta.misionesActivas.some(
            (m) => MISIONES_DATA[m.id]?.objetivo?.npcEntrega === npcId
          )
        ) {
          // Si no hay misiones para completar con ESTE NPC, y tampoco hay misiones activas que SEAN para este NPC (incluso si no están listas)
          modalContentHTML +=
            "<p>No tienes misiones para entregarme o reportarme en este momento.</p>";
          console.log(
            `[NPC Interaction] No missions found that are completable OR assignable to this NPC for completion.`
          );
        } else if (!algunaMisionParaCompletar) {
          // Hay misiones asignadas a este NPC, pero ninguna está lista para completarse.
          modalContentHTML +=
            "<p>Revisa los objetivos de tus misiones activas. Parece que aún no están listas para entregar/reportar.</p>";
          console.log(
            `[NPC Interaction] Missions are assigned to this NPC, but none are ready for completion yet.`
          );
        }
        modalContentHTML += "<hr>";

        // --- SECCIÓN: MISIONES DISPONIBLES (CON FILTRO DE NIVEL Y RANGO) ---
        // (Esta sección parece estar bien, la mantengo como estaba en tu código anterior con la lógica de requisitos)
        if (npcData.misionesOfrecidas && npcData.misionesOfrecidas.length > 0) {
          modalContentHTML += "<h4>Misiones Disponibles:</h4>";
          modalContentHTML += `<div id="npc-dynamic-content-missions" style="max-height: 200px; overflow-y: auto; border: 1px solid #444; padding: 10px; margin-bottom:10px;">`;
          let algunaMisionDisponibleMostrada = false;
          npcData.misionesOfrecidas.forEach((misionId, index) => {
            const mision = MISIONES_DATA[misionId];
            if (
              mision &&
              !player.secta.misionesActivas.some((m) => m.id === misionId) &&
              !player.secta.misionesCompletadas[misionId]
            ) {
              const nivelRequerido = mision.requisitoNivel || 0;
              const rangoRequeridoNombre = mision.requisitoRango;
              let cumpleRequisitos = true;

              if (player.level < nivelRequerido) {
                cumpleRequisitos = false;
              }
              if (rangoRequeridoNombre) {
                const indiceRangoJugador = SECTA_DATA.rangos.findIndex(
                  (r) => r.nombre === player.secta.rango
                );
                const indiceRangoRequerido = SECTA_DATA.rangos.findIndex(
                  (r) => r.nombre === rangoRequeridoNombre
                );
                if (indiceRangoJugador < indiceRangoRequerido) {
                  cumpleRequisitos = false;
                }
              }

              if (cumpleRequisitos) {
                let recompensaTextoResumido = `Recompensa: ${
                  mision.recompensa.pcs || 0
                } PCS, ${mision.recompensa.exp || 0} EXP`;
                if (mision.recompensa.items)
                  recompensaTextoResumido += ", Objetos";
                if (mision.recompensa.nuevoRango)
                  recompensaTextoResumido += `, Ascenso a ${mision.recompensa.nuevoRango}`;

                const buttonId = `accept-mission-btn-${misionId.replace(
                  /\W/g,
                  "_"
                )}-${index}`;
                const botonHTML = `<button id="${buttonId}">Aceptar Misión</button>`;

                modalContentHTML += `<div style="padding: 5px; border: 1px solid #555; margin-bottom: 5px;">
                                            <strong>${
                                              mision.titulo
                                            }</strong> (Req. Nv: ${
                  nivelRequerido > 0 ? nivelRequerido : "Ninguno"
                }${
                  rangoRequeridoNombre ? ", Rango: " + rangoRequeridoNombre : ""
                })<br><small>${mision.descripcion}</small><br>
                                            <small style="color: #aaa;"><em>${recompensaTextoResumido}</em></small><br>
                                            ${botonHTML} 
                                        </div>`;
                elementsToProcess.push({
                  buttonId: buttonId,
                  missionIdToAccept: misionId,
                });
                algunaMisionDisponibleMostrada = true;
              }
            }
          });
          if (!algunaMisionDisponibleMostrada)
            modalContentHTML +=
              "<p>No hay nuevas misiones para ti en este momento que cumplan tus requisitos.</p>";
          modalContentHTML += `</div>`;
          modalContentHTML += "<hr>";
        } else {
          modalContentHTML +=
            "<p>No tengo misiones para ti en este momento.</p><hr>";
        }

        // --- SECCIÓN: ENTREGA DE RECURSOS ---
        // (Esta sección parece estar bien, la mantengo)
        if (npcData.aceptaRecursos && npcData.aceptaRecursos.length > 0) {
          modalContentHTML += `<h4>Entregar Recursos:</h4>`;
          modalContentHTML += `<div id="npc-dynamic-content-resources" style="max-height: 150px; overflow-y: auto;">`;
          let puedeEntregarAlgo = false;
          npcData.aceptaRecursos.forEach((itemName) => {
            const cantidadPlayer = gameState.inventory[itemName] || 0;
            if (cantidadPlayer > 0) {
              const pcsPorItem =
                itemName === "Hierbas Medicinales"
                  ? 2
                  : itemName === "Cristales de Qi"
                  ? 5
                  : itemName === "Núcleo de Bestia Menor"
                  ? 10
                  : 1;
              const buttonIdEntregar1 = `entregar-1-${itemName.replace(
                /\W/g,
                "_"
              )}`;
              const buttonIdEntregarAll = `entregar-all-${itemName.replace(
                /\W/g,
                "_"
              )}`;
              modalContentHTML += `<p>${itemName} (Tienes: ${cantidadPlayer}): 
                                    <button id="${buttonIdEntregar1}">Entregar 1 (${pcsPorItem} PCS)</button>
                                    ${
                                      cantidadPlayer > 1
                                        ? `<button id="${buttonIdEntregarAll}">Entregar Todo (${
                                            pcsPorItem * cantidadPlayer
                                          } PCS)</button>`
                                        : ""
                                    }
                                </p>`;
              elementsToProcess.push({
                buttonId: buttonIdEntregar1,
                action: () => {
                  entregarRecursoSecta(itemName, 1, pcsPorItem);
                  interactWithSectNPC(npcId);
                },
              });
              if (cantidadPlayer > 1) {
                elementsToProcess.push({
                  buttonId: buttonIdEntregarAll,
                  action: () => {
                    entregarRecursoSecta(
                      itemName,
                      cantidadPlayer,
                      pcsPorItem * cantidadPlayer
                    );
                    interactWithSectNPC(npcId);
                  },
                });
              }
              puedeEntregarAlgo = true;
            }
          });
          if (!puedeEntregarAlgo)
            modalContentHTML +=
              "<p>No tienes recursos que pueda necesitar en este momento.</p>";
          modalContentHTML += `</div><hr>`;
        }

        showModal("Interacción con " + npcData.nombre, modalContentHTML);

        const modalTextEl = document.getElementById("modalText");
        if (modalTextEl) {
          elementsToProcess.forEach((item) => {
            const buttonElement = modalTextEl.querySelector(
              "#" + item.buttonId
            );
            if (buttonElement) {
              if (item.missionIdToAccept) {
                buttonElement.addEventListener("click", () => {
                  acceptMission(item.missionIdToAccept);
                  interactWithSectNPC(npcId);
                });
              } else if (item.action) {
                buttonElement.addEventListener("click", item.action);
              }
            } else {
              console.warn(
                "[NPC Interaction] Could not find button with ID:",
                item.buttonId,
                "in #modalText to attach listener."
              );
            }
          });
        } else {
          console.error(
            "[NPC Interaction] #modalText element not found for attaching listeners to dynamic buttons."
          );
        }
      }

      function entregarRecursoSecta(itemName, cantidad, pcsGanados) {
        if ((gameState.inventory[itemName] || 0) < cantidad) {
          showModal("Error", "No tienes suficientes objetos.");
          return;
        }
        gameState.inventory[itemName] -= cantidad;
        gameState.player.secta.puntosContribucion += pcsGanados;
        showModal(
          "Recurso Entregado",
          `Entregaste ${cantidad} ${itemName} y ganaste ${pcsGanados} PCS.`
        );
        updateSectUI();
        updateInventoryUI();
        checkAndActivateRankChallengeMissions();
        closeModal();
      }

      function acceptMission(misionId) {
        const misionData = MISIONES_DATA[misionId];
        const player = gameState.player;
        if (!misionData) {
          showModal("Error de Misión", "Datos no encontrados.");
          return;
        }
        if (
          player.secta.misionesActivas.some((m) => m.id === misionId) ||
          player.secta.misionesCompletadas[misionId]
        ) {
          showModal("Error de Misión", "Ya activa/completada.");
          return;
        }
        if (!misionData.objetivo) {
          showModal("Error de Misión", "Objetivo no definido.");
          return;
        }

        let nuevaMisionActiva;
        try {
          nuevaMisionActiva = {
            id: misionId,
            progreso: 0,
            objetivoOriginal: JSON.parse(JSON.stringify(misionData.objetivo)),
          };
        } catch (error) {
          showModal("Error de Misión", "Problema al procesar objetivo.");
          return;
        }

        player.secta.misionesActivas.push(nuevaMisionActiva);
        showModal("Misión Aceptada", `Has aceptado: ${misionData.titulo}`);
        updateSectUI();

        const npcInteractionModal = document.getElementById("interactionModal");
        const modalTitleElement = document.getElementById("modalTitle");
        if (
          npcInteractionModal.style.display === "flex" &&
          modalTitleElement &&
          modalTitleElement.textContent.includes("Interacción con Secta")
        ) {
          closeModal();
        }
      }

      function removeEntity(entityToRemove) {
        const index = gameState.map.entities.findIndex(
          (e) => e.id === entityToRemove.id
        ); // Usar ID único

        if (index > -1) {
          const removedEntity = gameState.map.entities.splice(index, 1)[0];

          // Si la entidad provenía de una zona de spawn, actualizar el contador de esa zona
          if (removedEntity.zoneOrigin) {
            const originZone = gameState.map.terrainZones.find(
              (z) => z.name === removedEntity.zoneOrigin && z.spawnSettings
            );
            if (originZone) {
              const targetSpawnInfo =
                originZone.spawnSettings.targetEntities.find(
                  (t) => t.entityTypeId === removedEntity.originalEntityTypeId // <-- USAR ESTO
                );
              if (targetSpawnInfo && targetSpawnInfo.currentCount > 0) {
                targetSpawnInfo.currentCount--;
                // console.log(`Entidad ${removedEntity.name} eliminada de zona ${originZone.name}. Restantes de tipo ${targetSpawnInfo.entityTypeId}: ${targetSpawnInfo.currentCount}`);

                // Si el contador baja y el timer estaba en cooldown, podemos resetear el timer
                // para que intente reaparecer antes si la zona está por debajo del objetivo.
                // Opcional: Podrías querer que el cooldown siempre se cumpla.
                // if (originZone.spawnSettings.respawnTimer > 10) { // Si estaba en cooldown largo
                //    originZone.spawnSettings.respawnTimer = 10; // Poner un cooldown corto para el próximo chequeo
                // }
              }
            }
          }
          renderMap(); // Actualizar visualización
        }
      }

      function isRespawnNeeded() {
        const player = gameState.player;
        const activeBoss = gameState.map.entities.find(
          (e) =>
            e.isBoss &&
            !player.worldState.defeatedBosses[e.id || e.type] &&
            Math.abs(e.x - player.x) <= 5 &&
            Math.abs(e.y - player.y) <= 5
        );
        return !activeBoss;
      }

      function toggleCultivation() {
        if (gameState.battle.active) {
          showModal("Acción no permitida", "No puedes cultivar en combate.");
          return;
        }
        if (gameState.player.isCultivating) {
          showActiveCultivationModal();
        } else {
          openCultivationChoiceModal();
        }
      }

      function openCultivationChoiceModal() {
        const player = gameState.player;
        const techniquesListDiv = document.getElementById(
          "cultivableTechniquesList"
        );
        techniquesListDiv.innerHTML = "";
        let hasCultivableTechniques = false;
        for (const techId in player.learnedTechniques) {
          const playerTech = player.learnedTechniques[techId];
          const techData = techniqueData[techId];
          if (
            techData &&
            techData.cultivationSettings &&
            playerTech.level < techData.maxLevel
          ) {
            hasCultivableTechniques = true;
            const techButton = document.createElement("button");
            techButton.className = "cultivation-option-btn";
            techButton.textContent = `${techData.name} (Nv. ${playerTech.level})`;
            techButton.onclick = () => {
              startCultivationMode("technique", techId);
              closeCultivationChoiceModal();
            };
            techniquesListDiv.appendChild(techButton);
          }
        }
        if (!hasCultivableTechniques) {
          techniquesListDiv.innerHTML =
            "<p>No tienes técnicas que requieran más cultivo.</p>";
        }
        document.getElementById("cultivationChoiceModal").style.display =
          "flex";
        hideTouchControls();
      }

      function closeCultivationChoiceModal() {
        document.getElementById("cultivationChoiceModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
      }

      function startCultivationMode(type, targetId = null) {
        const player = gameState.player;
        if (player.isCultivating) {
          stopCultivation();
        }

        player.isCultivating = true;
        player.cultivationMode.type = type;
        player.cultivationMode.targetId = targetId;
        player.cultivationMode.startTime = Date.now();

        // Si se inicia el modo de recuperación, reseteamos el progreso de su barra visual
        if (type === "recovery") {
          recoveryProgress = 0;
          recoveryDirection = 1;
        }

        const cultivateBtnSidebar = document.getElementById("cultivateButton");
        if (cultivateBtnSidebar) {
          cultivateBtnSidebar.textContent = "🚫 Detener Cultivo";
        } else {
          console.error(
            "Error en startCultivationMode: No se encontró 'cultivateButton'."
          );
        }

        if (gameState.cultivationInterval)
          clearInterval(gameState.cultivationInterval);
        gameState.cultivationInterval = setInterval(
          processCultivationTick,
          1000
        );

        showActiveCultivationModal();
      }

      function stopCultivation() {
        const player = gameState.player;
        if (!player.isCultivating) return;
        player.isCultivating = false;

        if (gameState.cultivationInterval) {
          clearInterval(gameState.cultivationInterval);
          gameState.cultivationInterval = null;
        }

        closeActiveCultivationModal();

        const cultivateBtn = document.getElementById("cultivateButton");
        if (cultivateBtn) cultivateBtn.textContent = "🧘‍♀️ Cultivar";

        const durationSeconds = Math.floor(
          (Date.now() - player.cultivationMode.startTime) / 1000
        );
        showModal(
          "Cultivo Terminado",
          `Has terminado de meditar/cultivar por ${durationSeconds} segundos.`
        );
        updateUI();
        if (
          document.getElementById("techniqueModal").style.display === "flex"
        ) {
          showTechniquePanel();
        }
      }

      function showActiveCultivationModal() {
        const player = gameState.player;
        const mode = player.cultivationMode;

        const modal = document.getElementById("activeCultivationModal");
        const title = document.getElementById("activeCultivationTitle");
        const description = document.getElementById(
          "activeCultivationDescription"
        );

        const techniqueProgressUIDiv = document.getElementById(
          "activeCultivationProgressUI"
        );
        const recoveryProgressUIDiv = document.getElementById(
          "recoveryCultivationProgressUI"
        );
        const cultivationBoostSection = document.getElementById(
          "cultivationBoostSection"
        ); // Nueva referencia
        if (!player.isCultivating) {
          closeActiveCultivationModal();
          return;
        }

        // Ocultar barras sobre el jugador en el mapa mientras el modal está abierto
        const playerBarsOnMap = document.getElementById(
          "playerOnMapBarsContainer"
        );
        if (playerBarsOnMap) playerBarsOnMap.style.display = "none";

        // Ocultar barras sobre el sprite en batalla (aunque no debería estar en batalla y cultivando)
        const playerBarsInBattle = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        if (playerBarsInBattle) playerBarsInBattle.style.display = "none";

        if (techniqueProgressUIDiv)
          techniqueProgressUIDiv.style.display = "none";
        if (recoveryProgressUIDiv) recoveryProgressUIDiv.style.display = "none";
        if (cultivationBoostSection)
          cultivationBoostSection.style.display = "none";

        if (mode.type === "recovery") {
          title.textContent = "Meditación Restauradora";
          description.textContent =
            "Recuperando energía vital, Qi y absorbiendo experiencia del entorno.";

          if (recoveryProgressUIDiv) {
            recoveryProgressUIDiv.style.display = "block";
            const recoveryProgressBar = document.getElementById(
              "recoveryProgressBar"
            );
            const recoveryCycleText =
              document.getElementById("recoveryCycleText");

            // Referencias a los elementos de HP y Maná del modal
            const modalHpText = document.getElementById("modalHpText");
            const modalHpBar = document.getElementById("modalHpBar");
            const modalManaText = document.getElementById("modalManaText");
            const modalManaBar = document.getElementById("modalManaBar");

            if (recoveryProgressBar)
              recoveryProgressBar.style.width = `${recoveryProgress}%`;
            if (recoveryCycleText)
              recoveryCycleText.textContent =
                recoveryDirection === 1
                  ? "Inhalando Qi..."
                  : "Exhalando impurezas...";

            // Actualizar texto y barras de HP/Maná en el modal
            if (modalHpText)
              modalHpText.textContent = `${Math.floor(player.hp)}/${
                player.maxHp
              }`;
            if (modalHpBar)
              modalHpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
            if (modalManaText)
              modalManaText.textContent = `${Math.floor(player.mana)}/${
                player.maxMana
              }`;
            if (modalManaBar)
              modalManaBar.style.width = `${
                (player.mana / player.maxMana) * 100
              }%`;
          }
        } else if (mode.type === "technique" && mode.targetId) {
          const techData = techniqueData[mode.targetId];
          const playerTech = player.learnedTechniques[mode.targetId];

          if (techData && playerTech) {
            title.textContent = `Cultivando: ${techData.name}`;
            description.textContent = techData.description;

            if (techniqueProgressUIDiv) {
              techniqueProgressUIDiv.style.display = "block";
              const targetNameSpan = document.getElementById(
                "activeCultivationTargetName"
              );
              const targetLevelSpan = document.getElementById(
                "activeCultivationTargetLevel"
              );
              const techniqueProgressBar = document.getElementById(
                "activeCultivationProgressBar"
              );
              const techniqueProgressText = document.getElementById(
                "activeCultivationProgressText"
              );

              if (targetNameSpan) targetNameSpan.textContent = techData.name;
              if (targetLevelSpan)
                targetLevelSpan.textContent = playerTech.level;

              const timeToNext =
                playerTech.cultivationTimeToNextLevel ||
                (techData.cultivationSettings
                  ? techData.cultivationSettings.baseTimeToLevelUp
                  : Infinity);
              const progressPercent =
                playerTech.currentCultivationProgress && timeToNext !== Infinity
                  ? (playerTech.currentCultivationProgress / timeToNext) * 100
                  : playerTech.level >= techData.maxLevel
                  ? 100
                  : 0;
              if (techniqueProgressBar)
                techniqueProgressBar.style.width = `${Math.min(
                  100,
                  progressPercent
                )}%`;
              if (techniqueProgressText)
                techniqueProgressText.textContent =
                  timeToNext === Infinity
                    ? "Nivel Máximo"
                    : `${Math.floor(
                        playerTech.currentCultivationProgress || 0
                      )}s / ${timeToNext}s`;
            }

            // Mostrar y configurar la sección de aceleración
            if (cultivationBoostSection) {
              cultivationBoostSection.style.display = "block";
              document.getElementById(
                "cultivationModalPlayerStones"
              ).textContent = gameState.inventory["Piedras Espirituales"] || 0;
              const boostButton = document.getElementById(
                "boostCultivationButton"
              );
              if (boostButton) {
                boostButton.disabled =
                  (gameState.inventory["Piedras Espirituales"] || 0) < 1 ||
                  playerTech.level >= techData.maxLevel;
                if (playerTech.level >= techData.maxLevel) {
                  boostButton.title = "Técnica al máximo nivel";
                } else if (
                  (gameState.inventory["Piedras Espirituales"] || 0) < 1
                ) {
                  boostButton.title = "Piedras Espirituales insuficientes";
                } else {
                  boostButton.title = "Acelerar Cultivo (1 Piedra = 10s)";
                }
              }
            }
          } else {
            // Fallback a recuperación si hay un error
            title.textContent = "Meditación Restauradora";
            description.textContent =
              "Error al cargar datos de técnica/habilidad. Cultivo de recuperación activado.";
            if (recoveryProgressUIDiv) {
              recoveryProgressUIDiv.style.display = "block";
              const modalHpText = document.getElementById("modalHpText");
              const modalHpBar = document.getElementById("modalHpBar");
              const modalManaText = document.getElementById("modalManaText");
              const modalManaBar = document.getElementById("modalManaBar");
              if (modalHpText)
                modalHpText.textContent = `${Math.floor(player.hp)}/${
                  player.maxHp
                }`;
              if (modalHpBar)
                modalHpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
              if (modalManaText)
                modalManaText.textContent = `${Math.floor(player.mana)}/${
                  player.maxMana
                }`;
              if (modalManaBar)
                modalManaBar.style.width = `${
                  (player.mana / player.maxMana) * 100
                }%`;
            }
          }
        } // No añadas llaves extra aquí, asegúrate de que la función cierra correctamente.

        if (modal) modal.style.display = "flex";

        hideTouchControls();
      }

      function closeActiveCultivationModal() {
        document.getElementById("activeCultivationModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
      }

      function processCultivationTick() {
        const player = gameState.player;
        if (!player.isCultivating) {
          if (gameState.cultivationInterval)
            clearInterval(gameState.cultivationInterval);
          gameState.cultivationInterval = null;
          return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        if (mode === "recovery") {
          // --- Recuperación General ---
          if (player.hp < player.maxHp)
            player.hp = Math.min(
              player.maxHp,
              player.hp + player.hpPerSecondBase
            );

          let manaGainThisTick = player.qiPerSecondBase;
          if (
            player.canUseQiConversion &&
            player.isQiConversionActive &&
            player.learnedTechniques["qi_to_hp_conversion_1"]
          ) {
            const conversionTechInfo = techniqueData["qi_to_hp_conversion_1"];
            const playerConversionTech =
              player.learnedTechniques["qi_to_hp_conversion_1"];
            if (conversionTechInfo?.effect && playerConversionTech.level > 0) {
              const effectDef = conversionTechInfo.effect;
              const techLevel = playerConversionTech.level;
              let currentManaCost =
                effectDef.baseManaCostPerSecond -
                (effectDef.manaCostReductionPerLevel || 0) * (techLevel - 1);
              currentManaCost = Math.max(0.1, currentManaCost);
              let currentHpGain =
                effectDef.baseHpGainPerSecond +
                (effectDef.hpGainIncreasePerLevel || 0) * (techLevel - 1);
              if (player.mana >= currentManaCost && player.hp < player.maxHp) {
                player.mana -= currentManaCost;
                manaGainThisTick = 0;
                player.hp = Math.min(player.maxHp, player.hp + currentHpGain);
              }
            }
          }
          if (player.mana < player.maxMana && manaGainThisTick > 0) {
            player.mana = Math.min(
              player.maxMana,
              player.mana + manaGainThisTick
            );
          }
          gainExperience(player.expPerSecondBase);

          // --- Lógica para la barra de progreso de ciclo de recuperación ---
          const increment = 100 / RECOVERY_CYCLE_DURATION;
          recoveryProgress += recoveryDirection * increment;
          if (recoveryProgress >= 100) {
            recoveryProgress = 100;
            recoveryDirection = -1;
          } else if (recoveryProgress <= 0) {
            recoveryProgress = 0;
            recoveryDirection = 1;
          }

          // Actualizar UI del ciclo de recuperación si el modal está abierto
          if (
            document.getElementById("activeCultivationModal").style.display ===
            "flex"
          ) {
            const recoveryProgressBar = document.getElementById(
              "recoveryProgressBar"
            );
            const recoveryCycleText =
              document.getElementById("recoveryCycleText");
            if (recoveryProgressBar)
              recoveryProgressBar.style.width = `${recoveryProgress}%`;
            if (recoveryCycleText)
              recoveryCycleText.textContent =
                recoveryDirection === 1
                  ? "Inhalando Qi..."
                  : "Exhalando impurezas...";
          }
        } else if (mode === "technique" && targetId) {
          // ... (lógica de cultivo de técnica sin cambios aquí para las barras del modal,
          //      ya que esas barras son principalmente para 'recovery')
          const playerTech = player.learnedTechniques[targetId];
          const techData = techniqueData[targetId];
          if (
            playerTech &&
            techData &&
            techData.cultivationSettings &&
            playerTech.level < techData.maxLevel
          ) {
            playerTech.currentCultivationProgress =
              (playerTech.currentCultivationProgress || 0) + 1;
            gainExperience(player.expPerSecondBase * 0.2);
            if (
              playerTech.currentCultivationProgress >=
              playerTech.cultivationTimeToNextLevel
            ) {
              playerTech.level++;
              playerTech.currentCultivationProgress = 0;
              if (playerTech.level < techData.maxLevel) {
                playerTech.cultivationTimeToNextLevel = Math.floor(
                  techData.cultivationSettings.baseTimeToLevelUp *
                    (techData.cultivationSettings.levelTimeMultiplier *
                      playerTech.level)
                );
                playerTech.cultivationTimeToNextLevel = Math.max(
                  techData.cultivationSettings.baseTimeToLevelUp,
                  playerTech.cultivationTimeToNextLevel
                );
              } else {
                playerTech.cultivationTimeToNextLevel = Infinity;
              }
              applyTechniqueEffect(targetId, playerTech.level);
              recalculatePlayerStats();
              let message = `¡Has cultivado '${techData.name}' al Nivel ${playerTech.level}!`;
              if (playerTech.level >= techData.maxLevel) {
                message += " (¡Nivel Máximo alcanzado!)";
              }
              stopCultivation();
              showModal(
                "¡Técnica Mejorada!",
                message +
                  "\n\nEl cultivo se ha detenido. Puedes reiniciarlo si lo deseas."
              );
              if (
                document.getElementById("techniqueModal").style.display ===
                "flex"
              )
                showTechniquePanel();
            }
          } else if (
            playerTech &&
            techData &&
            playerTech.level >= techData.maxLevel
          ) {
            stopCultivation();
          }
        } else if (mode === "skill" && targetId) {
          // ...
        }

        updateUI();
        if (
          document.getElementById("activeCultivationModal").style.display ===
          "flex"
        ) {
          showActiveCultivationModal(); // Refresca el modal, incluyendo la nueva barra de recuperación
        }
      }

      function boostCultivationProgress() {
        const player = gameState.player;
        const mode = player.cultivationMode;

        if (
          !player.isCultivating ||
          mode.type !== "technique" ||
          !mode.targetId
        ) {
          showModal(
            "Error de Aceleración",
            "Solo puedes acelerar el cultivo activo de una técnica específica."
          );
          return;
        }

        if ((gameState.inventory["Piedras Espirituales"] || 0) < 1) {
          showModal(
            "Piedras Insuficientes",
            "No tienes suficientes Piedras Espirituales para acelerar."
          );
          return;
        }

        const techId = mode.targetId;
        const playerTech = player.learnedTechniques[techId];
        const techData = techniqueData[techId];

        if (
          !playerTech ||
          !techData ||
          !techData.cultivationSettings ||
          playerTech.level >= techData.maxLevel
        ) {
          // Añadida comprobación de techData.cultivationSettings
          showModal(
            "Límite Alcanzado",
            "Esta técnica ya está en su nivel máximo, no se puede cultivar más, o faltan datos de cultivo."
          );
          const boostButton = document.getElementById("boostCultivationButton");
          if (boostButton) boostButton.disabled = true;
          return;
        }

        // Consumir piedra
        gameState.inventory["Piedras Espirituales"]--;

        // Añadir progreso (10 segundos)
        playerTech.currentCultivationProgress =
          (playerTech.currentCultivationProgress || 0) + 10;
        gainExperience(player.expPerSecondBase * 0.2 * 2);

        let leveledUpThisBoost = false;
        let firstLevelUpMessage = "";

        // Asegurarse de que cultivationTimeToNextLevel está inicializado si el nivel es 0
        if (
          playerTech.level === 0 &&
          (!playerTech.cultivationTimeToNextLevel ||
            playerTech.cultivationTimeToNextLevel === Infinity)
        ) {
          playerTech.cultivationTimeToNextLevel =
            techData.cultivationSettings.baseTimeToLevelUp;
        }

        while (
          playerTech.currentCultivationProgress >=
            playerTech.cultivationTimeToNextLevel &&
          playerTech.level < techData.maxLevel
        ) {
          playerTech.level++;
          playerTech.currentCultivationProgress -=
            playerTech.cultivationTimeToNextLevel;

          if (playerTech.level < techData.maxLevel) {
            playerTech.cultivationTimeToNextLevel = Math.floor(
              techData.cultivationSettings.baseTimeToLevelUp *
                (techData.cultivationSettings.levelTimeMultiplier *
                  playerTech.level)
            );
            // La siguiente línea es crucial: Asegura que el tiempo calculado no sea MENOR que el baseTimeToLevelUp.
            // Y aquí estaba el error: se usaba baseTimeToNextLevel en lugar de baseTimeToLevelUp
            playerTech.cultivationTimeToNextLevel = Math.max(
              techData.cultivationSettings.baseTimeToLevelUp,
              playerTech.cultivationTimeToNextLevel
            ); // <-- CORRECCIÓN IMPORTANTE AQUÍ
          } else {
            playerTech.currentCultivationProgress = 0;
            playerTech.cultivationTimeToNextLevel = Infinity;
          }

          applyTechniqueEffect(techId, playerTech.level);
          recalculatePlayerStats();

          if (!leveledUpThisBoost) {
            firstLevelUpMessage = `¡Aceleraste '${techData.name}' al Nivel ${playerTech.level}!`;
            if (playerTech.level >= techData.maxLevel) {
              firstLevelUpMessage += " (¡Nivel Máximo alcanzado!)";
            }
          }
          leveledUpThisBoost = true;
        }

        if (leveledUpThisBoost) {
          stopCultivation();
          showModal(
            "¡Técnica Mejorada con Aceleración!",
            firstLevelUpMessage +
              "\n\nEl cultivo se ha detenido. Puedes reiniciarlo."
          );
        } else if (playerTech.level >= techData.maxLevel) {
          stopCultivation();
          showModal(
            "Nivel Máximo Alcanzado",
            `La técnica ${techData.name} ya está en su máximo potencial. El cultivo se ha detenido.`
          );
        }

        updateUI();
        // Es importante llamar a showActiveCultivationModal() DESPUÉS de stopCultivation() si el cultivo se detuvo,
        // o si no se detuvo, para que refleje el estado actual.
        // Si se detuvo, el modal se cerrará por stopCultivation(). Si el modal no está abierto, esta llamada no hará nada.
        if (
          document.getElementById("activeCultivationModal").style.display ===
          "flex"
        ) {
          showActiveCultivationModal();
        }

        if (
          document.getElementById("techniqueModal").style.display === "flex"
        ) {
          showTechniquePanel();
        }
      }

      function toggleQiConversionMode() {
        if (!gameState.player.canUseQiConversion) {
          showModal(
            "Habilidad Bloqueada",
            "Debes dominar la Técnica de Conversión de Qi."
          );
          return;
        }
        if (gameState.player.isCultivating) {
          showModal(
            "Acción no Permitida",
            "Detén tu cultivo antes de cambiar conversión."
          );
          return;
        }
        gameState.player.isQiConversionActive =
          !gameState.player.isQiConversionActive;
        updateToggleQiConversionButtonVisibility();
        showModal(
          "Modo de Cultivo",
          `Conversión de Qi ${
            gameState.player.isQiConversionActive ? "Activada" : "Desactivada"
          }.`
        );
      }

      function useItem(itemName) {
        if (gameState.battle.active) {
          showModal(
            "Acción no permitida",
            "No puedes usar objetos del inventario en combate desde aquí."
          );
          return;
        }
        if (
          !gameState.inventory[itemName] ||
          gameState.inventory[itemName] <= 0
        ) {
          showModal("Inventario Vacío", `No tienes ${itemName}.`);
          return;
        }
        const itemInfo = itemData[itemName];
        if (!itemInfo || !itemInfo.effect) {
          showModal(
            "Error",
            `${itemName} no tiene efecto o no se puede usar así.`
          );
          return;
        }
        if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
          let reason = "No puedes usar esto ahora.";
          if (
            itemName === "Hierbas Medicinales" &&
            gameState.player.hp >= gameState.player.maxHp
          )
            reason = "Vida al máximo.";
          if (
            itemName === "Cristales de Qi" &&
            gameState.player.mana >= gameState.player.maxMana
          )
            reason = "Maná al máximo.";
          showModal("No se puede usar", reason);
          return;
        }
        const message =
          itemName === "Piedras Espirituales" ||
          itemName === "Núcleo de Bestia Menor" ||
          (itemInfo.description &&
            (itemInfo.description.includes("Otorga") ||
              itemInfo.description.includes("otorga")))
            ? itemInfo.effect(gameState.player, gainExperience)
            : itemInfo.effect(gameState.player);

        // Solo decrementar si el mensaje no indica un error (por si el efecto mismo retorna un error)
        if (
          message &&
          !message.toLowerCase().includes("error") &&
          !message.toLowerCase().includes("al máximo")
        ) {
          gameState.inventory[itemName]--;
        }
        showModal("Objeto Usado", message);
        updateUI();
      }

      function gainExperience(amount) {
        if (amount <= 0) return;
        gameState.player.exp += amount;
        while (gameState.player.exp >= gameState.player.expToNext) {
          levelUp();
        }
      }

      function levelUp() {
        const player = gameState.player;
        player.exp -= player.expToNext;
        player.level++;

        const hpIncrease = 20 + Math.floor(player.level / 2);
        const manaIncrease = 10 + Math.floor(player.level / 3);
        const attackIncrease = 2 + Math.floor(player.level / 4);
        const defenseIncrease = 1 + Math.floor(player.level / 5);

        player.baseMaxHp += hpIncrease;
        player.baseMaxMana += manaIncrease;
        player.baseAttack += attackIncrease;
        player.baseDefense += defenseIncrease;

        player.hp = player.baseMaxHp; // Rellenar HP y Mana al subir de nivel
        player.mana = player.baseMaxMana;
        player.expToNext = Math.floor(
          player.expToNext * (1.3 + player.level * 0.02)
        );

        const oldRealm = player.realm;
        const realms = [
          "Mortal",
          "Forjado del Cuerpo",
          "Condensación de Qi",
          "Fundación",
          "Núcleo Dorado",
          "Alma Naciente",
          "Espíritu Primordial",
        ];
        const realmIndex = Math.min(
          Math.floor((player.level - 1) / 5),
          realms.length - 1
        );
        player.realm = realms[realmIndex];
        let realmChangeMessage = "";
        if (player.realm !== oldRealm) {
          realmChangeMessage = `\n\n¡Has avanzado al Reino de ${player.realm}! Sientes una profunda transformación...`;
          generateMap(true);
        }
        recalculatePlayerStats();

        showModal(
          "¡Nivel Aumentado!",
          `Nivel ${player.level}!\nReino: ${player.realm}\n+${hpIncrease} HP, +${manaIncrease} Maná\n+${attackIncrease} Atk, +${defenseIncrease} Def${realmChangeMessage}`
        );
      }

      function recalculatePlayerStats() {
        const player = gameState.player;
        // Reiniciar stats a base
        player.maxHp = player.baseMaxHp;
        player.maxMana = player.baseMaxMana;
        player.attack = player.baseAttack;
        player.defense = player.baseDefense;

        // Asegurar que HP y Mana actuales no excedan los máximos recalculados
        player.hp = Math.min(player.hp, player.maxHp);
        player.mana = Math.min(player.mana, player.maxMana);

        gameState.activeCombatAbilities = []; // Reiniciar lista de habilidades de combate activas

        // Procesar técnicas aprendidas para habilidades de combate activas y efectos pasivos directos
        for (const techId in player.learnedTechniques) {
          const playerTech = player.learnedTechniques[techId];
          if (playerTech.level > 0) {
            // Solo si la técnica ha sido cultivada al menos al nivel 1 (o 0 si así lo defines)
            const techInfo = techniqueData[techId];
            if (
              techInfo?.type === "active_ability" &&
              !gameState.activeCombatAbilities.find(
                (ab) => ab.id === techInfo.abilityId
              )
            ) {
              gameState.activeCombatAbilities.push({
                id: techInfo.abilityId,
                name: techInfo.name,
                source: "technique",
                sourceTechniqueId: techId, // Guardar el ID de la técnica fuente es útil
              });
            }
            // Si tienes técnicas pasivas que modifican stats como "Fortificación Corporal Básica",
            // sus efectos ya se aplicaron al player.baseStat cuando se aprendieron/subieron de nivel en applyTechniqueEffect.
            // recalculatePlayerStats se encarga de que maxHp, attack, etc., se actualicen desde baseMaxHp, baseAttack.
          }
        }
        updateUI(); // Actualizar la UI con los stats recalculados
      }

      function startBattle(mapEntity) {
        const toggleBtn = document.getElementById('toggleMapControlsBtn');
        if (toggleBtn) {
            toggleBtn.classList.add('hidden-during-battle');
        }
        const player = gameState.player;
        if (player.isCultivating) stopCultivation();
        hideTouchControls();

        // Detener animación de caminar al entrar en batalla
        player.isMoving = false;
        if (player.animationTimer) {
          clearInterval(player.animationTimer);
          player.animationTimer = null;
        }
        if (player.idleTimeout) {
          clearTimeout(player.idleTimeout);
          player.idleTimeout = null;
        }
        player.currentDirection = "down"; // O la dirección que quieras en batalla
        player.currentFrame = 0; // Frame idle
        updatePlayerSpriteVisual(); // Actualizar para mostrar el sprite de batalla

        gameState.battle.active = true;
        gameState.battle.enemy = {
          ...mapEntity,
          hp: mapEntity.hp,
          maxHp: mapEntity.maxHp || mapEntity.hp,
          entityRef: mapEntity,
          frozenTurns: 0,
          stunnedTurns: 0,
          burningTurns: 0,
          burnDamage: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          defenseReductionTurns: 0,
          defenseReductionAmount: 0,
          rootedTurns: 0,
          rootDamage: 0,
          attackReductionTurns: 0,
          attackReductionAmount: 0,
        };
        gameState.battle.playerTurn = true;

        document.getElementById("battleScreen").style.display = "flex";
        populateBattleActionButtons();
        updateBattleUI();
        logBattle(`¡Un ${gameState.battle.enemy.name} te enfrenta!`);
        updateBottomNavVisibility();
        updatePlayerBarsOnMap();
      }

      function populateBattleActionButtons() {
        const battleActionButtons = document.getElementById(
          "battleActionButtons"
        );
        battleActionButtons.innerHTML = `
            <button onclick="battleAction('attack')">⚔️ Atacar</button>
            <button onclick="battleAction('defend')">🛡️ Defender</button>
            <button onclick="battleAction('qi_fist')">🧘 Puño de Qi</button> 
            <button onclick="battleAction('escape')">🏃 Huir</button>
        `;
        gameState.activeCombatAbilities.forEach((ability) => {
          const abilityButton = document.createElement("button");
          let buttonText = `✨ ${ability.name}`;
          let canAfford = true;
          if (ability.source === "technique" && ability.sourceTechniqueId) {
            const techLevel =
              gameState.player.learnedTechniques[ability.sourceTechniqueId]
                ?.level;
            if (techLevel > 0) buttonText += ` (Nv.${techLevel})`;
            else {
              abilityButton.disabled = true;
              abilityButton.title = "Requiere refinamiento";
            }
          }
          const techDetails =
            ability.source === "technique" && ability.sourceTechniqueId
              ? techniqueData[ability.sourceTechniqueId]
              : null;
          let manaCost = 0;
          if (
            techDetails &&
            techDetails.effect &&
            techDetails.effect.manaCost
          ) {
            manaCost = techDetails.effect.manaCost;
          } else if (ability.id === "qi_blast_minor") {
            manaCost = 15;
          } else if (techDetails && techDetails.manaCost) {
            manaCost = techDetails.manaCost;
          }
          if (manaCost > 0 && gameState.player.mana < manaCost) {
            canAfford = false;
          }

          abilityButton.textContent = buttonText;
          abilityButton.onclick = () => battleAction(ability.id, ability);
          abilityButton.disabled = abilityButton.disabled || !canAfford;
          if (!canAfford && !abilityButton.disabled)
            abilityButton.title = "Maná insuficiente";

          battleActionButtons.appendChild(abilityButton);
        });
      }

      function updateBattleUI() {
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const battleScreenActive = document.getElementById('battleScreen').style.display === 'flex';

        // --- Actualización del Jugador (Barras sobre el sprite) ---
        const playerBarsContainer = document.getElementById("playerInBattleSpriteBarsContainer");
        const playerSpriteInBattle = document.querySelector(".battle-area .character .character-sprite");

        if (playerBarsContainer && playerSpriteInBattle && battleScreenActive) {
            playerBarsContainer.style.display = 'flex';
            const spriteTop = playerSpriteInBattle.offsetTop;
            const spriteLeft = playerSpriteInBattle.offsetLeft;
            const spriteWidth = playerSpriteInBattle.offsetWidth;
            const barContainerHeight = playerBarsContainer.offsetHeight;

            playerBarsContainer.style.top = `${spriteTop - barContainerHeight - 3}px`;
            playerBarsContainer.style.left = `${spriteLeft + (spriteWidth / 2)}px`;

            const playerHpFill = document.getElementById("playerInBattleSpriteHpFill");
            const playerManaFill = document.getElementById("playerInBattleSpriteManaFill");
            if(playerHpFill) playerHpFill.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
            if(playerManaFill) playerManaFill.style.width = `${Math.max(0, (player.mana / player.maxMana) * 100)}%`;

        } else if (playerBarsContainer) {
            playerBarsContainer.style.display = 'none';
        }

        // --- Actualización del Enemigo (Info y barras sobre el sprite) ---
        const enemyInfoContainer = document.getElementById('enemyInBattleInfoContainer');
        const enemySpriteEl = document.getElementById('enemySprite');
        
        // MOVER LA DECLARACIÓN DE enemyHpPercent AQUÍ ARRIBA
        let enemyHpPercent = 0;
        if (enemy) { // Asegurarse que enemy exista antes de calcular
            enemyHpPercent = Math.max(0, (enemy.hp / (enemy.maxHp || enemy.hp)) * 100);
        }

        if (enemy && enemyInfoContainer && enemySpriteEl && battleScreenActive) {
            enemyInfoContainer.style.display = 'flex';

            const spriteTop = enemySpriteEl.offsetTop;
            const spriteLeft = enemySpriteEl.offsetLeft;
            const spriteWidth = enemySpriteEl.offsetWidth;
            const infoContainerHeight = enemyInfoContainer.offsetHeight;

            if (isMobileView()) {
                console.log("[Mobile Battle UI] Enemy Sprite - offsetTop:", spriteTop, "offsetLeft:", spriteLeft, "offsetWidth:", spriteWidth);
                console.log("[Mobile Battle UI] Enemy InfoContainer - offsetHeight:", infoContainerHeight);
                console.log("[Mobile Battle UI] Calculated top:", `${spriteTop - infoContainerHeight - 5}px`, "Calculated left:", `${spriteLeft + (spriteWidth / 2)}px`);
            }

            enemyInfoContainer.style.top = `${spriteTop - infoContainerHeight - 5}px`;
            enemyInfoContainer.style.left = `${spriteLeft + (spriteWidth / 2)}px`;

            const enemyNameLevelEl = document.getElementById('enemyBattleNameLevel');
            const enemySpriteHpFill = document.getElementById('enemyInBattleSpriteHpFill'); // Barra SOBRE el sprite

            if (enemyNameLevelEl) {
                let enemyDisplayName = enemy.name;
                if (enemy.level) enemyDisplayName += ` (Nv.${enemy.level})`;
                else if (enemy.isBoss) enemyDisplayName += ` (Jefe)`;
                else if (enemy.isMiniBoss) enemyDisplayName += ` (Élite)`;
                enemyNameLevelEl.textContent = enemyDisplayName;
            }
            if (enemySpriteHpFill) enemySpriteHpFill.style.width = `${enemyHpPercent}%`; // Usa la variable ya calculada

        } else if (enemyInfoContainer) {
            enemyInfoContainer.style.display = 'none';
        }

        // --- Actualización del resto de la UI de batalla (nombres debajo, barras principales, etc.) ---
        if (battleScreenActive) {
            document.getElementById('playerBattleName').textContent = `Cultivador (Nv.${player.level})`;
            document.getElementById('playerBattleHp').textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
            document.getElementById('playerBattleHpBar').style.width = `${(player.hp / player.maxHp) * 100}%`;
            
            // updatePlayerBarsInBattle(); // Esta llamada podría ser redundante si ya actualizamos las barras del jugador arriba.
                                        // Mantenla si hace algo más o si la lógica de arriba se mueve.

            if (enemy && enemySpriteEl) { // Añadir chequeo para enemySpriteEl aquí también
                enemySpriteEl.textContent = enemy.symbol || '?';
                document.getElementById('enemyName').textContent = enemy.name;
                document.getElementById('enemyHp').textContent = `${Math.floor(enemy.hp)}/${enemy.maxHp || enemy.hp}`;
                document.getElementById('enemyHpBar').style.width = `${enemyHpPercent}%`; // Usa la variable ya calculada
            }
        }
    }
      function battleAction(action, abilityDetails = null) {
        if (!gameState.battle.playerTurn || !gameState.battle.active) return;
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        let actionTaken = true;
        let playerTechLevel = 0;
        if (
          abilityDetails &&
          abilityDetails.source === "technique" &&
          abilityDetails.sourceTechniqueId
        ) {
          playerTechLevel =
            player.learnedTechniques[abilityDetails.sourceTechniqueId]?.level ||
            0;
        }

        // --- Aplicar DoTs y HoTs al JUGADOR ---
        if (player.burningTurns > 0) {
          player.hp -= player.burnDamage;
          logBattle(`Sufres ${player.burnDamage} daño por quemadura.`);
          player.burningTurns--;
          if (player.burningTurns === 0) logBattle("Quemadura se extingue.");
        }
        if (player.poisonedTurns > 0) {
          player.hp -= player.poisonDamage;
          logBattle(`Sufres ${player.poisonDamage} daño por veneno.`);
          player.poisonedTurns--;
          if (player.poisonedTurns === 0) logBattle("Veneno desaparece.");
        }
        if (player.healingRainTurns > 0) {
          const heal = player.healingRainAmount;
          player.hp = Math.min(player.maxHp, player.hp + heal);
          logBattle(`Lluvia Curativa te sana ${heal} HP.`);
          player.healingRainTurns--;
          if (player.healingRainTurns === 0) logBattle("Lluvia Curativa cesa.");
        }

        // --- Revertir buffs/debuffs temporales del JUGADOR ---
        if (player.defenseBoostTurns > 0) {
          player.defenseBoostTurns--;
          if (player.defenseBoostTurns === 0) {
            player.defense -= player.defenseBoostAmount;
            logBattle(`Piel de Piedra termina. Defensa: ${player.defense}.`);
            player.defenseBoostAmount = 0;
          }
        }
        if (player.bloodRitualTurns > 0 && action !== "blood_ritual") {
          player.bloodRitualTurns--;
          if (player.bloodRitualTurns === 0) {
            player.attack -= player.bloodRitualAttackBoost;
            logBattle(`Ritual de Sangre termina. Ataque: ${player.attack}.`);
            player.bloodRitualAttackBoost = 0;
          }
        }
        if (player.immuneTurns > 0 && action !== "aura_of_purity") {
          player.immuneTurns--;
          if (player.immuneTurns === 0) {
            logBattle(`Inmunidad termina.`);
          }
        }
        if (
          player.cloneActive &&
          player.cloneTurns > 0 &&
          action !== "phantom_clone"
        ) {
          player.cloneTurns--;
          if (player.cloneTurns === 0) {
            player.cloneActive = false;
            logBattle("Clon Fantasma desaparece.");
          }
        }
        if (player.elementalTurns > 0 && action !== "summon_elemental") {
          player.elementalTurns--;
          if (player.elementalTurns === 0) {
            player.attack -= player.tempAttackBonus;
            player.defense -= player.tempDefenseBonus;
            logBattle("Elemental invocado desaparece.");
            player.tempAttackBonus = 0;
            player.tempDefenseBonus = 0;
          }
        }
        if (player.magicShieldTurns > 0 && action !== "mystic_barrier") {
          player.magicShieldTurns--;
          if (player.magicShieldTurns === 0 && player.magicShieldValue > 0) {
            logBattle("Barrera Mística se disipa.");
            player.magicShieldValue = 0;
          }
        }

        if (player.hp <= 0) {
          logBattle("Has sucumbido antes de actuar.");
          player.hp = 0;
          setTimeout(() => {
            player.hp = Math.floor(player.maxHp * 0.1);
            player.mana = Math.floor(player.maxMana * 0.1);
            const expLossPercentage = 0.1;
            const expToLose = Math.floor(player.exp * expLossPercentage);
            player.exp = Math.max(0, player.exp - expToLose);
            logBattle(`Pierdes ${expToLose} EXP.`);
            const safeRespawnCoords = findSafeRespawnLocation(
              G_SAFE_RESPAWN_X,
              G_SAFE_RESPAWN_Y
            );
            player.x = safeRespawnCoords.x;
            player.y = safeRespawnCoords.y;
            updatePlayerPosition();
            endBattle(false);
            showModal("Derrota", "Has sido derrotado...");
          }, 2000);
          return;
        }

        switch (action) {
          case "attack":
            const damage = Math.max(
              1,
              player.attack -
                (enemy.defense || 0) +
                Math.floor(Math.random() * 5 - 2)
            );
            enemy.hp -= damage;
            logBattle(`Atacas causando ${damage} daño.`);
            break;
          case "defend":
            let healAmount = Math.floor(player.maxHp * 0.1);
            player.hp = Math.min(player.maxHp, player.hp + healAmount);
            logBattle(`Te defiendes y recuperas ${healAmount} HP.`);
            const meditationSkillInfo = getSkillById("se_mana_regen_1");
            if (
              meditationSkillInfo &&
              player.learnedSkills["se_mana_regen_1"]
            ) {
              const manaRegenEffect = meditationSkillInfo.effects.find(
                (e) => e.effectId === "mana_regen_on_defend"
              );
              if (manaRegenEffect) {
                player.mana = Math.min(
                  player.maxMana,
                  player.mana + manaRegenEffect.value
                );
                logBattle(
                  `Meditación profunda restaura ${manaRegenEffect.value} maná.`
                );
              }
            }
            break;
          case "qi_fist":
            const qiFistCost = 10;
            if (player.mana >= qiFistCost) {
              player.mana -= qiFistCost;
              const magicDamage = Math.max(
                1,
                Math.floor(player.attack * 0.8 + player.maxMana * 0.2) -
                  (enemy.defense || 0)
              );
              enemy.hp -= magicDamage;
              logBattle(`Puño de Qi causa ${magicDamage} daño mágico.`);
            } else {
              logBattle("Maná insuficiente para Puño de Qi.");
              actionTaken = false;
            }
            break;
          case "escape":
            if (enemy.isBoss) {
              logBattle(`¡No puedes huir de un ${enemy.name}!`);
            } else if (Math.random() < 0.7) {
              logBattle("¡Escapaste!");
              endBattle(false);
              return;
            } else {
              logBattle("¡No pudiste escapar!");
            }
            break;
          case "sword_slash":
            const swordTechDetails = techniqueData["sword_slash_1"];
            const swordManaCost = swordTechDetails.manaCost || 10;
            if (player.mana >= swordManaCost) {
              player.mana -= swordManaCost;
              const damageMultiplier =
                swordTechDetails.effect.baseDamageMultiplier +
                (playerTechLevel - 1) * 0.2;
              const swordDamage = Math.max(
                1,
                Math.floor(player.attack * damageMultiplier) -
                  (enemy.defense || 0)
              );
              enemy.hp -= swordDamage;
              logBattle(
                `¡${swordTechDetails.name} (Nv.${playerTechLevel}) causa ${swordDamage} daño!`
              );
            } else {
              logBattle(`Maná insuficiente para ${swordTechDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "qi_blast_minor":
            const qiBlastCostSkill = 15;
            if (player.mana >= qiBlastCostSkill) {
              player.mana -= qiBlastCostSkill;
              const qiDamage = Math.max(
                1,
                Math.floor(player.attack * 0.6 + player.maxMana * 0.4) -
                  (enemy.defense || 0)
              );
              enemy.hp -= qiDamage;
              logBattle(
                `¡Lanzas ${abilityDetails.name} causando ${qiDamage} daño Qi!`
              );
            } else {
              logBattle(`Maná insuficiente para ${abilityDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "ice_prison":
            const icePrisonDetails = techniqueData["ice_prison_1"];
            const iceManaCost = icePrisonDetails.effect.manaCost;
            if (player.mana >= iceManaCost) {
              player.mana -= iceManaCost;
              const freezeChance =
                icePrisonDetails.effect.freezeChance +
                (playerTechLevel - 1) * 0.05;
              if (Math.random() < freezeChance) {
                const freezeDuration =
                  icePrisonDetails.effect.freezeDuration +
                  Math.floor((playerTechLevel - 1) / 2);
                enemy.frozenTurns = Math.max(enemy.frozenTurns, freezeDuration);
                logBattle(
                  `¡${icePrisonDetails.name} (Nv.${playerTechLevel}) congela a ${enemy.name} por ${freezeDuration} turnos!`
                );
              } else {
                logBattle(
                  `¡${icePrisonDetails.name} (Nv.${playerTechLevel}) falló!`
                );
              }
            } else {
              logBattle(`Maná insuficiente para ${icePrisonDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "flame_strike":
            const flameStrikeDetails = techniqueData["flame_strike_1"];
            const flameManaCost = flameStrikeDetails.effect.manaCost;
            if (player.mana >= flameManaCost) {
              player.mana -= flameManaCost;
              const baseDam = Math.floor(
                player.attack *
                  (flameStrikeDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.1)
              );
              const burnDam =
                flameStrikeDetails.effect.burnDamagePerTurn +
                (playerTechLevel - 1) * 2;
              const burnDur = flameStrikeDetails.effect.burnDuration;
              enemy.hp -= baseDam;
              enemy.burningTurns = Math.max(enemy.burningTurns, burnDur);
              enemy.burnDamage = Math.max(enemy.burnDamage, burnDam);
              logBattle(
                `¡${flameStrikeDetails.name} (Nv.${playerTechLevel}) causa ${baseDam} daño e inflige quemadura de ${burnDam} por ${burnDur} turnos!`
              );
            } else {
              logBattle(`Maná insuficiente para ${flameStrikeDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "thunder_fury":
            const thunderDetails = techniqueData["thunder_fury_1"];
            const thunderManaCost = thunderDetails.effect.manaCost;
            if (player.mana >= thunderManaCost) {
              player.mana -= thunderManaCost;
              const damage = Math.floor(
                player.attack *
                  (thunderDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.15)
              );
              enemy.hp -= damage;
              logBattle(
                `${thunderDetails.name} (Nv.${playerTechLevel}) golpea con ${damage} daño.`
              );
              const stunChance =
                thunderDetails.effect.stunChance + (playerTechLevel - 1) * 0.08;
              if (Math.random() < stunChance) {
                enemy.stunnedTurns = Math.max(
                  enemy.stunnedTurns,
                  1 + Math.floor((playerTechLevel - 1) / 3)
                );
                logBattle(`¡${enemy.name} queda aturdido!`);
              }
            } else {
              logBattle(`Maná insuficiente para ${thunderDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "poison_dart":
            const poisonDetails = techniqueData["poison_dart_1"];
            const poisonManaCost = poisonDetails.effect.manaCost;
            if (player.mana >= poisonManaCost) {
              player.mana -= poisonManaCost;
              const baseDam = Math.floor(
                player.attack *
                  (poisonDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.05)
              );
              const poisonDam =
                poisonDetails.effect.poisonDamagePerTurn +
                Math.floor((playerTechLevel - 1) * 1.5);
              const poisonDur = poisonDetails.effect.poisonDuration;
              enemy.hp -= baseDam;
              enemy.poisonedTurns = Math.max(enemy.poisonedTurns, poisonDur);
              enemy.poisonDamage = Math.max(enemy.poisonDamage, poisonDam);
              logBattle(
                `¡${poisonDetails.name} (Nv.${playerTechLevel}) causa ${baseDam} daño e inflige veneno de ${poisonDam} por ${poisonDur} turnos!`
              );
            } else {
              logBattle(`Maná insuficiente para ${poisonDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "stone_skin":
            const stoneSkinDetails = techniqueData["stone_skin_1"];
            const stoneManaCost = stoneSkinDetails.effect.manaCost;
            if (player.mana >= stoneManaCost) {
              player.mana -= stoneManaCost;
              if (player.defenseBoostTurns > 0) {
                logBattle(`Refrescas ${stoneSkinDetails.name}.`);
              } else {
                player.defenseBoostAmount =
                  stoneSkinDetails.effect.defenseBoost +
                  (playerTechLevel - 1) * 3;
                player.defense += player.defenseBoostAmount;
                logBattle(
                  `${stoneSkinDetails.name} (Nv.${playerTechLevel}) aumenta tu defensa en ${player.defenseBoostAmount}. Defensa: ${player.defense}.`
                );
              }
              player.defenseBoostTurns = stoneSkinDetails.effect.duration;
            } else {
              logBattle(`Maná insuficiente para ${stoneSkinDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "shadow_step":
            const shadowDetails = techniqueData["shadow_step_1"];
            const shadowManaCost = shadowDetails.effect.manaCost;
            if (player.mana >= shadowManaCost) {
              player.mana -= shadowManaCost;
              player.dodgeNextAttack = true;
              logBattle(
                `¡${shadowDetails.name} (Nv.${playerTechLevel})! Te preparas para esquivar.`
              );
            } else {
              logBattle(`Maná insuficiente para ${shadowDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "soul_drain":
            const soulDrainDetails = techniqueData["soul_drain_1"];
            const soulManaCost = soulDrainDetails.effect.manaCost;
            if (player.mana >= soulManaCost) {
              player.mana -= soulManaCost;
              const damageDealt = Math.max(
                1,
                Math.floor(
                  player.attack *
                    (soulDrainDetails.effect.baseDamageMultiplier +
                      (playerTechLevel - 1) * 0.1)
                ) - (enemy.defense || 0)
              );
              enemy.hp -= damageDealt;
              const lifeStolen = Math.floor(
                damageDealt *
                  (soulDrainDetails.effect.lifeStealPercent +
                    (playerTechLevel - 1) * 0.05)
              );
              player.hp = Math.min(player.maxHp, player.hp + lifeStolen);
              logBattle(
                `${soulDrainDetails.name} (Nv.${playerTechLevel}) drena ${damageDealt} HP y te cura ${lifeStolen} HP.`
              );
            } else {
              logBattle(`Maná insuficiente para ${soulDrainDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "cyclone_strike":
            const cycloneDetails = techniqueData["cyclone_strike_1"];
            const cycloneManaCost = cycloneDetails.effect.manaCost;
            if (player.mana >= cycloneManaCost) {
              player.mana -= cycloneManaCost;
              const damageDealt = Math.max(
                1,
                Math.floor(
                  player.attack *
                    (cycloneDetails.effect.baseDamageMultiplier +
                      (playerTechLevel - 1) * 0.1)
                ) - (enemy.defense || 0)
              );
              enemy.hp -= damageDealt;
              logBattle(
                `${cycloneDetails.name} (Nv.${playerTechLevel}) golpea a ${enemy.name} con ${damageDealt} daño.`
              );
            } else {
              logBattle(`Maná insuficiente para ${cycloneDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "healing_rain":
            const healingRainDetails = techniqueData["healing_rain_1"];
            const healingManaCost = healingRainDetails.effect.manaCost;
            if (player.mana >= healingManaCost) {
              player.mana -= healingManaCost;
              player.healingRainTurns = healingRainDetails.effect.duration;
              player.healingRainAmount =
                healingRainDetails.effect.healPerTurn +
                (playerTechLevel - 1) * 5;
              logBattle(
                `${healingRainDetails.name} (Nv.${playerTechLevel}) invoca lluvia curativa por ${player.healingRainTurns} turnos.`
              );
            } else {
              logBattle(`Maná insuficiente para ${healingRainDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "mind_blast":
            const mindBlastDetails = techniqueData["mind_blast_1"];
            const mindManaCost = mindBlastDetails.effect.manaCost;
            if (player.mana >= mindManaCost) {
              player.mana -= mindManaCost;
              const damageDealt = Math.max(
                1,
                Math.floor(
                  player.attack *
                    (mindBlastDetails.effect.baseDamageMultiplier +
                      (playerTechLevel - 1) * 0.05) +
                    player.maxMana *
                      (mindBlastDetails.effect.manaDamageMultiplier +
                        (playerTechLevel - 1) * 0.02)
                ) - (enemy.defense || 0)
              );
              enemy.hp -= damageDealt;
              const defReduction =
                mindBlastDetails.effect.defenseReduction +
                (playerTechLevel - 1) * 1;
              enemy.defense = Math.max(0, (enemy.defense || 0) - defReduction);
              logBattle(
                `${mindBlastDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} daño y reduce defensa enemiga en ${defReduction}.`
              );
            } else {
              logBattle(`Maná insuficiente para ${mindBlastDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "celestial_arrow":
            const arrowDetails = techniqueData["celestial_arrow_1"];
            if (player.mana >= arrowDetails.effect.manaCost) {
              player.mana -= arrowDetails.effect.manaCost;
              const damage = Math.floor(
                player.attack *
                  (arrowDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.1)
              );
              enemy.hp -= damage;
              logBattle(
                `${arrowDetails.name} (Nv.${playerTechLevel}) ignora defensas y causa ${damage} daño.`
              );
            } else {
              logBattle(`Maná insuficiente para ${arrowDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "nature_grasp":
            const natureDetails = techniqueData["nature_grasp_1"];
            if (player.mana >= natureDetails.effect.manaCost) {
              player.mana -= natureDetails.effect.manaCost;
              const initialDamage = Math.floor(
                player.attack *
                  (natureDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.05)
              );
              enemy.hp -= initialDamage;
              enemy.rootedTurns = Math.max(
                enemy.rootedTurns,
                natureDetails.effect.rootDuration
              );
              enemy.rootDamage = Math.max(
                enemy.rootDamage,
                natureDetails.effect.damagePerTurn + (playerTechLevel - 1) * 1
              );
              logBattle(
                `${natureDetails.name} (Nv.${playerTechLevel}) causa ${initialDamage} daño y enreda, causando ${enemy.rootDamage} daño por ${enemy.rootedTurns} turnos.`
              );
            } else {
              logBattle(`Maná insuficiente para ${natureDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "dragon_roar":
            const roarDetails = techniqueData["dragon_roar_1"];
            if (player.mana >= roarDetails.effect.manaCost) {
              player.mana -= roarDetails.effect.manaCost;
              const stunChance =
                roarDetails.effect.aoeStunChance + (playerTechLevel - 1) * 0.03;
              if (Math.random() < stunChance) {
                enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                logBattle(
                  `${roarDetails.name} (Nv.${playerTechLevel}) aturde a ${enemy.name}!`
                );
              }
              const attackRed =
                roarDetails.effect.attackReduction + (playerTechLevel - 1) * 2;
              enemy.attack = Math.max(5, (enemy.attack || 0) - attackRed);
              enemy.attackReductionTurns = roarDetails.effect.duration;
              enemy.attackReductionAmount = attackRed;
              logBattle(
                `${roarDetails.name} reduce ataque enemigo en ${attackRed} por ${roarDetails.effect.duration} turnos.`
              );
            } else {
              logBattle(`Maná insuficiente para ${roarDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "phantom_clone":
            const cloneDetails = techniqueData["phantom_clone_1"];
            if (player.mana >= cloneDetails.effect.manaCost) {
              player.mana -= cloneDetails.effect.manaCost;
              player.cloneActive = true;
              player.cloneHealth =
                cloneDetails.effect.cloneHealth + (playerTechLevel - 1) * 10;
              player.cloneTurns =
                cloneDetails.effect.duration +
                Math.floor((playerTechLevel - 1) / 2);
              logBattle(
                `${cloneDetails.name} (Nv.${playerTechLevel}) crea clon con ${player.cloneHealth} HP por ${player.cloneTurns} turnos.`
              );
            } else {
              logBattle(`Maná insuficiente para ${cloneDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "temporal_shift":
            const temporalDetails = techniqueData["temporal_shift_1"];
            if (player.mana >= temporalDetails.effect.manaCost) {
              player.mana -= temporalDetails.effect.manaCost;
              player.temporalShiftTurns = temporalDetails.effect.duration;
              logBattle(
                `${temporalDetails.name} (Nv.${playerTechLevel}) distorsiona tiempo por ${player.temporalShiftTurns} turnos.`
              );
            } else {
              logBattle(`Maná insuficiente para ${temporalDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "blood_ritual":
            const bloodDetails = techniqueData["blood_ritual_1"];
            const hpCost =
              bloodDetails.effect.hpCost - (playerTechLevel - 1) * 2;
            if (
              player.hp > hpCost &&
              player.mana >= bloodDetails.effect.manaCost
            ) {
              player.hp -= hpCost;
              player.mana -= bloodDetails.effect.manaCost;
              if (player.bloodRitualTurns === 0) {
                player.bloodRitualAttackBoost =
                  bloodDetails.effect.attackBoost + (playerTechLevel - 1) * 5;
                player.attack += player.bloodRitualAttackBoost;
              } else {
                logBattle(`Refrescas Ritual de Sangre.`);
              }
              player.bloodRitualTurns = bloodDetails.effect.duration;
              logBattle(
                `${bloodDetails.name} (Nv.${playerTechLevel}) sacrifica ${hpCost} HP, aumenta ataque en ${player.bloodRitualAttackBoost} por ${player.bloodRitualTurns} turnos. Ataque: ${player.attack}.`
              );
            } else {
              logBattle(`HP o Maná insuficiente para ${bloodDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "aura_of_purity":
            const auraDetails = techniqueData["aura_of_purity_1"];
            if (player.mana >= auraDetails.effect.manaCost) {
              player.mana -= auraDetails.effect.manaCost;
              let cleansed = false;
              if (player.poisonedTurns > 0) {
                player.poisonedTurns = 0;
                player.poisonDamage = 0;
                cleansed = true;
              }
              if (player.burningTurns > 0) {
                player.burningTurns = 0;
                player.burnDamage = 0;
                cleansed = true;
              }
              if (cleansed)
                logBattle(
                  `${auraDetails.name} (Nv.${playerTechLevel}) purifica efectos negativos.`
                );
              player.immuneTurns =
                auraDetails.effect.immunityDuration +
                Math.floor((playerTechLevel - 1) / 2);
              logBattle(`Ganas inmunidad por ${player.immuneTurns} turnos.`);
            } else {
              logBattle(`Maná insuficiente para ${auraDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "summon_elemental":
            const summonDetails = techniqueData["summon_elemental_1"];
            if (player.mana >= summonDetails.effect.manaCost) {
              player.mana -= summonDetails.effect.manaCost;
              player.tempAttackBonus =
                (summonDetails.effect.elementalAttack || 20) +
                (playerTechLevel - 1) * 3;
              player.tempDefenseBonus =
                Math.floor((summonDetails.effect.elementalAttack || 20) / 2) +
                (playerTechLevel - 1) * 2;
              player.attack += player.tempAttackBonus;
              player.defense += player.tempDefenseBonus;
              player.elementalTurns = summonDetails.effect.duration;
              logBattle(
                `${summonDetails.name} (Nv.${playerTechLevel}) invoca elemental, +${player.tempAttackBonus} Atk, +${player.tempDefenseBonus} Def por ${player.elementalTurns} turnos.`
              );
            } else {
              logBattle(`Maná insuficiente para ${summonDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "mystic_barrier":
            const barrierDetails = techniqueData["mystic_barrier_1"];
            if (player.mana >= barrierDetails.effect.manaCost) {
              player.mana -= barrierDetails.effect.manaCost;
              player.magicShieldValue =
                (barrierDetails.effect.magicShield || 40) +
                (playerTechLevel - 1) * 10;
              player.magicShieldTurns = barrierDetails.effect.duration;
              logBattle(
                `${barrierDetails.name} (Nv.${playerTechLevel}) crea barrera que absorberá ${player.magicShieldValue} daño mágico por ${player.magicShieldTurns} turnos.`
              );
            } else {
              logBattle(`Maná insuficiente para ${barrierDetails.name}.`);
              actionTaken = false;
            }
            break;

          default:
            logBattle("Acción desconocida.");
            actionTaken = false;
            break;
        }

        if (!actionTaken) {
          updateBattleUI();
          return;
        }
        gameState.battle.playerTurn = false;
        updateBattleUI();

        if (enemy.hp <= 0) {
          handleEnemyDefeat();
        } else {
          let enemyDiedToDot = false;
          if (enemy.burningTurns > 0) {
            enemy.hp -= enemy.burnDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.burnDamage
              } por quemadura. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.poisonedTurns > 0) {
            enemy.hp -= enemy.poisonDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.poisonDamage
              } por veneno. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.rootedTurns > 0) {
            enemy.hp -= enemy.rootDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.rootDamage
              } por enredo. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }

          if (enemyDiedToDot) {
            handleEnemyDefeat();
          } else {
            setTimeout(enemyTurn, 1000);
          }
        }
      }

      function handleEnemyDefeat() {
        const enemy = gameState.battle.enemy;
        const player = gameState.player; // Añadir referencia al jugador

        logBattle(`¡Has derrotado al ${enemy.name}!`);
        gainExperience(enemy.exp);

        // ... (tu lógica de progreso de misiones existente) ...
        const misionesActivasDelJugador = [...player.secta.misionesActivas];
        misionesActivasDelJugador.forEach((misionActiva) => {
          const misionDataOriginal = MISIONES_DATA[misionActiva.id];
          if (!misionDataOriginal || !misionActiva.objetivoOriginal) return;
          const objetivo = misionActiva.objetivoOriginal;

          if (objetivo.tipo === "eliminar_enemigo") {
            const enemyJustDefeated = gameState.battle.enemy;
            if (
              enemyJustDefeated.originalEntityTypeId === objetivo.enemigoTipo || // Comparar con originalEntityTypeId
              enemyJustDefeated.name === objetivo.nombreDisplay
            ) {
              misionActiva.progreso = (misionActiva.progreso || 0) + 1;
              logBattle(
                `Progreso '${misionDataOriginal.titulo}': ${misionActiva.progreso}/${objetivo.cantidad}`
              );
            }
          } else if (objetivo.tipo === "derrotar_npc_especifico") {
            if (enemy.isSectChallengeRival && enemy.npcId === objetivo.npcId) {
              completeMission(misionActiva.id);
            }
          } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot") {
            // Comprobar si el enemigo derrotado es el objetivo de la caza
            if (enemy.originalEntityTypeId === objetivo.enemigoTipo) {
              // El loot se añade más abajo. Aquí solo podrías marcar un progreso
              // si la misión lo requiere antes de obtener el item.
              // Por ejemplo, si la misión es "derrota X y luego trae Y".
              // Si la misión es solo "trae Y" y el loot es la única condición,
              // la comprobación del item en inventario se hace al ENTREGAR al NPC.
              // PERO, es bueno marcar que el tipo correcto fue derrotado
              misionActiva.progreso = 1; // 1 significa que el tipo correcto fue derrotado
              logBattle(
                `Has derrotado a un ${enemy.name}. Busca el ${objetivo.itemPrueba} entre el botín.`
              );
            }
          }
        });
        updateSectUI();

        // Lógica de Loot
        if (enemy.lootTable && enemy.lootTable.length > 0) {
          enemy.lootTable.forEach((loot) => {
            if (Math.random() < loot.chance) {
              const quantity =
                loot.quantity && loot.quantity.length === 2
                  ? Math.floor(
                      Math.random() * (loot.quantity[1] - loot.quantity[0] + 1)
                    ) + loot.quantity[0]
                  : 1;
              gameState.inventory[loot.itemName] =
                (gameState.inventory[loot.itemName] || 0) + quantity;
              logBattle(`¡${enemy.name} soltó ${quantity} ${loot.itemName}!`);

              // Si el item looteado es el item de la misión "cazar_y_recuperar_item_de_loot"
              player.secta.misionesActivas.forEach((mActiva) => {
                const mDataOrig = MISIONES_DATA[mActiva.id];
                if (
                  mDataOrig?.objetivo?.tipo ===
                    "cazar_y_recuperar_item_de_loot" &&
                  enemy.originalEntityTypeId ===
                    mDataOrig.objetivo.enemigoTipo && // Asegurarse que es del enemigo correcto
                  loot.itemName === mDataOrig.objetivo.itemPrueba
                ) {
                  // El progreso ya se puso a 1 al derrotar. Aquí solo confirmamos.
                  // La UI de la misión ya debería reflejarlo bien.
                  console.log(
                    `[Loot] Item de misión "${loot.itemName}" obtenido para "${mDataOrig.titulo}".`
                  );
                }
              });
            }
          });
        }

        // Manejo de Jefes y Entidades Fijas Derrotadas
        if (enemy.isBoss) {
          player.worldState.defeatedBosses[
            enemy.originalEntityTypeId || enemy.type
          ] = true; // Usar originalEntityTypeId si existe
          if (enemy.nextBossId) {
            player.worldState.currentBossToSpawn = enemy.nextBossId;
          } else {
            player.worldState.currentBossToSpawn = null;
          }
          // generateMap(true); // Opcional regenerar todo el mapa. ensureFixedEntities se encargará de no reaparecerlo.
        } else if (
          enemy.isFixed &&
          (enemy.isMiniBoss ||
            entityTypes[enemy.originalEntityTypeId]?.respawnTime)
        ) {
          // Para entidades fijas que son minibosses o tienen un tiempo de respawn.
          if (!player.worldState.defeatedFixedEntities) {
            player.worldState.defeatedFixedEntities = {};
          }
          player.worldState.defeatedFixedEntities[enemy.originalEntityTypeId] =
            {
              time: Date.now(),
              // defeated: true // Ya implícito por estar en el objeto
            };
          console.log(
            `[Defeat] Miniboss/Fixed ${enemy.name} (ID: ${enemy.originalEntityTypeId}) marcado como derrotado.`
          );
        }

        updateUI();
        setTimeout(() => endBattle(true), 2000); // endBattle(true) ya llama a removeEntity para el enemigo de la batalla.
        // ensureFixedEntities se encargará de si debe reaparecer o no en la próxima carga/tick.
      }

      function completeMission(misionId, npcIdEntregaManual = null) {
        // npcIdEntregaManual es para cuando se completa desde el diálogo del NPC
        const player = gameState.player;
        const misionActiva = player.secta.misionesActivas.find(
          (m) => m.id === misionId
        );
        const misionDataOriginal = MISIONES_DATA[misionId];

        if (!misionActiva || !misionDataOriginal) {
          console.error(
            `Error al intentar completar misión: ${misionId}. Datos no encontrados.`
          );
          showModal("Error de Misión", "Datos de la misión no encontrados.");
          return false; // Indicar fallo
        }

        // No filtrar más por !player.secta.misionesActivas.some(m => m.id === misionId) aquí,
        // ya que la estamos buscando DENTRO de las activas.

        console.log(
          `Intentando completar misión: ${misionDataOriginal.titulo}`
        );

        // Verificar si los objetivos están realmente cumplidos ANTES de dar recompensas
        let objetivosCumplidos = false;
        const objetivo = misionActiva.objetivoOriginal;

        switch (objetivo.tipo) {
          case "entregar_item":
            if (
              (gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad
            ) {
              // Solo restar si es una entrega manual a un NPC o si es una misión que se autocompleta con entrega
              // (por ahora, asumimos que todas las de entrega requieren NPC)
              if (
                npcIdEntregaManual &&
                npcIdEntregaManual === objetivo.npcEntrega
              ) {
                gameState.inventory[objetivo.item] -= objetivo.cantidad;
                updateInventoryUI();
                objetivosCumplidos = true;
              } else if (!objetivo.npcEntrega) {
                // Caso raro: misión de entrega sin NPC específico (se autocompleta)
                gameState.inventory[objetivo.item] -= objetivo.cantidad;
                updateInventoryUI();
                objetivosCumplidos = true;
              } else {
                // No se cumple aquí, se debe completar hablando con el NPC
                // showModal("Entrega Pendiente", `Debes entregar ${objetivo.item} a ${SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre || 'un NPC'}.`);
                return false;
              }
            } else {
              showModal(
                "Objetivo Incompleto",
                `Aún necesitas ${
                  objetivo.cantidad - (gameState.inventory[objetivo.item] || 0)
                } ${objetivo.item}.`
              );
              return false;
            }
            break;
          case "eliminar_enemigo":
            if (misionActiva.progreso >= objetivo.cantidad) {
              objetivosCumplidos = true;
              // No hay ítems que restar aquí. La finalización será al hablar con el NPC.
            } else {
              // showModal("Objetivo Incompleto", `Aún necesitas eliminar más enemigos.`);
              return false;
            }
            break;
          case "recolectar_multiples_items":
            let todosItemsRecolectados = true;
            for (const itemReq of objetivo.items) {
              if (
                (gameState.inventory[itemReq.nombre] || 0) < itemReq.cantidad
              ) {
                todosItemsRecolectados = false;
                showModal(
                  "Objetivo Incompleto",
                  `Aún necesitas recolectar más ${itemReq.nombre}.`
                );
                break;
              }
            }
            if (todosItemsRecolectados) {
              if (
                npcIdEntregaManual &&
                npcIdEntregaManual === objetivo.npcEntrega
              ) {
                for (const itemReq of objetivo.items) {
                  gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                }
                updateInventoryUI();
                objetivosCumplidos = true;
              } else if (!objetivo.npcEntrega) {
                for (const itemReq of objetivo.items) {
                  gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                }
                updateInventoryUI();
                objetivosCumplidos = true;
              } else {
                return false;
              }
            } else {
              return false;
            }
            break;
          case "cazar_y_recuperar_item_de_loot":
            // El progreso a 1 indica que el ítem FUE looteado. Ahora se comprueba si AÚN lo tiene.
            if (
              misionActiva.progreso === 1 &&
              (gameState.inventory[objetivo.itemPrueba] || 0) >=
                objetivo.cantidadItemPrueba
            ) {
              if (
                npcIdEntregaManual &&
                npcIdEntregaManual === objetivo.npcEntrega
              ) {
                gameState.inventory[objetivo.itemPrueba] -=
                  objetivo.cantidadItemPrueba;
                updateInventoryUI();
                objetivosCumplidos = true;
              } else if (!objetivo.npcEntrega) {
                gameState.inventory[objetivo.itemPrueba] -=
                  objetivo.cantidadItemPrueba;
                updateInventoryUI();
                objetivosCumplidos = true;
              } else {
                return false;
              }
            } else {
              showModal(
                "Objeto Faltante",
                `Parece que ya no tienes ${objetivo.itemPrueba} o no lo has obtenido aún.`
              );
              return false;
            }
            break;
          case "derrotar_npc_especifico": // Estas se autocompletan al derrotar al NPC
            // El progreso ya se verificó al llamar a completeMission desde handleEnemyDefeat
            objetivosCumplidos = true;
            break;
          // Añadir más casos según tipos de misión
          default:
            console.warn(
              `Tipo de objetivo desconocido '${objetivo.tipo}' para misión ${misionId}`
            );
            showModal("Error de Misión", "Tipo de objetivo no reconocido.");
            return false;
        }

        if (!objetivosCumplidos) {
          console.log(
            `Objetivos no cumplidos para ${misionDataOriginal.titulo} al intentar completar.`
          );
          return false; // No completar si los objetivos no están verificados
        }

        // --- Dar Recompensas ---
        player.secta.puntosContribucion +=
          misionDataOriginal.recompensa.pcs || 0;
        gainExperience(misionDataOriginal.recompensa.exp || 0);
        let recompensaItemsTexto = "";
        if (misionDataOriginal.recompensa.items) {
          for (const itemName in misionDataOriginal.recompensa.items) {
            gameState.inventory[itemName] =
              (gameState.inventory[itemName] || 0) +
              misionDataOriginal.recompensa.items[itemName];
            recompensaItemsTexto += `${misionDataOriginal.recompensa.items[itemName]} ${itemName}, `;
          }
          updateInventoryUI();
          if (recompensaItemsTexto)
            recompensaItemsTexto = recompensaItemsTexto.slice(0, -2); // quitar última coma y espacio
        }

        let recompensaTextoGlobal = `Recompensas: ${
          misionDataOriginal.recompensa.pcs || 0
        } PCS, ${misionDataOriginal.recompensa.exp || 0} EXP`;
        if (recompensaItemsTexto)
          recompensaTextoGlobal += `, ${recompensaItemsTexto}`;

        player.secta.misionesActivas = player.secta.misionesActivas.filter(
          (m) => m.id !== misionId
        );
        player.secta.misionesCompletadas[misionId] = true;

        showModal(
          "¡Misión Completada!",
          `Completaste: ${misionDataOriginal.titulo}.\n${recompensaTextoGlobal}`
        );

        if (misionDataOriginal.recompensa.nuevoRango) {
          player.secta.rango = misionDataOriginal.recompensa.nuevoRango;
          showModal(
            "¡Ascenso en la Secta!",
            `¡Felicidades! Ascendiste a ${player.secta.rango}.`
          );
          applyRankBenefits(player.secta.rango);
        }
        updateSectUI();
        checkAndActivateRankChallengeMissions(); // Verificar si se desbloquean desafíos de rango
        return true; // Indicar éxito
      }

      function updateSectUI() {
        const player = gameState.player;
        document.getElementById("sectaNombreDisplay").textContent =
          player.secta.nombre;
        document.getElementById("playerSectRank").textContent =
          player.secta.rango;
        document.getElementById("playerPCS").textContent =
          player.secta.puntosContribucion;

        const missionsListDiv = document.getElementById("activeMissionsList");
        missionsListDiv.innerHTML = "";

        if (player.secta.misionesActivas.length === 0) {
          missionsListDiv.innerHTML = "<p>Ninguna misión activa.</p>";
        } else {
          player.secta.misionesActivas.forEach((misionActiva) => {
            const misionDataOriginal = MISIONES_DATA[misionActiva.id];
            if (misionDataOriginal && misionActiva.objetivoOriginal) {
              // Asegurar que objetivoOriginal exista
              let progresoTexto = "";
              const objetivo = misionActiva.objetivoOriginal;
              const npcEntregaNombre =
                SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre ||
                "NPC correspondiente";

              if (objetivo.tipo === "eliminar_enemigo") {
                progresoTexto = ` (${misionActiva.progreso || 0}/${
                  objetivo.cantidad
                } ${objetivo.nombreDisplay || "objetivos"})`;
                if ((misionActiva.progreso || 0) >= objetivo.cantidad) {
                  progresoTexto += ` <strong>¡Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "entregar_item") {
                const tiene = gameState.inventory[objetivo.item] || 0;
                const necesita = objetivo.cantidad;
                progresoTexto = ` (Tienes ${tiene}/${necesita} ${objetivo.item})`;
                if (tiene >= necesita) {
                  progresoTexto += ` <strong>¡Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "recolectar_multiples_items") {
                let todosListos = true;
                let itemsStatusArray = objetivo.items.map((itemReq) => {
                  const tiene = gameState.inventory[itemReq.nombre] || 0;
                  const necesita = itemReq.cantidad;
                  if (tiene < necesita) todosListos = false;
                  return `${tiene}/${necesita} ${itemReq.nombre}`;
                });
                progresoTexto = ` (${itemsStatusArray.join(", ")})`;
                if (todosListos) {
                  progresoTexto += ` <strong>¡Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot") {
                const tieneItem =
                  (gameState.inventory[objetivo.itemPrueba] || 0) >=
                  objetivo.cantidadItemPrueba;
                progresoTexto =
                  misionActiva.progreso === 1 && tieneItem
                    ? ` (Prueba '${objetivo.itemPrueba}' obtenida)`
                    : ` (Cazar ${objetivo.enemigoTipo} y obtener ${objetivo.itemPrueba})`;
                if (misionActiva.progreso === 1 && tieneItem) {
                  progresoTexto += ` <strong>¡Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "derrotar_npc_especifico") {
                // Estas se autocompletan, así que no aparecerán mucho aquí si se completan rápido
                progresoTexto = ` (Derrotar a ${
                  entityTypes[objetivo.npcId]?.name || "objetivo"
                })`;
              }
              const p = document.createElement("p");
              p.innerHTML = `<strong>${misionDataOriginal.titulo}</strong><small>${progresoTexto}</small>`;
              missionsListDiv.appendChild(p);
            }
          });
        }
      }

      function checkAndActivateRankChallengeMissions() {
        const player = gameState.player;
        const currentRankIndex = SECTA_DATA.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );

        if (currentRankIndex === -1) {
          console.error(
            "Error: Rango actual del jugador no encontrado en SECTA_DATA.rangos"
          );
          return;
        }

        // Si ya está en el rango máximo, no hay más desafíos
        if (currentRankIndex + 1 >= SECTA_DATA.rangos.length) {
          // console.log("Jugador en el rango máximo o no hay más rangos definidos.");
          return;
        }

        const nextRankData = SECTA_DATA.rangos[currentRankIndex + 1];

        // Verificar si el jugador cumple los PCS para el siguiente rango
        if (player.secta.puntosContribucion >= nextRankData.pcsRequeridos) {
          // Verificar si hay un ID de rival para el desafío de este próximo rango
          if (nextRankData.desafioRivalId) {
            const desafioMisionId = Object.keys(MISIONES_DATA).find((mId) => {
              const mision = MISIONES_DATA[mId];
              return (
                mision.objetivo?.tipo === "derrotar_npc_especifico" &&
                mision.objetivo?.npcId === nextRankData.desafioRivalId &&
                (mision.autoActivarAlCumplirRequisitos === true ||
                  mision.recompensa?.nuevoRango === nextRankData.nombre)
              ); // Condición para identificar la misión de desafío
            });

            if (desafioMisionId) {
              // Verificar si la misión de desafío NO está ya activa o completada
              const isMissionActive = player.secta.misionesActivas.some(
                (m) => m.id === desafioMisionId
              );
              const isMissionCompleted =
                player.secta.misionesCompletadas[desafioMisionId];

              if (!isMissionActive && !isMissionCompleted) {
                acceptMission(desafioMisionId);
                const misionData = MISIONES_DATA[desafioMisionId];
                showModal(
                  "¡Nuevo Desafío de Rango!",
                  `Has alcanzado los requisitos de PCS para el rango de ${nextRankData.nombre}.\n` +
                    `Se ha activado la misión de desafío: "${misionData.titulo}".\n` +
                    `¡Prepárate y busca a tu oponente en la arena de la secta!`
                );

                // Asegurar que el NPC del desafío (el rival) aparezca en el mapa si tiene fixedLocation
                // ensureFixedEntities() debería encargarse de esto si el rival está en la lista de entidades fijas
                // y no ha sido derrotado (lo cual es el caso si la misión se acaba de activar).
                // Si el rival no es una entidad fija por defecto, podrías añadirlo aquí dinámicamente,
                // pero es más limpio manejarlo con ensureFixedEntities.
                ensureFixedEntities();
                renderMap(); // Para asegurar que el rival (si es nuevo) se muestre
              } else {
                // console.log(`Misión de desafío ${desafioMisionId} para ${nextRankData.nombre} ya está activa o completada.`);
              }
            } else {
              console.warn(
                `No se encontró una misión de desafío auto-activable para el rival ${nextRankData.desafioRivalId} del rango ${nextRankData.nombre}.`
              );
            }
          } else {
            // console.log(`El siguiente rango ${nextRankData.nombre} no tiene un desafioRivalId definido. Podría ser un rango sin desafío.`);
          }
        } else {
          // console.log(`Jugador no tiene suficientes PCS para el siguiente rango ${nextRankData.nombre}. Necesita: ${nextRankData.pcsRequeridos}, Tiene: ${player.secta.puntosContribucion}`);
        }
        updateSectUI(); // Actualizar la UI de la secta por si algo cambió
      }

      function applyRankBenefits(newRankName) {
        const rankData = SECTA_DATA.rangos.find(
          (r) => r.nombre === newRankName
        );
        if (rankData) {
          showModal(
            "Beneficios de Rango",
            `Has obtenido beneficios de ${newRankName}: ${rankData.beneficios}`
          );
        }
        updateUI();
      }

      function enemyTurn() {
        if (!gameState.battle.active || gameState.battle.playerTurn) return;
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        let enemyDamage = enemy.attack; // Inicializar con el ataque base del enemigo
        let actionMessage = `${enemy.name} te ataca`;
        let enemySkippedTurn = false;

        // --- LOGS INICIALES DEL TURNO DEL ENEMIGO ---
        console.log(`--- Enemy Turn Start: ${enemy.name} ---`);
        console.log(
          `Enemy Base Attack: ${enemy.attack}, Initial enemyDamage: ${enemyDamage}`
        );
        console.log(
          `Player Defense: ${player.defense}, Player HP: ${player.hp}`
        );
        console.log(
          `Enemy Status - Frozen: ${enemy.frozenTurns}, Stunned: ${enemy.stunnedTurns}, Burning: ${enemy.burningTurns} (Dmg: ${enemy.burnDamage}), Poisoned: ${enemy.poisonedTurns} (Dmg: ${enemy.poisonDamage}), Rooted: ${enemy.rootedTurns}`
        );
        console.log(
          `Player Status - Dodge: ${player.dodgeNextAttack}, Clone: ${player.cloneActive} (HP: ${player.cloneHealth}), MagicShield: ${player.magicShieldValue}`
        );
        // --- FIN LOGS INICIALES ---

        // ... (lógica de DoTs y HoTs del enemigo sin cambios) ...
        if (enemy.burningTurns > 0) {
          enemy.hp -= enemy.burnDamage;
          logBattle(
            `${enemy.name} sufre ${
              enemy.burnDamage
            } por quemadura (inicio turno). HP: ${Math.floor(enemy.hp)}`
          );
          enemy.burningTurns--;
          if (enemy.burningTurns === 0)
            logBattle(`Quemadura en ${enemy.name} se extingue.`);
          if (enemy.hp <= 0) {
            handleEnemyDefeat();
            return;
          }
        }
        if (enemy.poisonedTurns > 0) {
          enemy.hp -= enemy.poisonDamage;
          logBattle(
            `${enemy.name} sufre ${
              enemy.poisonDamage
            } por veneno (inicio turno). HP: ${Math.floor(enemy.hp)}`
          );
          enemy.poisonedTurns--;
          if (enemy.poisonedTurns === 0)
            logBattle(`Veneno en ${enemy.name} desaparece.`);
          if (enemy.hp <= 0) {
            handleEnemyDefeat();
            return;
          }
        }
        if (enemy.rootedTurns > 0) {
          enemy.rootedTurns--;
          logBattle(`${enemy.name} sigue enredado.`);
          if (enemy.rootedTurns === 0)
            logBattle(`Enredo en ${enemy.name} se deshace.`);
        }

        if (enemy.frozenTurns > 0) {
          logBattle(`¡${enemy.name} está congelado!`);
          enemy.frozenTurns--;
          enemySkippedTurn = true;
        } else if (enemy.stunnedTurns > 0) {
          logBattle(`¡${enemy.name} está aturdido!`);
          enemy.stunnedTurns--;
          enemySkippedTurn = true;
        }

        if (enemy.attackReductionTurns > 0) {
          enemy.attackReductionTurns--;
          if (enemy.attackReductionTurns === 0) {
            // enemy.attack += enemy.attackReductionAmount; // CUIDADO: Esto modifica el ataque base permanentemente si no se gestiona bien
            // Es mejor aplicar la reducción al 'enemyDamage' del turno actual
            logBattle(`Reducción de ataque en ${enemy.name} termina.`);
            // enemy.attackReductionAmount = 0; // Ya no es necesario si se aplica al damage del turno
          } else {
            // Aplicar la reducción al daño de este turno si el debuff está activo
            enemyDamage = Math.max(
              1,
              enemy.attack - (enemy.attackReductionAmount || 0)
            );
            console.log(
              `Enemy attack reduced. Current turn damage: ${enemyDamage}`
            );
          }
        }

        if (enemySkippedTurn) {
          console.log("Enemy skipped turn due to status effect.");
          gameState.battle.playerTurn = true;
          updateBattleUI();
          updateUI();
          return;
        }

        // Lógica de ataque especial o curación del enemigo
        if (enemy.specialChance && Math.random() < enemy.specialChance) {
          enemyDamage = Math.floor(
            enemy.attack * (enemy.specialAttackMultiplier || 1.5)
          );
          actionMessage = `${enemy.name} usa golpe de Qi y`;
          console.log(
            `Enemy uses Special Attack! Damage before defense: ${enemyDamage}`
          );
        } else if (enemy.healChance && Math.random() < enemy.healChance) {
          const heal = Math.floor(enemy.maxHp * 0.15);
          enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
          logBattle(`${enemy.name} recupera ${heal} vida.`);
          console.log("Enemy healed.");
          gameState.battle.playerTurn = true;
          updateBattleUI();
          updateUI();
          return;
        }
        // Lógica de habilidades de jefe
        if (enemy.isBoss && enemy.abilities) {
          for (const ability of enemy.abilities) {
            if (Math.random() < (ability.chance || 0.1)) {
              if (ability.type === "area_attack_simulated") {
                enemyDamage = Math.floor(
                  enemy.attack * (ability.damageMultiplier || 1.0)
                );
                actionMessage = `${enemy.name} usa ${ability.name}! Aura opresiva te envuelve, y`;
                console.log(
                  `Boss uses Ability '${ability.name}'! Damage before defense: ${enemyDamage}`
                );
              } else if (
                ability.type === "healPercentage" &&
                ability.healPercentage
              ) {
                const bossHeal = Math.floor(
                  enemy.maxHp * ability.healPercentage
                );
                enemy.hp = Math.min(enemy.maxHp, enemy.hp + bossHeal);
                logBattle(
                  `${enemy.name} usa ${ability.name} y recupera ${bossHeal} vida!`
                );
                console.log("Boss healed with ability.");
                gameState.battle.playerTurn = true;
                updateBattleUI();
                updateUI();
                return;
              }
              break;
            }
          }
        }

        console.log(
          `After enemy special/ability checks, enemyDamage is: ${enemyDamage}`
        );

        // Lógica de esquivar del jugador
        if (player.dodgeNextAttack) {
          const shadowDetails = techniqueData["shadow_step_1"];
          const dodgeTechLevel =
            player.learnedTechniques["shadow_step_1"]?.level || 1;
          const dodgeChance =
            (shadowDetails?.effect?.dodgeChance || 0.8) +
            (dodgeTechLevel - 1) * 0.03;
          if (Math.random() < dodgeChance) {
            logBattle(`¡Esquivas el ataque de ${enemy.name}!`);
            player.dodgeNextAttack = false;
            console.log("Player dodged attack.");
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
          } else {
            logBattle(`Intentaste esquivar, ¡pero ${enemy.name} te alcanzó!`);
            player.dodgeNextAttack = false;
            console.log("Player failed to dodge.");
          }
        }

        // Lógica del clon del jugador
        if (player.cloneActive && player.cloneHealth > 0) {
          const cloneDetails = techniqueData["phantom_clone_1"];
          const aggroCloneChance =
            (cloneDetails?.effect?.aggroChance || 0.8) +
            (player.learnedTechniques["phantom_clone_1"]?.level || 1 - 1) *
              0.02;
          if (Math.random() < aggroCloneChance) {
            let damageToClone = Math.max(
              1,
              enemyDamage - 0 + Math.floor(Math.random() * 5 - 2)
            ); // Clon no tiene defensa
            player.cloneHealth -= damageToClone;
            logBattle(
              `Clon intercepta ataque, recibe ${damageToClone} daño. HP clon: ${player.cloneHealth}.`
            );
            if (player.cloneHealth <= 0) {
              player.cloneActive = false;
              logBattle("¡Clon destruido!");
            }
            console.log("Clone took damage.");
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
          } else {
            logBattle(`Clon distrae, pero ${enemy.name} te enfoca!`);
            console.log("Clone did not take aggro.");
          }
        }

        // Lógica de Barrera Mística del jugador
        let isEnemyAttackMagic = actionMessage.includes("golpe de Qi"); // Simplificación, podrías tener una propiedad en el ataque del enemigo
        if (player.magicShieldValue > 0 && isEnemyAttackMagic) {
          let absorbedDamage = Math.min(player.magicShieldValue, enemyDamage);
          enemyDamage -= absorbedDamage;
          player.magicShieldValue -= absorbedDamage;
          logBattle(
            `Barrera Mística absorbe ${absorbedDamage} daño mágico. Barrera: ${player.magicShieldValue}.`
          );
          if (player.magicShieldValue <= 0) {
            logBattle("Barrera Mística rota.");
          }
          console.log(
            `Magic shield absorbed ${absorbedDamage}. Remaining shield: ${player.magicShieldValue}. Enemy damage now: ${enemyDamage}`
          );
        }

        // --- CÁLCULO FINAL DE DAÑO ---
        // Añadir un aleatorizador al daño base del enemigo ANTES de restar la defensa del jugador
        const randomFactor = Math.floor(Math.random() * 5 - 2); // Entre -2 y +2
        const damageBeforeDefense = Math.max(1, enemyDamage + randomFactor);
        const damageDealt = Math.max(0, damageBeforeDefense - player.defense);

        console.log(
          `Final Calculation - EnemyDamage (after buffs/specials): ${enemyDamage}, RandomFactor: ${randomFactor}, DamageBeforePlayerDefense: ${damageBeforeDefense}, PlayerDefense: ${player.defense}, FinalDamageDealt: ${damageDealt}`
        );
        // --- FIN CÁLCULO FINAL DE DAÑO ---

        if (damageDealt > 0) {
          player.hp -= damageDealt;
          logBattle(`${actionMessage} causando ${damageDealt} daño.`);
        } else {
          logBattle(
            `${actionMessage} pero tu defensa bloquea el ataque o el daño es insignificante.`
          );
        }

        // ... (resto de la lógica de derrota del jugador y fin de turno sin cambios) ...
        if (player.hp <= 0) {
          player.hp = 0;
          logBattle("¡Has sido derrotado!");
          setTimeout(() => {
            player.hp = Math.floor(player.maxHp * 0.1);
            player.mana = Math.floor(player.maxMana * 0.1);
            const expLoss = Math.floor(player.exp * 0.1);
            player.exp = Math.max(0, player.exp - expLoss);
            logBattle(`Pierdes ${expLoss} EXP.`);
            const safeCoords = findSafeRespawnLocation(
              G_SAFE_RESPAWN_X,
              G_SAFE_RESPAWN_Y
            );
            player.x = safeCoords.x;
            player.y = safeCoords.y;
            updatePlayerPosition();
            endBattle(false);
            showModal(
              "Derrota",
              "Has sido derrotado. Regresas a un lugar seguro, mermado."
            );
          }, 2000);
          return;
        }

        if (player.elementalTurns > 0) {
          player.elementalTurns--;
          if (player.elementalTurns === 0) {
            player.attack -= player.tempAttackBonus;
            player.defense -= player.tempDefenseBonus;
            logBattle("Elemental invocado desaparece.");
            player.tempAttackBonus = 0;
            player.tempDefenseBonus = 0;
          }
        }
        gameState.battle.playerTurn = true;
        updateBattleUI();
        updateUI();
      }

      function endBattle(victory) {
        const player = gameState.player;
        gameState.battle.active = false;
        document.getElementById("battleScreen").style.display = "none";
        document.getElementById("battleLog").innerHTML = "";
        // Ocultar las barras sobre el sprite en batalla explícitamente al finalizar
        const barsInBattleContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        if (barsInBattleContainer) {
          barsInBattleContainer.style.display = "none";
        }
        if (victory && gameState.battle.enemy?.entityRef) {
          removeEntity(gameState.battle.enemy.entityRef);
        }
        gameState.battle.enemy = null;

        // Restaurar sprite a idle después de la batalla
        player.currentDirection = "down"; // O la última dirección antes de la batalla
        player.currentFrame = 0;
        player.isMoving = false; // Asegurarse de que no esté en estado de movimiento
        updatePlayerSpriteVisual();

        recalculatePlayerStats();
        updateUI();
        updateBottomNavVisibility();
        showTouchControls();
        updatePlayerBarsOnMap();
      }

      function findSafeRespawnLocation(preferredX, preferredY) {
        const isHostile = (entity) =>
          G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss;
        let preferredSpotOccupiedByHostile = gameState.map.entities.some(
          (e) => e.x === preferredX && e.y === preferredY && isHostile(e)
        );
        if (!preferredSpotOccupiedByHostile)
          return { x: preferredX, y: preferredY };
        for (let r = 1; r <= G_SAFE_RESPAWN_SEARCH_RADIUS; r++) {
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
              const cx = preferredX + dx;
              const cy = preferredY + dy;
              if (
                cx < 0 ||
                cx >= gameState.map.width ||
                cy < 0 ||
                cy >= gameState.map.height
              )
                continue;
              const isCompletelyEmpty = !gameState.map.entities.some(
                (e) => e.x === cx && e.y === cy
              );
              if (isCompletelyEmpty) return { x: cx, y: cy };
            }
          }
        }
        return { x: preferredX, y: preferredY };
      }

      function logBattle(message) {
        const log = document.getElementById("battleLog");
        const p = document.createElement("p");
        p.textContent = message;
        log.appendChild(p);
        log.scrollTop = log.scrollHeight;
      }

      function showTechniquePanel() {
        const container = document.getElementById("learnedTechniquesContainer");
        container.innerHTML = "";
        const player = gameState.player;
        if (Object.keys(player.learnedTechniques).length === 0) {
          container.innerHTML = "<p>Aún no has aprendido ninguna técnica.</p>";
        }
        for (const techId in player.learnedTechniques) {
          const techInfo = techniqueData[techId];
          const playerTech = player.learnedTechniques[techId];
          if (!techInfo) continue;
          const div = document.createElement("div");
          div.className = "technique-item";
          let levelText =
            playerTech.level >= techInfo.maxLevel
              ? `Nivel: ${playerTech.level} (MAX)`
              : `Nivel: ${playerTech.level} / ${techInfo.maxLevel}`;
          let description = techInfo.description;
          // Podrías añadir lógica aquí para mostrar el efecto actual basado en el nivel
          // Ejemplo: if (techInfo.effect.baseDamageMultiplier) description += ` (Daño actual: ${...})`;
          div.innerHTML = `<strong>${techInfo.name} ${
            techInfo.icon || ""
          }</strong> (${levelText})<br><small>${description}</small><br>`;
          if (
            techInfo.cultivationSettings &&
            playerTech.level < techInfo.maxLevel
          ) {
            const progress = playerTech.currentCultivationProgress || 0;
            const timeToNext =
              playerTech.cultivationTimeToNextLevel ||
              (techInfo.cultivationSettings
                ? techInfo.cultivationSettings.baseTimeToLevelUp
                : Infinity);
            div.innerHTML += `<small>Progreso Cultivo: ${Math.floor(
              progress
            )}s / ${timeToNext}s para Nv. ${playerTech.level + 1}</small><br>`;
          }
          container.appendChild(div);
        }
        document.getElementById("techniqueModal").style.display = "flex";
        hideTouchControls();
      }

      function startTechniqueRefinement(techId) {}

      function stopTechniqueRefinement() {}

      function applyTechniqueEffect(techId, newLevel) {
        const techInfo = techniqueData[techId];
        const player = gameState.player;
        if (!techInfo) return;
        const effect = techInfo.effect;
        switch (techInfo.type) {
          case "passive_cultivation":
            if (player.hasOwnProperty(effect.statToBoost)) {
              player[effect.statToBoost] += effect.value;
            }
            break;
          case "passive_stat":
            if (player.hasOwnProperty(effect.statToBoost)) {
              player[effect.statToBoost] += effect.value;
            }
            recalculatePlayerStats();
            break;
          case "active_ability":
            recalculatePlayerStats();
            break;
          case "active_refinement_effect": // O el tipo que uses para Conversión de Qi
            if (techId === "qi_to_hp_conversion_1") {
              if (newLevel >= 1) {
                player.canUseQiConversion = true;
                updateToggleQiConversionButtonVisibility();
              }
              // Aquí no se modifican los stats base del jugador directamente,
              // sino que se asume que la lógica que USA esta técnica (en processCultivationTick)
              // leerá el nivel actual de la técnica desde player.learnedTechniques[techId].level
              // y aplicará los efectos escalados (como hpGainIncreasePerLevel) basados en ese nivel.
              // Lo importante es que el nivel de la técnica SÍ se ha incrementado.
              console.log(
                `Técnica ${techInfo.name} mejorada a Nv.${newLevel}. Sus efectos de conversión serán más potentes.`
              );
            }
            break;
        }
        updateUI();
      }

      function closeTechniqueModal() {
        document.getElementById("techniqueModal").style.display = "none";
        updatePlayerBarsOnMap();
        showTouchControls();
      }

      let currentShopPage = 1;
      const shopItemsPerPage = 6;

      function openShop() {
        document.getElementById(
          "playerSpiritualStones"
        ).textContent = `Piedras Espirituales: ${
          gameState.inventory["Piedras Espirituales"] || 0
        }`;
        document.getElementById("shopModal").style.display = "flex";
        renderShopProducts();
        hideTouchControls();
      }

      function renderShopProducts() {
        const shopProductsEl = document.getElementById("shopProducts");
        shopProductsEl.innerHTML = "";
        const activeCategory =
          document.querySelector("#shopCategories .active")?.dataset.category ||
          "all";
        const searchTerm = document
          .getElementById("shopSearch")
          .value.toLowerCase();
        const priceVal = parseInt(document.getElementById("priceRange").value);
        document.getElementById(
          "priceRangeValue"
        ).textContent = `${priceVal} PS`;

        let filteredItems = shopData.inventory.filter((item) => {
          const itemNameLower = item.itemName.toLowerCase();
          const itemCategory = item.category || "other";
          const itemTypeForFilter =
            item.type ||
            (itemNameLower.includes("rollo:") ? "scroll" : "other");

          if (
            searchTerm &&
            !itemNameLower.includes(searchTerm) &&
            !(
              item.description &&
              item.description.toLowerCase().includes(searchTerm)
            )
          )
            return false;
          if (item.price > priceVal) return false;

          if (activeCategory !== "all") {
            if (activeCategory === "combat" && !techIsCombat(item.itemName))
              return false;
            if (
              activeCategory === "cultivation" &&
              !techIsCultivation(item.itemName)
            )
              return false;
            if (
              activeCategory === "scroll" &&
              !itemNameLower.startsWith("rollo: ")
            )
              return false;
            if (
              activeCategory === "consumable" &&
              itemTypeForFilter !== "consumable" &&
              ![
                "Hierbas Medicinales",
                "Cristales de Qi",
                "Píldora de Recuperación Menor",
              ].includes(item.itemName)
            )
              return false;
            if (activeCategory === "weapon" && itemCategory !== "weapon")
              return false;
            if (activeCategory === "armor" && itemCategory !== "armor")
              return false;
            if (activeCategory === "material" && !isMaterial(item.itemName))
              return false;
          }
          return true;
        });

        const totalPages = Math.ceil(filteredItems.length / shopItemsPerPage);
        const startIndex = (currentShopPage - 1) * shopItemsPerPage;
        const pageItems = filteredItems.slice(
          startIndex,
          startIndex + shopItemsPerPage
        );

        pageItems.forEach((item) => {
          const itemInfo = itemData[item.itemName] || {};
          const productCard = document.createElement("div");
          productCard.className = "product-card";
          let itemIcon = getItemIcon(item.itemName, item.category);
          let itemType = getItemShopType(
            item.itemName,
            item.category,
            item.type
          );

          productCard.innerHTML = `
                <div class="product-header">
                    <div>
                        <div class="product-name">${itemIcon} ${
            item.itemName
          }</div>
                        <span class="product-type">${itemType}</span>
                    </div>
                    <div class="product-price">${item.price} PS</div>
                </div>
                <div class="product-description">${
                  itemInfo.description ||
                  item.description ||
                  "Un objeto misterioso."
                }</div>
                ${
                  item.levelRequirement
                    ? `<div><strong>Req:</strong> Nv ${item.levelRequirement}</div>`
                    : ""
                }
                ${
                  typeof item.stock === "number"
                    ? `<div><strong>Disp:</strong> ${item.stock}</div>`
                    : ""
                }
                <div class="product-actions">
                    <button class="buy-btn" data-item="${
                      item.itemName
                    }" data-price="${item.price}">Comprar</button>
                </div>`;
          const buyBtn = productCard.querySelector(".buy-btn");
          if (
            (gameState.inventory["Piedras Espirituales"] || 0) < item.price ||
            item.stock === 0
          ) {
            buyBtn.disabled = true;
            buyBtn.title =
              item.stock === 0 ? "Agotado" : "Piedras insuficientes";
          }
          buyBtn.addEventListener("click", () => buyFromShop(item.itemName));
          shopProductsEl.appendChild(productCard);
        });
        renderShopPagination(totalPages);
      }

      function techIsCombat(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "active_ability" ||
            techniqueData[techId].abilityId)
        );
      }
      function techIsCultivation(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "passive_cultivation" ||
            techniqueData[techId].type === "passive_stat" ||
            techniqueData[techId].type === "active_refinement_effect")
        );
      }
      function isMaterial(itemName) {
        const knownMaterials = [
          "Cristal de Hielo",
          "Esencia de Fuego",
          "Núcleo de Tormenta",
          "Venenos Mortales",
          "Fragmentos de Jade",
          "Esencia Oscura",
          "Almas Condenadas",
          "Núcleo de Vórtice",
          "Rocío Celestial",
          "Cristales Psíquicos",
          "Mineral de Hierro Espiritual",
          "Plumas de Fénix",
          "Semillas Ancestrales",
          "Escamas de Dragón",
          "Espejos Astrales",
          "Relojes de Arena",
          "Sangre de Demonio",
          "Lágrimas de Unicornio",
          "Núcleo Elemental",
          "Polvo de Arcano",
          "Piedras Espirituales",
          "Cristales de Qi",
          "Hierbas Medicinales",
        ];
        return knownMaterials.includes(itemName);
      }

      function getItemIcon(itemName, category) {
        if (itemName.includes("Espada") || category === "weapon") return "⚔️";
        if (itemName.includes("Armadura") || category === "armor") return "🛡️";
        if (itemName.includes("Hierba")) return "🌿";
        if (itemName.includes("Cristal")) return "💎";
        if (itemName.includes("Piedra")) return "💎";
        if (itemName.startsWith("Rollo:")) return "📜";
        return "📦";
      }

      function getItemShopType(itemName, category, type) {
        if (itemName.startsWith("Rollo: ")) return "Técnica";
        if (category === "weapon") return "Arma";
        if (category === "armor") return "Armadura";
        if (
          type === "consumable" ||
          [
            "Hierbas Medicinales",
            "Cristales de Qi",
            "Píldora de Recuperación Menor",
          ].includes(itemName)
        )
          return "Consumible";
        if (isMaterial(itemName)) return "Material";
        return "Objeto";
      }

      function renderShopPagination(totalPages) {
        const pagination = document.getElementById("shopPagination");
        pagination.innerHTML = "";
        if (totalPages <= 1) return;
        const prevBtn = document.createElement("button");
        prevBtn.className = "page-btn";
        prevBtn.textContent = "«";
        prevBtn.addEventListener("click", () => {
          if (currentShopPage > 1) {
            currentShopPage--;
            renderShopProducts();
          }
        });
        pagination.appendChild(prevBtn);
        const startPage = Math.max(1, currentShopPage - 1);
        const endPage = Math.min(totalPages, currentShopPage + 1);
        for (let i = startPage; i <= endPage; i++) {
          const pageBtn = document.createElement("button");
          pageBtn.className = `page-btn ${
            i === currentShopPage ? "active" : ""
          }`;
          pageBtn.textContent = i;
          pageBtn.addEventListener("click", () => {
            currentShopPage = i;
            renderShopProducts();
          });
          pagination.appendChild(pageBtn);
        }
        const nextBtn = document.createElement("button");
        nextBtn.className = "page-btn";
        nextBtn.textContent = "»";
        nextBtn.addEventListener("click", () => {
          if (currentShopPage < totalPages) {
            currentShopPage++;
            renderShopProducts();
          }
        });
        pagination.appendChild(nextBtn);
      }

      function closeShopModal() {
        document.getElementById("shopModal").style.display = "none";
        updatePlayerBarsOnMap();
        showTouchControls();
      }

      function buyFromShop(itemName) {
        const itemToBuy = shopData.inventory.find(
          (i) => i.itemName === itemName
        );
        const playerStones = gameState.inventory["Piedras Espirituales"] || 0;
        if (
          !itemToBuy ||
          itemToBuy.stock === 0 ||
          playerStones < itemToBuy.price
        ) {
          showModal(
            "Error Compra",
            "No se puede comprar (fondos insuficientes, agotado o no existe)."
          );
          return;
        }
        gameState.inventory["Piedras Espirituales"] -= itemToBuy.price;
        if (itemToBuy.type === "equipment" && itemToBuy.attackBonus) {
          gameState.player.baseAttack += itemToBuy.attackBonus;
          recalculatePlayerStats();
          showModal(
            "¡Equipo Comprado!",
            `Compraste ${itemName}. Ataque base +${itemToBuy.attackBonus}.`
          );
        } else {
          gameState.inventory[itemName] =
            (gameState.inventory[itemName] || 0) + 1;
          if (
            itemData[itemName] &&
            itemData[itemName].effect &&
            itemName.startsWith("Rollo: ")
          ) {
            showModal(
              "¡Rollo Comprado!",
              `Has comprado ${itemName}. Úsalo desde tu inventario para aprender la técnica.`
            );
          } else {
            showModal("¡Objeto Comprado!", `Has comprado ${itemName}.`);
          }
        }
        if (typeof itemToBuy.stock === "number" && itemToBuy.stock > 0)
          itemToBuy.stock--;
        openShop();
        updateUI();
      }

      function sellToShop(itemName, quantityToSell, totalStonesEarned) {}

      function saveGame() {
        try {
          const gameStateToSave = JSON.parse(JSON.stringify(gameState));
          const gameDataJson = JSON.stringify(gameStateToSave, null, 2);
          const blob = new Blob([gameDataJson], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "camino_del_cultivador_save.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showModal("Partida Guardada", "Progreso guardado como archivo JSON.");
        } catch (error) {
          showModal("Error al Guardar", `Hubo un problema: ${error.message}`);
        }
      }
      function triggerFileUpload() {
        document.getElementById("fileInput").click();
      }

      // --- CARGA DE PARTIDA ---

      function loadGameFromFile(event) {
        const file = event.target.files[0];
        if (!file) {
          showModal("Carga Cancelada", "No se seleccionó archivo.");
          return;
        }
        if (file.type !== "application/json") {
          showModal("Error de Archivo", "Selecciona un JSON válido.");
          event.target.value = null;
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            // 0. DETENER PROCESOS EN CURSO Y LIMPIAR ESTADO ANTERIOR PARCIALMENTE
            if (gameState.player.isCultivating) {
              stopCultivation(); // Asegúrate que esta función limpie gameState.cultivationInterval
            }
            if (gameState.battle.active) {
              endBattle(false); // false indica que no es una victoria
            }
            // Limpiar el intervalo de cultivo explícitamente si stopCultivation no lo hace o por si acaso
            if (gameState.cultivationInterval) {
              clearInterval(gameState.cultivationInterval);
              gameState.cultivationInterval = null;
            }

            const loadedGameState = JSON.parse(e.target.result);

            // Validación básica del formato del archivo cargado
            if (
              typeof loadedGameState !== "object" ||
              loadedGameState === null ||
              !loadedGameState.player ||
              !loadedGameState.map ||
              !loadedGameState.inventory
            ) {
              throw new Error(
                "Formato de guardado incorrecto o datos esenciales (jugador, mapa, inventario) faltantes."
              );
            }

            // 1. CARGAR DATOS DEL JUGADOR (PLAYER DATA)
            // Primero, copia las propiedades primitivas y luego maneja los objetos anidados.
            for (const key in loadedGameState.player) {
              if (loadedGameState.player.hasOwnProperty(key)) {
                if (
                  typeof loadedGameState.player[key] !== "object" ||
                  loadedGameState.player[key] === null
                ) {
                  gameState.player[key] = loadedGameState.player[key];
                }
              }
            }

            // Objetos anidados dentro de player (copia profunda para evitar problemas de referencia)
            gameState.player.learnedTechniques = loadedGameState.player
              .learnedTechniques
              ? JSON.parse(
                  JSON.stringify(loadedGameState.player.learnedTechniques)
                )
              : {};
            gameState.player.secta = loadedGameState.player.secta
              ? JSON.parse(JSON.stringify(loadedGameState.player.secta))
              : {
                  nombre: "Secta del Viento Azure",
                  rango: "Discípulo Externo",
                  puntosContribucion: 0,
                  misionesActivas: [],
                  misionesCompletadas: {},
                  rivalesDerrotadosClave: {},
                };
            gameState.player.worldState = loadedGameState.player.worldState
              ? JSON.parse(JSON.stringify(loadedGameState.player.worldState))
              : {
                  defeatedBosses: {},
                  currentBossToSpawn: "boss_demon_general",
                };
            gameState.player.cultivationMode = loadedGameState.player
              .cultivationMode
              ? JSON.parse(
                  JSON.stringify(loadedGameState.player.cultivationMode)
                )
              : { type: null, targetId: null, startTime: 0 };
            gameState.player.directionRowMap = loadedGameState.player
              .directionRowMap
              ? JSON.parse(
                  JSON.stringify(loadedGameState.player.directionRowMap)
                )
              : { down: 0, left: 1, right: 2, up: 3 };
            gameState.player.sprites = loadedGameState.player.sprites
              ? JSON.parse(JSON.stringify(loadedGameState.player.sprites))
              : {
                  idle: "img/personaje_cultivador_idle.png",
                  up: "img/personaje_cultivador_up.png",
                  down: "img/personaje_cultivador_down.png",
                  left: "img/personaje_cultivador_left.png",
                  right: "img/personaje_cultivador_right.png",
                };

            // Asegurar propiedades del sprite (valores por defecto si no están en el guardado)
            gameState.player.spriteSheetUrl =
              loadedGameState.player.spriteSheetUrl ||
              gameState.player.spriteSheetUrl ||
              "img/personaje_cultivador_spritesheet.png";
            gameState.player.frameWidth =
              loadedGameState.player.frameWidth ||
              gameState.player.frameWidth ||
              64;
            gameState.player.frameHeight =
              loadedGameState.player.frameHeight ||
              gameState.player.frameHeight ||
              64;
            gameState.player.animationFrames =
              loadedGameState.player.animationFrames ||
              gameState.player.animationFrames ||
              4;
            gameState.player.currentFrame = 0; // Siempre resetear frame al cargar
            gameState.player.currentDirection =
              loadedGameState.player.currentDirection ||
              gameState.player.currentDirection ||
              "down";
            gameState.player.animationSpeed =
              loadedGameState.player.animationSpeed ||
              gameState.player.animationSpeed ||
              150;

            // Resetear estados transitorios del jugador
            gameState.player.isMoving = false;
            if (gameState.player.animationTimer)
              clearInterval(gameState.player.animationTimer);
            gameState.player.animationTimer = null;
            if (gameState.player.idleTimeout)
              clearTimeout(gameState.player.idleTimeout);
            gameState.player.idleTimeout = null;
            gameState.player.isCultivating = false; // El cultivo no se reanuda automáticamente

            // 2. CARGAR INVENTARIO (CRUCIAL)
            gameState.inventory = loadedGameState.inventory
              ? JSON.parse(JSON.stringify(loadedGameState.inventory))
              : { "Piedras Espirituales": 0 };

            // 3. CARGAR DATOS DEL MAPA (MAP DATA)
            // Las entidades del mapa (gameState.map.entities) serán reconstruidas por generateMap(true).
            // Lo importante es cargar las dimensiones y las definiciones de zona si se guardan.
            gameState.map.width = loadedGameState.map.width || 200;
            gameState.map.height = loadedGameState.map.height || 200;
            gameState.map.defaultTerrain =
              loadedGameState.map.defaultTerrain || "GRASSLAND";
            if (loadedGameState.map.terrainZones) {
              // Si guardas las terrainZones (suelen ser estáticas pero por si acaso)
              gameState.map.terrainZones = JSON.parse(
                JSON.stringify(loadedGameState.map.terrainZones)
              );
            }
            // La rejilla de terreno (terrainGrid) se suele generar, así que no es necesario cargarla.
            gameState.map.terrainGrid = null; // Para forzar su regeneración si es necesario.
            // Las entidades (monstruos, recursos no fijos) se regenerarán. Las entidades fijas (tienda, NPCs de secta)
            // serán gestionadas por ensureFixedEntities dentro de generateMap.

            // 4. CARGAR OTROS ESTADOS GLOBALES DEL JUEGO
            gameState.gameTime = loadedGameState.gameTime || 0;
            gameState.lastGameTimeUpdate = Date.now(); // Resetear al momento de carga
            gameState.activeCombatAbilities = []; // Se recalculará después

            // 5. RECONSTRUIR EL MUNDO DEL JUEGO Y ACTUALIZAR ESTADOS
            // generateMap(true) se encarga de:
            // - Limpiar entidades no fijas.
            // - Repoblar zonas con entidades (monstruos, recursos) según spawnSettings (currentCount se resetea).
            // - Añadir elementos decorativos.
            // - Llamar a ensureFixedEntities() para asegurar la presencia de entidades fijas (tienda, secta, NPCs).
            // - initializeTerrainGrid() (si está implementado dentro o es llamado por funciones que usa generateMap).
            generateMap(true);

            recalculatePlayerStats(); // Recalcula stats derivados y habilidades de combate activas.

            // Actualizar la interfaz gráfica y la posición del jugador.
            // La posición del jugador (X, Y) ya fue cargada en gameState.player.
            calculateAndSetTileSize(); // Ajustar tamaño de tiles si la ventana cambió.
            updatePlayerVisualSize(); // Ajustar tamaño del sprite del jugador.
            updatePlayerSpriteVisual(); // Configurar el frame y dirección correctos del sprite.
            updatePlayerPosition("loadGameFromFile_end"); // Mueve el mapa y renderiza. Esto también llama a updateUI().

            // Estado de batalla generalmente no se guarda en medio de una.
            gameState.battle.active = false;
            document.getElementById("battleScreen").style.display = "none";
            if (document.getElementById("playerInBattleSpriteBarsContainer")) {
              document.getElementById(
                "playerInBattleSpriteBarsContainer"
              ).style.display = "none";
            }

            showModal("Partida Cargada", "¡Partida restaurada con éxito!");
          } catch (error) {
            showModal(
              "Error al Cargar",
              `Hubo un problema al leer o procesar el archivo: ${error.message}`
            );
            console.error("Error loading game:", error);
          } finally {
            event.target.value = null; // Resetear el input de archivo para permitir cargar el mismo archivo de nuevo.
          }
        };
        reader.onerror = () => {
          showModal(
            "Error de Lectura",
            "No se pudo leer el archivo de guardado."
          );
          event.target.value = null;
        };
        reader.readAsText(file);
      }

      // Asegúrate de que tu función initializeTerrainGrid (si la tienes separada) se llame
      // al inicio del juego (en DOMContentLoaded antes de generateMap) y, si es necesario,
      // también después de cargar las terrainZones en loadGameFromFile si estas cambian.
      // Si getTerrainTypeAt solo usa terrainZones, no necesitas un grid separado.

      // En tu DOMContentLoaded, asegúrate que initializeTerrainGrid (si la usas) se llame antes de generateMap:
      /*
        document.addEventListener('DOMContentLoaded', () => {
            // ...
            initializeTerrainGrid(); // Si usas gameState.map.terrainGrid explícitamente
            generateMap(true);
            // ...
        });
    */

      function showHelp() {
        showModal(
          "Ayuda - Camino del Cultivador",
          "Explora y conviértete en un cultivador poderoso.\n\n" +
            '🧘 Cultiva (Botón "Cultivar") para mejorar HP/Maná/EXP y tus Técnicas.\n' +
            "📖 Aprende y Refina Técnicas para obtener nuevas habilidades y mejoras pasivas.\n" +
            "⬆️ Sube de Nivel para aumentar tus estadísticas base.\n" + // Actualizado
            "👹 Combate demonios y rivales.\n" +
            "💎 Recolecta recursos y tesoros.\n" +
            "📜 Busca o compra rollos de técnicas para volverte más fuerte\n\n" + // Eliminada mención al árbol de habilidades
            "Controles (Teclado):\n" +
            "  WASD/Flechas: Moverse\n" +
            "  ESPACIO: Interactuar\n\n" +
            "Controles (Táctil):\n" +
            "  Joystick: Moverse\n" +
            '  Botón "Acción": Interactuar'
        );
      }
      //ACTUALIZAR BARRAS DEL JUGADOR
      function updatePlayerBarsOnMap() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerOnMapBarsContainer"
        );
        const hpFill = document.getElementById("playerOnMapHpFill");
        const manaFill = document.getElementById("playerOnMapManaFill");
        const playerElement = document.getElementById("player"); // El sprite del jugador

        if (!barsContainer || !hpFill || !manaFill || !playerElement) {
          // console.warn("Elementos de barras sobre el jugador no encontrados en el DOM.");
          return;
        }

        // Ocultar barras si el jugador está en batalla o si algún modal principal está abierto.
        if (gameState.battle.active || isAnyModalOpen()) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // La posición del playerElement (sprite) ya está calculada y centrada en updatePlayerPosition.
        // Usamos su 'top' y 'left' (que son relativos al map-container) como referencia.
        const playerVisualTop = parseFloat(playerElement.style.top) || 0;
        const playerVisualLeft = parseFloat(playerElement.style.left) || 0;
        const playerVisualWidth = playerElement.offsetWidth;

        // Posicionar las barras ligeramente encima del sprite del jugador.
        const barHeightWithGap = barsContainer.offsetHeight || 13; // Alto total aprox. de las 2 barras + gap
        barsContainer.style.top = `${playerVisualTop - barHeightWithGap - 5}px`; // 5px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // El 'transform: translateX(-50%)' en el CSS ayuda con esto si 'left' es el centro.
        barsContainer.style.left = `${
          playerVisualLeft + playerVisualWidth / 2
        }px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      function updatePlayerBarsInBattle() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        const hpFill = document.getElementById("playerInBattleSpriteHpFill");
        const manaFill = document.getElementById(
          "playerInBattleSpriteManaFill"
        );
        const playerSpriteInBattle = document.querySelector(
          ".battle-area .character .character-sprite"
        );

        if (!barsContainer || !hpFill || !manaFill || !playerSpriteInBattle) {
          // console.warn("Elementos de barras sobre el sprite del jugador en batalla no encontrados.");
          if (barsContainer) barsContainer.style.display = "none"; // Ocultar si faltan elementos
          return;
        }

        // Solo mostrar si la pantalla de batalla está activa
        if (
          !gameState.battle.active ||
          document.getElementById("battleScreen").style.display !== "flex"
        ) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // Posicionar las barras ligeramente encima del sprite del jugador en batalla.
        // El sprite (.character-sprite) es un div, necesitamos su offsetTop y offsetLeft
        // relativo a su padre (.character) que ahora es 'position: relative'.

        const spriteTop = playerSpriteInBattle.offsetTop; // Distancia desde el borde superior del .character
        const spriteLeft = playerSpriteInBattle.offsetLeft; // Distancia desde el borde izquierdo del .character
        const spriteWidth = playerSpriteInBattle.offsetWidth;

        const barHeightWithGap = barsContainer.offsetHeight || 12; // Alto total aprox. de las 2 barras + gap

        // El 'top' de las barras será el 'top' del sprite menos la altura de las barras y un pequeño margen.
        barsContainer.style.top = `${spriteTop - barHeightWithGap - 3}px`; // 3px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // 'left' será el 'left' del sprite más la mitad del ancho del sprite.
        // El 'transform: translateX(-50%)' en CSS centra el contenedor de barras.
        barsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      const joystickContainer = document.getElementById("joystick-container");
      const joystickPad = document.getElementById("joystick-pad");
      const joystickHandle = document.getElementById("joystick-handle");
      const actionButtonTouch = document.getElementById("action-button-touch");
      let joystickActive = false;
      let joystickCurrentDx = 0; // Guardar la dirección actual del joystick
      let joystickCurrentDy = 0;

      const JOYSTICK_THRESHOLD = 15;
      const JOYSTICK_GAME_MOVE_INTERVAL = 250;
      let joystickGameMoveTimerId = null;
      let lastJoystickMoveTime = 0;
      let joystickLoopId = null;
      let joystickTouchIdentifier = null; // <!-- CAMBIO JOYSTICK: Para seguir el dedo correcto -->

      function initJoystick() {
        if (
          !joystickContainer ||
          !joystickPad ||
          !joystickHandle ||
          !actionButtonTouch
        ) {
          console.error(
            "Error inicializando joystick: Elementos no encontrados."
          );
          return;
        }
        resetJoystickHandle();

        joystickPad.addEventListener(
          "touchstart",
          (event) => {
            if (
              gameState.player.isCultivating ||
              gameState.battle.active ||
              joystickActive
            )
              return;
            const touch = event.changedTouches[0];
            if (!touch) return;
            const padRect = joystickPad.getBoundingClientRect();
            if (
              touch.clientX < padRect.left ||
              touch.clientX > padRect.right ||
              touch.clientY < padRect.top ||
              touch.clientY > padRect.bottom
            ) {
              return;
            }
            event.preventDefault();
            joystickActive = true;
            joystickTouchIdentifier = touch.identifier;
            document.addEventListener("touchmove", handleJoystickMove, {
              passive: false,
            });
            document.addEventListener("touchend", handleJoystickEnd, {
              passive: false,
            });
            document.addEventListener("touchcancel", handleJoystickEnd, {
              passive: false,
            });

            // No iniciar el gameMoveTimer aquí, la animación la maneja handlePlayerMovementInput
            // updateJoystickHandlePosition y determinar dirección inicial
            updateJoystickHandlePosition(touch, true); // true para indicar que es el inicio
          },
          { passive: false }
        );

        actionButtonTouch.addEventListener("click", () => {
          if (!gameState.player.isCultivating && !gameState.battle.active) {
            interact();
          }
        });
      }
      function resetJoystickHandle() {
        if (joystickHandle)
          joystickHandle.style.transform = "translate(0px, 0px)";
        joystickCurrentDx = 0;
        joystickCurrentDy = 0;
      }
      // <!-- CAMBIO JOYSTICK: Modificaciones en los manejadores -->
      function handleJoystickStart(event) {
        // event.preventDefault(); // Puede ser necesario, pero probar sin él primero si causa problemas
        if (
          gameState.player.isCultivating ||
          gameState.battle.active ||
          joystickActive
        )
          return;

        // Solo procesar el primer toque en el pad
        const touch = event.changedTouches[0];
        if (!touch) return;

        // Comprobar si el toque está realmente dentro del joystickPad (opcional, pero bueno para evitar activaciones accidentales)
        const padRect = joystickPad.getBoundingClientRect();
        if (
          touch.clientX < padRect.left ||
          touch.clientX > padRect.right ||
          touch.clientY < padRect.top ||
          touch.clientY > padRect.bottom
        ) {
          return;
        }

        event.preventDefault(); // Prevenir scroll/zoom si el toque es para el joystick

        joystickActive = true;
        joystickTouchIdentifier = touch.identifier; // Guardar el ID del dedo

        // Añadir listeners de movimiento y fin al documento para seguir el dedo fuera del pad
        document.addEventListener("touchmove", handleJoystickMove, {
          passive: false,
        });
        document.addEventListener("touchend", handleJoystickEnd, {
          passive: false,
        });
        document.addEventListener("touchcancel", handleJoystickEnd, {
          passive: false,
        });

        if (!joystickGameMoveTimerId) {
          joystickGameMoveTimerId = setInterval(
            processJoystickGameMove,
            JOYSTICK_GAME_MOVE_INTERVAL
          );
        }
        updateJoystickHandlePosition(touch);
        // console.log("Joystick Start, ID:", joystickTouchIdentifier);
      }
      function handleJoystickMove(event) {
        if (!joystickActive) return;

        // Encontrar el toque correcto
        let touch = null;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touch = event.changedTouches[i];
            break;
          }
        }

        if (touch) {
          event.preventDefault(); // Prevenir scroll si el movimiento es del dedo del joystick
          updateJoystickHandlePosition(touch);
          // console.log("Joystick Move");
        }
      }

      function updateJoystickHandlePosition(touch, isStart = false) {
        const padRect = joystickPad.getBoundingClientRect();
        if (padRect.width === 0 || padRect.height === 0) return;

        const joystickCenterX = padRect.left + padRect.width / 2;
        const joystickCenterY = padRect.top + padRect.height / 2;

        const currentX = touch.clientX - joystickCenterX;
        const currentY = touch.clientY - joystickCenterY;

        const angle = Math.atan2(currentY, currentX);
        const maxDistance =
          joystickPad.offsetWidth / 2 - joystickHandle.offsetWidth / 2;
        if (maxDistance <= 0) return;

        const distance = Math.min(maxDistance, Math.hypot(currentX, currentY));
        const limitedX = distance * Math.cos(angle);
        const limitedY = distance * Math.sin(angle);
        if (joystickHandle)
          joystickHandle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;

        let newJoystickDx = 0;
        let newJoystickDy = 0;
        let newDirection = null;

        const magnitude = Math.hypot(currentX, currentY);
        if (magnitude > JOYSTICK_THRESHOLD) {
          if (Math.abs(currentX) > Math.abs(currentY)) {
            newJoystickDx = currentX > 0 ? 1 : -1;
            newDirection = currentX > 0 ? "right" : "left";
          } else {
            newJoystickDy = currentY > 0 ? 1 : -1;
            newDirection = currentY > 0 ? "down" : "up";
          }
        }

        if (
          newDirection &&
          (newDirection !== gameState.player.currentDirection ||
            isStart ||
            !gameState.player.isMoving)
        ) {
          // Si la dirección cambia o si estábamos parados, actualizamos
          // Primero, "soltamos" la dirección anterior si la hay y estábamos moviéndonos
          if (
            gameState.player.isMoving &&
            gameState.player.currentDirection &&
            gameState.player.currentDirection !== newDirection
          ) {
            handlePlayerMovementInput(gameState.player.currentDirection, false);
          }
          // Luego, "presionamos" la nueva dirección
          handlePlayerMovementInput(newDirection, true);
          // Y movemos lógicamente
          movePlayer(newJoystickDx, newJoystickDy);
        } else if (!newDirection && gameState.player.isMoving) {
          // Si no hay nueva dirección (el dedo volvió al centro) y estábamos moviéndonos
          handlePlayerMovementInput(gameState.player.currentDirection, false);
        }
        // Guardar para referencia en processJoystickGameMove si lo vuelves a usar
        joystickCurrentDx = newJoystickDx;
        joystickCurrentDy = newJoystickDy;
      }

      function handleJoystickEnd(event) {
        // Simplificado
        if (!joystickActive) return;
        let touchEndedIsOurs = false;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touchEndedIsOurs = true;
            break;
          }
        }
        if (touchEndedIsOurs) {
          joystickActive = false;
          joystickTouchIdentifier = null;
          resetJoystickHandle();
          document.removeEventListener("touchmove", handleJoystickMove);
          document.removeEventListener("touchend", handleJoystickEnd);
          document.removeEventListener("touchcancel", handleJoystickEnd);

          // "Soltar" la tecla de movimiento actual
          if (gameState.player.isMoving) {
            handlePlayerMovementInput(gameState.player.currentDirection, false);
          }
          joystickCurrentDx = 0;
          joystickCurrentDy = 0;
        }
      }
      // processJoystickGameMove se mantiene igual
      // <!-- FIN CAMBIO JOYSTICK -->
      function processJoystickGameMove() {
        // Esta función se llama cada JOYSTICK_GAME_MOVE_INTERVAL
        if (
          joystickActive &&
          (joystickCurrentDx !== 0 || joystickCurrentDy !== 0)
        ) {
          // console.log(`[processJoystickGameMove] Effective move: dx=${joystickCurrentDx}, dy=${joystickCurrentDy}. Calling movePlayer.`);
          movePlayer(joystickCurrentDx, joystickCurrentDy);
        }
      }
      function joystickLoop() {
        if (!joystickActive) {
          joystickLoopId = null;
          return;
        }
        const now = Date.now();
        if (now - lastJoystickMoveTime > JOYSTICK_MOVE_INTERVAL) {
          let dx = 0,
            dy = 0;
          const magnitude = Math.hypot(joystickCurrentX, joystickCurrentY);
          if (magnitude > JOYSTICK_THRESHOLD) {
            if (Math.abs(joystickCurrentX) > Math.abs(joystickCurrentY)) {
              dx = joystickCurrentX > 0 ? 1 : -1;
            } else {
              dy = joystickCurrentY > 0 ? 1 : -1;
            }
          }
          if (dx !== 0 || dy !== 0) {
            movePlayer(dx, dy);
            lastJoystickMoveTime = now;
          }
        }
        joystickLoopId = requestAnimationFrame(joystickLoop);
      }
      // --- NUEVAS FUNCIONES PARA LOS MODALES DE INVENTARIO Y PERSONAJE (EJEMPLOS) ---

      // Modal para Inventario Detallado (si decides usar un modal en lugar del sidebar)
      function openInventoryModal() {
        let inventoryContent = "<h2>Inventario</h2>";
        inventoryContent += '<div class="inventory-grid" style="max-height: 60vh; overflow-y: auto;">'; // Grid dentro del modal

        if (Object.keys(gameState.inventory).every(key => gameState.inventory[key] === 0 && key !== "Piedras Espirituales")) {
            inventoryContent += "<p>Tu inventario está vacío, excepto por tus Piedras Espirituales.</p>";
            if (gameState.inventory["Piedras Espirituales"] > 0) {
                inventoryContent += `<p>Piedras Espirituales: ${gameState.inventory["Piedras Espirituales"]}</p>`;
            }
        } else {
            Object.entries(gameState.inventory).forEach(([itemName, count]) => {
            if (count <= 0 && itemName !== "Piedras Espirituales") return; // No mostrar items con 0 cantidad (excepto piedras)

            const itemInfo = itemData[itemName];
            const description = itemInfo ? itemInfo.description : "Un objeto misterioso.";
            const canBeUsedNow = itemInfo && itemInfo.canUse ? itemInfo.canUse(gameState.player) : (itemInfo && itemInfo.effect ? true : false);
            const isEquipment = itemInfo && itemInfo.type === "equipment"; // Asumiendo que tienes 'type' en itemData

            inventoryContent += `
                <div class="inventory-item-modal" style="border: 1px solid #d4af37; padding: 10px; margin-bottom: 8px; border-radius: 5px; background: rgba(212,175,55,0.1);">
                <strong>${getItemIcon(itemName, itemInfo?.category)} ${itemName}: ${count}</strong><br>
                <small><em>${description}</em></small><br>`;

            if (itemInfo && itemInfo.effect && !isEquipment) { // Solo mostrar botón "Usar" para no equipables
                inventoryContent += `<button class="modal-use-item-btn" data-itemname="${itemName}" ${!canBeUsedNow ? 'disabled title="No se puede usar ahora"' : ''} style="margin-top: 5px; padding: 5px 10px;">Usar</button>`;
            } else if (isEquipment) {
                // Aquí podrías poner un botón "Equipar" o mostrar stats si es un arma/armadura
                // Por ahora lo dejamos sin botón de acción directa en el modal de inventario general
            }
            inventoryContent += `</div>`;
            });
        }
        inventoryContent += '</div>';
        showModal("Detalles del Inventario", inventoryContent); // Usas tu función showModal existente

        // Añadir event listeners a los botones "Usar" generados dinámicamente
        document.querySelectorAll('.modal-use-item-btn').forEach(button => {
            button.addEventListener('click', function() {
            const itemName = this.dataset.itemname;
            // Llamar a la función de usar item, pero esta vez el modal se cerrará y reabrirá
            // o se actualizará si la lógica de useItem no cierra todos los modales.
            const itemInfo = itemData[itemName];
            let message = "";
            if (itemInfo && itemInfo.effect) {
                if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
                    message = "No puedes usar esto ahora.";
                } else {
                    message = (itemName === "Piedras Espirituales" || itemName === "Núcleo de Bestia Menor" || (itemInfo.description && (itemInfo.description.includes("Otorga") || itemInfo.description.includes("otorga"))))
                    ? itemInfo.effect(gameState.player, gainExperience)
                    : itemInfo.effect(gameState.player);
                    if (message && !message.toLowerCase().includes("error") && !message.toLowerCase().includes("al máximo")) {
                    gameState.inventory[itemName]--;
                    }
                }
            } else {
                message = `${itemName} no tiene un efecto usable.`;
            }
            // Actualizar la UI del juego (stats, inventario en sidebar si aún es visible)
            updateUI();
            // Volver a abrir el modal de inventario para reflejar el cambio
            closeModal(); // Cierra el modal actual
            openInventoryModal(); // Vuelve a abrir con el contenido actualizado
            showModal("Objeto Usado", message); // Muestra el mensaje del uso del objeto sobre el modal de inventario
            });
        });
        }

      // Modal para Personaje (Stats, Equipo, etc.)
      function openCharacterModal() {
        const player = gameState.player;
        let characterContent = `
                <h2>${player.realm} - Nivel ${player.level}</h2>
                <div style="text-align: left; margin-top: 15px;">
                <p><strong>Vida:</strong> ${Math.floor(player.hp)} / ${
          player.maxHp
        }</p>
                <div class="stat-bar" style="height:18px;"><div class="stat-fill hp-fill" style="width: ${
                  (player.hp / player.maxHp) * 100
                }%;"></div></div>
                <p><strong>Maná:</strong> ${Math.floor(player.mana)} / ${
          player.maxMana
        }</p>
                <div class="stat-bar" style="height:18px;"><div class="stat-fill mana-fill" style="width: ${
                  (player.mana / player.maxMana) * 100
                }%;"></div></div>
                <p><strong>Experiencia:</strong> ${Math.floor(player.exp)} / ${
          player.expToNext
        }</p>
                <div class="stat-bar" style="height:18px;"><div class="stat-fill exp-fill" style="width: ${
                  (player.exp / player.expToNext) * 100
                }%;"></div></div>
                <hr style="margin: 15px 0;">
                <p><strong>Ataque:</strong> ${player.attack}</p>
                <p><strong>Defensa:</strong> ${player.defense}</p>
                <p><strong>Piedras Espirituales:</strong> ${
                  gameState.inventory["Piedras Espirituales"] || 0
                }</p>
                <hr style="margin: 15px 0;">
                <h4>Secta: ${player.secta.nombre}</h4>
                <p><strong>Rango:</strong> ${player.secta.rango}</p>
                <p><strong>Puntos de Contribución:</strong> ${
                  player.secta.puntosContribucion
                } PCS</p>
                </div>
                `;
        // Aquí podrías añadir una sección para el equipo si lo implementas.
        showModal("Detalles del Personaje", characterContent);
      }

      // Placeholder para un futuro modal de menú principal
      function openMainMenuModal() {
        let menuContent = `
                <h2>Menú Principal</h2>
                <button class="cultivation-option-btn" onclick="saveGame(); closeModal();">💾 Guardar Partida</button>
                <button class="cultivation-option-btn" onclick="triggerFileUpload(); closeModal();">📁 Cargar Partida</button>
                <button class="cultivation-option-btn" onclick="showHelp();">❓ Ayuda</button>
                <button class="cultivation-option-btn" onclick="closeModal();">↩️ Volver al Juego</button>
            `;
        // Usamos el showModal genérico pero sin el botón de cierre por defecto, ya que "Volver al Juego" hace esa función.
        // Para ello, tu showModal necesitaría una forma de ocultar su propio botón de cierre.
        // Si showModal no lo permite, necesitarías un modal específico para el menú.
        // Por ahora, asumiré que el showModal genérico tiene un botón de cierre que se ocultará
        // o que el usuario usará el botón "Volver al Juego".

        // Modificamos el modal genérico para que no muestre su propio botón "Cerrar" si se lo indicamos
        const modalElement = document.getElementById("interactionModal");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalTextEl = document.getElementById("modalText");
        const closeButton = modalElement.querySelector(
          "button.close-modal-btn"
        );

        modalTitleEl.textContent = "Menú Principal"; // El H2 ya está en menuContent
        modalTextEl.innerHTML = menuContent.replace(
          "<h2>Menú Principal</h2>",
          ""
        ); // Quitar el H2 duplicado
        if (closeButton) closeButton.style.display = "none"; // Ocultar el botón de cierre por defecto del modal

        modalElement.style.display = "flex";
        hideTouchControls();
        updateBottomNavVisibility();
      }

      function openSectHallInterface() {
        const player = gameState.player;
        const sectData = SECTA_DATA;
        console.log(
          "[SectHall] Abrir interfaz. Rango actual:",
          player.secta.rango,
          "PCS:",
          player.secta.puntosContribucion
        ); // LOG INICIAL

        document.getElementById(
          "sectHallModalTitle"
        ).textContent = `Salón ${player.secta.nombre}`;
        document.getElementById("sectHallPlayerRank").textContent =
          player.secta.rango;
        document.getElementById("sectHallPlayerPCS").textContent =
          player.secta.puntosContribucion;

        const availableMissionsDiv = document.getElementById(
          "sectHallAvailableMissions"
        );
        availableMissionsDiv.innerHTML =
          "<p>Habla con Guía Lin o Admin Yao para asignaciones generales.</p>";

        const rankChallengesDiv = document.getElementById(
          "sectHallRankChallenges"
        );
        rankChallengesDiv.innerHTML = "";

        const currentRankIndex = sectData.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );
        console.log("[SectHall] currentRankIndex:", currentRankIndex); // LOG currentRankIndex

        let challengeButtonAdded = false;

        // Condición principal para mostrar el botón de consulta
        if (
          currentRankIndex !== -1 &&
          currentRankIndex + 1 < sectData.rangos.length
        ) {
          console.log(
            "[SectHall] Condición para mostrar botón CUMPLIDA. Hay un siguiente rango."
          ); // LOG
          const nextRankData = sectData.rangos[currentRankIndex + 1];
          console.log(
            "[SectHall] Siguiente rango:",
            nextRankData.nombre,
            "PCS Req:",
            nextRankData.pcsRequeridos
          ); // LOG nextRankData

          const challengeButton = document.createElement("button");
          challengeButton.textContent = `Consultar Desafío para ${nextRankData.nombre}`;
          challengeButton.className = "cultivation-option-btn";
          challengeButton.style.marginBottom = "10px";

          challengeButton.onclick = () => {
            // ... (lógica del onclick que ya tienes, puedes añadir logs internos aquí también si es necesario) ...
            console.log("[SectHall] Botón 'Consultar Desafío' CLICADO.");
            const pcsNecesarios = nextRankData.pcsRequeridos;
            const tieneSuficientesPCS =
              player.secta.puntosContribucion >= pcsNecesarios;
            const rivalIdParaDesafio = nextRankData.desafioRivalId;
            let mensajeDesafio = `<strong>Desafío para ascender a ${nextRankData.nombre}:</strong><br>`;
            let misionDesafioActiva = null;
            let misionDesafioDataObj = null;
            let idDeLaMisionAsociada = null;

            console.log(
              `[SectHall - OnClick] PCS Necesarios: ${pcsNecesarios}, Tiene PCS: ${tieneSuficientesPCS}, Rival ID: ${rivalIdParaDesafio}`
            );

            if (rivalIdParaDesafio) {
              const misionEntry = Object.entries(MISIONES_DATA).find(
                ([mKey, mVal]) =>
                  mVal.objetivo?.tipo === "derrotar_npc_especifico" &&
                  mVal.objetivo?.npcId === rivalIdParaDesafio &&
                  mVal.recompensa?.nuevoRango === nextRankData.nombre
              );
              console.log(
                "[SectHall - OnClick] Mision Entry encontrada:",
                misionEntry
              );

              if (misionEntry) {
                idDeLaMisionAsociada = misionEntry[0];
                misionDesafioDataObj = misionEntry[1];
                misionDesafioActiva = player.secta.misionesActivas.find(
                  (m) => m.id === idDeLaMisionAsociada
                );
                console.log(
                  "[SectHall - OnClick] ID Misión Asociada:",
                  idDeLaMisionAsociada,
                  "Misión Activa?:",
                  !!misionDesafioActiva
                );

                mensajeDesafio += `<em>"${misionDesafioDataObj.descripcion}"</em><br>`;
                mensajeDesafio += `Oponente: <strong>${
                  entityTypes[rivalIdParaDesafio]?.name ||
                  "Guardián Desconocido"
                }</strong>.<br>`;
                mensajeDesafio += `Recompensas: ${
                  misionDesafioDataObj.recompensa.pcs || 0
                } PCS, ${misionDesafioDataObj.recompensa.exp || 0} EXP, Rango ${
                  nextRankData.nombre
                }.<br><hr>`;
              } else {
                mensajeDesafio += `Información del desafío específico no encontrada (error de configuración o la misión no está definida correctamente).<br><hr>`;
              }
            } else {
              mensajeDesafio += `Este rango no parece requerir un desafío de combate para ascender.<br><hr>`;
            }

            mensajeDesafio += `<strong>Requisitos Actuales:</strong><br>`;
            mensajeDesafio += `Puntos de Contribución (PCS): ${player.secta.puntosContribucion} / ${pcsNecesarios} PCS. `;
            mensajeDesafio += tieneSuficientesPCS
              ? "<span style='color: #66ff66;'>(Cumplido)</span><br>"
              : `<span style='color: #ffcc66;'>(Faltan ${
                  pcsNecesarios - player.secta.puntosContribucion
                } PCS)</span><br>`;

            if (misionDesafioActiva) {
              mensajeDesafio +=
                "<br><strong style='color: #66ff66;'>¡El desafío está ACTIVO!</strong> Dirígete a la arena.";
            } else if (
              idDeLaMisionAsociada &&
              player.secta.misionesCompletadas[idDeLaMisionAsociada]
            ) {
              mensajeDesafio +=
                "<br><strong style='color: #aaa;'>Ya has completado este desafío.</strong>";
            } else if (
              tieneSuficientesPCS &&
              rivalIdParaDesafio &&
              misionDesafioDataObj &&
              idDeLaMisionAsociada
            ) {
              const activarDesafioBtnId = "activar-desafio-btn-specific";
              mensajeDesafio += `<br><button id="${activarDesafioBtnId}">Activar Misión de Desafío Ahora</button>`;

              window.tempChallengeActivationInfo = {
                misionId: idDeLaMisionAsociada,
                nextRankName: nextRankData.nombre,
              };
            } else if (!tieneSuficientesPCS) {
              mensajeDesafio +=
                "<br>Aún no cumples los requisitos de PCS para activar este desafío.";
            } else if (!rivalIdParaDesafio || !misionDesafioDataObj) {
              mensajeDesafio +=
                "<br>No hay un desafío de combate claramente definido para este rango o falta información de la misión.";
            }

            showModal("Información del Desafío de Rango", mensajeDesafio);

            if (
              window.tempChallengeActivationInfo &&
              document.getElementById("activar-desafio-btn-specific")
            ) {
              document.getElementById("activar-desafio-btn-specific").onclick =
                () => {
                  console.log(
                    "[SectHall - OnClick] Botón 'Activar Misión Ahora' CLICADO."
                  );
                  const info = window.tempChallengeActivationInfo;
                  const misionDataParaActivar = MISIONES_DATA[info.misionId];
                  const playerRef = gameState.player;
                  const nextRankDataRef = SECTA_DATA.rangos.find(
                    (r) => r.nombre === info.nextRankName
                  );

                  if (
                    misionDataParaActivar &&
                    nextRankDataRef &&
                    playerRef.secta.puntosContribucion >=
                      nextRankDataRef.pcsRequeridos
                  ) {
                    if (
                      !playerRef.secta.misionesActivas.some(
                        (m) => m.id === info.misionId
                      ) &&
                      !playerRef.secta.misionesCompletadas[info.misionId]
                    ) {
                      acceptMission(info.misionId);
                      closeModal();
                      openSectHallInterface();
                      ensureFixedEntities();
                      renderMap();
                    } else {
                      showModal(
                        "Desafío ya Gestionado",
                        "Este desafío ya está activo o ha sido completado."
                      );
                    }
                  } else {
                    showModal(
                      "Requisitos No Cumplidos",
                      "Ya no cumples los requisitos para activar este desafío."
                    );
                  }
                  delete window.tempChallengeActivationInfo;
                };
            } else if (
              document.getElementById("activar-desafio-btn-specific")
            ) {
              console.warn(
                "[SectHall - OnClick] Botón 'activar-desafio-btn-specific' existe, pero window.tempChallengeActivationInfo no está definido."
              );
            }
          };
          rankChallengesDiv.appendChild(challengeButton);
          challengeButtonAdded = true;
          console.log("[SectHall] Botón 'Consultar Desafío' AÑADIDO al DOM."); // LOG si se añade
        } else {
          // Este bloque se ejecuta si la condición if (currentRankIndex !== -1 && currentRankIndex + 1 < sectData.rangos.length) NO se cumple
          console.log("[SectHall] Condición para mostrar botón NO CUMPLIDA."); // LOG
          if (currentRankIndex === -1) {
            console.log(
              "[SectHall] Razón: currentRankIndex es -1 (rango del jugador no encontrado)."
            ); // LOG
          } else {
            console.log(
              "[SectHall] Razón: Jugador en rango máximo o no hay más rangos (currentRankIndex + 1 >= sectData.rangos.length)."
            ); // LOG
          }
        }

        // Mensajes de fallback si el botón no se añadió
        if (!challengeButtonAdded) {
          console.log(
            "[SectHall] challengeButtonAdded es FALSE. Mostrando mensaje de fallback."
          ); // LOG
          if (currentRankIndex === -1) {
            rankChallengesDiv.innerHTML =
              "<p>Error al determinar tu rango actual.</p>";
          } else if (currentRankIndex + 1 >= sectData.rangos.length) {
            rankChallengesDiv.innerHTML =
              "<p>¡Has alcanzado el rango más alto o no hay más desafíos definidos!</p>";
          } else {
            // Esta situación es menos común si la lógica anterior es correcta,
            // pero podría ocurrir si hay un `nextRankData` pero por alguna razón no se crea el botón.
            rankChallengesDiv.innerHTML =
              "<p>No hay información de desafío disponible en este momento (situación de fallback inesperada).</p>";
          }
        }

        document.getElementById("sectHallModal").style.display = "flex";
        hideTouchControls();
      }
      function acceptMissionFromSectHall(misionId) {
        acceptMission(misionId);
        if (document.getElementById("sectHallModal").style.display === "flex") {
          openSectHallInterface();
        }
      }
      function closeSectHallModal() {
        document.getElementById("sectHallModal").style.display = "none";
        showTouchControls();
        updatePlayerBarsOnMap();
        showTouchControls();
      }
      function openSectShop() {
        showModal("Tienda de Secta", "El Depósito aún está siendo abastecido.");
      }

      // --- INICIALIZACIÓN ---
      document.addEventListener("DOMContentLoaded", () => {
        const navBtnInventory = document.getElementById('navBtnInventory');
        console.log("Dentro de DOMContentLoaded, navBtnInventory:", navBtnInventory);
        if (navBtnInventory) {
            console.log("Añadiendo listener al botón de inventario..."); // <-- AÑADE ESTO
          navBtnInventory.addEventListener("click", () => {
            console.log("¡Clic en el botón de Inventario detectado!"); // <-- AÑADE ESTO
            openInventoryModal();
            // Necesitas una función para abrir un MODAL de inventario
            // o decidir cómo quieres mostrarlo.
            // Por ahora, un simple placeholder:
            // showModal("Inventario", "Aquí se mostrará tu inventario detallado.");
            // O, si quieres mostrar el panel lateral de inventario y scrollear a él (menos ideal):
            const inventoryPanel = document.querySelector(".inventory-panel");
            if (inventoryPanel) {
              inventoryPanel.scrollIntoView({ behavior: "smooth" });
              // Podrías resaltar el panel de inventario temporalmente
            } else {
              // Si quieres un modal dedicado para el inventario:
              openInventoryModal(); // Tendrías que crear esta función y el modal
            }
          });
        }

        if (navBtnCharacter) {
          navBtnCharacter.addEventListener("click", () => {
            // Necesitas una función para abrir un MODAL de personaje
            openCharacterModal(); // Tendrías que crear esta función y el modal
          });
        }

        if (navBtnCultivate) {
          navBtnCultivate.addEventListener("click", () => {
            toggleCultivation(); // Tu función existente para iniciar/detener cultivo
          });
        }

        if (navBtnTechniques) {
          navBtnTechniques.addEventListener("click", () => {
            showTechniquePanel(); // Tu función existente para mostrar el modal de técnicas
          });
        }

        if (navBtnMenu) {
          navBtnMenu.addEventListener("click", () => {
            // Decide qué hace este botón. ¿Abre el sidebar? ¿Un menú de pausa?
            // Ejemplo: si quieres que muestre el sidebar en vista móvil donde está colapsado.
            const sidebar = document.querySelector(".sidebar");
            if (sidebar && isMobileView()) {
              // Podrías implementar una lógica para alternar la visibilidad del sidebar
              // o scrollear a él si es parte del layout principal.
              // Por ahora, un placeholder:
              sidebar.scrollIntoView({ behavior: "smooth" });
            } else {
              // showModal("Menú Principal", "Opciones del juego / Guardar / Cargar / Ayuda.");
              // O si tienes una función para abrir un modal de menú:
              openMainMenuModal(); // Tendrías que crear esta función
            }
          });
        }

        // Llamada inicial para asegurar el estado correcto de la barra
        updateBottomNavVisibility();

        // MODIFICACIÓN DEL LISTENER DE TECLADO
        document.addEventListener("keydown", (e) => {
          if (
            gameState.player.isCultivating ||
            gameState.battle.active ||
            isAnyModalOpen()
          ) {
            if (e.code === "Escape") {
              /* ... tu lógica de modales ... */
            }
            return;
          }
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
            case "Space":
              e.preventDefault();
              interact();
              return; // Interact no cambia
          }

          if (direction) {
            e.preventDefault();
            handlePlayerMovementInput(direction, true); // true para keyDown
            // El movePlayer original se llamará desde un intervalo o lógica de juego si es necesario
            // para desacoplar la actualización visual de la lógica de movimiento
            if (
              dxFromDirection(direction) !== 0 ||
              dyFromDirection(direction) !== 0
            ) {
              movePlayer(
                dxFromDirection(direction),
                dyFromDirection(direction)
              );
            }
          }
        });
        document.addEventListener("keyup", (e) => {
          if (
            gameState.player.isCultivating ||
            gameState.battle.active ||
            isAnyModalOpen()
          ) {
            return;
          }
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
          }
          if (direction) {
            handlePlayerMovementInput(direction, false); // false para keyUp
          }
        });
        // Helper para convertir dirección a dx/dy para movePlayer
        function dxFromDirection(direction) {
          if (direction === "left") return -1;
          if (direction === "right") return 1;
          return 0;
        }

        function dyFromDirection(direction) {
          if (direction === "up") return -1;
          if (direction === "down") return 1;
          return 0;
        }

        const fileInput = document.getElementById("fileInput");
        if (fileInput) fileInput.addEventListener("change", loadGameFromFile);

        const toggleControlsBtn = document.getElementById(
          "toggleMapControlsBtn"
        );
        if (toggleControlsBtn)
          toggleControlsBtn.addEventListener(
            "click",
            toggleMapControlsVisibility
          );

        // Listener para redimensionar y recalcular el tamaño de los tiles
        window.addEventListener("resize", () => {
          calculateAndSetTileSize();
          renderMap(); // Vuelve a dibujar con el nuevo tamaño
          updatePlayerPosition(); // Asegura que el jugador esté bien posicionado
        });

        // Iniciar el bucle de actualización del juego
        setInterval(gameTickUpdater, 1000); // Llama cada segundo, ajusta según necesidad
        initJoystick();
        calculateAndSetTileSize();
        // generateMap() ahora es más simple, isRespawn = false para carga inicial completa
        gameState.lastGameTimeUpdate = Date.now(); // Inicializar antes del primer tick
        // ---------- CAMBIO IMPORTANTE AQUÍ ----------
        generateMap(true); // Usar true para la generación inicial completa, incluyendo decorativos
        // ---------- FIN DEL CAMBIO IMPORTANTE ----------
        recalculatePlayerStats();
        updatePlayerVisualSize(); // Asegura el tamaño correcto del div del jugador
        updatePlayerSpriteVisual(); // Establece el sprite inicial
        updatePlayerPosition("DOMContentLoaded_init"); // Llama después de sprite visual

        updatePlayerSpriteVisual(); // Llamar una vez para establecer el sprite inicial

        showTouchControls();

        showModal(
          "Despertar del Cultivador",
          "Has despertado en un mundo de cultivadores buscando poder supremo. " +
            "Te encuentras cerca de la <strong>Secta del Viento Azure</strong>. Quizás allí encuentres tu camino.\n\n" +
            "<strong>Objetivo:</strong> Asciende en la secta, domina técnicas, derrota enemigos y desvela secretos.\n\n" +
            "Busca al <strong>Guía Lin</strong> en la secta (⛩️) para comenzar.\n\n" +
            'Usa Controles (Teclado/Táctil) para moverte e interactuar. Presiona "?" para ayuda.'
        );
        document
          .querySelectorAll("#shopCategories .category-item")
          .forEach((item) => {
            item.addEventListener("click", function () {
              document
                .querySelectorAll("#shopCategories .category-item")
                .forEach((i) => i.classList.remove("active"));
              this.classList.add("active");
              currentShopPage = 1;
              renderShopProducts();
            });
          });
        document.getElementById("shopSearch").addEventListener("input", () => {
          currentShopPage = 1;
          renderShopProducts();
        });
        document.getElementById("priceRange").addEventListener("input", (e) => {
          document.getElementById(
            "priceRangeValue"
          ).textContent = `${e.target.value} PS`;
          currentShopPage = 1;
          renderShopProducts();
        });
      });
    </script>
  </body>
</html>
