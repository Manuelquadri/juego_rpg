<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Camino del Cultivador</title>
    <style>
      /****************************************
       * 1. ESTILOS GENERALES Y LAYOUT
       ****************************************/
       
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", monospace;
        background: linear-gradient(135deg, #2c1810, #8b4513);
        color: #f4e4bc;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Evita el scroll indeseado */
      }

      .game-container {
        display: flex;
        flex-grow: 1;
        /* El padding-top crea el espacio para la barra de navegación superior */
        padding-top: 55px; /* Ajusta este valor si cambia la altura de la barra */
        position: relative;
        z-index: 1;
      }

      .sidebar {
        display: none; /* La barra lateral ya no se usa, se oculta permanentemente */
      }

      button {
        background: linear-gradient(135deg, #d4af37, #b8941f);
        color: #2c1810;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      button:hover {
        background: linear-gradient(135deg, #f4d03f, #d4af37);
        transform: translateY(-2px);
      }

      button:disabled {
        background: #666;
        color: #999;
        cursor: not-allowed;
        transform: none;
      }
      /* Esta regla se aplicará a TODAS las barras de estadísticas del juego */
      .stat-bar {
        width: 100%;
        height: 18px; /* Una altura estándar y visible. Puedes ajustarla. */
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 9px;
        overflow: hidden; /* Asegura que el relleno no se salga */
        border: 1px solid rgba(212, 175, 55, 0.2);
        margin: 8px 0; /* Un poco de espacio vertical para que no se pegue a otros elementos */
      }

      /* El relleno de la barra */
      .stat-fill {
        height: 100%; /* Ahora esto funcionará, porque el padre (.stat-bar) tiene una altura fija */
        transition: width 0.3s linear;
      }
      #fullscreenIcon {
        margin-right: 8px;
        display: inline-block;
        /* Para el ícono de salir */
        font-family: 'Arial Unicode MS', 'Apple Symbols', 'sans-serif';
      }
      /* ESTILO PARA LA REJILLA DEL MAPA */
      .grid-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 2; 
          background-size: var(--tile-size, 100px) var(--tile-size, 100px);
          background-image:
              linear-gradient(to right, #ff00d94d 2px, transparent 1px),
              linear-gradient(to bottom, #ff00d94d 2px, transparent 1px);
          display: none;
      }
      .grid-overlay.active {
          display: block;
      }
      /****************************************
       * 2. INTERFAZ PRINCIPAL (HUD, BARRAS, BOTONES)
       ****************************************/

      /* --- Barra de Navegación Superior --- */
      .top-nav-bar {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 55px; /* Altura fija para el cálculo de padding */
        background: linear-gradient(180deg, #2c1810, #1a1a1a);
        border-bottom: 2px solid #d4af37;
        display: flex;
        justify-content: space-around;
        align-items: center;
        z-index: 250;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease-in-out;
        transform: translateY(0);
      }

      .top-nav-bar.hidden {
        transform: translateY(-100%);
      }

      .nav-button {
        position: relative;
        background: transparent;
        border: none;
        color: #f4e4bc;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 8px 5px;
        cursor: pointer;
        font-family: "Courier New", monospace;
        font-size: 0.75rem;
        flex-grow: 1;
        max-width: 20%;
        transition: background-color 0.2s, color 0.2s;
      }

      .nav-button:hover,
      .nav-button.active {
        background-color: rgba(212, 175, 55, 0.15);
        color: #f4d03f;
      }

      .nav-icon {
        font-size: 1.5rem;
        margin-bottom: 3px;
      }

      /* --- HUD de Stats del Jugador (Esquina superior izquierda) --- */
      .stats-panel {
        position: fixed; /* FIJO en la ventana, no relativo al mapa */
        top: 70px; /* 55px de la barra + 15px de margen */
        left: 15px;
        z-index: 100;
        width: 180px;
        background: rgba(26, 26, 26, 0.75);
        backdrop-filter: blur(4px);
        border: 2px solid #d4af37;
        border-radius: 8px;
        padding: 10px;
        margin: 0;
      }

      .stats-panel .stat-bar {
        width: 100%;
        height: 12px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 7px;
        margin-top: 3px;
        margin-bottom: 8px;
        overflow: hidden;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      .stat-fill {
        height: 100%;
        transition: width 0.3s;
      }
      .stats-panel .stat-line,
      .stats-panel .stat-block {
        margin-bottom: 8px; /* Espaciado consistente */
      }

      .stats-panel .stat-stones {
        color: #f4d03f; /* Destacar las piedras espirituales */
        font-weight: bold;
        margin-top: 4px;
      }

      .stats-panel .stat-block span {
        display: block; /* Asegura que el texto esté en su propia línea */
        font-size: 0.9em;
        margin-bottom: 2px;
      }
      .hp-fill {
        background: linear-gradient(90deg, #ff4444, #ff6666);
      }
      .mana-fill {
        background: linear-gradient(90deg, #4444ff, #6666ff);
      }
      .exp-fill {
        background: linear-gradient(90deg, #44ff44, #66ff66);
      }
      .stats-panel.hidden {
        opacity: 0;
        pointer-events: none; /* Evita que se pueda hacer clic en el panel cuando está oculto */
        transform: translateX(
          -100%
        ); /* Opcional: lo desliza fuera de la pantalla */
        transition: opacity 0.3s ease, transform 0.3s ease;
      }
      /* --- Barra de Acceso Rápido Inferior --- */
      .quick-slot-bar {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        padding: 8px;
        background: rgba(26, 26, 26, 0.8);
        border: 2px solid #d4af37;
        border-radius: 12px;
        z-index: 150;
        box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
        backdrop-filter: blur(4px);
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      }
      .quick-slot-bar.hidden {
          opacity: 0;
          visibility: hidden;
          pointer-events: none; /* Importante para que no sea clickeable cuando está invisible */
      }

      .quick-slot {
        width: 55px;
        height: 55px;
        border: 2px solid rgba(212, 175, 55, 0.5);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        position: relative;
        transition: all 0.2s;
      }
      .quick-slot:hover {
        background-color: rgba(212, 175, 55, 0.2);
        border-color: #f4d03f;
      }
      .quick-slot.empty {
        border-style: dashed;
      }

      .slot-item-count {
        position: absolute;
        bottom: 2px;
        right: 4px;
        font-size: 14px;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px black;
      }

      .slot-key-hint {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 12px;
        color: #f4e4bc;
        opacity: 0.7;
      }
      .cultivate-slot {
        font-size: 28px; /* Hacemos el emoji un poco más grande */
        border-style: solid; /* Para que no se vea punteado como un slot vacío */
      }

      /* Estilo para cuando el cultivo está activo */
      .cultivate-slot.active-cultivation {
        background-color: rgba(
          139,
          69,
          19,
          0.5
        ); /* Un brillo sutil de color del tema */
        border-color: #f4d03f;
        box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
        animation: pulse-cultivation 2s infinite;
      }
      .conversion-slot {
        font-size: 28px;
        border-style: solid;
        color: #f4e4bc;
        opacity: 0.6; /* Un poco tenue cuando está inactivo */
        transition: all 0.3s;
      }

      .conversion-slot:hover {
        opacity: 1;
      }

      .conversion-slot.active-conversion {
        opacity: 1;
        background-color: rgba(68, 68, 255, 0.3); /* Brillo azulado */
        border-color: #6666ff;
        box-shadow: 0 0 10px rgba(102, 102, 255, 0.7);
        animation: pulse-conversion 2s infinite;
      }
      .rune-slot {
          font-size: 28px;
          border-style: solid;
          color: #ff99ff; /* Un tono magenta/rosa para la magia rúnica */
          opacity: 0.6; /* Un poco tenue cuando no se usa activamente */
          transition: all 0.3s;
      }

      .rune-slot:hover {
          opacity: 1;
          color: #ffc0ff;
          border-color: #ff99ff;
      }

      /* (Opcional) Un estilo para cuando la habilidad se esté usando, aunque para plantar runas no es tan necesario */
      .rune-slot.active-scribing {
          opacity: 1;
          background-color: rgba(255, 100, 255, 0.2); /* Brillo magenta */
          border-color: #ff99ff;
          box-shadow: 0 0 10px rgba(255, 153, 255, 0.7);
          animation: pulse-rune-slot 1.5s infinite;
      }

      @keyframes pulse-rune-slot {
          0% { transform: scale(1); }
          50% { transform: scale(1.05); }
          100% { transform: scale(1); }
      }
      .rune-marker {
          background-color: rgba(255, 100, 255, 0.2);
          border: 2px solid #ff00ff;
          border-radius: 50%;
          box-shadow: 0 0 15px #ff00ff, inset 0 0 10px #ff00ff;
          animation: pulse-rune 2.5s infinite ease-in-out;
      }

      @keyframes pulse-rune {
          0% { transform: scale(0.8); opacity: 0.7; }
          50% { transform: scale(1.0); opacity: 1; }
          100% { transform: scale(0.8); opacity: 0.7; }
      }
      @keyframes pulse-conversion {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes pulse-cultivation {
        0% {
          transform: scale(1);
          box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 15px rgba(244, 208, 63, 0.8);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
        }
      }
      @keyframes pulse-mission-marker {
          0% {
              box-shadow: 0 0 5px rgba(255, 223, 0, 0.4), inset 0 0 5px rgba(255, 223, 0, 0.3);
              opacity: 0.7;
          }
          50% {
              box-shadow: 0 0 20px rgba(255, 223, 0, 0.8), inset 0 0 10px rgba(255, 223, 0, 0.5);
              opacity: 1;
          }
          100% {
              box-shadow: 0 0 5px rgba(255, 223, 0, 0.4), inset 0 0 5px rgba(255, 223, 0, 0.3);
              opacity: 0.7;
          }
      }

      /* --- Botones de Control Superpuestos (Móvil) --- */
      #mobileMenuBtn {
        display: none;
        position: fixed;
        top: 10px;
        right: 10px; /* <--- CORREGIDO */
        z-index: 1000;
        width: 45px;
        height: 45px;
        font-size: 24px;
        padding: 0;
      }

      #toggleMapControlsBtn {
          display: none; /* Se controla por JS y media queries */
          position: fixed;
          top: 60px; /* Posición respecto a la ventana */
          right: 10px;
          z-index: 200; /* Aseguramos que esté al mismo nivel que los otros controles */
          padding: 8px 12px;
          font-size: 14px;
      }

      #toggleMapControlsBtn.hidden-during-battle {
        display: none !important;
      }

      /****************************************
       * 3. MAPA Y ELEMENTOS DEL MAPA
       ****************************************/
      .map-container {
        flex: 1;
        position: relative;
        background: #1a3d2e;
        border: 3px solid #d4af37;
        overflow: hidden;
      }

      .map {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .tile {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .player {
        z-index: 10;
        color: transparent; /* Oculta el emoji de fallback */
        font-size: 0;
        background-image: url("img/tu_sprite_sheet.png"); /* Asegúrate que la ruta sea correcta */
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: 256px 256px; /* Ajusta al tamaño total de tu spritesheet */
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }

      /* Barras de stats sobre el jugador en el mapa */
      #playerOnMapBarsContainer {
        position: absolute;
        width: 48px;
        display: none; /* JS lo controla */
        flex-direction: column;
        gap: 1px;
        z-index: 15;
        pointer-events: none;
        transform: translateX(-50%);
      }

      .on-map-stat-bar {
        width: 100%;
        height: 6px;
        background-color: rgba(50, 50, 50, 0.7);
        border: 1px solid rgba(0, 0, 0, 0.5);
        border-radius: 2px;
        overflow: hidden;
      }

      .on-map-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerOnMapHpFill {
        background-color: #f44336;
      }
      #playerOnMapManaFill {
        background-color: #2196f3;
      }
      .entity-name-plate {
        position: absolute; /* Para posicionarlo relativo al mapa */
        bottom: 100%; /* Lo coloca justo encima del 'top' del sprite */
        left: 50%;
        transform: translateX(-50%); /* Lo centra horizontalmente */
        background-color: rgba(10, 10, 10, 0.7);
        color: #f4e4bc;
        padding: 2px 5px;
        border-radius: 4px;
        font-size: 10px; /* Un tamaño de fuente pequeño y legible */
        font-weight: bold;
        white-space: nowrap; /* Evita que el nombre se parta en dos líneas */
        z-index: 6; /* Asegura que esté por encima de la entidad */
        pointer-events: none; /* Evita que la etiqueta intercepte clics del ratón */
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      /****************************************
       * 4. PANTALLA DE BATALLA
       ****************************************/

      .battle-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        display: none;
        flex-direction: column;
        z-index: 300;
        overflow: hidden;
        max-height: 100dvh; 
      }

      .battle-area {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: space-around;
        padding: 20px 10px;
        gap: 10px;
        overflow-y: auto;
      }

      .character,
      .enemy {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-basis: 45%;
        max-width: 280px;
        min-width: 120px;
        padding: 60px 0;
      }

      .character-sprite,
      .enemy-sprite {
        width: 80px;
        height: 80px;
        font-size: 60px;
        margin-bottom: 10px;
      }
      .enemy-sprite {
        background-size: contain; /* Asegura que la imagen quepa completa en el div */
        background-repeat: no-repeat;
        background-position: center; /* Centra la imagen del sprite */
        image-rendering: pixelated; /* Mantiene la estética pixel-art si la tienes */
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }

      .character-sprite {
        background-image: url("img/tu_sprite_sheet.png");
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: auto;
        color: transparent;
      }

      .battle-actions {
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-top: 2px solid #d4af37;
        flex-shrink: 0;
      }

      .action-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 5px;
        margin-bottom: 10px;
      }

      .battle-actions button {
        padding: 8px 10px;
        font-size: 0.8em;
      }

      .log {
        display: none;
      }

      /* Barras sobre sprites en batalla */
      #playerInBattleSpriteBarsContainer,
      #enemyInBattleInfoContainer {
        position: absolute;
        display: none;
        flex-direction: column;
        gap: 2px;
        z-index: 5;
        pointer-events: none;
        transform: translateX(-50%);
      }

      #playerInBattleSpriteBarsContainer {
        width: 60px;
      }
      #enemyInBattleInfoContainer {
        min-width: 70px;
        max-width: 300px;
        align-items: center;
        padding: 2px 4px;
        background-color: rgba(10, 10, 10, 0.6);
        border-radius: 3px;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      .in-battle-sprite-stat-bar {
        width: 100%;
        height: 5px;
        background-color: rgba(50, 50, 50, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.6);
        border-radius: 2px;
        overflow: hidden;
      }
      .in-battle-sprite-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerInBattleSpriteHpFill {
        background-color: #e53935;
      }
      #playerInBattleSpriteManaFill {
        background-color: #1e88e5;
      }
      #enemyInBattleSpriteHpFill {
        background-color: #c62828;
      }

      .enemy-battle-name-level {
        font-size: 0.8em;
        color: #f4e4bc;
        font-weight: bold;
        white-space: nowrap;
      }

      /****************************************
       * 5. MODALES Y ELEMENTOS DE UI
       ****************************************/
      /* === NUEVO: ESTILOS PARA EL VELO OSCURECEDOR === */
      /* Estilos para la cuadrícula del tutorial de formaciones */
      #formation-pattern-grid {
          display: grid;
          grid-template-columns: repeat(5, 1fr);
          grid-template-rows: repeat(5, 1fr);
          width: 150px; /* Tamaño de la cuadrícula de ejemplo */
          height: 150px;
          margin: 15px auto;
          border: 2px solid #555;
          background-color: rgba(0,0,0,0.2);
      }

      .grid-cell {
          border: 1px solid #444;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 1.2em;
      }

      .grid-cell.rune {
          color: #ff00ff; /* Color de la runa de ejemplo */
          font-weight: bold;
      }

      .grid-cell.enemy {
          color: #ff4d4d; /* Color del enemigo de ejemplo */
      }
      .game-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6); /* Color negro semitransparente */
        backdrop-filter: blur(
          3px
        ); /* Efecto de desenfoque para el fondo (opcional, muy vistoso) */
        z-index: 290; /* Clave: Por encima del juego (z-index < 290) pero por debajo de la batalla/modales (z-index >= 300) */
        opacity: 0;
        pointer-events: none; /* No debe ser clickeable cuando está invisible */
        transition: opacity 0.4s ease-in-out;
      }

      .game-overlay.active {
        opacity: 1;
        pointer-events: auto; /* Se vuelve "sólido" para evitar clics en el juego de fondo */
      }
      /* === FIN DE ESTILOS PARA EL VELO === */

      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 500; /* Más alto que la batalla */
        padding: 10px;
      }

      .modal-content {
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        border: 3px solid #d4af37;
        border-radius: 15px;
        padding: 20px;
        max-width: 95%;
        width: 500px;
        text-align: center;
        max-height: 90vh;
        overflow-y: auto;
      }
      .inventory-modal-item .item-description {
          font-size: 0.9em;
          opacity: 0.8;
          margin-top: 4px;
          margin-bottom: 8px; /* <-- Añade este margen inferior */
      }

      .cultivation-option-btn {
        display: block;
        width: 100%;
        padding: 10px;
        margin-bottom: 8px;
        text-align: left;
      }

      /* Controles táctiles del mapa (Joystick, Botón Acción) */
      #joystick-container {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
        z-index: 200;
        /* display: none;  SE MUESTRA/OCULTA CON EL OVERLAY PADRE */
        opacity: 0.7;
      }
      #joystick-pad {
        z-index: 1;
        width: 100%;
        height: 100%;
        background-color: rgba(128, 128, 128, 0.5);
        border-radius: 50%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid rgba(255, 255, 255, 0.7);
      }
      #joystick-handle {
        width: 50px;
        height: 50px;
        background-color: rgba(80, 80, 80, 0.8);
        border-radius: 50%;
        position: absolute;
        border: 2px solid rgba(200, 200, 200, 0.9);
      }
      #action-button-touch {
        position: fixed;
        bottom: 60px;
        right: 60px;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        z-index: 200;
        /* display: none; SE MUESTRA/OCULTA CON EL OVERLAY PADRE */
        font-size: 0.8em;
      }
      #touch-controls-overlay {
          /* Este contenedor no tiene tamaño, solo sirve para agrupar 
            y asegurar que sus hijos 'fixed' se muestren correctamente */
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none; /* Clave: Permite que los clics "atraviesen" el overlay y lleguen al mapa */
          z-index: 199; /* Justo debajo de los controles individuales */
          display: none; /* Por defecto, oculto. JS lo controla. */
      }

      /* Cualquier elemento clickeable DENTRO del overlay debe reactivar los pointer-events */
      #touch-controls-overlay > * {
          pointer-events: auto;
      }
      /* --- Estilos para Modal de Inventario --- */
      .inventory-modal-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 15px;
        padding: 10px;
        margin-bottom: 8px;
        border: 1px solid rgba(212, 175, 55, 0.2);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.15);
      }

      .inventory-modal-item .item-details {
        flex-grow: 1;
      }

      .inventory-modal-item .item-name {
        font-weight: bold;
        color: #f4d03f;
        font-size: 1.1em;
      }

      .inventory-modal-item .item-description {
        font-size: 0.9em;
        opacity: 0.8;
        margin-top: 4px;
      }

      .inventory-modal-item .item-actions {
        display: flex;
        gap: 8px;
        flex-shrink: 0;
      }

      .inventory-modal-item .item-actions button {
        padding: 6px 10px;
        font-size: 0.8em;
      }
      .assignable-item {
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .assignable-item:hover {
        background-color: rgba(212, 175, 55, 0.1);
        border-color: rgba(212, 175, 55, 0.4);
      }
      /* --- Fin Estilos Modal Inventario --- */

      /* === ESTILOS PARA NOTIFICACIÓN DE ZONA === */
      .zone-notification {
        position: absolute;
        top: 20%; /* Posición vertical */
        left: 50%;
        transform: translateX(-50%); /* Centrado horizontal */
        background-color: rgba(10, 10, 10, 0.8);
        color: #f4d03f;
        font-size: 1.5em; /* Tamaño de fuente grande */
        font-weight: bold;
        padding: 15px 30px;
        border-radius: 10px;
        border: 2px solid #d4af37;
        z-index: 200; /* Por encima del mapa pero debajo de otros modales */
        pointer-events: none; /* Para que no intercepte clics */
        opacity: 0; /* Empieza invisible */
        transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out;
        text-shadow: 1px 1px 3px black;
        white-space: nowrap; /* Evita que el texto se rompa */
      }

      .zone-notification.show {
        opacity: 1;
        top: 25%; /* Se mueve un poco hacia abajo al aparecer */
      }

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
      @media (max-width: 768px),
        (max-height: 500px),
        (hover: none) and (pointer: coarse) {
        .game-container {
          padding-top: 0; /* En móvil, no hay espacio arriba, el menú es un overlay */
          /* --- CORRECCIÓN CLAVE --- */
          /* Hacemos que el contenedor del juego pueda estar detrás de la barra */
        
        }

        .map-container {
          max-height: 100dvh; 
        }

        #mobileMenuBtn,
        #toggleMapControlsBtn {
          display: block;
        }

        .top-nav-bar {
        flex-direction: column;
        justify-content: flex-start;
        align-items: stretch;
        height: auto; /* <-- Correcto */
        padding-top: 60px; /* <-- Correcto */
        z-index: 200;
        transform: translateY(-100%);
        transition: transform 0.4s ease-in-out;

        /* 1. Establecemos una altura máxima. No puede ser más alto que la pantalla. */
        max-height: 100dvh; 
        
        /* 2. LA CLAVE: Si el contenido se desborda, creamos un scroll vertical. */
        overflow-y: auto; 

        /* 3. (Opcional pero recomendado) Mejoramos la estética de la barra de scroll en navegadores Webkit (Chrome, Safari) */
        scrollbar-width: thin;
        scrollbar-color: #d4af37 rgba(0, 0, 0, 0.3);
        }
        /* Para navegadores Webkit (Chrome, Safari, Edge) */
        .top-nav-bar::-webkit-scrollbar {
            width: 8px;
        }
        .top-nav-bar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        .top-nav-bar::-webkit-scrollbar-thumb {
            background-color: #b8941f;
            border-radius: 4px;
            border: 2px solid transparent;
            background-clip: content-box;
        }
        .top-nav-bar.open {
          transform: translateY(0);
        }

        .top-nav-bar .nav-button {
          justify-content: flex-start;
          padding: 15px 20px;
          max-width: 100%;
        }

        .stats-panel .desktop-only {
          display: none;
        }

        .stats-panel {
          /* Ajustes existentes para móvil */
          width: 180px; /* Un poco más ancho para la nueva info */
          padding: 8px;
          font-size: 0.8em; /* Un poco más grande para legibilidad */
          top: 10px;
          left: 10px;
          backdrop-filter: blur(2px);
        }

        #toggleMapControlsBtn {
          top: 60px; /* Vuelve a su posición original en móvil */
        }

        .character-sprite,
        .enemy-sprite {
          width: 60px;
          height: 60px;
          font-size: 55px;
        }
      }

      @media (max-width: 480px) {
        .nav-text {
          display: none;
        }
        .nav-icon {
          font-size: 1.8rem;
          margin-bottom: 0;
        }
        .nav-button {
          padding: 10px 5px;
        }

        .stats-panel {
          width: 160px;
          font-size: 0.8em;
        }
        .stats-panel h3 {
          font-size: 1.1em;
        }

        .character-sprite,
        .enemy-sprite {
          width: 50px;
          height: 50px;
          font-size: 50px;
        }
        .battle-actions button {
          padding: 6px 8px;
          font-size: 0.75em;
        }
      }
      @media (max-height: 500px) and (min-width: 600px), (orientation: landscape) {

        /* --- Acciones de Batalla más Compactas (LÓGICA MEJORADA) --- */
        .battle-actions {
            padding: 5px; 
        }

        .action-buttons {
            /* Clave: Forzamos la cuadrícula a tener más columnas para que se expanda horizontalmente */
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 5px; 
            margin-bottom: 5px;
            /* Opcional: Para centrar los botones si no llenan todo el espacio */
            justify-content: center; 
        }

        .battle-actions button {
            /* Hacemos los botones más anchos pero menos altos */
            padding: 8px 12px;     /* Más padding horizontal, menos vertical */
            min-height: 36px;      /* Establecemos una altura mínima/máxima para controlar su altura */
            max-height: 38px;
            font-size: 0.70rem;    /* Un tamaño de fuente legible pero compacto */
            line-height: 1.2;      /* Ayuda a centrar el texto verticalmente en la nueva altura */
            
            /* Aseguramos que el contenido dentro del botón se centre */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        /* --- Ajustes al resto de la UI en modo horizontal --- */
        .stats-panel {
            top: 10px;
            left: 10px;
            padding: 6px;
            font-size: 0.75rem;
        }

        .stats-panel h3 {
            font-size: 1rem;
            margin-bottom: 2px;
        }

        .quick-slot-bar {
            bottom: 5px;
            padding: 6px;
            gap: 6px;
        }
        .quick-slot {
            width: 48px;
            height: 48px;
            font-size: 22px;
        }
        .slot-item-count {
            font-size: 12px;
        }
        .slot-key-hint {
            font-size: 10px;
        }
        
       

        /* 2. Ajustamos los sprites y nombres para que ocupen el espacio liberado */
        .character,
        .enemy {
            padding: 10px 0; /* Reducimos drásticamente el padding vertical */
            justify-content: center; /* Centramos el contenido restante (sprite y nombre) */
        }

        .character-sprite,
        .enemy-sprite {
            margin-bottom: 8px; /* Un pequeño margen entre el sprite y el nombre */
        }

        /* 3. Aseguramos que la información sobre el sprite del enemigo sea visible */
        #enemyInBattleInfoContainer {
            /* Es posible que necesitemos ajustar su posición si se descuadra */
            transform: translate(-50%, 5px); /* Empuja la barra un poco hacia abajo para que no se pegue al borde */
        }
        

        }
      /****************************************
       * NUEVO: 7. ESTILOS DE LA TIENDA
       ****************************************/

      #shopModal .modal-content {
        max-width: 90%;
        width: 1000px; /* Un ancho mayor para la tienda */
        height: 90vh;
        display: flex;
        flex-direction: column;
      }

      .shop-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        flex-shrink: 0;
      }

      .shop-stats {
        font-size: 1.1em;
        color: #f4d03f;
      }

      .shop-container {
        display: flex;
        gap: 20px;
        flex-grow: 1;
        overflow: hidden; /* Evita que el contenedor principal scrollee */
      }

      .shop-filters {
        flex: 0 0 220px; /* No crece, no se encoge, base de 220px */
        padding-right: 15px;
        border-right: 1px solid rgba(212, 175, 55, 0.2);
        overflow-y: auto;
      }

      .shop-products {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .products-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 15px;
        overflow-y: auto; /* El scroll ahora está aquí */
        padding: 5px;
        flex-grow: 1;
      }

      .section-title {
        color: #f4d03f;
        margin-bottom: 10px;
        border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        padding-bottom: 5px;
      }

      .search-box {
        width: 100%;
        padding: 8px;
        background-color: rgba(0, 0, 0, 0.3);
        border: 1px solid #555;
        border-radius: 5px;
        color: #f4e4bc;
        margin-bottom: 15px;
      }

      .filter-group {
        margin-bottom: 20px;
      }
      .filter-title {
        font-weight: bold;
        margin-bottom: 8px;
        font-size: 0.9em;
        opacity: 0.8;
      }

      .category-list {
        list-style: none;
      }
      .category-item {
        padding: 8px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .category-item:hover {
        background-color: rgba(212, 175, 55, 0.1);
      }
      .category-item.active {
        background-color: rgba(212, 175, 55, 0.2);
        color: #f4d03f;
        font-weight: bold;
      }

      .product-card {
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(212, 175, 55, 0.3);
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
      }

      .product-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 10px;
      }

      .product-name {
        font-weight: bold;
        color: #f4d03f;
      }
      .product-type {
        font-size: 0.8em;
        opacity: 0.7;
      }
      .product-price {
        font-weight: bold;
        white-space: nowrap;
      }

      .product-description {
        font-size: 0.9em;
        margin: 10px 0;
        opacity: 0.9;
        flex-grow: 1; /* Hace que la descripción empuje el botón hacia abajo */
      }

      .product-actions {
        margin-top: auto; /* Empuja el botón al final de la tarjeta */
      }
      .buy-btn {
        width: 100%;
      }

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
      @media (max-width: 768px) {
        /* ... (tus otras media queries) ... */

        /* AÑADE ESTAS REGLAS DENTRO DE LA MEDIA QUERY DE 768px */
        #shopModal .modal-content {
          width: 95%; /* Ocupa más ancho en móvil */
          /* Quitamos la altura fija para que se adapte al contenido en móvil */
          height: auto;
          max-height: 85vh; /* Ponemos una altura máxima para que no ocupe toda la pantalla */
        }

        .shop-container {
          flex-direction: column; /* Apila los filtros encima de los productos */
          /* Hacemos que el scroll sea manejado por el .modal-content general en móvil */
          overflow: visible;
        }

        .shop-filters {
          flex: 0 0 auto; /* No debe crecer, su tamaño será determinado por su contenido */
          border-right: none;
          border-bottom: 1px solid rgba(212, 175, 55, 0.2);
          padding-bottom: 15px;
          margin-bottom: 15px;
          overflow-y: visible; /* Correcto, no queremos scroll aquí */
        }

        .shop-products {
          /* Quitamos el overflow: hidden que podría estar ocultando el contenido */
          overflow: visible;
        }

        .products-grid {
          grid-template-columns: 1fr; /* Una sola columna para los productos en móvil */
          overflow-y: visible; /* El scroll lo maneja el padre */
          /* Quitamos el flex-grow para evitar conflictos */
        }
      }
      /****************************************
       * NUEVO: 8. ESTILOS DE COMBATE FLOTANTES
       ****************************************/
      .damage-popup {
        position: absolute;
        z-index: 310; /* Encima de todo en la batalla */
        font-family: "Courier New", monospace;
        font-weight: bold;
        pointer-events: none; /* Para que no intercepte clics */
        text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.7);
        animation: floatUpAndFade 1.5s ease-out forwards;
      }

      /* Estilos específicos */
      .damage-popup.damage {
        color: #ff4d4d;
        font-size: 1.2em;
      }
      .damage-popup.heal {
        color: #66ff66;
        font-size: 1.8em;
      }
      .damage-popup.mana {
        color: #87cefa;
        font-size: 1.5em;
      }
      .damage-popup.ability {
        color: #f4d03f;
        font-size: 1.2em;
      }
      .damage-popup.debuff {
        color: #dda0dd;
        font-size: 1.2em;
      }

      @keyframes floatUpAndFade {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        100% {
          transform: translateY(-80px) scale(1.2);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <!-- ======================================================================= -->
    <!-- 1. CAPAS GLOBALES Y ELEMENTOS FIJOS (Velo, Stats, Botones) -->
    <!-- Estos elementos están en la capa superior y no se mueven con el mapa. -->
    <!-- ======================================================================= -->
    <div id="game-overlay" class="game-overlay"></div>
    <button id="mobileMenuBtn">☰</button>

    <div class="stats-panel">
      <p class="stat-line stat-coords">
        Coords: <span id="playerCoords">X: 0, Y: 0</span>
      </p>
      <p class="stat-line stat-zone">
        Zona: <span id="playerZone">Desconocida</span>
      </p>
      <p class="stat-line stat-level desktop-only">
        Nivel: <span id="playerLevel">1</span>
      </p>
      <p class="stat-line stat-realm desktop-only">
        Reino: <span id="playerRealm">Mortal</span>
      </p>
      <div class="stat-block desktop-only">
        <span>Vida: <span id="hpText">100/100</span></span>
        <div class="stat-bar">
          <div class="stat-fill hp-fill" id="hpBar" style="width: 100%"></div>
        </div>
      </div>
      <div class="stat-block desktop-only">
        <span>Maná: <span id="manaText">50/50</span></span>
        <div class="stat-bar">
          <div
            class="stat-fill mana-fill"
            id="manaBar"
            style="width: 100%"
          ></div>
        </div>
      </div>
      <div class="stat-block">
        <span>Experiencia: <span id="expText">0/100</span></span>
        <div class="stat-bar">
          <div class="stat-fill exp-fill" id="expBar" style="width: 0%"></div>
        </div>
      </div>
      <p class="stat-line stat-stones">
        P. Espirituales: <span id="playerStonesHud">0</span>
      </p>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display: none" />
   

    <!-- ======================================================================= -->
    <!-- 2. CONTENEDOR PRINCIPAL DEL JUEGO (El mundo que se mueve) -->
    <!-- Solo contiene el mapa, el jugador y los elementos que están DENTRO del mundo del juego. -->
    <!-- ======================================================================= -->
    <div class="game-container">
      <div class="map-container">
        <div class="map" id="gameMap"></div>
        
        <div class="grid-overlay"></div>
        
        <div class="tile player" id="player">🧘</div>
        <div id="zone-notification" class="zone-notification"></div>

        <div id="playerOnMapBarsContainer">
          <div class="on-map-stat-bar">
            <div class="on-map-stat-fill" id="playerOnMapHpFill"></div>
          </div>
          <div class="on-map-stat-bar">
            <div class="on-map-stat-fill" id="playerOnMapManaFill"></div>
          </div>
        </div>

        

        <!-- El sidebar es parte del layout del juego, por lo que se queda aquí. -->
        <div class="sidebar">
          <div class="inventory-panel">
            <h3>Inventario</h3>
            <div class="inventory-grid" id="inventory"></div>
          </div>
          <div class="controls-panel">
            <h3>Controles</h3>
            <p><strong>Escritorio:</strong></p>
            <p>WASD/Flechas: Moverse</p>
            <p>ESPACIO: Interactuar</p>
            <p style="margin-top: 5px"><strong>Móvil:</strong></p>
            <p>Joystick: Moverse</p>
            <p>Botón Acción: Interactuar</p>
            <p>
              "Ocultar/Mostrar Controles": Alterna visibilidad de controles
              táctiles.
            </p>
            <button id="cultivateButton" onclick="toggleCultivation()">
              🧘‍♀️ Cultivar
            </button>
            <button onclick="showTechniquePanel()">📖 Técnicas</button>
            <button onclick="saveGame()">💾 Guardar Partida</button>
            <button onclick="triggerFileUpload()">📁 Cargar Partida</button>
            <button onclick="showHelp()">❓ Ayuda</button>
          </div>
          <div class="secta-panel">
            <h3><span id="sectaNombreDisplay">Secta</span></h3>
            <p>Rango: <span id="playerSectRank">Discípulo Externo</span></p>
            <p>Puntos de Contribución: <span id="playerPCS">0</span> PCS</p>
            <h4>Misiones Activas:</h4>
            <div
              id="activeMissionsList"
              style="font-size: 0.9em; max-height: 150px; overflow-y: auto"
            >
              <p>Ninguna misión activa.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- <<--- FIN DEL CONTENEDOR PRINCIPAL DEL JUEGO -->
      
    <!-- === INICIO DE LA NUEVA SECCIÓN DE CONTROLES TÁCTILES === -->
    <!-- Este es el contenedor correcto que el JavaScript mostrará u ocultará -->
    <div id="touch-controls-overlay">
      <div id="joystick-container">
          <div id="joystick-pad">
              <div id="joystick-handle"></div>
          </div>
      </div>
      <button id="action-button-touch">Acción</button>
    </div>
    <button id="toggleMapControlsBtn">Ocultar Controles</button>
    <button id="toggleGridBtn" style="position: fixed; top: 100px; right: 10px; z-index: 200; padding: 8px 12px; font-size: 14px;">Mostrar Rejilla</button>

    <!-- ======================================================================= -->
    <!-- 3. TODAS LAS PANTALLAS Y MODALES SUPERPUESTOS -->
    <!-- Al estar fuera del game-container, no se verán borrosos en móvil. -->
    <!-- ======================================================================= -->

    <!-- Pantalla de Combate -->
    <div class="battle-screen" id="battleScreen">
      <div class="battle-area">
        <div class="character">
          <div id="playerInBattleSpriteBarsContainer">
            <div class="in-battle-sprite-stat-bar">
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteHpFill"
              ></div>
            </div>
            <div class="in-battle-sprite-stat-bar">
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteManaFill"
              ></div>
            </div>
          </div>
          <div class="character-sprite">🧘</div>
          <h3 id="playerBattleName">Cultivador</h3>
          <div>Vida: <span id="playerBattleHp">100/100</span></div>
          <div class="stat-bar"style="display: none;">
            <div
              class="stat-fill hp-fill"
              id="playerBattleHpBar"
              style="display:none"
            ></div>
          </div>
        </div>
        <div class="enemy">
          <div id="enemyInBattleInfoContainer">
            <div class="enemy-battle-name-level" id="enemyBattleNameLevel">
              Enemigo (Nv. X)
            </div>
            <div class="in-battle-sprite-stat-bar enemy-hp-bar">
              <div
                class="in-battle-sprite-stat-fill"
                id="enemyInBattleSpriteHpFill"
              ></div>
            </div>
          </div>
          <div class="enemy-sprite" id="enemySprite"></div>
          <h3 id="enemyName">Demonio</h3>
          <div>Vida: <span id="enemyHp">80/80</span></div>
          <div class="stat-bar"style="display: none;">
            <div
              class="stat-fill hp-fill"
              id="enemyHpBar"
              
            ></div>
          </div>
        </div>
      </div>
      <div class="battle-actions">
        <div class="action-buttons" id="battleActionButtons"></div>
        <div class="log" id="battleLog"></div>
      </div>
    </div>

    <!-- Modal para Cultivo Activo -->
    <div class="modal" id="activeCultivationModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="activeCultivationTitle">Cultivando...</h3>
        <p id="activeCultivationDescription">Concentrando tu energía...</p>
        <div id="activeCultivationProgressUI" style="display: none">
          <p>
            Progreso:
            <span id="activeCultivationTargetName">Técnica X</span> (Nv.
            <span id="activeCultivationTargetLevel">Y</span>)
          </p>
          <div class="stat-bar" style="background: #444; margin: 10px 0">
            <div
              class="stat-fill"
              id="activeCultivationProgressBar"
              style="
                width: 0%;
                background: linear-gradient(90deg, #ffd700, #ffae42);
              "
            ></div>
          </div>
          <p
            id="activeCultivationProgressText"
            style="text-align: center; font-size: 0.9em"
          >
            0s / 0s
          </p>
        </div>
        <div
          id="recoveryCultivationProgressUI"
          style="display: none; margin-top: 15px"
        >
          <p>Absorbiendo Qi del entorno...</p>
          <div style="margin-top: 15px; font-size: 0.9em">
            <div>Vida: <span id="modalHpText">100/100</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill hp-fill"
                id="modalHpBar"
                style="width: 100%"
              ></div>
            </div>
            <div>Maná: <span id="modalManaText">50/50</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill mana-fill"
                id="modalManaBar"
                style="width: 100%"
              ></div>
            </div>
          </div>
        </div>
        <div id="cultivationBoostSection" style="display: none; margin-top: 15px; padding-top: 10px; border-top: 1px solid #555;">
          <p>Piedras Espirituales: <span id="cultivationModalPlayerStones">0</span></p>
          
          <!-- Contenedor para los botones de aceleración -->
          <div style="display: flex; gap: 10px; margin-top: 8px;">
              
              <!-- Botón para usar 1 piedra -->
              <button id="boostCultivationButton1" onclick="boostCultivationProgress(1)" style="flex-grow: 1;">
                  ⚡ Usar 1 PS (+10s)
              </button>
              
              <!-- NUEVO Botón para usar 10 piedras -->
              <button id="boostCultivationButton10" onclick="boostCultivationProgress(10)" style="flex-grow: 1; background: linear-gradient(135deg, #e8c34f, #c9a82e);">
                  ⚡⚡ Usar 10 PS (+100s)
              </button>
      
          </div>
      </div>
        <button onclick="stopCultivation(true)" style="margin-top: 20px">
          🚫 Detener Cultivo
        </button>
      </div>
    </div>

    <!-- Modal para tienda -->
    <div class="modal" id="shopModal">
      <div class="modal-content">
        <div class="shop-header">
          <h2 id="shopName">Pabellón de Tesoros del Dragón Oculto</h2>
          <div class="shop-stats">
            <span id="playerSpiritualStones">Piedras Espirituales: 0</span>
          </div>
        </div>
        <div class="shop-container">
          <div class="shop-filters">
            <h3 class="section-title">Filtros</h3>
            <input
              type="text"
              class="search-box"
              id="shopSearch"
              placeholder="Buscar..."
            />
            <div class="filter-group">
              <div class="filter-title">Categorías</div>
              <ul class="category-list" id="shopCategories">
                <li class="category-item active" data-category="all">Todas</li>
                <li class="category-item" data-category="combat">T. Combate</li>
                <li class="category-item" data-category="cultivation">
                  T. Cultivo
                </li>
                <li class="category-item" data-category="weapon">Armas</li>
                <li class="category-item" data-category="armor">Armaduras</li>
                <li class="category-item" data-category="consumable">
                  Consumibles
                </li>
                <li class="category-item" data-category="material">
                  Materiales
                </li>
                <li class="category-item" data-category="scroll">Rollos</li>
              </ul>
            </div>
            <div class="filter-group">
              <div class="filter-title">Rango de Precio</div>
              <div>
                <input
                  type="range"
                  id="priceRange"
                  min="0"
                  max="10000"
                  value="10000"
                  style="width: 100%"
                />
              </div>
              <div
                style="
                  display: flex;
                  justify-content: space-between;
                  font-size: 0.8em;
                "
              >
                <span>0 PS</span><span id="priceRangeValue">1000 PS</span>
              </div>
            </div>
          </div>
          <div class="shop-products">
            <h3 class="section-title">Técnicas y Objetos</h3>
            <div class="products-grid" id="shopProducts"></div>
            <div class="pagination" id="shopPagination"></div>
          </div>
        </div>
        <div>
          <button onclick="closeShopModal()" style="margin-top: 20px">
            Salir de la Tienda
          </button>
        </div>
      </div>
    </div>

    <!-- Modal para Secta -->
    <div class="modal" id="sectHallModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 id="sectHallModalTitle">Salón de la Secta del Viento Azure</h3>
        <div id="sectHallOptions">
          <p>
            Bienvenido, Discípulo <span id="sectHallPlayerRank">Externo</span>.
          </p>
          <p>Puntos de Contribución: <span id="sectHallPlayerPCS">0</span></p>
          <hr />
          <h4>Tablón de Misiones</h4>
          <div
            id="sectHallAvailableMissions"
            style="
              max-height: 150px;
              overflow-y: auto;
              margin-bottom: 10px;
              border: 1px solid #444;
              padding: 5px;
            "
          >
            <p>Habla con el Guía Lin para nuevas asignaciones.</p>
          </div>
          <h4>Contribuciones a la Secta</h4>
          <div id="sectHallContributions" style="margin-bottom: 10px">
            <p>Visita al Administrador Yao para entregar recursos.</p>
          </div>
          <h4>Desafíos de Rango</h4>
          <div id="sectHallRankChallenges" style="margin-bottom: 10px">
            <p id="sectHallChallengeStatus">
              Consulta con el Maestro de la Arena.
            </p>
          </div>
          <h4>Tienda de la Secta</h4>
          <button onclick="openSectShop()">Visitar Depósito de la Secta</button>
          <hr />
        </div>
        <button
          onclick="closeSectHallModal()"
          style="display: block; margin: 20px auto 0"
        >
          Salir del Salón
        </button>
      </div>
    </div>

    <!-- Modal genérico para confirmaciones (Sí/No) -->
    <div class="modal" id="confirmationModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="confirmationModalTitle">Confirmar Acción</h3>
        <p id="confirmationModalText" style="margin: 15px 0; line-height: 1.5">
          ¿Estás seguro?
        </p>
        <div
          style="display: flex; justify-content: space-around; margin-top: 20px"
        >
          <button id="confirmBtn" style="background-color: #4caf50">
            Confirmar
          </button>
          <button
            id="cancelBtn"
            onclick="closeConfirmationModal()"
            style="background-color: #f44336"
          >
            Cancelar
          </button>
        </div>
      </div>
    </div>

    <!-- Modal para Misiones -->
    <div class="modal" id="missionsModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">Diario de Misiones</h3>
        <div
          id="missionsContainer"
          style="
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
          "
        ></div>
        <button
          onclick="closeMissionsModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Modal para Revisión de Batalla -->
    <div class="modal" id="battleReviewModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">Resumen del Combate</h3>
        <div
          id="battleReviewLog"
          style="
            margin-top: 15px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.5;
          "
        ></div>
        <button
          onclick="closeBattleReviewModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Modal para Selección de Cultivo -->
    <div class="modal" id="cultivationChoiceModal">
      <div class="modal-content" style="max-width: 500px; text-align: left">
        <h3>¿Qué deseas cultivar?</h3>
        <div id="cultivationOptionsContainer">
          <button
            class="cultivation-option-btn"
            onclick="startCultivationMode('recovery')"
          >
            🧘 Meditación Restauradora
          </button>
          <hr />
          <h4>Cultivar Técnica:</h4>
          <div
            id="cultivableTechniquesList"
            style="max-height: 200px; overflow-y: auto"
          ></div>
        </div>
        <button
          onclick="closeCultivationChoiceModal()"
          style="margin-top: 20px"
        >
          Cancelar
        </button>
      </div>
    </div>

    <!-- Modal genérico para interacciones y notificaciones -->
    <div class="modal" id="interactionModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="modalTitle">Título del Modal</h3>
        <p
          id="modalText"
          style="margin-top: 15px; margin-bottom: 20px; line-height: 1.5"
        >
          Texto.
        </p>
        <button onclick="closeModal()" class="close-modal-btn">Cerrar</button>
      </div>
    </div>
    <!-- Modal para Gestión de Técnicas -->
    <div class="modal" id="manageTechniquesModal">
      <div class="modal-content" style="max-width: 800px; text-align: left;">
          <h3 style="text-align: center;">Gestionar Técnicas de Combate</h3>
          <div id="technique-management-container" style="display: flex; gap: 20px; margin-top: 20px;">
              
              <!-- Columna de Técnicas Equipadas -->
              <div id="equipped-techniques-panel" style="flex: 1; border-right: 1px solid #555; padding-right: 20px;">
                  <h4>Equipadas (3 máx.)</h4>
                  <div id="equipped-techniques-list">
                      <!-- Los slots equipados se generarán aquí -->
                  </div>
              </div>

              <!-- Columna de Técnicas Aprendidas (disponibles para equipar) -->
              <div id="available-techniques-panel" style="flex: 2;">
                  <h4>Técnicas Aprendidas</h4>
                  <div id="available-techniques-list" style="max-height: 400px; overflow-y: auto;">
                      <!-- La lista de técnicas disponibles se generará aquí -->
                  </div>
              </div>

          </div>
          <button onclick="closeManageTechniquesModal()" style="display: block; margin: 20px auto 0;">Cerrar</button>
      </div>
  </div>
  <!-- Modal para el Tutorial de Formaciones -->
  <div class="modal" id="formationTutorialModal">
    <div class="modal-content" style="max-width: 550px; text-align: left;">
        <h3 id="formationTutorialTitle" style="text-align: center;">El Arte de las Matrices Rúnicas</h3>
        <p id="formationTutorialText" style="margin-top: 15px; line-height: 1.6;">
            Este antiguo mural detalla el arte perdido de las formaciones de combate. Al inscribir runas en un patrón preciso alrededor de un enemigo, puedes canalizar el Qi del entorno para crear efectos devastadores antes de que comience la batalla.
        </p>
        <hr style="margin: 15px 0;">
        
        <h4>Cómo Inscribir una Formación:</h4>
        <ol style="margin-left: 20px;">
            <li>Aprende y equipa la técnica <strong>"Inscripción Rúnica"</strong>.</li>
            <li>Asegúrate de tener <strong>"Tinta Rúnica"</strong> en tu inventario.</li>
            <li>Párate en una casilla <strong>adyacente</strong> a un enemigo.</li>
            <li>Usa la habilidad "Inscripción Rúnica" para trazar una runa en tu posición actual.</li>
            <li>Repite el proceso en diferentes casillas para formar un patrón.</li>
        </ol>

        <h4 style="margin-top: 20px;">Ejemplo: El Hexagrama Devastador</h4>
        <p style="font-size: 0.9em; opacity: 0.8;">Este patrón debilita las defensas del objetivo.</p>
        
        <!-- Contenedor de la cuadrícula del patrón -->
        <div id="formation-pattern-grid" style="margin-top: 10px;">
            <!-- La cuadrícula se generará con JavaScript -->
        </div>

        <button onclick="closeFormationTutorial()" style="display: block; margin: 20px auto 0;">Entendido</button>
    </div>
  </div>
    <!-- Modal para Técnicas -->
    <div class="modal" id="techniqueModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">Técnicas Aprendidas</h3>
        <div
          id="learnedTechniquesContainer"
          style="
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
          "
        ></div>
        <button onclick="openManageTechniquesModal()" style="display: block; margin: 20px auto 10px; background-color: #3a7c6a;">
          ⚔️ Gestionar Técnicas de Combate
      </button>
        <button
          onclick="closeTechniqueModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Modal para Recompensa de Ascenso de Rango -->
    <div class="modal" id="rankUpRewardModal">
      <div class="modal-content" style="max-width: 550px; text-align: left">
        <h3 id="rankUpRewardTitle">Recompensa por Ascenso</h3>
        <p>
          Como reconocimiento a tu progreso, la secta te otorga un manual de
          técnica. Elige sabiamente, pues este conocimiento definirá tu camino.
        </p>
        <div id="rankUpRewardOptionsContainer" style="margin-top: 15px"></div>
        <button onclick="closeRankUpRewardModal()" style="margin-top: 20px">
          Decidiré más tarde
        </button>
      </div>
    </div>

    <!-- Modal para Teletransporte -->
    <div class="modal" id="teleportModal">
      <div class="modal-content" style="max-width: 500px; text-align: left">
        <h3 id="teleportModalTitle">Red de Matrices Espirituales</h3>
        <p>Selecciona un destino sintonizado:</p>
        <div id="teleportOptionsContainer" style="margin-top: 15px"></div>
        <button onclick="closeTeleportModal()" style="margin-top: 20px">
          Cancelar
        </button>
      </div>
    </div>

    <!-- ======================================================================= -->
    <!-- 4. BARRAS DE NAVEGACIÓN SUPERPUESTAS -->
    <!-- También van fuera para garantizar su posición fija y renderizado nítido. -->
    <!-- ======================================================================= -->

    <nav class="top-nav-bar" id="topNavBar">
      <button id="navBtnCharacter" class="nav-button">
        <div class="nav-icon">👤</div>
        <span class="nav-text">Personaje</span>
      </button>
      <button id="navBtnMissions" class="nav-button">
        <div class="nav-icon">📖</div>
        <span class="nav-text">Misiones</span>
      </button>
      <button id="navBtnInventory" class="nav-button">
        <div class="nav-icon">🎒</div>
        <span class="nav-text">Inventario</span>
      </button>
      <button id="navBtnCultivate" class="nav-button">
        <div class="nav-icon">🧘</div>
        <span class="nav-text">Cultivar</span>
      </button>
      <button id="navBtnTechniques" class="nav-button">
        <div class="nav-icon">📜</div>
        <span class="nav-text">Técnicas</span>
      </button>
      <button id="navBtnMenu" class="nav-button">
        <div class="nav-icon">⚙️</div>
        <span class="nav-text">Menú</span>
      </button>
    </nav>
    <!-- ================================================================= -->
    <script>
      let lastSuccessfulMoveTime = 0;
      const PLAYER_MOVE_COOLDOWN = 250; // <-- ¡ESTE ES EL NÚMERO QUE AJUSTARÁS! (en milisegundos)
      let playerMovementKeysDown = {
        // Para rastrear qué teclas de movimiento están presionadas
        up: false,
        down: false,
        left: false,
        right: false,
      };
      let isGridVisible = false;

      const topNavBar = document.getElementById("topNavBar");
      const navBtnInventory = document.getElementById("navBtnInventory");
      console.log("Botón de Inventario (navBtnInventory):", navBtnInventory);
      const navBtnCharacter = document.getElementById("navBtnCharacter");
      const navBtnCultivate = document.getElementById("navBtnCultivate");
      const navBtnTechniques = document.getElementById("navBtnTechniques");
      const navBtnMenu = document.getElementById("navBtnMenu");
      let movePlayerCallCount = 0;
      // --- ESTADO DEL JUEGO ---
      let gameState = {
        /* ... (tu gameState existente sin cambios) ... */
      };
      // Estado del juego y datos principales
      gameState = {
        player: {
          x: 11,
          y: 15,
          level: 1,
          baseMaxHp: 100,
          baseMaxMana: 50,
          baseAttack: 15,
          baseDefense: 5,
          hp: 100,
          maxHp: 100,
          mana: 50,
          maxMana: 50,
          attack: 15,
          defense: 5,
          exp: 0,
          expToNext: 100,
          realm: "Mortal",
          quickSlots: [null, null, null, null, null], // 5 slots, inicialmente vacíos
          equippedTechniques: [null, null, null],
          isCultivating: false,
          cultivationMode: {
            type: null,
            targetId: null,
            startTime: 0,
          },
          cultivationStartTime: 0,
          qiPerSecondBase: 1,
          expPerSecondBase: 0.5,
          hpPerSecondBase: 1,
          learnedTechniques: {},
          activeRefiningTechniqueId: null,
          canUseQiConversion: false,
          isQiConversionActive: false,
          worldState: {
            defeatedBosses: {},
            currentBossToSpawn: "boss_dem",
            defeatedFixedEntities: {},
            storyFlags: {
              metAncianaSu: false,          // Hito 1: Conocer a la archivista.
              knowsAboutCalamity: false,    // Hito 2: Aprender sobre el desastre pasado.
              knowsAboutSoberano: false,    // Hito 3: El Maestro revela el secreto del Soberano.
              knowsFullTruth: false,        // Hito 4: El Santuario revela la verdad completa.
          },
          },
          secta: {
            nombre: "Secta del Viento Azure",
            rango: "Discípulo Externo",
            puntosContribucion: 0,
            misionesActivas: [],
            misionesCompletadas: {},
            rivalesDerrotadosClave: {},
          },
          // ---- PROPIEDADES DE ANIMACIÓN DEL SPRITE - ASEGÚRATE QUE ESTÉN AQUÍ Y CORRECTAS ----
          spriteSheetUrl: "img/personaje_cultivador_spritesheet.png",
          frameWidth: 64, // Ancho de un solo frame del sprite
          frameHeight: 64, // Alto de un solo frame del sprite
          directionRowMap: {
            // Mapeo de dirección a la fila Y en la hoja de sprites (0-indexed)
            down: 0, // Fila 0 para mirar/caminar hacia abajo
            left: 1, // Fila 1 para mirar/caminar hacia la izquierda
            right: 2, // Fila 2 para mirar/caminar hacia la derecha
            up: 3, // Fila 3 para mirar/caminar hacia arriba
          },
          animationFrames: 4, // Número de frames por dirección en la hoja
          currentFrame: 0, // Frame actual de la animación (0 a animationFrames - 1)
          currentDirection: "down", // Dirección inicial: 'up', 'down', 'left', 'right'
          currentZoneName: null,
          isMoving: false,
          unlockedTeleporters: {
            tp_sect_hub: true, // El teletransportador de la secta empieza activado
          },
          animationTimer: null, // Para el intervalo de la animación de caminar
          idleTimeout: null, // Para volver al estado idle después de moverse
          animationSpeed: 150, // Milisegundos entre frames de animación
          // ---- FIN PROPIEDADES DE ANIMACIÓN ----
          // NUEVO: Para animación de sprites
          sprites: {
            idle: "img/personaje_cultivador_idle.png", // O 'img/personaje_cultivador_down.png' si es tu frontal
            up: "img/personaje_cultivador_up.png",
            down: "img/personaje_cultivador_down.png",
            left: "img/personaje_cultivador_left.png",
            right: "img/personaje_cultivador_right.png",
          },
          currentSpriteKey: "idle", // 'idle', 'up', 'down', 'left', 'right'
          movementAnimationTimeout: null,
          //BUFF
          defenseBoostTurns: 0,
          defenseBoostAmount: 0,
          abilityCooldowns: {},
          // ===  DEBUFFS ===
          defenseReductionTurns: 0,
          defenseReductionAmount: 0,
          attackReductionTurns: 0,
          attackReductionAmount: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          burningTurns: 0,
          burnDamage: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          stunnedTurns: 0,
          manaDrainTurns: 0,
          manaDrainAmount: 0,
          // ===================================
          dodgeNextAttack: false,
          healingRainTurns: 0,

          defenseBoostTurns: 0,
          defenseBoostAmount: 0,
          dodgeNextAttack: false,
          healingRainTurns: 0,
          healingRainAmount: 0,
          manaRegenPerTurn: 0,
          // Para Ritual de Sangre
          bloodRitualTurns: 0,
          bloodRitualAttackBoost: 0,
          magicShieldValue: 0, // Valor actual del escudo de absorción
          magicShieldTurns: 0,

          activeChanneledAbility: {
            // Para habilidades con coste por turno
            id: null,
            hp: 0, // "Vida" de la habilidad (para los grilletes)
          },
          tempDefenseBoostTurns: 0,
          tempDefenseBoostAmount: 0,
          // Nuevos estados para técnicas de alto nivel
          isImmuneToStatus: false, // Inmunidad a quemaduras, veneno, stun, etc.
          passiveHpRegen: 0, // Cantidad de HP a regenerar por segundo pasivamente
          reviveChance: 0, // Probabilidad de resucitar al morir
          deathSaveChance: 0, // Probabilidad de sobrevivir con 1 HP
          damageToHealingTurns: 0, // Turnos para convertir daño en curación
          intangibleTurns: 0, // Turnos de ser intangible (inmune a daño directo)
          canRevive: false, // Flag activado por Llama del Fénix
         
          immuneTurns: 0,
          silencedTurns: 0, // Turnos en que no puede usar habilidades especiales
          sealedTurns: 0,   // Turnos en que no puede realizar ninguna acción
        },
        utilityRunes: {},
        cultivationInterval: null,
        inventory: {
          "Piedras Espirituales": 0,
          "Hierbas Medicinales": 0,
          "Cristales de Qi": 0,
        },
        map: {
          width: 600, // Más pequeño para pruebas iniciales
          height: 600,
          defaultTerrain: "GRASSLAND",
          terrainZones: [
            //ZONAS
            //LÍMITES DE MAPA
            // ... otras zonas (montañas, ruinas, agua sin spawns de monstruos terrestres)

            {
              x1: 91,
              y1: 28,
              x2: 110,
              y2: 29,
              type: "SWAMP",
              name: "Camino a Tierra salvaje",
              decorations: [
          
              ],
           
            },
            {
              x1: 2,
              y1: 9,
              x2: 600,
              y2: 9,
              type: "MOUNTAIN_FRENTE",
              name: "límite norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 0,
              y1: 0,
              x2: 600,
              y2: 8,
              type: "MOUNTAIN_SUP",
              name: "Montañas Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: -20,
              y1: 0,
              x2: 0,
              y2: 600,
              type: "MOUNTAIN_SUP",
              name: "Montañas del Oeste",
            }, // Sin spawnSettings = no spawns
            {
              x1: 92,
              y1: 0,
              x2: 110,
              y2: 27,
              type: "MOUNTAIN_SUP",
              name: "Limite mapa este con desfiladero",
            }, 
            {//Limite con Valle del Dragón
              x1: 145,
              y1: 0,
              x2: 145,
              y2: 600,
              type: "MOUNTAIN_SUP",
              name: "Limite mapa este con desfiladero",
            }, // Sin spawnSettings = no spawns
            {
              x1: 92,
              y1: 30,
              x2: 110,
              y2: 600,
              type: "MOUNTAIN_SUP",
              name: "Limite mapa este con desfiladero",
            }, // Sin spawnSettings = no spawns
            {
              x1: 91,
              y1: 9,
              x2: 91,
              y2: 9,
              type: "MOUNTAIN_SUP_DER",
              name: "Montañas del Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 9,
              x2: 1,
              y2: 9,
              type: "MOUNTAIN_SUP_IZQ",
              name: "Montañas del Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 40,
              x2: 1,
              y2: 40,
              type: "MOUNTAIN_INF_IZQ",
              name: "Montañas del Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 69,
              x2: 1,
              y2: 69,
              type: "MOUNTAIN_INF_IZQ",
              name: "borde desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 2,
              y1: 40,
              x2: 23,
              y2: 40,
              type: "MOUNTAIN_ABAJO_SUP",
              name: "frontera pradera-desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 26,
              y1: 40,
              x2: 89,
              y2: 40,
              type: "MOUNTAIN_ABAJO_SUP",
              name: "frontera pradera-desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 70,
              x2: 89,
              y2: 70,
              type: "MOUNTAIN_ABAJO_SUP_DES",
              name: "límite inferior desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 71,
              x2: 89,
              y2: 90,
              type: "MOUNTAIN_SUP",
              name: "límite inferior desierto",
            }, // Sin spawnSettings = no spawns

           

            {
              x1: 91,
              y1: 10,
              x2: 91,
              y2: 27,
              type: "MOUNTAIN_DER",
              name: "Límite este con desfiladero",
            }, // Sin spawnSettings = no spawns
            {
              x1: 144,
              y1: 10,
              x2: 144,
              y2: 600,
              type: "MOUNTAIN_DER",
              name: "Límite este con Valle del Dragón",
            }, // Sin spawnSettings = no spawns
            {
              x1: 91,
              y1: 30,
              x2: 91,
              y2: 600,
              type: "MOUNTAIN_DER",
              name: "Límite este",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 10,
              x2: 1,
              y2: 39,
              type: "MOUNTAIN_IZQ",
              name: "límite oeste pradera",
            }, // Sin spawnSettings = no spawns
            {
              x1: 146,
              y1: 10,
              x2: 146,
              y2: 600,
              type: "MOUNTAIN_IZQ",
              name: "límite este con Valle del Dragón",
            }, // Sin spawnSettings = no spawns
            // ...FIN DE LOS LIMITES

            // ARENA DE LA SECTA
            {
              x1: 4,
              y1: 12,
              x2: 8,
              y2: 16, // Ejemplo de coordenadas (ajusta según tu mapa)
              type: "ARENA", // Puedes usar 'DESERT' o crear un G_TERRAIN_TYPES.ARENA
              name: "Arena de la Secta",
              // No necesita spawnSettings por ahora, a menos que quieras pequeños mobs decorativos allí.
            },

            ///ZONA SEGURA DE LA SECTA

            {
              x1: 2,
              y1: 10,
              x2: 29,
              y2: 24,

              type: "GRASSLAND",
              name: "Terreno de la Secta (Seguro)",
            },
            {
              x1: 2,
              y1: 25,
              x2: 29,
              y2: 39,

              type: "GRASSLAND",
              name: "Praderas de la Secta",
              spawnSettings: {
                targetEntities: [
                  // Lista de objetivos de spawn para esta zona
                  {
                    entityTypeId: "monster_secta_debil",
                    count: 10,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster", count: 10, currentCount: 0 },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "cristal_qi", count: 3, currentCount: 0 },
                  {
                    entityTypeId: "cultivator_rival_low",
                    count: 10,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0, // Cuando llegue a 0, puede reaparecer
                respawnCooldown: 300, // Segundos para reaparecer después de vaciarse o parcialmente
                lastSpawnCheck: 0, // Timestamp del último intento de spawn
              },
            },
            // Bosque Esmeralda Profundo
            {
              x1: 54,
              y1: 10,
              x2: 65,
              y2: 39,
              type: "GRASSLAND", //
              name: "Bosque Esmeralda Profundo",
              decorations: [
                { entityTypeId: "deco_arbol_grande", density: 0.1 }, // 10% de las celdas tendrán un árbol grande
                { entityTypeId: "deco_arbol_normal", density: 0.3 }, // 30% tendrán un árbol normal
                { entityTypeId: "deco_roca_musgosa", density: 0.05 }, // 5% tendrán una roca
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "osa_mayor_esmeralda",
                    count: 2,
                    currentCount: 0,
                  }, // Un enemigo más raro y fuerte
                  { entityTypeId: "treant_anciano", count: 1, currentCount: 0 }, // Un mini-jefe de zon
                ],
                respawnTimer: 0,
                respawnCooldown: 450,
                lastSpawnCheck: 0,
              },
            },
            // Bosque Esmeralda
            {
              x1: 30,
              y1: 10,
              x2: 59,
              y2: 39,
              type: "GRASSLAND", // <-- El terreno base ahora es hierba
              name: "Bosque Esmeralda",
              decorations: [
                { entityTypeId: "deco_arbol_grande", density: 0.1 }, // 10% de las celdas tendrán un árbol grande
                { entityTypeId: "deco_arbol_normal", density: 0.3 }, // 30% tendrán un árbol normal
                { entityTypeId: "deco_roca_musgosa", density: 0.05 }, // 5% tendrán una roca
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_bosque_lobo",
                    count: 8,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_bosque_arana",
                    count: 5,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster_alpha", count: 5, currentCount: 0 },
                ],
                respawnTimer: 0,
                respawnCooldown: 450,
                lastSpawnCheck: 0,
              },
            },
            // Desierto Abrasador profundo
            {
              x1: 69,
              y1: 50,
              x2: 90,
              y2: 69,
              type: "DESERT",
              name: "Desierto Abrasador profundo",
              decorations: [
                { entityTypeId: "deco_desierto", density: 0.05 }, // 5% de las celdas tendrán un árbol grande
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "djinn_arenas",
                    count: 20,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "gusano_dunas_colosal",
                    count: 20,
                    currentCount: 0,
                    isElite: true,
                  }, // Golem como elite
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },
            // Desierto Abrasador
            {
              x1: 1,
              y1: 41,
              x2: 90,
              y2: 69,
              type: "DESERT",
              name: "Desierto Abrasador",
              decorations: [
                { entityTypeId: "deco_desierto", density: 0.05 }, // 5% de las celdas tendrán un árbol grande
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_desierto_escorpion",
                    count: 70,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_desierto_golem_arena",
                    count: 20,
                    currentCount: 0,
                    isElite: true,
                  }, // Golem como elite
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },
            // RUINAS
            {
              x1: 500,
              y1: 500,
              x2: 550,
              y2: 550,
              type: "RUINS",
              name: "Corazón de las Ruinas Olvidadas",
              decorations: [
                { entityTypeId: "deco_ruina_pilar", density: 0.02 },
              ],
              isIsolated: true, // Marca esta zona como un "mapa" separado
              ambientColor: "#1a1a1a", // Color del "vacío" alrededor de la zona
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "esqueleto_podrido",
                    count: 25,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "boss_ancient_golem",
                    count: 25,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // Ciénaga Sombría
            {
              x1: 66,
              y1: 10,
              x2: 90,
              y2: 39,
              type: "SWAMP",
              name: "Ciénaga Sombría",
              decorations: [
                // <-- NUEVA PROPIEDAD
                { entityTypeId: "deco_arbol_pantano", density: 0.1 }, // 10% de las celdas tendrán un árbol grande
                { entityTypeId: "deco_agua_estancada", density: 0.05 },
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_cienaga_serpiente",
                    count: 10,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "espectro_pantano",
                    count: 4,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "cultivador_renegado",
                    count: 5,
                    currentCount: 0,
                  },
                  
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // ===============================================
            // === ZONAS DE ALTO NIVEL (NUEVAS) ===
            // ===============================================

            // Zona para Misiones de Diácono
            {
              x1: 111,
              y1: 10,
              x2: 143,
              y2: 50,
              type: "GRASSLAND", // Usaremos un terreno rocoso y hostil
              name: "Desfiladero de los Lamentos",
              isIsolated: false, // Es como un mapa separado
              ambientColor: "#3c2f2f", // Un tono rojizo oscuro
              decorations: [
               
             
                { entityTypeId: "deco_montaña", density: 0.3 }, // 30% tendrán un árbol normal
                { entityTypeId: "deco_montaña_large", density: 0.05 },
    
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "cultivador_secta_rival",
                    count: 15,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "murcielago_cristal_sangriento",
                    count: 10,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "bandido_desfiladero",
                    count: 20,
                    currentCount: 0,
                  },
                  
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },

            // Zona para Misiones de Anciano
            {
              x1: 147,
              y1: 10,
              x2: 225,
              y2: 70,
              type: "SWAMP", // Un terreno antiguo y corrupto
              name: "Valle del Dragón Caído",
              isIsolated: true,
              ambientColor: "#2a3b2a", // Un verde enfermizo
              decorations: [
                { entityTypeId: "deco_arbol_pantano", density: 0.2 },
                { entityTypeId: "deco_huesos_gigantes", density: 0.05 }, // Necesitaremos definir esto
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "draco_hueso_antiguo",
                    count: 50,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "espectro_tifonico",
                    count: 80,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "draco_hueso_antiguo_boss",
                    count: 1,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 900,
                lastSpawnCheck: 0,
              },
            },

            // Zona para Misiones de Gran Anciano
            {
              x1: 400,
              y1: 10,
              x2: 450,
              y2: 60,
              type: "RUINS", // Terreno de otro mundo
              name: "La Fisura Demoníaca",
              isIsolated: true,
              ambientColor: "#4d194d", // Un púrpura corrupto
              decorations: [
                { entityTypeId: "deco_cristal_corrupto", density: 0.15 }, // Necesitaremos definir esto
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "demonio_de_la_fisura",
                    count: 20,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "guardian_celestial_caido",
                    count: 5,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 1200,
                lastSpawnCheck: 0,
              },
            },

            ///=========  FIN ZONAS ==========
          ],
          terrainGrid: null,
          entities: [],
        },
        battle: {
          active: false,
          enemy: {
            frozenTurns: 0,
            stunnedTurns: 0,
            burningTurns: 0,
            burnDamage: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            defenseReductionTurns: 0,
            defenseReductionAmount: 0,
            attackReductionTurns: 0,
            attackReductionAmount: 0,

            // --- AÑADE ESTAS LÍNEAS AQUÍ ---
            rootedTurns: 0, // Turnos que permanecerá atrapado
            rootDamage: 0, // Daño que sufrirá cada turno mientras esté atrapado
            // --- FIN DE LAS LÍNEAS A AÑADIR ---

            // Nuevos estados para efectos de alto nivel
            silencedTurns: 0,
            sealedTurns: 0,
            reflectDamageTurns: 0, // Para el aura de espinas
            reflectDamageMultiplier: 0,
            stunChance:0,
          },

          playerTurn: true,
        },
        gameTime: 0, // Un simple contador de segundos del juego para los temporizadores
        lastGameTimeUpdate: Date.now(),
        activeCombatAbilities: [],
      }; //FIN GAMESTATE

      let battleLogHistory = [];

      // --- CONSTANTES Y DATOS DEL JUEGO --- (sin cambios, deben estar aquí)
      let G_TILE_SIZE = 100; // Valor por defecto para escritorio
      const G_PLAYER_DISCOVERY_RANGE = 3;
      // --- VARIABLES GLOBALES ADICIONALES PARA CONTROL UI MÓVIL ---
      let mapControlsManuallyHidden = false;
      let currentTileSize = G_TILE_SIZE; // Usaremos este para los cálculos de renderizado
      let recoveryProgress = 0;
      let recoveryDirection = 1; // 1 para aumentar, -1 para disminuir
      const RECOVERY_CYCLE_DURATION = 2;

      const G_COMBAT_ENTITY_TYPES = [
        "monster",
        "esqueleto_podrido",
        "bandido_desfiladero",
        "monster_desierto_escorpion",
        "monster_secta_debil",
        "monster_alpha",
        "cultivator_rival_low",
        "cultivator_adept_hostile",
        "boss_dem",
        "boss_ancient_golem",
        "monster_cienaga_serpiente",
        "monster_bosque_lobo",
        "monster_bosque_arana",
        "monster_desierto_golem_arena",
        "jabali_colmilludo_alfa",
        "jabali_alfa_1",
        "jabali_alfa_2",
        "jabali_alfa_3",
        "jabali_alfa_4",
        "jabali_alfa_5",
        "jabali_alfa_6",
        "jabali_alfa_7",
        "jabali_alfa_8",
        "jabali_alfa_9",
        "jabali_alfa_10",
        "jabali_alfa_11",
        "jabali_alfa_12",
        "osa_mayor_esmeralda",
        "treant_anciano",
        "basilisco_cienaga",
        "espectro_pantano",
        "djinn_arenas",
        "gusano_dunas_colosal",
        "guardian_terracota",
        "murcielago_cristal_sangriento",
        "mercenario_acorazado",
        "bandido_desfiladero",
        "cultivador_secta_rival",
        "diacono_renegado_jin",
        "cultivador_renegado",
        "draco_hueso_antiguo",
        "espectro_tifonico",
        "demonio_de_la_fisura",
        "guardian_celestial_caido",
        "draco_hueso_antiguo_boss",
        "emperador_lich_del_valle",
      ];
      const G_MAX_MAP_ENTITIES = 30;
      const G_RESPAWN_THRESHOLD = 15;
      const G_SAFE_RESPAWN_X = 10;
      const G_SAFE_RESPAWN_Y = 10;
      const G_SAFE_RESPAWN_SEARCH_RADIUS = 3;
      // TELETRANSPORTE
      const TELEPORTER_DATA = {
        tp_sect_hub: {
          name: "Matriz Central de la Secta",
          x: 15, // <-- Coordenadas al lado de la secta
          y: 11,
          isHub: true, // Marca este como el punto de partida principal
        },
        tp_forest_shrine: {
          name: "Santuario del Bosque Esmeralda",
          x: 45, // <-- Coordenadas en medio del bosque
          y: 25,
          isHub: false,
        },
        tp_desert_oasis: {
          name: "Oasis del Desierto Abrasador",
          x: 40, // <-- Coordenadas en una zona segura del desierto
          y: 60,
          isHub: false,
        },
        tp_swamp_ruin: {
          name: "Ruina Hundida de la Ciénaga",
          x: 75, // <-- Coordenadas en la ciénaga
          y: 30,
          isHub: false,
        },
        tp_desfiladero: {
          name: "Desfiladero",
          x: 135, // 
          y: 30,
          isHub: false,
        },
        tp_dragon_valley: {
        name: "Corazón del Valle del Dragón",
        x: 150, // Coordenada segura DENTRO del valle
        y: 15,  // Puedes ajustar esto a donde quieras que aparezca el jugador
        isHub: false,
    },
        // Puedes añadir más teletransportadores aquí en el futuro
      };
      const G_TERRAIN_TYPES = {
        VOID: {
          textureUrl: "img/mont_sup.png", // ¡Asegúrate de que esta imagen exista!
          name: "Vacío",
        },
        ARENA: {
          symbol: "🏟️",
          textureUrl: "img/b_arena.png",
          color: "#D2B48C",
          name: "Arena",
        },

        GRASSLAND: {
          symbol: "🟩",
          textureUrl: "img/grassland.png",
          color: "#34A853",
          name: "Pradera",
        }, // Verde para pastizales
        FOREST: {
          symbol: "🌲",
          textureUrl: "img/grassland.png",
          color: "#1E824C",
          name: "Bosque",
        }, // Verde oscuro para bosques
        MOUNTAIN_FRENTE: {
          symbol: "⛰️",
          textureUrl: "img/mont_frente.png",
          color: "#A9A9A9",
          name: "Montaña",
        }, // Gris para montañas
        MOUNTAIN_SUP: {
          symbol: "⛰️",
          textureUrl: "img/mont_sup.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_SUP_DER: {
          symbol: "⛰️",
          textureUrl: "img/mont_sup_der.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_SUP_IZQ: {
          symbol: "⛰️",
          textureUrl: "img/mont_sup_izq.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_DER: {
          symbol: "⛰️",
          textureUrl: "img/mont_der.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_IZQ: {
          symbol: "⛰️",
          textureUrl: "img/mont_izq.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_INF_IZQ: {
          symbol: "⛰️",
          textureUrl: "img/mont_int_inf_izq.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_ABAJO_SUP: {
          symbol: "⛰️",
          textureUrl: "img/mont_abajo_sup.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_ABAJO_SUP_DES: {
          symbol: "⛰️",
          textureUrl: "img/mont_abajo_sup_des.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        WATER: {
          symbol: "🟦",
          color: "#4A86E8",
          name: "Agua",
        }, // Azul para agua (intransitable)
        RUINS: {
          symbol: "🏛️",
          textureUrl: "img/suelo_ruinas.png",
          color: "#706050",
          name: "Ruinas",
        }, // Marrón/Gris para ruinas
        TERRENO_MONT: {
          symbol: "🏛️",
          textureUrl: "img/terreno_mont.png",
          color: "#706050",
          name: "Ruinas",
        },
        DESERT: {
          symbol: "🟨",
          textureUrl: "img/arena.png",
          color: "#F9E79F",
          name: "Desierto",
        }, // Amarillo claro para desierto
        SWAMP: {
          symbol: "🟪",
          textureUrl: "img/pantano.png",
          color: "#5D3A9A",
          name: "Pantano",
        }, // Púrpura/Verde oscuro para pantano

        // Añade más según necesites
      };

      const PLAYER_SPRITE_FRAME_WIDTH = 64; // <--- ¡AJUSTA ESTO AL ANCHO DE UN FRAME DE TU SPRITE!
      const PLAYER_SPRITE_FRAME_HEIGHT = 64; // <--- ¡AJUSTA ESTO AL ALTO DE UN FRAME DE TU SPRITE!
      const PLAYER_ANIMATION_SPEED = 150; // Milisegundos entre frames de caminata (ajusta a gusto)
      const PLAYER_WALK_CYCLE = [0, 1, 0, 2]; // Los frames de columna a ciclar para caminar.
      // Si tu animación es 0-1-2-1, sería [0,1,2,1]
      // Si es 0-1-0-2 sería [0,1,0,2] (para un efecto de pie y luego paso)
      // Para tu sprite de 4 frames por dirección: [0, 1, 2, 3] y el frame 0 es el de "quieto"
      // o puedes usar [1,2,3,0] si el 0 es un frame de paso
      // Una animación común es "quieto" -> paso1 -> "quieto" -> paso2
      // O para ciclo continuo: paso1 -> paso2 -> paso3 -> paso4 -> paso1 ...
      // Para el sprite que mostraste, parece ser:
      // Frame 0: Quieto
      // Frame 1: Paso A
      // Frame 2: Quieto (o un frame intermedio)
      // Frame 3: Paso B
      // Entonces un ciclo podría ser [0, 1, 0, 3] o [1,0,3,0] para animación mientras se mueve
      // O si todos son frames de paso: [0,1,2,3]
      // VAMOS A USAR UN CICLO [1,0,3,0] (asumiendo frame 0 es el base/quieto y 1,3 son pasos)
      // Si el frame 0 es un paso y el personaje se "desliza" al estar quieto, cambia esto.
      // Definir las posiciones Y del sprite sheet para cada dirección
      const PLAYER_SPRITE_DIRECTIONS_Y = {
        down: 0 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 1 (índice 0) para caminar hacia abajo
        left: 1 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 2 (índice 1) para caminar hacia la izquierda
        right: 2 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 3 (índice 2) para caminar hacia la derecha
        up: 3 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 4 (índice 3) para caminar hacia arriba
      };
      // Podríamos añadir una propiedad 'walkable' a cada tipo de terreno
      G_TERRAIN_TYPES.MOUNTAIN_FRENTE.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_SUP.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_SUP_DER.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_DER.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_IZQ.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP_DES.walkable = false;
      G_TERRAIN_TYPES.WATER.walkable = false;
      // Por defecto, asumimos que son transitables si no se especifica 'walkable: false'
      const G_BLOCKING_ENTITY_TYPES = [
        "shop",
        "secta_entrada_principal",
        "secta_entrada_principal_2",
        "secta_entrada_principal_3",
        "secta_entrada_principal_4",
        "npc_secta_guia",
        "npc_secta_admin",
        "npc_anciana_su",
        "npc_maestro_jian",
        "santuario_del_eco",
      ];
      //SECTA
      const SECTA_DATA = {
        nombre: "Secta del Viento Azure",
        rangos: [
          {
            nombre: "Discípulo Externo",
            pcsRequeridos: 0,
            beneficios: "Acceso básico a la secta.",
          },
          {
            nombre: "Discípulo Interno", // GRADO 1
            pcsRequeridos: 50,
            desafioRivalId: "rival_interno_1",
            beneficios:
              "Acceso al Patio Interno, misiones de mayor nivel, +5% ganancia de Qi al cultivar en la secta.",
            techniqueChoice: [
              "sword_t1",
              "body_t1",
              "formation_t1",
              "fire_t1",
              "lightning_t1",
            ],
          },
          {
            nombre: "Discípulo Principal", // GRADO 2
            pcsRequeridos: 200,
            desafioRivalId: "rival_principal_1",
            beneficios:
              "Acceso a la Biblioteca de Técnicas (nuevas técnicas), +10% ganancia de EXP en misiones de secta.",
            techniqueChoice: [
              "sword_t2",
              "body_t2",
              "formation_t2",
              "movement_t2",
              "fire_t2",
            ],
          },
          {
            nombre: "Diácono", // GRADO 3
            pcsRequeridos: 500,
            desafioRivalId: "guardian_diacono_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir pequeños grupos de discípulos (mecánica futura).",
            techniqueChoice: [
              "sword_t3",
              "body_t3",
              "formation_t3",
              "lightning_t3",
              "movement_t3",
            ],
          },
          {
            nombre: "Anciano", // GRADO 4
            pcsRequeridos: 1500,
            desafioRivalId: "guardian_anciano_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir medianos grupos de discípulos (mecánica futura).",
            techniqueChoice: [
              "sword_t4",
              "body_t4",
              "fire_t4",
              "lightning_t4",
              "formation_t4",
              "movement_t4",
            ],
          },
          {
            nombre: "Gran Anciano", // GRADO 5
            pcsRequeridos: 2500,
            desafioRivalId: "guardian_gran_anciano_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir grandes grupos de discípulos (mecánica futura).",
            techniqueChoice: [
              "sword_t5",
              "body_t5",
              "fire_t5",
              "lightning_t5",
              "formation_t5",
              "movement_t5",
            ],
          },
          {
            nombre: "Maestro de Secta", // GRADO 6
            pcsRequeridos: 5000,
            desafioRivalId: "guardian_maestro_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir la secta completa (mecánica futura).",
            techniqueChoice: [
              "sword_t6",
              "body_t6",
              "fire_t6",
              "lightning_t6",
              "formation_t6",
              "movement_t6",
            ],
          },
          // === NUEVOS RANGOS AÑADIDOS ===
          {
            nombre: "Patriarca", // GRADO 7
            pcsRequeridos: 10000,
            desafioRivalId: "guardian_patriarca_1", // Necesitarías definir este rival
            beneficios:
              "Tu influencia trasciende la secta. Obtienes acceso a dominios secretos.",
            techniqueChoice: [
              "sword_t7",
              "body_t7",
              "fire_t7",
              "lightning_t7",
              "formation_t7",
              "movement_t7",
            ],
          },
          {
            nombre: "Soberano Inmortal", // GRADO 8
            pcsRequeridos: 25000,
            desafioRivalId: "guardian_soberano_1", // Necesitarías definir este rival
            beneficios:
              "Tu nombre es leyenda. El mundo mortal ya no puede contenerte.",
            techniqueChoice: [
              "sword_t8",
              "body_t8",
              "fire_t8",
              "lightning_t8",
              "formation_t8",
              "movement_t8",
            ],
          },
          {
            nombre: "Soberano del Dao", // GRADO 9
            pcsRequeridos: 50000,
            desafioRivalId: "guardian_dao_1", // Necesitarías definir este rival
            beneficios:
              "Te has fusionado con el Gran Dao. Eres uno con la creación.",
            techniqueChoice: ["sword_t9"], // Ejemplo con una sola técnica definitiva
          },
        ],
        npcs: {
          guia_lin: {
            nombre: "Guía Lin",
            rol: "Maestro de Reclutas",
            dialogoInicial:
              "Bienvenido, joven aspirante... ¿Estás listo para empezar? Compra Items con Piedras espirituales,aprende técnicas, completa misiones y sube de rango en la secta",

            misionesOfrecidas: [
              "mision_recolectar_hierbas_1", // Aunque la entrega sea a Yao, Lin puede ofrecerla
              "mision_eliminar_demonios_1",
              "mision_lobos_bosque_1", // Nueva misión ofrecida por Lin
              "mision_cultivador_hostil_1", // Nueva misión ofrecida por Lin
              "mision_componentes_alquimia_1",
              "mision_eliminar_golem_1",
              "mision_recuperar_artefacto_1",
              // --- NUEVAS MISIONES ASIGNADAS ---
              // Rango: Discípulo Externo
              "mision_ext_1",
              "mision_ext_3",
              "mision_ext_4",
              // Rango: Discípulo Interno
              "mision_int_1",
              "mision_int_2",
              "mision_int_4",
              // Rango: Discípulo Principal
              "mision_prin_4",
              // Misiones de Rango Diácono
              "mision_diac_1",
            
              "mision_diac_3",
              "mision_diac_4",

              // Misiones de Rango Anciano
              "mision_anc_1",
              "mision_anc_3",
              "mision_anc_4",

              // Misiones de Rango Gran Anciano
              "mision_gran_anc_1",
              "mision_gran_anc_2",
              "mision_gran_anc_3",

              // Misión Final de Maestro de Secta
              "mision_maestro_1",
            ],
          },
          admin_yao: {
            nombre: "Administrador Yao",
            rol: "Intendente de la Secta",
            dialogoInicial:
              "Entrega recursos valiosos o completa encargos para ganar Puntos de Contribución. También puedes adquirir algunos suministros aquí.",
            aceptaRecursos: [
              "Hierbas Medicinales",
              "Cristales de Qi",
              "Núcleo de Bestia Menor",
            ], // ...etc.
            tiendaSectaId: "tienda_secta_basica",
            misionesOfrecidas: [
              "mision_escorpiones_desierto_1", // Nueva misión ofrecida por Yao
              // --- NUEVAS MISIONES ASIGNADAS ---
              // Rango: Discípulo Externo
              "mision_ext_2",
              // Rango: Discípulo Interno
              "mision_int_3",
              // Rango: Discípulo Principal
              "mision_prin_1",
              "mision_prin_2",
              "mision_prin_3",
              // Misiones de Rango Diácono
              "mision_diac_2",

              // Misiones de Rango Anciano
              "mision_anc_2",

              // Misiones de Rango Gran Anciano
              "mision_gran_anc_4",
              // ... añade más ID de misiones que Yao ofrezca
            ],
          },
          npc_anciana_su: {
            symbol: "👵",
            name: "Anciana Su, la Archivista",
            spriteUrl: "img/anciana_su.png", // Necesitarás una imagen para ella
            interaction: "talk_story_npc",
            npcId: "anciana_su",
            fixedLocation: { x: 18, y: 14 }, // Por ejemplo, en un edificio tipo biblioteca de la secta
            discovered: true,
          },
          npc_maestro_jian: {
            symbol: "👑",
            name: "Maestro de Secta Jian",
            spriteUrl: "img/maestro_jian.png", // Necesitarás una imagen para él
            interaction: "talk_story_npc",
            npcId: "maestro_jian",
            fixedLocation: { x: 15, y: 18 }, // En la parte más profunda del salón principal
            discovered: true,
          },
          santuario_del_eco: {
            symbol: "⛩️",
            name: "Santuario del Eco",
            spriteUrl: "img/santuario_eco.png", // Necesitarás una imagen (puede ser un altar brillante)
            interaction: "interact_shrine",
            type: "story_shrine",
            fixedLocation: { x: 330, y: 15 }, // Oculto en el Valle del Dragón Caído
            discovered: false, // El jugador debe descubrirlo
          },
        },
      };

      const MISIONES_DATA = {
        // === MISIONES: DISCÍPULO EXTERNO ===

        mision_ext_1: {
          titulo: "Control de Plagas en la Pradera",
          descripcion:
            "Unas Bestias Menores de Pradera se están acercando demasiado a los terrenos de la secta. Demuestra tu valía eliminando 5 de ellas.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_secta_debil",
            cantidad: 5,
            nombreDisplay: "Bestia Menor",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 30,
            exp: 50,
            items: { "Piedras Espirituales": 5 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
        },
        mision_ext_2: {
          titulo: "Suministro de Energía",
          descripcion:
            "El Administrador Yao necesita reponer las reservas de energía de la secta. Recolecta 3 Cristales de Qi y entrégaselos.",
          objetivo: {
            tipo: "entregar_item",
            item: "Cristales de Qi",
            cantidad: 3,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 40,
            exp: 60,
            items: { "Piedras Espirituales": 10 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Externo",
        },
        mision_ext_3: {
          titulo: "Una Lección de Humildad",
          descripcion:
            "Algunos cultivadores novatos se han vuelto arrogantes y están causando problemas. El Guía Lin quiere que derrotes a 3 de ellos para que recuerden su lugar.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivator_rival_low",
            cantidad: 3,
            nombreDisplay: "Cultivador Novato Hostil",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 50,
            exp: 120,
            items: { "Píldora de Recuperación Menor": 1 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
        },
        mision_ext_4: {
          titulo: "Primera Incursión al Bosque",
          descripcion:
            "Los lobos del Bosque Esmeralda están mostrando una agresividad inusual. Adéntrate con cuidado y elimina 2 Lobos del Bosque para investigar.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_bosque_lobo",
            cantidad: 2,
            nombreDisplay: "Lobo del Bosque",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 60, exp: 150, items: { "Colmillo de Lobo": 1 } },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
          requisitoNivel: 3, // Un pequeño requisito de nivel para guiar al jugador.
        },

        mision_cultivador_hostil_1: {
          titulo: "Rivalidad Temprana",
          descripcion:
            "Un grupo de cultivadores están causando alboroto en la secta. El Guía Lin quiere que les des una lección. Derrótalos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivator_rival_low",
            cantidad: 10,
            nombreDisplay: "Cultivador Novato Hostil",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 200,
            exp: 400,
            items: {
              "Píldora de Recuperación Menor": 1,
              "Piedras Espirituales": 12,
            },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 8,
        },
        // Asegúrate de que las misiones que quieres que se entreguen a un NPC tengan `npcEntrega` en su `objetivo`.
        mision_componentes_alquimia_1: {
          titulo: "Medicina Urgente",
          descripcion:
            "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Raíces de Fuego Terrenal' para una píldora vital. Se dice que crecen en zonas con fluctuaciones elementales. Entrégalas al Administrador Yao.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "Flor de Luna Escarchada", cantidad: 3 },
              { nombre: "Raíz de Fuego Terrenal", cantidad: 2 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 250,
            items: {
              "Píldora de Recuperación Menor": 2,
              "Piedras Espirituales": 10,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
        },

        // === MISIONES: DISCÍPULO INTERNO ===
        // (Se desbloquean al alcanzar este rango)

        mision_int_1: {
          titulo: "La Plaga Arácnida",
          descripcion:
            "Las Arañas Tejesombras están infestando el Bosque Esmeralda, haciendo peligrosa la recolección de hierbas. Extermina a 8 de ellas.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_bosque_arana",
            cantidad: 8,
            nombreDisplay: "Araña Tejesombras",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 80, exp: 250, items: { "Seda de Araña": 3 } },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
        },
        mision_int_2: {
          titulo: "Limpieza en la Ciénaga",
          descripcion:
            "La Ciénaga Sombría es un lugar peligroso. Para mantener a raya a sus habitantes, elimina 4 Serpientes de Ciénaga.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_cienaga_serpiente",
            cantidad: 4,
            nombreDisplay: "Serpiente de Ciénaga",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 100,
            exp: 300,
            items: { "Piedras Espirituales": 25 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
        },
        mision_int_3: {
          titulo: "La Petición del Herrero",
          descripcion:
            "El herrero de la secta necesita Quitina Resistente para forjar armaduras ligeras. Caza Escorpiones de las Dunas hasta obtener 3 unidades de Quitina y entrégaselas a Yao.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "monster_desierto_escorpion",
            itemPrueba: "Quitina Resistente",
            cantidadItemPrueba: 3,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 400,
            items: { "Piedras Espirituales": 30 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Interno",
        },
        mision_int_4: {
          titulo: "La Bestia Alfa",
          descripcion:
            "Un Lobo Alfa ha sido avistado en el corazón del bosque, liderando a las manadas. Cazarlo será una prueba de tu creciente poder.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_alpha",
            cantidad: 1,
            nombreDisplay: "Lobo Alfa",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 500,
            items: { "Núcleo de Bestia Menor": 1, "Piedras Espirituales": 50 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
          requisitoNivel: 8,
        },
        mision_cazar_bestia_especifica_1: {
          titulo: "La Amenaza del Jabalí Colmilludo",
          descripcion:
            "Un Jabalí Colmilludo particularmente agresivo ha estado atacando a los recolectores de la secta en lo profundo del bosque. Caza a esta bestia y trae su 'Colmillo intacto' como prueba al Guía Lin.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "jabali_colmilludo_alfa",
            itemPrueba: "Colmillo de Jabalí Alfa",
            cantidadItemPrueba: 1,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 300,
            items: { "Piedras Espirituales": 20, "Carne de Bestia Exótica": 3 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
          requisitoNivel: 10,
        },
        mision_eliminar_golem_1: {
          titulo: "La Amenaza Pétrea",
          descripcion: "Un Golem Ancestral de Jade ha despertado al sur de la pradera. Su presencia es una amenaza para toda la secta. Destrúyelo y reporta tu éxito al Guía Lin.",
          // CORREGIDO: La estructura del objeto 'objetivo' ahora es plana y correcta.
          objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "boss_ancient_golem",
              cantidad: 1,
              nombreDisplay: "Golem Ancestral de Jade",
              npcEntrega: "guia_lin",
          },
          recompensa: {
              pcs: 300,
              exp: 800,
              items: { "Piedras Espirituales": 50, "Corazón de Golem de Jade": 1 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
          requisitoNivel: 11,
      },

        // === MISIONES: DISCÍPULO PRINCIPAL ===
        // (Se desbloquean al alcanzar este rango)

        mision_prin_1: {
          titulo: "Arena y Aguijón",
          descripcion:
            "Las caravanas que comercian con la secta reportan ataques de Escorpiones de las Dunas. Reduce su número eliminando a 10 de ellos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_desierto_escorpion",
            cantidad: 10,
            nombreDisplay: "Escorpión de las Dunas",
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 180,
            exp: 600,
            items: { "Piedras Espirituales": 70 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Principal",
        },
        mision_prin_2: {
          titulo: "Corazones de Arena",
          descripcion:
            "Los Golems de Tormenta de Arena son una amenaza mayor en el desierto. Destruye 5 y trae sus Núcleos de Arena como prueba.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "monster_desierto_golem_arena",
            itemPrueba: "Núcleo de Arena",
            cantidadItemPrueba: 5,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 250,
            exp: 800,
            items: { "Fragmento Desértico": 2, "Piedras Espirituales": 100 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Principal",
          requisitoNivel: 12,
        },
        mision_prin_3: {
          titulo: "Ecos Espectrales",
          descripcion:
            "Los alquimistas de la secta pagan bien por Esencias Espectrales. Se dice que los Espectros del Pantano las dejan al ser derrotados. Consigue 2 esencias.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "espectro_pantano",
            itemPrueba: "Esencia Espectral",
            cantidadItemPrueba: 2,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 300,
            exp: 900,
            items: { "Talismán de Percepción": 1 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Principal",
        },
        mision_prin_4: {
          titulo: "Renegados Peligrosos",
          descripcion:
            "Un grupo de Cultivadores Renegados ha establecido un campamento en el bosque profundo, desafiando la autoridad de la secta. Disuélvelos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivador_renegado",
            cantidad: 4,
            nombreDisplay: "Cultivador Renegado",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 280,
            exp: 1000,
            items: {
              "Rollo: Técnica Aleatoria Menor": 1,
              "Piedras Espirituales": 80,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Principal",
          requisitoNivel: 15,
        },
        // === MISIONES: DIÁCONO ===
        mision_diac_1: {
          titulo: "Contención de Rivales",
          descripcion:
            "La Secta de la Llama Negra se está expandiendo a nuestro territorio. Ve al Desfiladero de los Lamentos y derrota a 10 de sus cultivadores para enviar un mensaje.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivador_secta_rival",
            cantidad: 10,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 400,
            exp: 2500,
            items: { "Piedras Espirituales": 200 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Diácono",
        },
        mision_diac_2: {
          titulo: "Recolección Peligrosa",
          descripcion:
            "Nuestros alquimistas necesitan Cristales de Sangre Puros, que solo se encuentran en la Caverna de Cristal de Sangre, dentro del Desfiladero. Ten cuidado con sus guardianes. Necesitamos 3 cristales.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "murcielago_cristal_sangriento",
            itemPrueba: "Cristal de Sangre Puro",
            cantidadItemPrueba: 3,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 500,
            exp: 3000,
            items: { "Píldora de Recuperación Mayor": 2 },
          }, // Necesitarías definir este item
          npcInicio: "admin_yao",
          requisitoRango: "Diácono",
        },
        mision_diac_3: {
            titulo: "Limpieza en el Desfiladero",
            descripcion: "Un grupo de bandidos bien armados se ha asentado en el Desfiladero de los Lamentos, interrumpiendo las rutas de la secta. Elimínalos.",
            // CORREGIDO: El objeto 'objetivo' ahora es el correcto para una misión de eliminación.
            objetivo: {
                tipo: "eliminar_enemigo",
                enemigoTipo: "bandido_desfiladero",
                nombreDisplay: "Bandido del Desfiladero",
                cantidad: 10,
                npcEntrega: "guia_lin"
            },
            recompensa: {
                pcs: 800,
                exp: 4000,
                items: { "Piedras Espirituales": 150 }
            },
            npcInicio: "guia_lin",
            requisitoRango: "Diácono",
        },
        mision_diac_4: {
            titulo: "La Traición de Jin",
            descripcion: "Es hora de acabar con la amenaza del Diácono Renegado Jin. Derrótalo y restaura el honor de la secta.",
            objetivo: {
                tipo: "derrotar_npc_especifico", // <-- TIPO CORRECTO
                npcId: "diacono_renegado_jin",   // <-- PROPIEDAD CORRECTA
                npcEntrega: "guia_lin"
            },
            recompensa: {
                pcs: 1000,
                exp: 5000,
                items: { "Rollo: Técnica de Absorción de Qi Celestial": 1 }
            },
            npcInicio: "guia_lin",
            requisitoRango: "Diácono", 
        },

        // === MISIONES: ANCIANO ===
        mision_anc_1: {
          titulo: "El Resentimiento del Dragón",
          descripcion:
            "La energía Yin en el Valle del Dragón Caído ha reanimado a los antiguos dracos. Pacifica a 8 de estas criaturas esqueléticas.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "draco_hueso_antiguo",
            cantidad: 8,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 1200,
            exp: 8000,
            items: { "Piedras Espirituales": 500 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Anciano",
        },
        mision_anc_2: {
          titulo: "El Corazón de la Tormenta",
          descripcion:
            "Para forjar un artefacto celestial, necesitamos un Corazón de Tifón. Caza a los Espectros Tifónicos en el Valle hasta que obtengas uno.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "espectro_tifonico",
            itemPrueba: "Corazón de Tifón",
            cantidadItemPrueba: 1,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 1500,
            exp: 10000,
            items: { "Piedras Espirituales": 700 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Anciano",
        },
        mision_anc_3: {
          titulo: "La Fuente de la Corrupción",
          descripcion:
            "Creemos que un poderoso no-muerto es la causa de la corrupción en el Valle. Encuentra su guarida y prepárate para enfrentarlo.",
          objetivo: {
            tipo: "llegar_a_punto",
            x: 200,
            y: 48,
            nombreArea: "Trono del Lich",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 500, exp: 3000 },
          npcInicio: "guia_lin",
          requisitoRango: "Anciano",
        },
        mision_anc_4: {
          titulo: "Sellar al Emperador Lich",
          descripcion:
            "El Emperador Lich amenaza con extender su plaga no-muerta. Destrúyelo y reclama su filacteria como prueba.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "emperador_lich_del_valle",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 2500,
            exp: 15000,
            items: {
              "Filacteria del Lich": 1,
              "Rollo: Técnica de Anciano Aleatoria": 1,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Anciano",
        },

        // === MISIONES: GRAN ANCIANO ===
        mision_gran_anc_1: {
          titulo: "Defensa de la Realidad",
          descripcion:
            "Una Fisura Demoníaca se ha abierto, y sus habitantes se derraman en nuestro mundo. Repele la primera oleada eliminando a 15 Demonios de la Fisura.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "demonio_de_la_fisura",
            cantidad: 15,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 3000,
            exp: 20000,
            items: { "Fragmento de la Fisura": 5 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Gran Anciano",
        },
        mision_gran_anc_2: {
          titulo: "Luz Caída",
          descripcion:
            "Los Guardianes Celestiales que protegían el sello de la fisura han sido corrompidos. Libera a 3 de ellos de su tormento.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "guardian_celestial_caido",
            cantidad: 3,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 4000,
            exp: 25000,
            items: { "Lágrima Celestial": 1 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Gran Anciano",
        },
        mision_gran_anc_3: {
          titulo: "El General del Abismo",
          descripcion:
            "El General Demoníaco Abismal comanda las fuerzas de la Fisura. Adéntrate en su corazón y derrótalo para sellar la amenaza... por ahora.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "general_demoniaco_abismal",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 5000,
            exp: 40000,
            items: {
              "Corazón del Abismo": 1,
              "Rollo: Técnica de Gran Anciano Aleatoria": 1,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Gran Anciano",
        },
        mision_gran_anc_4: {
          titulo: "Preparativos para la Ascensión",
          descripcion:
            "Has llegado al pináculo. Para trascender, necesitas forjar un Sello del Dao. Reúne 3 Lágrimas Celestiales, 5 Fragmentos de la Fisura y 10 Escamas de Dragón Espectral.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "Lágrima Celestial", cantidad: 3 },
              { nombre: "Fragmento de la Fisura", cantidad: 5 },
              { nombre: "Escama de Dragón Espectral", cantidad: 10 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: { pcs: 10000, exp: 50000 },
          npcInicio: "admin_yao",
          requisitoRango: "Gran Anciano",
        },

        // === MISIÓN FINAL: MAESTRO DE SECTA ===
        mision_maestro_1: {
          titulo: "El Duelo del Destino",
          descripcion:
            "El equilibrio del mundo se ha roto. Un Avatar del Dao Corrupto ha despertado para consumir toda la existencia. Como Maestro de Secta, es tu deber enfrentarlo y proteger este mundo.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "avatar_del_dao_corrupto",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 0,
            exp: 100000,
            items: { "Semilla del Dao Verdadero": 1 },
            nuevoRango: "Soberano Inmortal",
          }, // Rango final honorífico
          npcInicio: "guia_lin",
          requisitoRango: "Maestro de Secta",
        },

        //MISIONES DE DESAFÍO
        mision_desafio_interno_1: {
          titulo: "Prueba de Discípulo Interno",
          descripcion:
            "Para ser reconocido como Discípulo Interno, debes demostrar tu fuerza venciendo al Guardián de la Prueba, Han Li. Encuéntralo en la arena de desafíos de la secta.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_interno_1",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 200, exp: 300, nuevoRango: "Discípulo Interno" },
          autoActivarAlCumplirRequisitos: true,
        },
        mision_desafio_principal_1: {
          titulo: "Prueba de Discípulo Principal",
          descripcion:
            "La Anciana Shui espera en la arena. Demuestra que eres digno del rango de Discípulo Principal.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_principal_1",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 500, exp: 800, nuevoRango: "Discípulo Principal" },
          autoActivarAlCumplirRequisitos: true,
        },
        mision_desafio_diacono_1: {
          titulo: "Prueba de Diácono",
          descripcion:
            "Has demostrado tu valía a través de tus contribuciones. Para ser reconocido como Diácono, debes derrotar al Guardián de la Arena, Feng, en un duelo honorable.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_diacono_1",
            npcEntrega: "guia_lin", // El Guía Lin confirmará tu ascenso
          },
          recompensa: {
            pcs: 500,
            exp: 2000,
            nuevoRango: "Diácono",
            // La elección de técnica ya está manejada por tu lógica de ascenso
          },
          autoActivarAlCumplirRequisitos: true, // Esto es clave para la automatización
        },

        mision_desafio_anciano_1: {
          titulo: "Prueba de Anciano",
          descripcion:
            "Solo los más fuertes pueden guiar a la secta. El Anciano Guardián Lei te espera en la arena para probar si eres digno del título de Anciano.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_anciano_1",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 1000,
            exp: 5000,
            nuevoRango: "Anciano",
          },
          autoActivarAlCumplirRequisitos: true,
        },

        mision_desafio_gran_anciano_1: {
          titulo: "Prueba de Gran Anciano",
          descripcion:
            "La Gran Anciana de la Hoja, Yue, pondrá a prueba no solo tu fuerza, sino tu ingenio en combate. Véncela para obtener el respeto de todo el consejo de ancianos.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_gran_anciano_1",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 2000,
            exp: 10000,
            nuevoRango: "Gran Anciano",
          },
          autoActivarAlCumplirRequisitos: true,
        },

        mision_desafio_maestro_1: {
          titulo: "La Prueba Final: El Legado del Maestro",
          descripcion:
            "El camino hacia la cima llega a su fin. El Maestro de Secta anterior te espera para una última prueba. Demuestra que estás listo para heredar su voluntad y liderar la secta hacia la gloria.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_maestro_1",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 5000,
            exp: 20000,
            nuevoRango: "Maestro de Secta",
          },
          autoActivarAlCumplirRequisitos: true,
        },
      };

      const shopData = {
        name: "Pabellón de Tesoros del Dragón Oculto",
        inventory: [
        { 
              itemName: "Tinta Rúnica",
              type: "material", 
              category: "material",
              price: 15, 
              stock: 50, 
              description: "Tinta imbuida de Qi, necesaria para trazar formaciones rúnicas en el suelo."
          },
          { itemName: "Hierbas Medicinales", price: 1, stock: 100 },
          { itemName: "Cristales de Qi", price: 1, stock: 100 },
          {
            itemName: "Espada de Hierro",
            type: "equipment",
            category: "weapon",
            attackBonus: 5,
            price: 50,
            stock: 1,
            description: "Una espada básica pero fiable. (+5 Ataque)",
          },
          //nivel 0
          { itemName: "Rollo: Absorción de Qi Menor", price: 15, stock: 1 },
          { itemName: "Rollo: Inscripción Rúnica", price: 150, stock: 1 },
          { itemName: "Rollo: Conversión de Qi", price: 25, stock: 10 },
          //nivel inferior
          { itemName: "Rollo: Tajo del Viento Veloz (Inferior)", price: 150, stock: 1 },
          { itemName: "Rollo: Físico de Buey de Piedra (Inferior)", price: 200, stock: 1 },
          { itemName: "Rollo: Matriz de Escudo de Qi (Inferior)", price: 180, stock: 1 },
          { itemName: "Rollo: Chispa Ígnea (Inferior)", price: 170, stock: 1 },
          { itemName: "Rollo: Dedo de Relámpago (Inferior)", price: 220, stock: 1 },
          //nivel terrenal

          {
            itemName: "Rollo: Estocada Perfora-Armadura (Terrenal)",
            price: 300,
            stock: 1,
          },
          { itemName: "Rollo: Piel de Acero Fundido (Terrenal)", price: 300, stock: 1 },
          {
            itemName: "Rollo: Matriz de Grilletes de Qi (Terrenal)",
            price: 300,
            stock: 1,
          },
          { itemName: "Rollo: Paso Etéreo (Terrenal)", price: 300, stock: 5 },
          { itemName: "Rollo: Aliento de Dragón Menor (Terrenal)", price: 300, stock: 1 },
          //nivel marcial
          {
            itemName: "Rollo: Danza de Espada Ciclónica (Marcial)",
            price: 600,
            stock: 1,
          },
          {
            itemName: "Rollo: Corazón de Voluntad Indomable (Marcial)",
            price: 600,
            stock: 1,
          },
          {
            itemName: "Rollo: Matriz de Supresión Espiritual (Marcial)",
            price: 600,
            stock: 1,
          },
          { itemName: "Rollo: Jaula de Rayos (Marcial)", price: 600, stock: 1 },
          { itemName: "Rollo: Parpadeo de Sombra (Marcial)", price: 600, stock: 1 },
          //Nivel soberano
          {
            itemName: "Rollo: Intenteción de Espada del Tirano (Soberano)",
            price: 1200,
            stock: 1,
          },
          { itemName: "Rollo: Cuerpo Dorado Inmortal (Soberano)", price: 1200, stock: 1 },
          { itemName: "Rollo: Sol Abrasador (Soberano)", price: 1200, stock: 1 },
          {
            itemName: "Rollo: Llamada del Juicio del Trueno (Soberano)",
            price: 1200,
            stock: 1,
          },
          {
            itemName: "Rollo: Santuario Dorado Protector (Soberano)",
            price: 1200,
            stock: 1,
          },
          //nivel trascendente
          {
            itemName: "Rollo: Corte que Divide Cielos y Tierra (Trascendente)",
            price: 2400,
            stock: 1,
          },
          {
            itemName: "Rollo: Constitución de Dragón Ancestral (Trascendente)",
            price: 2400,
            stock: 1,
          },
          {
            itemName: "Rollo: Llama del Fénix Renaciente (Trascendente)",
            price: 2400,
            stock: 1,
          },
          {
            itemName: "Rollo: Tribulación de los Nueve Cielos (Trascendente)",
            price: 2400,
            stock: 1,
          },
          {
            itemName: "Rollo: Matriz de Reversión del Cosmos (Trascendente)",
            price: 2400,
            stock: 1,
          },
          { itemName: "Rollo: Paso del Vacío Infinito (Trascendente)", price: 2400, stock: 1 },
//nivel celestial
          { itemName: "Rollo: Espada del Emperador (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Cuerpo Inmortal de Jade (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Incineración del Mundo Mortal (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Decreto del Señor del Trueno (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Matriz del Sello del Demonio (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Omnipresencia Divina (Celestial)", price: 5000, stock: 1 },

       
          
        ],
      };

      //ROLLOS DE TECNICAS
      const techniqueData = {
        // =================================================================
        // == GRADO 1 (Rango: Discípulo Externo)
        // =================================================================
        formation_scribing_1: {
          id: "formation_scribing_1",
          name: "Inscripción Rúnica",
          icon: "✍️",
          description: "Te permite usar 'Tinta Rúnica' para trazar runas. Cultivar esta técnica mejora la potencia de todas tus formaciones completadas.",
          type: "active_ability",
          abilityId: "plant_rune",
          manaCost: 10,
          // --- CAMBIOS CLAVE ---
          maxLevel: 10, // Ahora se puede subir de nivel
          cultivationSettings: {
              baseTimeToLevelUp: 300, // Requiere tiempo para dominarla
              levelTimeMultiplier: 2,
          },
          // Este efecto no se aplica directamente, lo leeremos en otra función
          effect: {
              // +10% de potencia por cada nivel después del primero.
              amplificationPerLevel: 0.10 
          }
      },
      
        qi_to_hp_conversion_1: {
          id: "qi_to_hp_conversion_1",
          name: "Técnica de Conversión de Qi",
          description:
            "Permite activar/desactivar la conversión de Maná en HP al cultivar. Mejora la tasa de conversión y eficiencia con cada nivel de refinamiento.",
          type: "active_refinement_effect",
          effect: {
            baseManaCostPerSecond: 2.0, // Mantenemos un coste base razonable
            baseHpGainPerSecond: 3.0, // <-- ¡VALOR CORREGIDO! Ahora es más eficiente.
            hpGainIncreasePerLevel: 1, // Hacemos que la mejora por nivel sea más gradual pero sostenida
            manaCostReductionPerLevel: 0.02, // Reducimos la mejora de eficiencia para balancear
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Cristales de Qi": 5, "Piedras Espirituales": 10 },
            levelRequirement: 1,
          },
          icon: "☯️",
        },
        qi_absorption_boost_1: {
          id: "qi_absorption_boost_1",
          name: "Técnica de Absorción de Qi Menor",
          description:
            "Aumenta la cantidad de Qi ganado por segundo al cultivar en 0.5.",
          type: "passive_cultivation",
          effect: { statToBoost: "qiPerSecondBase", value: 0.5 },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 60,
            levelTimeMultiplier: 1.5,
          },
          refinementCost: {
            baseTime: 30,
            materials: { "Piedras Espirituales": 20 },
            levelRequirement: 1,
          },
          icon: "📜",
        },

        qi_absorption_celestial_1: {
          id: "qi_absorption_celestial_1",
          name: "Técnica de Absorción de Qi Celestial",
          description: "Una técnica de cultivo superior que alinea tu espíritu con los cielos, aumentando drásticamente la cantidad de Qi ganado por segundo al cultivar (+2.0 Qi/s).",
          type: "passive_cultivation",
          effect: { statToBoost: "qiPerSecondBase", value: 2.0 },
          maxLevel: 10, // Se puede mejorar para aumentar aún más el beneficio
          cultivationSettings: {
            baseTimeToLevelUp: 300, // Requiere más tiempo para subir de nivel que las básicas
            levelTimeMultiplier: 1.8,
          },
          icon: "🌌",
        },

        // =================================================================
        // == GRADO 1 (Rango: Discípulo Interno) - Nivel Mortal
        // =================================================================
        sword_t1: {
          id: "sword_t1",
          requiredRank: "Discípulo Interno",
          name: "Tajo del Viento Veloz (Inferior)",
          icon: "💨",
          description:
            "Un corte de espada rápido y eficiente. Un pilar del combate básico.",
          type: "active_ability",
          abilityId: "sword_t1",
          // --- INICIO DE LA MODIFICACIÓN ---
          effect: { 
            baseDamageMultiplier: 1.2,
            multiplierIncreasePerLevel: 0.2 // Aumenta el multiplicador en 0.2 por cada nivel.
          },
          // --- FIN DE LA MODIFICACIÓN ---
          manaCost: 10,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          cooldown: 1,
        },
        body_t1: {
          requiredRank: "Discípulo Interno",
          id: "body_t1",
          name: "Físico de Buey de Piedra (Inferior)",
          icon: "🐂",
          description:
            "Fortalece pasivamente tu cuerpo, aumentando tu Vida Máxima base.",
          type: "passive_stat",
          effect: { 
            statToBoost: "baseMaxHp", 
            value: 25 },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 120,
            levelTimeMultiplier: 1.7,
          },
        },
        formation_t1: {
          requiredRank: "Discípulo Interno",
          id: "formation_t1",
          name: "Matriz de Escudo de Qi (Inferior)",
          icon: "💠",
          description: "Crea un escudo temporal que absorbe daño. A niveles más altos, el escudo es más resistente e incluso restaura una pequeña cantidad de vida al ser invocado.",
          type: "active_ability",
          abilityId: "formation_t1",
          effect: {
              // --- VALORES MEJORADOS ---
              shieldValue: 50,                // Aumentado desde 40. Un mejor punto de partida.
              shieldIncreasePerLevel: 15,     // Aumentado. +15 de escudo por nivel es muy notable.
              duration: 3,
              // --- NUEVO EFECTO SECUNDARIO ---
              healOnCastLevelReq: 5,          // Requiere nivel 5 de la técnica para empezar a curar.
              healOnCastAmount: 20            // Cantidad base de la curación.
          },
          manaCost: 20,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 100, levelTimeMultiplier: 1.8 },
      },
      fire_t1: {
        requiredRank: "Discípulo Interno",
          id: "fire_t1",
          name: "Chispa Ígnea (Inferior)",
          icon: "🔥",
          description:
            "Lanza una pequeña bola de fuego que causa daño y puede aplicar una quemadura menor.",
          type: "active_ability",
          abilityId: "fire_t1",
          effect: {
            baseDamageMultiplier: 0.8,
            multiplierIncreasePerLevel: 0.1, // <-- MODIFICACIÓN AÑADIDA
            burnDamagePerTurn: 5,
            burnDamageIncreasePerLevel: 1, // <-- MODIFICACIÓN AÑADIDA
            burnDuration: 2,
          },
          manaCost: 15,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 110,
            levelTimeMultiplier: 1.7,
          },
        },
        lightning_t1: {
          requiredRank: "Discípulo Interno",
          id: "lightning_t1",
          name: "Dedo de Relámpago (Inferior)",
          icon: "⚡",
          description:
            "Un rápido chispazo de relámpago que puede aturdir brevemente al enemigo.",
          type: "active_ability",
          abilityId: "lightning_t1",
          effect: { 
            baseDamageMultiplier: 0.9,
            multiplierIncreasePerLevel: 0.1, // <-- MODIFICACIÓN AÑADIDA
            stunChance: 0.2,
            stunChanceIncreasePerLevel: 0.03, // <-- MODIFICACIÓN AÑADIDA
          },
          manaCost: 18,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 130,
            levelTimeMultiplier: 1.8,
          },
        },
        movement_t1: {
          requiredRank: "Discípulo Interno",
          id: "movement_t1",
          name: "Paso Veloz (Inferior)",
          icon: "👟",
          description: "Un movimiento rápido que te reposiciona, aumentando temporalmente tu defensa para el siguiente turno.",
          type: "active_ability",
          abilityId: "movement_t1",
          effect: { 
              tempDefenseBuff: 10, // Un bono fijo y simple para una técnica inicial
              buffDuration: 2,     // Dura tu turno actual y el siguiente del enemigo
              buffIncreasePerLevel: 2 // Aumenta el bono en 2 por cada nivel
          },
          manaCost: 15,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 100, levelTimeMultiplier: 1.7 }
      },

        // =================================================================
        // == GRADO 2 (Rango: Discípulo Principal) - Nivel Terrenal
        // =================================================================
        sword_t2: {
            id: "sword_t2",
            requiredRank: "Discípulo Principal", 
            name: "Estocada Perfora-Armadura (Terrenal)",
            icon: "🗡️",
            description: "Un ataque preciso que ignora una porción de la defensa enemiga y puede causar una herida sangrante.",
            type: "active_ability",
            abilityId: "sword_t2",
            effect: {
                // --- VALORES MEJORADOS ---
                baseDamageMultiplier: 1.8,      // Aumentado desde 1.1. Ahora es claramente más fuerte.
                defensePenetration: 0.3,        // Aumentado desde 0.25. Ignora más defensa.
                bleedChance: 0.3,               // NUEVO: 30% de probabilidad de causar hemorragia.
                bleedDamagePerTurn: 15,         // NUEVO: Daño de la hemorragia.
                bleedDuration: 2                // NUEVO: Duración de la hemorragia.
            },
            manaCost: 25,
            cooldown: 2,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 180, levelTimeMultiplier: 1.6 },
        },
        body_t2: {
          
          id: "body_t2",
          requiredRank: "Discípulo Principal", 
          name: "Piel de Acero Fundido (Terrenal)",
          icon: "🦾",
          description:
            "Aumenta pasivamente tu Defensa base, haciéndote más resistente.",
          type: "passive_stat",
          effect: { statToBoost: "baseDefense", value: 5 },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 200,
            levelTimeMultiplier: 1.7,
          },
        },
        formation_t2: {
          id: "formation_t2",
          requiredRank: "Discípulo Principal", 
          name: "Matriz de Grilletes de Qi (Terrenal)",
          icon: "🔗",
          description:
            "Una formación que intenta enraizar al enemigo. Consume maná cada turno y puede romperse si el enemigo ataca con fuerza.",
          type: "active_ability",
          abilityId: "formation_t2",
          effect: {
            rootDuration: 2,
            damagePerTurn: 10,
            damagePerTurnIncreasePerLevel: 2, // <-- MODIFICACIÓN AÑADIDA
            rootChance: 0.7,
            shacklesHP: 100, 
            shacklesHPIncreasePerLevel: 20, // <-- MODIFICACIÓN AÑADIDA
            manaUpkeep: 5,
          },
          manaCost: 30,
          cooldown: 3,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 190,
            levelTimeMultiplier: 1.8,
          },
        },
        movement_t2: {
          id: "movement_t2",
          requiredRank: "Discípulo Principal", 
          name: "Paso Etéreo (Terrenal)",
          icon: "👟",
          description: "Esquivas el próximo ataque. El movimiento fluido también aumenta tu defensa temporalmente. El bono de defensa aumenta con el nivel.",
          type: "active_ability",
          abilityId: "movement_t2",
          effect: {
              dodgeNextAttack: true,
              // --- NUEVAS PROPIEDADES ---
              tempDefenseBuff: 5,      // Defensa extra que otorga
              buffDuration: 2,         // Duración del buff en turnos
              buffIncreasePerLevel: 2  // Cuánto aumenta el buff de defensa por nivel
          },
          manaCost: 40,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 220, levelTimeMultiplier: 1.9 },
      },
      fire_t2: {
          id: "fire_t2",
          requiredRank: "Discípulo Principal", 
          name: "Aliento de Dragón Menor (Terrenal)",
          icon: "🐲",
          description:
            "Exhalas un cono de fuego que quema con mayor intensidad.",
          type: "active_ability",
          abilityId: "fire_t2",
          effect: {
            baseDamageMultiplier: 1.0,
            multiplierIncreasePerLevel: 0.2, // <-- MODIFICACIÓN AÑADIDA
            burnDamagePerTurn: 15,
            burnDamageIncreasePerLevel: 2, // <-- MODIFICACIÓN AÑADIDA
            burnDuration: 3,
          },
          manaCost: 35,
          cooldown: 3,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 200,
            levelTimeMultiplier: 1.7,
          },
        },
        lightning_t2: {
          id: "lightning_t2",
          requiredRank: "Discípulo Principal", 
          name: "Látigo de Trueno (Terrenal)",
          icon: "⚡️",
          description: "Un chasquido de energía eléctrica que golpea al enemigo, reduciendo su defensa temporalmente.",
          type: "active_ability",
          abilityId: "lightning_t2",
          effect: { 
              baseDamageMultiplier: 1.4,
              multiplierIncreasePerLevel: 0.15, // <-- MODIFICACIÓN AÑADIDA
              defenseReduction: 10,
              defenseReductionIncreasePerLevel: 1, // <-- MODIFICACIÓN AÑADIDA
              duration: 2
          },
          manaCost: 28,
          cooldown: 2,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 190, levelTimeMultiplier: 1.8 }
      },

        // =================================================================
        // == GRADO 3 (Rango: Diácono) - Nivel Marcial
        // =================================================================
        sword_t3: {
            id: "sword_t3",
            requiredRank: "Diácono",
            name: "Danza de Espada Ciclónica (Marcial)",
            icon: "🌪️",
            description: "Giras como un ciclón, golpeando al enemigo múltiples veces. El número de golpes aumenta con el nivel.",
            type: "active_ability",
            abilityId: "sword_t3",
            effect: {
                baseDamageMultiplier: 1.5,
                baseHits: 3, // <-- Nuevo: Golpes base
                hitsIncreasePerLevel: 0.5 // <-- Nuevo: Medio golpe por nivel (se redondeará)
            },
            manaCost: 50,
            cooldown: 2,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 300, levelTimeMultiplier: 1.6 },
        },
        body_t3: {
          id: "body_t3",
          requiredRank: "Diácono",
          name: "Corazón de Voluntad Indomable (Marcial)",
          icon: "❤️‍🔥",
          description:
            "Pasivamente, tu voluntad de hierro reduce una porción de todo el daño recibido.",
          type: "passive_stat",
          effect: { statToBoost: "damageReduction", value: 0.05 }, // Esto necesitará lógica en el cálculo de daño
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 350,
            levelTimeMultiplier: 1.7,
          },
        },
        formation_t3: {
            id: "formation_t3",
            requiredRank: "Diácono",
            name: "Matriz de Supresión Espiritual (Marcial)",
            icon: "🕸️",
            description: "Crea un campo que debilita al enemigo, reduciendo su ataque y defensa. El efecto es más potente con el nivel.",
            type: "active_ability",
            abilityId: "formation_t3",
            effect: { 
                baseReduction: 15, // <-- Nuevo
                reductionIncreasePerLevel: 3, // <-- Nuevo
                duration: 4 
            },
            manaCost: 45,
            cooldown: 5,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 320, levelTimeMultiplier: 1.8 },
        },
        lightning_t3: {
            id: "lightning_t3",
            requiredRank: "Diácono",
            name: "Jaula de Rayos (Marcial)",
            icon: "⛓️",
            description: "Encierra al enemigo en una jaula eléctrica, causando daño y con alta probabilidad de aturdir, ambos mejoran con el nivel.",
            type: "active_ability",
            abilityId: "lightning_t3",
            effect: {
                baseDamageMultiplier: 1.2,
                damageMultiplierIncreasePerLevel: 0.1, // <-- Nuevo
                baseStunChance: 0.5, // <-- Nuevo
                stunChanceIncreasePerLevel: 0.03, // <-- Nuevo
                duration: 2
            },
            manaCost: 60,
            cooldown: 4,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 380, levelTimeMultiplier: 1.8 },
        },
        movement_t3: {
          id: "movement_t3",
          requiredRank: "Diácono",
          name: "Parpadeo de Sombra (Marcial)",
          icon: "👻",
          description: "Te teletransportas instantáneamente detrás del enemigo para un golpe crítico garantizado. Su potencia aumenta con el nivel.", // Descripción mejorada
          type: "active_ability",
          abilityId: "movement_t3",
          effect: { 
              baseDamageMultiplier: 2.0, 
              multiplierIncreasePerLevel: 0.2, // <-- NUEVA PROPIEDAD DE ESCALADO
              isCritical: true 
          },
          manaCost: 55,
          cooldown: 3,
          maxLevel: 10,
          cultivationSettings: {
              baseTimeToLevelUp: 400,
              levelTimeMultiplier: 1.9,
          },
      },

        // =================================================================
        // == GRADO 4 (Rango: Anciano) - Nivel Soberano
        // =================================================================
        sword_t4: {
            id: "sword_t4",
            requiredRank: "Anciano",
            name: "Intención de Espada del Tirano (Soberano)",
            icon: "👑",
            description: "Canalizas tu Qi para una onda de energía que daña y puede aturdir. Su poder aumenta con el nivel.",
            type: "active_ability",
            abilityId: "sword_t4",
            effect: { 
                baseDamageMultiplier: 2.8,
                multiplierIncreasePerLevel: 0.25, // <-- Nuevo
                baseStunChance: 0.4, // <-- Nuevo
                stunChanceIncreasePerLevel: 0.02, // <-- Nuevo
            },
            manaCost: 70,
            cooldown: 1,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 500, levelTimeMultiplier: 1.5 },
        },
        body_t4: {
          id: "body_t4",
          requiredRank: "Anciano",
          name: "Cuerpo Dorado Inmortal (Soberano)",
          icon: "🌟",
          description:
            "Tu cuerpo se vuelve tan duro que regenera vida pasivamente incluso fuera del cultivo.",
          type: "passive_stat",
          effect: { statToBoost: "passiveHpRegen", value: 0.5 }, // Necesitará lógica en el game tick
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 600,
            levelTimeMultiplier: 1.6,
          },
        },
        fire_t4: {
            id: "fire_t4",
            requiredRank: "Anciano",
            name: "Sol Abrasador (Soberano)",
            icon: "☀️",
            description: "Creas un sol en miniatura que explota, causando daño masivo y dejando una quemadura intensa que escala con el nivel.", // Descripción actualizada
            type: "active_ability",
            abilityId: "fire_t4",
            effect: { 
                baseDamageMultiplier: 2.5,
                multiplierIncreasePerLevel: 0.3, 
                aoe: true,
                // --- INICIO DE LA MODIFICACIÓN ---
                burnDamagePerTurn: 30,       // Daño de quemadura base.
                burnDuration: 3,           // Duración de la quemadura en turnos.
                burnIncreasePerLevel: 5    // El daño de la quemadura aumenta en 5 por cada nivel.
                // --- FIN DE LA MODIFICACIÓN ---
            },
            manaCost: 80,
            cooldown: 4,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 550, levelTimeMultiplier: 1.6 },
        },
        lightning_t4: {
            id: "lightning_t4",
            requiredRank: "Anciano",
            name: "Llamada del Juicio del Trueno (Soberano)",
            icon: "🌩️",
            description: "Invocas un rayo celestial que ignora la defensa. Su daño base aumenta con el nivel.",
            type: "active_ability",
            abilityId: "lightning_t4",
            effect: { 
                baseDamageMultiplier: 2.0,
                multiplierIncreasePerLevel: 0.25, // <-- Nuevo
                ignoreDefense: true 
            },
            manaCost: 75,
            cooldown: 4,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 580, levelTimeMultiplier: 1.7 },
        },
        formation_t4: {
            id: "formation_t4",
            requiredRank: "Anciano",
            name: "Santuario Dorado Protector (Soberano)",
            icon: "🏰",
            description: "Una matriz defensiva definitiva que te hace inmune al daño. A niveles altos, dura un turno más.",
            type: "active_ability",
            abilityId: "formation_t4",
            effect: { 
                baseDuration: 2, // <-- Nuevo
                levelForExtraTurn: 7 // <-- Nuevo: A nivel 7, dura un turno extra
            },
            manaCost: 100,
            cooldown: 8,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 620, levelTimeMultiplier: 1.8 },
        },
        movement_t4: {
          id: "movement_t4",
          requiredRank: "Anciano",
          name: "Danza del Viento Espectral (Soberano)",
          icon: "💃",
          description: "Un ataque veloz que confunde al enemigo, permitiéndote esquivar con certeza el siguiente golpe recibido.",
          type: "active_ability",
          abilityId: "movement_t4",
          effect: { 
              baseDamageMultiplier: 1.8, 
              multiplierIncreasePerLevel: 0.2, // <-- MODIFICACIÓN AÑADIDA
              dodgeNextAttack: true
          },
          manaCost: 65,
          cooldown: 1,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 600, levelTimeMultiplier: 1.8 }
      },

        // =================================================================
        // == GRADO 5 (Rango: Gran Anciano) - Nivel Transcendente
        // =================================================================
        sword_t5: {
          id: "sword_t5",
          requiredRank: "Gran Anciano",
          name: "Corte que Divide Cielos y Tierra (Transcendente)",
          icon: "⚔️",
          description:
            "Una técnica legendaria que corta a través de cualquier defensa y causa daño verdadero.",
          type: "active_ability",
          abilityId: "sword_t5",
          effect: {
            baseDamageMultiplier: 4.0,
            multiplierIncreasePerLevel: 0.5, // <-- MODIFICACIÓN AÑADIDA
            trueDamage: true,
            criticalChance: 0.3,
            criticalChanceIncreasePerLevel: 0.02 // <-- MODIFICACIÓN AÑADIDA (2% más por nivel)
          },
          manaCost: 120,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 800,
            levelTimeMultiplier: 1.4,
          },
        },
        body_t5: {
            id: "body_t5",
            requiredRank: "Gran Anciano",
            name: "Constitución de Dragón Ancestral (Transcendente)",
            icon: "🐉",
            description: "Tu cuerpo alcanza la perfección dracónica, aumentando tu resistencia a efectos de estado y regenerando vida poderosamente.",
            type: "passive_stat",
            effect: {
                // === NUEVO SISTEMA DE RESISTENCIA ===
                statusResistChanceBase: 0.10,      // 10% de resistencia base al nivel 1
                statusResistChancePerLevel: 0.04,  // +4% de resistencia por cada nivel adicional
                // ===================================
                passiveHpRegen: 2.0,
            },
            maxLevel: 10,
            cultivationSettings: {
                baseTimeToLevelUp: 900,
                levelTimeMultiplier: 1.5,
            },
        },
        fire_t5: {
          id: "fire_t5",
          requiredRank: "Gran Anciano",
          name: "Llama del Fénix Renaciente (Transcendente)",
          icon: "🔥",
          description:
            "Invocas el fuego sagrado del fénix que causa daño masivo y puede resucitarte al morir.",
          type: "active_ability",
          abilityId: "fire_t5",
          effect: { 
            baseDamageMultiplier: 3.5, 
            aoe: true, 
            reviveChance: 0.25,
            reviveChanceIncreasePerLevel: 0.025 // <-- MODIFICACIÓN AÑADIDA (2.5% más por nivel)
          },
          manaCost: 150,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 850,
            levelTimeMultiplier: 1.5,
          },
        },
        lightning_t5: {
          id: "lightning_t5",
          requiredRank: "Gran Anciano",
          name: "Tribulación de los Nueve Cielos (Transcendente)",
          icon: "🌩️",
          description:
            "Canalizas el poder de la tribulación celestial para devastar a todos los enemigos.",
          type: "active_ability",
          abilityId: "lightning_t5",
          effect: {
            baseDamageMultiplier: 3.0,
            multiplierIncreasePerLevel: 0.4, // <-- MODIFICACIÓN AÑADIDA
            aoe: true,
            paralyzeChance: 0.6,
            paralyzeChanceIncreasePerLevel: 0.04, // <-- MODIFICACIÓN AÑADIDA
            duration: 2,
          },
          manaCost: 140,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 880,
            levelTimeMultiplier: 1.6,
          },
        },
        formation_t5: {
          id: "formation_t5",
          requiredRank: "Gran Anciano",
          name: "Matriz de Reversión del Cosmos (Transcendente)",
          icon: "🌌",
          description:
            "Una formación que invierte el daño recibido, convirtiéndolo en curación.",
          type: "active_ability",
          abilityId: "formation_t5",
          effect: { damageToHealingDuration: 3, reflectDamage: 0.5 },
          manaCost: 180,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 950,
            levelTimeMultiplier: 1.7,
          },
        },
        movement_t5: {
          id: "movement_t5",
          requiredRank: "Gran Anciano",
          name: "Paso del Vacío Infinito (Transcendente)",
          icon: "🌀",
          description:
            "Te mueves entre dimensiones, volviéndote intangible y atacando desde múltiples ángulos.",
          type: "active_ability",
          abilityId: "movement_t5",
          effect: {
            baseDamageMultiplier: 2.5,
            intangibleTurns: 2,
            multiHit: 3,
          },
          manaCost: 130,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 820,
            levelTimeMultiplier: 1.8,
          },
        },

        // =================================================================
        // == GRADO 6 (Rango: Patriarca) - Nivel Celestial
        // =================================================================
        sword_t6: {
          id: "sword_t6",
          requiredRank: "Maestro de Secta",
          name: "Espada del Emperador (Celestial)",
          icon: "👑",
          description:
            "El arte supremo de la espada que puede cortar a través del destino mismo.",
          type: "active_ability",
          abilityId: "sword_t6",
          effect: {
            baseDamageMultiplier: 6.0,
            multiplierIncreasePerLevel: 0.5, // <-- MODIFICACIÓN AÑADIDA
            ignoreAllEffects: true,
            executeThreshold: 0.2,
            executeThresholdIncreasePerLevel: 0.01 // <-- MODIFICACIÓN AÑADIDA (1% más de umbral por nivel)
          },
          manaCost: 200,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1200,
            levelTimeMultiplier: 1.3,
          },
        },
        body_t6: {
          id: "body_t6",
          requiredRank: "Maestro de Secta",
          name: "Cuerpo Inmortal de Jade (Celestial)",
          icon: "💎",
          description:
            "Tu cuerpo trasciende la mortalidad, volviéndose prácticamente indestructible.",
          type: "passive_stat",
          effect: {
            statToBoost: "damageReduction",
            value: 0.25,
            deathSaveChance: 0.5,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1400,
            levelTimeMultiplier: 1.4,
          },
        },
        fire_t6: {
          id: "fire_t6",
          requiredRank: "Maestro de Secta",
          name: "Incineración del Mundo Mortal (Celestial)",
          icon: "🌋",
          description:
            "Reduces todo a cenizas con el fuego que arde desde el núcleo de la creación.",
          type: "active_ability",
          abilityId: "fire_t6",
          effect: {
            baseDamageMultiplier: 5.0,
            aoe: true,
            burnDamagePerTurn: 100,
            burnDuration: 5,
          },
          manaCost: 250,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1300,
            levelTimeMultiplier: 1.4,
          },
        },
        lightning_t6: {
          id: "lightning_t6",
          requiredRank: "Maestro de Secta",
          name: "Decreto del Señor del Trueno (Celestial)",
          icon: "⚡",
          description:
            "Como señor de las tormentas, tu palabra se convierte en ley absoluta.",
          type: "active_ability",
          abilityId: "lightning_t6",
          effect: {
            baseDamageMultiplier: 4.5,
            aoe: true,
            silenceDuration: 3,
            stunChance: 0.8,
          },
          manaCost: 220,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1350,
            levelTimeMultiplier: 1.5,
          },
        },
        formation_t6: {
          id: "formation_t6",
          requiredRank: "Maestro de Secta",
          name: "Matriz del Sello del Demonio (Celestial)",
          icon: "🔒",
          description:
            "Sella completamente al enemigo, impidiendo todas sus acciones por varios turnos.",
          type: "active_ability",
          abilityId: "formation_t6",
          effect: { sealDuration: 4, damagePerTurn: 50 },
          manaCost: 300,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1500,
            levelTimeMultiplier: 1.6,
          },
        },
        movement_t6: {
          id: "movement_t6",
          requiredRank: "Maestro de Secta",
          name: "Omnipresencia Divina (Celestial)",
          icon: "👁️",
          description:
            "Existes en múltiples lugares simultáneamente, atacando desde todas partes.",
          type: "active_ability",
          abilityId: "movement_t6",
          effect: { baseDamageMultiplier: 3.0, unavoidable: true, multiHit: 5 },
          manaCost: 280,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1250,
            levelTimeMultiplier: 1.7,
          },
        },

        // =================================================================
        // == GRADO 7 (Rango: Soberano Supremo) - Nivel Legendario
        // =================================================================
        sword_t7: {
          id: "sword_t7",
          requiredRank: "Maestro de Secta",
          name: "Lamento del Fin del Mundo",
          icon: "🗡️",
          description:
            "Una técnica que lleva la esencia de la destrucción apocalíptica.",
          type: "active_ability",
          abilityId: "sword_t7",
          effect: {
            baseDamageMultiplier: 8.0,
            aoe: true,
            ignoreAllDefenses: true,
            lifeSteal: 0.5,
          },
          manaCost: 350,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2000,
            levelTimeMultiplier: 1.2,
          },
        },
        body_t7: {
          id: "body_t7",
          requiredRank: "Maestro de Secta",
          name: "Forma del Ancestro Primordial",
          icon: "🌟",
          description:
            "Tu cuerpo alcanza la forma perfecta de los antiguos dioses creadores.",
          type: "passive_stat",
          effect: {
            statToBoost: "allStats",
            multiplier: 2.0,
            regenAllPerTurn: true,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2500,
            levelTimeMultiplier: 1.3,
          },
        },
        fire_t7: {
          id: "fire_t7",
          requiredRank: "Maestro de Secta",
          name: "Génesis Ígneo",
          icon: "🔥",
          description:
            "El fuego que creó el universo, capaz de destruir y recrear la realidad.",
          type: "active_ability",
          abilityId: "fire_t7",
          effect: {
            baseDamageMultiplier: 7.0,
            aoe: true,
            resetEnemyBuffs: true,
            burnDamagePerTurn: 200,
          },
          manaCost: 400,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2200,
            levelTimeMultiplier: 1.3,
          },
        },
        lightning_t7: {
          id: "lightning_t7",
          requiredRank: "Maestro de Secta",
          name: "Cólera del Emperador Celestial",
          icon: "⚡",
          description:
            "La ira divina se manifiesta como rayos que juzgan a todos los seres.",
          type: "active_ability",
          abilityId: "lightning_t7",
          effect: {
            baseDamageMultiplier: 6.5,
            aoe: true,
            judgmentEffect: true,
            chainLightning: 10,
          },
          manaCost: 380,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2300,
            levelTimeMultiplier: 1.4,
          },
        },
        formation_t7: {
          id: "formation_t7",
          requiredRank: "Maestro de Secta",
          name: "Matriz del Caos Primordial",
          icon: "🌀",
          description:
            "Invocas el caos que existía antes de la creación para deshacer a tus enemigos.",
          type: "active_ability",
          abilityId: "formation_t7",
          effect: { randomCatastrophicEffects: true, reality_distortion: 5 },
          manaCost: 450,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2800,
            levelTimeMultiplier: 1.5,
          },
        },
        movement_t7: {
          id: "movement_t7",
          requiredRank: "Maestro de Secta",
          name: "Danza del Tejido Espacio-Tiempo",
          icon: "🌌",
          description:
            "Manipulas el espacio y el tiempo para existir en múltiples momentos simultáneamente.",
          type: "active_ability",
          abilityId: "movement_t7",
          effect: {
            baseDamageMultiplier: 4.0,
            timeLoop: 3,
            spacialDistortion: true,
          },
          manaCost: 420,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2400,
            levelTimeMultiplier: 1.6,
          },
        },

        // =================================================================
        // == GRADO 8 (Rango: Emperador Inmortal) - Nivel Épico
        // =================================================================
        sword_t8: {
          id: "sword_t8",
          requiredRank: "Maestro de Secta",
          name: "Decreto Imperial: Extinción",
          icon: "👑",
          description:
            "Como emperador, tu palabra es ley absoluta. Decretas la extinción de tus enemigos.",
          type: "active_ability",
          abilityId: "sword_t8",
          effect: {
            baseDamageMultiplier: 12.0,
            instantKillChance: 0.3,
            ignoreAllProtections: true,
          },
          manaCost: 500,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 3500,
            levelTimeMultiplier: 1.1,
          },
        },
        body_t8: {
          id: "body_t8",
          requiredRank: "Maestro de Secta",
          name: "Avatar del Dao Eterno",
          icon: "☯️",
          description:
            "Te conviertes en la manifestación física del Dao, trascendiendo todas las limitaciones.",
          type: "passive_stat",
          effect: {
            statToBoost: "transcendence",
            value: true,
            immuneToAll: true,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 4000,
            levelTimeMultiplier: 1.2,
          },
        },
        fire_t8: {
          id: "fire_t8",
          requiredRank: "Maestro de Secta",
          name: "Apocalipsis de Llamas Divinas",
          icon: "🔥",
          description:
            "El fuego que consume universos enteros, purificando la existencia misma.",
          type: "active_ability",
          abilityId: "fire_t8",
          effect: {
            baseDamageMultiplier: 10.0,
            aoe: true,
            purificationEffect: true,
            universeScaleDamage: true,
          },
          manaCost: 600,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 3800,
            levelTimeMultiplier: 1.2,
          },
        },
        lightning_t8: {
          id: "lightning_t8",
          requiredRank: "Maestro de Secta",
          name: "Tribulación del Fin de los Tiempos",
          icon: "⚡",
          description:
            "Invocas la tribulación final que marcará el fin de una era.",
          type: "active_ability",
          abilityId: "lightning_t8",
          effect: {
            baseDamageMultiplier: 9.0,
            aoe: true,
            eraEndingEffect: true,
            temporalDamage: true,
          },
          manaCost: 550,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 3600,
            levelTimeMultiplier: 1.3,
          },
        },
        formation_t8: {
          id: "formation_t8",
          requiredRank: "Maestro de Secta",
          name: "Matriz de Reescritura de la Realidad",
          icon: "📜",
          description:
            "Reescribes las leyes fundamentales de la realidad a tu favor.",
          type: "active_ability",
          abilityId: "formation_t8",
          effect: {
            realityRewrite: true,
            lawManipulation: true,
            existenceControl: 7,
          },
          manaCost: 700,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 4500,
            levelTimeMultiplier: 1.4,
          },
        },
        movement_t8: {
          id: "movement_t8",
          requiredRank: "Maestro de Secta",
          name: "Trascendencia Dimensional",
          icon: "🌀",
          description:
            "Trasciendes las limitaciones dimensionales, existiendo en todas las dimensiones.",
          type: "active_ability",
          abilityId: "movement_t8",
          effect: {
            baseDamageMultiplier: 6.0,
            dimensionalTravel: true,
            omnipresence: true,
          },
          manaCost: 650,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 4200,
            levelTimeMultiplier: 1.5,
          },
        },

        // =================================================================
        // == GRADO 9 (Rango: Soberano del Dao) - Nivel Mítico Supremo
        // =================================================================
        sword_t9: {
          id: "sword_t9",
          requiredRank: "Maestro de Secta",
          name: "Corte del Origen Absoluto",
          icon: "⚔️",
          description:
            "Cortas a través del origen mismo de la existencia, negando la realidad de tus enemigos.",
          type: "active_ability",
          abilityId: "sword_t9",
          effect: {
            baseDamageMultiplier: 20.0,
            existenceNegation: true,
            conceptualDamage: true,
          },
          manaCost: 800,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 6000,
            levelTimeMultiplier: 1.0,
          },
        },
      };

      // ===  DICCIONARIO DE HABILIDADES DE ENEMIGOS ===
      const enemyAbilityData = {
        // --- BUFFS (Mejoras al enemigo) ---

        stone_skin_1: {
          name: "Piel de Piedra",
          type: "buff_stat",
          logMessage: (enemyName, defenseBoost, duration) =>
            `${enemyName} usa Piel de Piedra. ¡Su defensa aumenta en ${defenseBoost} por ${duration} turnos!`,
          effect: {
            stat: "defense", // La estadística a mejorar
            amount: 15, // Cuánto aumenta
            duration: 3, // Cuántos turnos dura
          },
        },
        // --- DEBUFFS (Perjuicios al jugador) ---
        armor_break: {
          name: "Golpe Rompe-Armadura",
          type: "debuff_stat",
          logMessage: (enemyName, damage, reduction, duration) =>
            `¡${enemyName} usa un Golpe Rompe-Armadura! Recibes ${damage} de daño y tu defensa se reduce en ${reduction} por ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 1.2,
            debuff: {
              stat: "defense",
              amount: 10,
              duration: 3,
            },
          },
        },
        thorns_aura: {
          name: "Aura de Espinas",
          type: "buff_reflect",
          logMessage: (enemyName, reflectPercent, duration) =>
            `${enemyName} se rodea de un Aura de Espinas. ¡Reflejará un ${reflectPercent}% del daño durante ${duration} turnos!`,
          effect: {
            reflectChance: 1.0, // 100% de probabilidad de reflejar
            reflectMultiplier: 0.25, // Refleja el 25% del daño
            duration: 2,
          },
        },
        armor_piercing_strike: {
          name: "Golpe Perforante",
          type: "piercing_damage",
          logMessage: (enemyName, damage) =>
            `${enemyName} utiliza un Golpe Perforante que ignora parte de tu armadura, ¡causando ${damage} de daño!`,
          effect: {
            baseDamageMultiplier: 1.1,
            armorPenetration: 0.3, // 30% de la defensa del jugador será ignorada
          },
        },
        intimidating_roar: {
          name: "Rugido Intimidante",
          type: "debuff_stat_no_damage", // Un debuff que no hace daño directo
          logMessage: (enemyName, reduction, duration) =>
            `¡${enemyName} suelta un Rugido Intimidante! Tu ataque se reduce en ${reduction} por ${duration} turnos.`,
          effect: {
            debuff: {
              stat: "attack",
              amount: 8,
              duration: 3,
            },
          },
        },

        // --- ATAQUES CON DAÑO EN EL TIEMPO (DoT) ---
        fire_breath: {
          name: "Aliento de Fuego",
          type: "dot_damage",
          logMessage: (enemyName, damage, burnDmg, duration) =>
            `¡${enemyName} te envuelve en su Aliento de Fuego! Recibes ${damage} de daño y quedas quemado por ${burnDmg} de daño durante ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 0.8,
            dot: {
              type: "burn", // 'burn', 'poison', 'curse', etc.
              damagePerTurn: 8,
              duration: 3,
            },
          },
        },

        poison_sting: {
          name: "Picadura Venenosa",
          type: "dot_damage",
          logMessage: (enemyName, damage, poisonDmg, duration) =>
            `¡${enemyName} te clava su Aguijón Venenoso! Recibes ${damage} de daño y quedas envenenado por ${poisonDmg} de daño durante ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 0.5, // El golpe inicial no es tan fuerte
            poison: {
              damagePerTurn: 10, // Daño base del veneno
              duration: 3,
            },
          },
        },
        // Una maldición que drena el maná del jugador cada turno
        mana_curse: {
          name: "Maldición de Maná",
          type: "dot_resource", // <--- TIPO NUEVO (DoT que afecta un recurso)
          logMessage: (enemyName, manaDrain, duration) =>
            `${enemyName} te maldice, ¡drenando ${manaDrain} de tu maná cada turno durante ${duration} turnos!`,
          effect: {
            dot: {
              resource: "mana", // El recurso a drenar
              drainPerTurn: 15,
              duration: 3,
            },
          },
        },
        shattering_curse: {
          name: "Maldición Quebrantadora",
          type: "debuff_stat_percent", // Nuevo tipo de habilidad
          logMessage: (enemyName, percent, duration) => `${enemyName} lanza una Maldición Quebrantadora. ¡Tu defensa se reduce en un ${percent}% por ${duration} turnos!`,
          effect: {
              debuff: {
                  stat: "defense",
                  percentage: 0.3, // Reduce la defensa en un 30%
                  duration: 3,
              }
          }
      },

        // Habilidad que causa daño basado en el % de vida máxima del jugador
        abyssal_drain: {
            name: "Drenaje Abismal",
            type: "percent_hp_damage", // Nuevo tipo
            logMessage: (enemyName, damage) => `${enemyName} usa Drenaje Abismal, arrancando un trozo de tu fuerza vital y causándote ${damage} de daño!`,
            effect: {
                percentage: 0.25 // Causa un 25% de la vida máxima del jugador como daño
            }
        },

        // Habilidad de daño verdadero que ignora toda defensa
        reality_tear: {
            name: "Desgarro de Realidad",
            type: "true_damage", // Nuevo tipo
            logMessage: (enemyName, damage) => `${enemyName} desgarra el tejido de la realidad, ¡causándote ${damage} de daño verdadero que ignora toda defensa!`,
            effect: {
                damage: 500 // Un valor fijo y alto de daño verdadero
            }
        },
        // --- HABILIDADES DE CURACIÓN Y ROBO DE VIDA ---
        basic_heal: {
          name: "Recuperación Menor",
          type: "heal",
          logMessage: (enemyName, healAmount) =>
            `${enemyName} se concentra y recupera ${healAmount} de vida.`,
          effect: {
            healAmount: 50,
          },
        },
        life_drain: {
          name: "Drenaje Vital",
          type: "heal_damage", // Hace daño Y se cura
          logMessage: (enemyName, damage, healAmount) =>
            `¡${enemyName} usa Drenaje Vital! Te roba ${damage} de vida y se cura ${healAmount}.`,
          effect: {
            baseDamageMultiplier: 0.8,
            lifesteal: 0.5, // 50% del daño infligido se convierte en curación para el enemigo
          },
        },

        //--- HABILIDADES DE ATURDIMIENTO
        concussive_blow: {
          name: "Golpe Conmocionador",
          type: "stun_chance", // <--- TIPO NUEVO
          logMessage: (enemyName, damage, didStun) => {
            let msg = `${enemyName} te asesta un Golpe Conmocionador, infligiendo ${damage} de daño.`;
            if (didStun) {
              msg += " ¡Quedas aturdido y pierdes tu próximo turno!";
            }
            return msg;
          },
          effect: {
            baseDamageMultiplier: 0.7, // Menos daño directo a cambio del potente efecto
            stunChance: 0.4, // 40% de probabilidad de aturdir
          },
        },

        //  HABILIDADES DE BLANCO ESPECIAL

        //  Un ataque que golpea a un clon si está activo, o al jugador si no.
        clone_hunter: {
          name: "Cazador de Ilusiones",
          type: "special_target_damage", // <--- TIPO NUEVO
          logMessage: (enemyName, damage, target) => {
            if (target === "clone") {
              return `${enemyName} usa Cazador de Ilusiones y destruye tu clon!`;
            } else {
              return `${enemyName} usa Cazador de Ilusiones, ¡y te golpea directamente con ${damage} de daño!`;
            }
          },
          effect: {
            baseDamageMultiplier: 1.5, // Muy dañino si no hay clon
          },
        },
      };
//PATRONES DE FORMACIONES /  RUNAS
      const FORMATION_PATTERNS = {
      shattering_hexagram: {
          name: "Hexagrama Devastador",
          description: "Un patrón ofensivo que quiebra las defensas del enemigo al inicio del combate.",
          // El patrón es una matriz 5x5. 0=vacío, 1=runa, 2=centro (enemigo)
          pattern: [
              [0, 1, 0, 1, 0],
              [0, 0, 0, 0, 0],
              [1, 0, 2, 0, 1],
              [0, 0, 0, 0, 0],
              [0, 1, 0, 1, 0]
          ],
          effect: {
              type: 'enemy_debuff',
              stat: 'defense',
              amount: 50, // Reduce la defensa en 50 puntos
              duration: 'permanent' // Dura toda la batalla
          }
      },
      verdant_life_circle: {
          name: "Círculo de Vida Frondoso",
          description: "Un círculo de energía vital que te cura al inicio de cada uno de tus turnos en combate.",
          pattern: [
              [0, 1, 1, 1, 0],
              [1, 0, 0, 0, 1],
              [1, 0, 2, 0, 1],
              [1, 0, 0, 0, 1],
              [0, 1, 1, 1, 0]
          ],
          effect: {
              type: 'player_buff',
              stat: 'hpRegenPerTurn',
              amount: 20 // Regenera 20 HP por turno en batalla
          }
      },
      arcane_vortex_array: {
        name: "Matriz del Vórtice Arcano",
        description: "Una formación asimétrica que crea un pozo de energía espiritual, aumentando tu regeneración de maná durante el combate.",
        // Patrón: [0,0,1,1,1;1,0,0,0,1;0,0,2,0,0;1,0,0,0,1;1,1,1,0,0]
        pattern: [
            [0, 0, 1, 1, 1],
            [1, 0, 0, 0, 1],
            [0, 0, 2, 0, 0],
            [1, 0, 0, 0, 1],
            [1, 1, 1, 0, 0]
        ],
        effect: {
            type: 'player_buff',
            stat: 'manaRegenPerTurn', // Usaremos una nueva propiedad para esto
            amount: 15 // Regenera 15 de Maná por turno en batalla
        }
    },

    aegis_of_the_mountain: {
        name: "Égida de la Montaña Inamovible",
        description: "Este patrón de sellado canaliza la solidez de la tierra, otorgándote un significativo aumento de defensa al inicio del combate.",
        // Patrón: [1,1,1,1,1;1,0,0,0,1;1,0,2,0,1;0,0,0,0,0;0,0,1,0,0]
        // CORRECCIÓN: Tu patrón tenía un error de simetría, lo ajusté ligeramente para que tenga más sentido visual.
        // Si prefieres el original, simplemente copia y pega el tuyo. Este es el corregido:
        pattern: [
            [1, 1, 1, 1, 1],
            [1, 0, 0, 0, 1],
            [1, 0, 2, 0, 1],
            [1, 0, 0, 0, 1],
            [0, 0, 1, 0, 0]
        ],
        effect: {
            type: 'player_buff',
            stat: 'defenseBoost',
            amount: 40 // Aumenta la defensa en 40 puntos para toda la batalla
        }
    },
        emergency_return_matrix: {
        name: "Matriz de Retorno de Emergencia",
        description: "Una matriz que abre un portal directo al centro de la secta.",
        // El patrón es 3x3. El jugador estará en el centro (1) al completarlo.
        pattern: [
            [1, 0, 1],
            [0, 1, 0],
            [1, 0, 1]
        ],
        effect: {
            type: 'utility_teleport',
            // ¡Importante! Este ID debe coincidir con un teletransportador en TELEPORTER_DATA
            destinationId: 'tp_sect_hub' 
        }
    },
      // ¡Puedes añadir más patrones aquí en el futuro!
  };

      const entityTypes = {
        //FIJOS
        shop: {
          symbol: "🏪",
          name: "Tienda Misteriosa",
          spriteUrl: "img/shop.png",
          interaction: "browse",
          type: "shop", // 'type' es importante para la interacción
          // fixedX: 12, // Podrías tener esto
          // fixedY: 13, // O esto
          fixedLocation: { x: 12, y: 13 }, // O esto (preferiblemente esto)
          discovered: true, // ¡IMPORTANTE para que se muestre desde el inicio!
        },
        tutorial_formation_mural: {
            symbol: "🎨",
            name: "Mural de Formaciones Antiguas",
            spriteUrl: "img/mural_formaciones.png", // ¡Necesitarás crear esta imagen! (Ver nota abajo)
            interaction: "read_formation_tutorial", // Una nueva interacción específica
            fixedLocation: { x: 19, y: 14 }, // Cerca de la Anciana Su en la "biblioteca"
            discovered: true, // Para que sea visible desde el principio
        },
        mural_circulo_vital: {
          symbol: "🎨",
          name: "Mural Desgastado",
          spriteUrl: "img/mural_formaciones.png", // Puedes reutilizar la imagen existente
          interaction: "read_lore", // Un nuevo tipo de interacción
          loreText: "La imagen muestra ocho figuras rodeando a una novena en un círculo protector. Una inscripción casi ilegible reza: '...y en el abrazo de los ocho, la vida misma florece de nuevo...'",
          fixedLocation: { x: 58, y: 12 }, // Una ubicación escondida en el Bosque Esmeralda Profundo
          discovered: true,
      },

        secta_entrada_principal: {
          symbol: "⛩️",
          name: "Salón Principal de la Secta",
          spriteUrl: "img/secta.png",
          interaction: "access_sect_hall",
          // fixedX: 12, // Si tenías esto antes
          // fixedY: 15, // Si tenías esto antes
          // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 15, y: 15 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },
        secta_entrada_principal_2: {
          symbol: "",
          name: "Salón Principal de la Secta",
          
          interaction: "access_sect_hall",
          // fixedX: 12, // Si tenías esto antes
          // fixedY: 15, // Si tenías esto antes
          // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 16, y: 15 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },
        secta_entrada_principal_3: {
          symbol: "",
          name: "Salón Principal de la Secta",
          
          interaction: "access_sect_hall",
          // fixedX: 12, // Si tenías esto antes
          // fixedY: 15, // Si tenías esto antes
          // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 15, y: 14 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },
        secta_entrada_principal_4: {
          symbol: "",
          name: "Salón Principal de la Secta",
          
          interaction: "access_sect_hall",
          // fixedX: 12, // Si tenías esto antes
          // fixedY: 15, // Si tenías esto antes
          // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 16, y: 14 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },

        // --- ELEMENTOS DECORATIVOS ---
        deco_pino: {
          symbol: "🌳",
          name: "Pino",
          spriteUrl: "img/pino.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_pequeño: {
          symbol: "🌳",
          name: "Pino",
          spriteUrl: "img/arbol.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_normal: {
          symbol: "",
          name: "Otro arbol",
          spriteUrl: "img/arbol.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_desierto: {
          symbol: "🪨",
          name: "Roca Musgosa",
          spriteUrl: "img/deco_desierto.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_agua_estancada: {
          name: "Agua Estancada",
          spriteUrl: "img/agua_estancada.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_pantano: {
          symbol: "🌳",
          name: "Arbol Pantano",
          spriteUrl: "img/arbol_pantano.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_ruina_pilar: {
          symbol: "🏛",
          name: "Pilar Caído",
          spriteUrl: "img/columnas.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        }, // Usar un símbolo diferente si '🏛️' ya está en uso
        deco_flor_rara: {
          symbol: "🌸",
          name: "Flor Luminiscente",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_montaña: {
          symbol: "🏛",
          name: "Montaña",
          spriteUrl: "img/terreno_mont.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_montaña_large: {
          symbol: "🏛",
          name: "Montaña",
          spriteUrl: "img/deco_montaña_large.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        // === NUEVAS DECORACIONES DE ALTO NIVEL ===
        deco_huesos_gigantes: {
          symbol: "🦴",
          name: "Restos de Dragón",
          spriteUrl: "img/deco_huesos.png", // Necesitarás una imagen para esto
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_cristal_corrupto: {
          symbol: "🔮",
          name: "Cristal Demoníaco",
          spriteUrl: "img/deco_cristal_corrupto.png", // Necesitarás una imagen para esto
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },

        ///----------------- FIN DECORACIONES------------
        /// ============================  NPCs  ========================================
        npc_secta_guia: {
          symbol: "👨‍🏫",
          name: "Guía Lin",
          spriteUrl: "img/guia_lin.png",
          interaction: "talk_secta_npc",
          npcId: "guia_lin",
          fixedLocation: { x: 13, y: 15 },
          discovered: true,
        },
        npc_secta_admin: {
          symbol: " 👴",
          name: "Administrador Yao",
          spriteUrl: "img/adm_yao.png",
          interaction: "talk_secta_npc",
          npcId: "admin_yao",
          fixedLocation: { x: 17, y: 15 },
          discovered: true,
        },
        npc_anciana_su: {
          symbol: "👵",
          name: "Anciana Su, la Archivista",
          spriteUrl: "img/anciana_su.png",
          interaction: "talk_story_npc",
          npcId: "anciana_su",
          fixedLocation: { x: 18, y: 14 },
          discovered: true,
        },
        npc_maestro_jian: {
          symbol: "👑",
          name: "Maestro de Secta Jian",
          spriteUrl: "img/maestro_jian.png",
          interaction: "talk_story_npc",
          npcId: "maestro_jian",
          fixedLocation: { x: 15, y: 18 },
          discovered: true,
        },
        santuario_del_eco: {
          symbol: "⛩️",
          name: "Santuario del Eco",
          spriteUrl: "img/santuario_eco.png",
          interaction: "interact_shrine",
          type: "story_shrine",
          fixedLocation: { x: 330, y: 15 },
          discovered: false,
        },
        rival_interno_1: {
          symbol: "😠",
          name: "Han Li (Guardián Interno)",
          spriteUrl: "img/rival_1.png",
          typeOverride: "monster",
          hp: 250,
          attack: 60,
          defense: 15,
          exp: 150,
          maxHp: 250,
          isSectChallengeRival: true,
          npcId: "rival_interno_1",
          fixedLocation: { x: 5, y: 12 },
        },
        rival_principal_1: {
          symbol: "😡",
          name: "Anciana Shui (Prueba Principal)",
          spriteUrl: "img/rival_2.png",
          typeOverride: "monster",
          hp: 600,
          attack: 90,
          defense: 25,
          exp: 400,
          maxHp: 600,
          isSectChallengeRival: true,
          npcId: "rival_principal_1",
          fixedLocation: { x: 4, y: 12 },
          specialChance: 0.2,
          specialAttackMultiplier: 1.6,
        },
        guardian_diacono_1: {
          symbol: "👨‍⚖️",
          name: "Guardián de la Arena, Feng (Prueba de Diácono)",
          spriteUrl: "img/rival_3.png", // Necesitarás una imagen para él
          typeOverride: "monster",
          level: 28,
          hp: 2000,
          maxHp: 2000,
          attack: 150,
          defense: 80,
          exp: 1500,
          isSectChallengeRival: true,
          npcId: "guardian_diacono_1", // ID único para la misión
          abilities: [
            { abilityId: "armor_piercing_strike", chance: 0.3 },
            { abilityId: "stone_skin_1", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [300, 400],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 6, y: 14 }, // Posición en la Arena de la Secta
        },

        guardian_anciano_1: {
          symbol: "👴",
          name: "Anciano Guardián, Yao (Prueba de Anciano)",
          spriteUrl: "img/adm_yao.png", // Necesitarás una imagen para él
          typeOverride: "monster",
          level: 45,
          hp: 4500,
          maxHp: 4500,
          attack: 300,
          defense: 150,
          exp: 4000,
          isSectChallengeRival: true,
          npcId: "guardian_anciano_1",
          abilities: [
            { abilityId: "thorns_aura", chance: 0.25 },
            { abilityId: "life_drain", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [800, 1000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 7, y: 14 }, // Posición en la Arena de la Secta
        },

        guardian_gran_anciano_1: {
          symbol: "👵",
          name: "Gran Anciano de la Hoja, Lin (Prueba de Gran Anciano)",
          spriteUrl: "img/guia_lin.png", // Necesitarás una imagen para ella
          typeOverride: "monster",
          level: 62,
          hp: 8000,
          maxHp: 8000,
          attack: 550,
          defense: 220,
          exp: 8000,
          isSectChallengeRival: true,
          npcId: "guardian_gran_anciano_1",
          abilities: [
            { abilityId: "clone_hunter", chance: 0.3 },
            { abilityId: "concussive_blow", chance: 0.25 },
            { abilityId: "basic_heal", chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [1500, 2000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 5, y: 15 }, // Posición en la Arena de la Secta
        },

        guardian_maestro_1: {
          symbol: "👑",
          name: "Maestro de Secta Anterior (Prueba Final)",
          spriteUrl: "img/maestro_jian.png", // Necesitarás una imagen para él
          typeOverride: "monster",
          level: 75,
          hp: 15000,
          maxHp: 15000,
          attack: 700,
          defense: 300,
          exp: 15000,
          isSectChallengeRival: true,
          npcId: "guardian_maestro_1",
          abilities: [
            { abilityId: "mana_curse", chance: 0.4 },
            { abilityId: "intimidating_roar", chance: 0.3 },
            { abilityId: "fire_breath", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Sello del Maestro de Secta",
              quantity: [1, 1],
              chance: 1.0,
            },
          ], // Un item único como prueba
          fixedLocation: { x: 6, y: 15 }, // Posición en la Arena de la Secta
        },
        //== FIN NPC===
        //RECURSOS
        cristal_qi: {
          symbol: "💎",
          name: "Cristal de Qi",
          spriteUrl: "img/cristal_de_qi.png",
          reward: "Cristales de Qi",
          interaction: "collect_resource",
        },
        piedras_espirituales: {
          symbol: "💎",
          name: "Piedra espiritual",
          spriteUrl: "img/piedra_esp.png",
          reward: "Piedras Espirituales",
          interaction: "collect_resource",
        },
        cultivation: {
          symbol: "🌸",
          name: "Lugar de Cultivo",
          benefit: "mana",
          manaGain: 20,
          interaction: "meditate_spot",
        },
        resource_hierbas_bosque: {
          symbol: "🌿", // <--- ¡ASEGÚRATE DE QUE ESTO ESTÉ!
          name: "Hierbas del Bosque Profundo",
          spriteUrl: "img/hierbas.png",
          type: "resource",
          reward: "Hierbas Medicinales",
          interaction: "collect_resource",
        },
        // Tipo genérico para la plataforma
        teleport_platform: {
          symbol: "🌀",
          name: "Matriz de Teletransporte",
          spriteUrl: "img/teleport_plat.png", // ¡Necesitarás crear o encontrar esta imagen!
          interaction: "activate_teleporter", // Esta es la nueva interacción clave
          discovered: true, // Queremos que se vean en el mapa desde el principio
        },
        tp_sect_hub: {
          symbol: "🌀",
          name: "Matriz Central",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",
          teleporterId: "tp_sect_hub",
          fixedLocation: { x: 15, y: 10 },
          discovered: true,
        },
        tp_forest_shrine: {
          symbol: "🌀",
          name: "Matriz Bosque esmeralda",
          spriteUrl: "img/teleport_plat.png",

          teleporterId: "tp_forest_shrine",
          interaction: "activate_teleporter",
          fixedLocation: { x: 45, y: 25 },

          discovered: true,
        },
        tp_desert_oasis: {
          symbol: "🌀",
          name: "Matriz Desierto",
          spriteUrl: "img/teleport_plat.png",
          teleporterId: "tp_desert_oasis",
          interaction: "activate_teleporter",
          fixedLocation: { x: 40, y: 60 },
          discovered: false,
        },
        tp_swamp_ruin: {
          symbol: "🌀",
          name: "Matriz Ruinas 1",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",
          teleporterId: "tp_swamp_ruin",
          fixedLocation: { x: 75, y: 30 },
          discovered: false,
        },
        tp_desfiladero: {
          symbol: "🌀",
          name: "Matriz desfiladero",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",
          teleporterId: "tp_desfiladero",
          fixedLocation: { x: 125, y: 30 },
          discovered: false,
        },
        tp_dragon_valley: {
          symbol: "🌀",
          name: "Matriz del Valle del Dragón",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",  // La interacción clave
          teleporterId: "tp_dragon_valley",    // ¡DEBE coincidir con el ID de TELEPORTER_DATA!
          fixedLocation: { x: 150, y: 15 },    // La ubicación física DENTRO del valle
          discovered: true, // Para que sea visible en cuanto entres a la zona
      },

        // === NUEVAS ENTIDADES DE TRANSICIÓN ===
        transition_ruins_entrance: {
          symbol: "🌀",
          name: "Entrada a las Ruinas",
          spriteUrl: "img/entrada_ruinas.png", // Crea o usa una imagen para el portal
          interaction: "transition",
          fixedLocation: { x: 45, y: 45 }, // Ubicación en el mundo principal
          targetX: 501, // Coordenada X de destino (dentro de la zona de ruinas)
          targetY: 501, // Coordenada Y de destino
          discovered: true,
        },
        transition_ruins_exit: {
          symbol: "🌀",
          name: "Salida de las Ruinas",
          spriteUrl: "img/portal.png",
          interaction: "transition",
          fixedLocation: { x: 501, y: 500 }, // Ubicación DENTRO de las ruinas
          targetX: 45, // Coordenada X de destino (de vuelta al mundo principal)
          targetY: 45, // Coordenada Y de destino (aparece al lado de la entrada)
          discovered: true,
        },
        transition_valley_entrance: {
          symbol: "🌀",
          name: "Entrada al valle del Dragón",
          spriteUrl: "img/entrada_valle_dragon.png", // Crea o usa una imagen para el portal
          interaction: "transition",
          fixedLocation: { x: 143, y: 20 }, // Ubicación en el mundo principal
          targetX: 147, // Coordenada X de destino (dentro de la zona de ruinas)
          targetY: 20, // Coordenada Y de destino
          discovered: true,
        },
        transition_valley_exit: {
          symbol: "🌀",
          name: "Salida del valle del Dragón",
          spriteUrl: "img/entrada_valle_dragon.png",
          interaction: "transition",
          fixedLocation: { x: 147, y: 20 }, // Ubicación DENTRO de las ruinas
          targetX: 143, // Coordenada X de destino (de vuelta al mundo principal)
          targetY: 20, // Coordenada Y de destino (aparece al lado de la entrada)
          discovered: true,
        },
        transition_fisura_entrance: {
          symbol: "🌀",
          name: "Entrada a la Fisura Demoníaca",
          spriteUrl: "img/portal.png", // Puedes reutilizar un sprite de portal
          interaction: "transition",
          fixedLocation: { x: 200, y: 47 }, // Colócalo en una zona accesible del mapa principal
          targetX: 401, // Coordenada X de destino (dentro de la Fisura)
          targetY: 11,  // Coordenada Y de destino
          discovered: true,
      },
      transition_fisura_exit: {
          symbol: "🌀",
          name: "Salida de la Fisura",
          spriteUrl: "img/portal.png",
          interaction: "transition",
          fixedLocation: { x: 401, y: 10 }, // Ubicación DENTRO de la Fisura
          targetX: 140, // Coordenada X de vuelta al mapa principal
          targetY: 60,  // Coordenada Y de vuelta
          discovered: true,
      },

        //ENEMIGOS
        monster: {
          symbol: "👹",
          name: "Demonio Menor",
          spriteUrl: "img/demonio_menor.png",
          level: 2,
          hp: 90,
          attack: 30,
          defense: 2,
          exp: 25,
          maxHp: 60,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_secta_debil: {
          symbol: "🐾",
          name: "Bestia Menor de Pradera",
          spriteUrl: "img/monstruo_pradera.png",
          level: 1,
          hp: 40,
          attack: 30,
          defense: 1,
          exp: 12,
          maxHp: 40,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_bosque_lobo: {
          symbol: "🐺",
          name: "Lobo del Bosque",
          spriteUrl: "img/lobo_bosque.png",
          hp: 170,
          level: 2,
          attack: 40,
          defense: 3,
          exp: 20,
          maxHp: 170,
          lootTable: [
            { itemName: "Colmillo de Lobo", quantity: [1, 1], chance: 0.4 },
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.6,
            },
            { itemName: "Tinta Rúnica", quantity: [1, 2], chance: 0.6 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
          ],
        },
        monster_bosque_arana: {
          symbol: "🕷️",
          name: "Araña Tejesombras",
          hp: 250,
          level: 1,
          attack: 45,
          defense: 5,
          exp: 18,
          maxHp: 250,
          lootTable: [
            { itemName: "Seda de Araña", quantity: [1, 3], chance: 0.7 },
            { itemName: "Veneno Débil", quantity: [1, 1], chance: 0.2 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            {
              itemName: "Raíz de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.3,
            },
          ],
        },

        monster_desierto_escorpion: {
          symbol: "🦂",
          name: "Escorpión de las Dunas",
          spriteUrl: "img/escorpion.png",
          hp: 390,
          level: 9,
          attack: 30,
          defense: 10,
          exp: 35,
          maxHp: 390,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              abilityId: "poison_sting", // ID de la habilidad en enemyAbilityData
              chance: 0.4, // 40% de probabilidad de usar esta habilidad en su turno
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Tinta Rúnica", quantity: [1, 2], chance: 0.6 },
            { itemName: "Aguijón de Escorpión", quantity: [1, 1], chance: 0.5 },
            { itemName: "Quitina Resistente", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
          ],
        },
        monster_desierto_golem_arena: {
          symbol: "🧱",
          name: "Golem de Tormenta de Arena",
          spriteUrl: "img/golem_arena.png",
          hp: 400,
          level: 12,
          attack: 35,
          defense: 15,
          exp: 80,
          maxHp: 400,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              abilityId: " piel_de_piedra", // ID de la habilidad en enemyAbilityData
              chance: 0.4, // 40% de probabilidad de usar esta habilidad en su turno
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [2, 3], chance: 0.3 },
            { itemName: "Núcleo de Arena", quantity: [1, 1], chance: 0.6 },
            { itemName: "Fragmento Desértico", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
          ],
        },
        monster_cienaga_serpiente: {
          symbol: "🐍",
          name: "Serpiente de Ciénaga",
          spriteUrl: "img/serpiente.png",
          hp: 360,
          level: 15,
          attack: 50,
          defense: 6,
          exp: 100,
          maxHp: 360,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              abilityId: "poison_sting", // ID de la habilidad en enemyAbilityData
              chance: 0.3,
            },
          ],
          lootTable: [
            { itemName: "Escama de Serpiente", quantity: [1, 2], chance: 0.5 },
            
            { itemName: "Veneno de Ciénaga", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [4, 7], chance: 1 },
          ],
        },
        cultivator_rival_low: {
          symbol: "😠",
          name: "Cultivador Novato Hostil",
          spriteUrl: "img/cultivador_hostil.png",
          hp: 150,
          level: 5,
          attack: 50,
          defense: 5,
          exp: 80,
          maxHp: 150,
          specialChance: 0.2,
          specialAttackMultiplier: 1.5,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            { itemName: "Tinta Rúnica", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_alpha: {
          symbol: "🐺",
          name: "Lobo Alfa",
          spriteUrl: "img/lobo_alfa.png",
          hp: 200,
          level: 9,
          attack: 60,
          defense: 4,
          exp: 100,
          maxHp: 200,
          abilities: [
            { abilityId: "armor_break", chance: 0.3 },
            { abilityId: "intimidating_roar", chance: 0.2 },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            {
              itemName: "Núcleo de Bestia Menor",
              quantity: [1, 1],
              chance: 0.25,
            },
            { itemName: "Cristal de Hielo", quantity: [1, 2], chance: 0.1 },
            { itemName: "Esencia de Fuego", quantity: [1, 2], chance: 0.1 },
            { itemName: "Piedras Espirituales", quantity: [4, 10], chance: 1 },
          ],
        },
        cultivator_adept_hostile: {
          symbol: "😡",
          name: "Cultivador Adepto Agresivo",
          spriteUrl: "img/cultivador_hostil.png",
          hp: 400,
          level: 15,
          attack: 80,
          defense: 20,
          exp: 250,
          maxHp: 400,
          specialChance: 0.25,
          specialAttackMultiplier: 1.7,
          healChance: 0.1,
          lootTable: [
            { itemName: "Piedras Espirituales", quantity: [5, 10], chance: 1 },
            { itemName: "Cristales de Qi", quantity: [3, 10], chance: 0.3 },
            { itemName: "Tinta Rúnica", quantity: [3, 6], chance: 1 },
           
            { itemName: "Fragmentos de Jade", quantity: [1, 2], chance: 0.02 },
            { itemName: "Esencia Oscura", quantity: [1, 1], chance: 0.05 },
           
          
          ],
        },

        flor_luna_escarchada_guardian: {
          symbol: "❄️",
          name: "Espíritu de Hielo Protector",
          typeOverride: "monster",
          hp: 120,
          level: 5,
          attack: 35,
          defense: 10,
          exp: 40,
          maxHp: 120,
          lootTable: [
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.8,
            },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
          ],
        },
        raiz_fuego_terrenal_elemental: {
          symbol: "🔥",
          name: "Elemental de Magma Menor",
          typeOverride: "monster",
          hp: 150,
          level: 17,
          attack: 40,
          defense: 5,
          exp: 45,
          maxHp: 150,
          lootTable: [
            {
              itemName: "Raíz de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.7,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [5, 10],
              chance: 0.5,
            },
          ],
        },
        

        esqueleto_podrido: {
          symbol: "💀",
          name: "Esqueleto podrido",
          spriteUrl: "img/esqueleto_1.png",
          typeOverride: "monster",
          hp: 500,
          maxHp: 500,
          level: 20,
          attack: 80,
          defense: 30,
          exp: 120,
          abilities: [
            { abilityId: "mana_curse", chance: 0.35 }, // Dificulta a los jugadores que usan maná
            { abilityId: "basic_heal", chance: 0.2 }, // Prolonga el combate curándose
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [8, 10],
              chance: 0.8,
            },
          ],
        },
        jabali_alfa_1: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 53, y: 26 },
        },
        jabali_alfa_2: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 55, y: 26 },
        },
        jabali_alfa_3: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 57, y: 26 },
        },
        jabali_alfa_4: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 59, y: 26 },
        },
        jabali_alfa_5: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 50, y: 28 },
        },
        jabali_alfa_6: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 28 },
        },
        jabali_alfa_7: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 54, y: 28 },
        },
        jabali_alfa_8: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 56, y: 30 },
        },
        jabali_alfa_9: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            /* (mismo loot) */
          ],
          fixedLocation: { x: 58, y: 30 },
        },
        jabali_alfa_10: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 55, y: 32 },
        },
        jabali_alfa_10: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 30 },
        },
        jabali_alfa_11: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 32 },
        },
        jabali_alfa_12: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 34 },
        },
        // ==========================================================
        // === NUEVOS ENEMIGOS DE NIVEL MEDIO (10-20) ===
        // ==========================================================

        // --- ENEMIGOS DEL BOSQUE PROFUNDO ---

        // 1. Osa Mayor Esmeralda (Tanque con Buff de Defensa)
        osa_mayor_esmeralda: {
          symbol: "🐻",
          name: "Osa Mayor Esmeralda",
          spriteUrl: "img/osa_mayor.png", // Necesitarías un sprite para este
          level: 12,
          hp: 1450,
          maxHp: 1450,
          attack: 90,
          defense: 25,
          exp: 150,
          abilities: [
            { abilityId: "stone_skin_1", chance: 0.3 }, // Se vuelve muy dura
            { abilityId: "concussive_blow", chance: 0.15 }, // Un golpe poderoso pero poco frecuente
          ],
          lootTable: [
            {
              itemName: "Piel de Bestia Gruesa",
              quantity: [1, 2],
              chance: 0.7,
            },
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [2, 4],
              chance: 0.5,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 20],
              chance: 1.0,
            },
          ],
        },

        // 2. Treant Anciano (Drenaje de Recursos y Curación)
        treant_anciano: {
          symbol: "🌳",
          name: "Treant Anciano",
          spriteUrl: "img/treant.png", // Necesitarías un sprite para este
          level: 12,
          hp: 600,
          maxHp: 600,
          attack: 80,
          defense: 30,
          exp: 220,
          abilities: [
            { abilityId: "mana_curse", chance: 0.35 }, // Dificulta a los jugadores que usan maná
            { abilityId: "basic_heal", chance: 0.2 }, // Prolonga el combate curándose
          ],
          lootTable: [
            {
              itemName: "Corazón de Madera Viviente",
              quantity: [1, 1],
              chance: 0.4,
            },
            { itemName: "Tinta Rúnica", quantity: [4, 8], chance: 1 },
            { itemName: "Semillas Ancestrales", quantity: [1, 3], chance: 0.2 },
            {
              itemName: "Piedras Espirituales",
              quantity: [15, 25],
              chance: 1.0,
            },
          ],
        },

        // --- ENEMIGOS DE LA CIÉNAGA SOMBRÍA ---

        // 3. Basilisco de Ciénaga (Aturdimiento y Veneno)
        basilisco_cienaga: {
          symbol: "🦎",
          name: "Basilisco de Ciénaga",
          spriteUrl: "img/basilisco.png", // Necesitarías un sprite para este
          level: 12,
          hp: 1380,
          maxHp: 1380,
          attack: 65,
          defense: 80,
          exp: 300,
          abilities: [
            { abilityId: "concussive_blow", chance: 0.25 }, // Simula una mirada petrificante con el stun
            { abilityId: "poison_sting", chance: 0.4 }, // Su mordida es venenosa
          ],
          lootTable: [
            { itemName: "Ojo de Basilisco", quantity: [1, 1], chance: 0.3 },
            { itemName: "Escamas Iridiscentes", quantity: [2, 3], chance: 0.6 },
            {
              itemName: "Piedras Espirituales",
              quantity: [12, 22],
              chance: 1.0,
            },
          ],
        },
        bandido_desfiladero: {
          symbol: "😠",
          name: "Bandido del Desfiladero",
          spriteUrl: "img/mercenario.png",
          typeOverride: "monster",
          hp: 600,
          level: 14,
          attack: 100,
          defense: 80,
          exp: 600,
          maxHp: 600,
          healChance: 0.15,
          abilities: [
            { abilityId: "stone_skin_1", chance: 0.4 }, // Siempre mantiene su defensa alta
            { abilityId: "concussive_blow", chance: 0.2 }, // Golpe de escudo
            { abilityId: "armor_piercing_strike", chance: 0.6 },
            { itemName: "Tinta Rúnica", quantity: [5, 10], chance: 1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 30],
              chance: 0.5,
            },
           
          ],
          
        },
        // 4. Espectro del Pantano (Drena Vida y Debilita)
        espectro_pantano: {
          symbol: "👻",
          name: "Espectro del Pantano",
          spriteUrl: "img/espectro.png", // Necesitarías un sprite para este
          level: 11,
          hp: 550,
          maxHp: 550,
          attack: 180,
          defense: 15, // Baja defensa física, pero peligroso
          exp: 250,
          abilities: [
            { abilityId: "life_drain", chance: 0.8 }, // Se cura a costa del jugador
            { abilityId: "intimidating_roar", chance: 0.25 }, // Su lamento debilita el ataque
          ],
          lootTable: [
            { itemName: "Esencia Espectral", quantity: [1, 2], chance: 0.5 },
            { itemName: "Almas Condenadas", quantity: [1, 1], chance: 0.25 },
            {
              itemName: "Piedras Espirituales",
              quantity: [20, 30],
              chance: 1.0,
            },
          ],
        },

        // --- ENEMIGOS DEL DESIERTO ABRASADOR ---

        // 5. Djinn de las Arenas (Ataque perforante)
        djinn_arenas: {
          symbol: "🧞",
          name: "Djinn de las Arenas",
          spriteUrl: "img/djinn.png", // Necesitarías un sprite para este
          level: 12,
          hp: 650,
          maxHp: 650,
          attack: 100,
          defense: 20,
          exp: 300,
          abilities: [
            { abilityId: "armor_piercing_strike", chance: 0.4 }, // Su cimitarra de viento corta cualquier armadura
            { abilityId: "fire_breath", chance: 0.2 }, // Aliento abrasador del desierto
          ],
          lootTable: [
            {
              itemName: "Corazón de Tormenta de Arena",
              quantity: [1, 1],
              chance: 0.2,
            },
            { itemName: "Esencia de Fuego", quantity: [2, 4], chance: 0.5 },
            {
              itemName: "Piedras Espirituales",
              quantity: [25, 40],
              chance: 1.0,
            },
          ],
        },

        // 6. Gusano de las Dunas Colosal (Tanque con reflejo de daño)
        gusano_dunas_colosal: {
          symbol: "🐛",
          name: "Gusano de las Dunas Colosal",
          spriteUrl: "img/gusano.png", // Necesitarías un sprite para este
          level: 13,
          hp: 1000,
          maxHp: 1000,
          attack: 160,
          defense: 60,
          exp: 500,
          abilities: [
            { abilityId: "thorns_aura", chance: 0.3 }, // Su piel quitinosa daña a los atacantes
            { abilityId: "armor_break", chance: 0.2 }, // Su mordida aplastante rompe defensas
          ],
          lootTable: [
    
            {
              itemName: "Piedras Espirituales",
              quantity: [50, 75],
              chance: 1.0,
            },
          ],
        },

        // --- CULTIVADORES RIVALES Y BANDIDOS ---

        // 7. Cultivador Renegado (Equilibrado y peligroso)
        cultivador_renegado: {
          symbol: "😡",
          name: "Cultivador Renegado",
          spriteUrl: "img/cultivador_hostil.png", // Un sprite de cultivador más avanzado
          level: 14,
          hp: 500,
          maxHp: 500,
          attack: 75,
          defense: 50,
          exp: 1000,
          abilities: [
            { abilityId: "armor_piercing_strike", chance: 0.25 }, // Sabe dónde golpear
            { abilityId: "basic_heal", chance: 0.15 }, // Usa píldoras para curarse
            { abilityId: "fire_breath", chance: 0.2 }, // Usa una técnica de fuego
            { itemName: "Tinta Rúnica", quantity: [10, 20], chance: 1 },
          ],
          lootTable: [
            {
              itemName: "Píldora de Recuperación Menor",
              quantity: [1, 2],
              chance: 0.3,
            },
           /*  {
              itemName: "Rollo: Técnica Aleatoria Menor",
              quantity: [1, 1],
              chance: 0.05,
            }, // Requeriría una lógica de loot especial */
            {
              itemName: "Piedras Espirituales",
              quantity: [30, 50],
              chance: 1.0,
            },
          ],
        },

        // 8. Mercenario Acorazado (Defensa y Stun)//valle del dragon
        mercenario_acorazado: {
          symbol: "🛡️",
          name: "Mercenario Acorazado",
          spriteUrl: "img/mercenario.png", // Necesitarías un sprite para este
          level: 18,
          hp: 1500,
          maxHp: 1500,
          attack: 150,
          defense: 70,
          exp: 1600,
          abilities: [
            { abilityId: "stone_skin_1", chance: 0.4 }, // Siempre mantiene su defensa alta
            { abilityId: "concussive_blow", chance: 0.2 }, // Golpe de escudo
          ],
          lootTable: [
            {
              itemName: "Fragmento de Armadura Pesada",
              quantity: [1, 1],
              chance: 0.6,
            },
            {
              itemName: "Contrato de Mercenario",
              quantity: [1, 1],
              chance: 0.1,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [15, 25],
              chance: 1.0,
            },
          ],
        },

        // --- ENEMIGOS DE RUINAS ANTIGUAS ---

        // 9. Guardián de Terracota (Defensivo y con Reflejo)
        guardian_terracota: {
          symbol: "🗿",
          name: "Guardián de Terracota",
          spriteUrl: "img/guardian_terracota.png", // Necesitarías un sprite para este
          level: 10,
          hp: 1000,
          maxHp: 1000,
          attack: 70,
          defense: 50,
          exp: 350,
          abilities: [
            { abilityId: "thorns_aura", chance: 0.25 }, // Su superficie encantada devuelve el daño
            { abilityId: "stone_skin_1", chance: 0.25 }, // Se endurece aún más
            { abilityId: "armor_break", chance: 0.15 }, // Un golpe para ablandar al objetivo
          ],
          lootTable: [
            { itemName: "Fragmentos de Jade", quantity: [2, 5], chance: 0.5 },
            {
              itemName: "Núcleo de Golem Antiguo",
              quantity: [1, 1],
              chance: 0.2,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [40, 60],
              chance: 1.0,
            },
          ],
        },

        // 10. Ilusionista Sombrío (Cazador de Clones y Drenaje de Maná)// valle del dragon
        ilusionista_sombrio: {
          symbol: "👤",
          name: "Ilusionista Sombrío",
          spriteUrl: "img/ilusionista.png", // Necesitarías un sprite para este
          level: 20,
          hp: 800,
          maxHp: 800,
          attack: 85, // Golpea duro si te pilla sin defensas
          defense: 40,
          exp: 320,
          abilities: [
            { abilityId: "clone_hunter", chance: 0.5 }, // Su principal estrategia es eliminar clones
            { abilityId: "mana_curse", chance: 0.3 }, // Te deja sin recursos para contraatacar
          ],
          lootTable: [
    
            {
              itemName: "Piedras Espirituales",
              quantity: [35, 55],
              chance: 1.0,
            },
          ],
        },
        // === NUEVOS ENEMIGOS Y JEFES DE ALTO NIVEL ===

        // -- Nivel Diácono (Nivel 15-18) --
        cultivador_secta_rival: {
          symbol: "⚔️",
          name: "Cultivador de la Secta de la Llama Negra",
          spriteUrl: "img/rival_1.png",
          level: 15,
          hp: 800,
          maxHp: 800,
          attack: 170,
          defense: 80,
          exp: 450,
          abilities: [
            { abilityId: "fire_breath", chance: 0.3 },
            { abilityId: "armor_piercing_strike", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Píldora de Recuperación Menor",
              quantity: [1, 2],
              chance: 0.2,
            },
            {
              itemName: "Insignia de Secta Rival",
              quantity: [1, 1],
              chance: 0.5,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [40, 60],
              chance: 1.0,
            },
            { itemName: "Tinta Rúnica", quantity: [10, 20], chance: 1 },

          ],
        },
        murcielago_cristal_sangriento: {
          symbol: "🦇",
          name: "Murciélago de Cristal Sangriento",
          spriteUrl: "img/murcielago_sangre.png",
          level: 16,
          hp: 800,
          maxHp: 800,
          attack: 190,
          defense: 80,
          exp: 500,
          abilities: [{ abilityId: "life_drain", chance: 0.4 }],
          lootTable: [
            {
              itemName: "Cristal de Sangre Puro",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [50, 75],
              chance: 1.0,
            },
          ],
        },
        diacono_renegado_jin: {
          symbol: "👿",
          name: "Diácono Renegado Jin (Jefe)",
          spriteUrl: "img/rival_3.png",
          typeOverride: "monster",
          level: 17,
          hp: 2500,
          maxHp: 2500,
          attack: 180,
          defense: 60,
          exp: 2000,
          isBoss: true,
          abilities: [
            { abilityId: "thorns_aura", chance: 0.3 },
            { abilityId: "armor_break", chance: 0.25 },
            { abilityId: "basic_heal", chance: 0.15 },
          ],
          lootTable: [
           
            {
              itemName: "Piedras Espirituales",
              quantity: [50, 100],
              chance: 1.0,
            },
            {
            itemName: "Rollo: Técnica de Absorción de Qi Celestial",
              quantity: [1, 1],
              chance: 1.0, // 
            },
            { itemName: "Tinta Rúnica", quantity: [20, 50], chance: 1 },
          ],
          fixedLocation: { x: 90, y: 15 }, // Ubicación en el Desfiladero
        },

        // -- Nivel Anciano (Nivel 35-45) --
        draco_hueso_antiguo: {
          symbol: "🐉",
          name: "Draco de Hueso Antiguo",
          spriteUrl: "img/draco_hueso.png",
          level: 18,
          hp: 1500,
          maxHp: 1500,
          attack: 350,
          defense: 100,
          exp: 1200,
          abilities: [
            { abilityId: "intimidating_roar", chance: 0.3 },
            { abilityId: "mana_curse", chance: 0.2 },
            { abilityId: 'fire_breath', chance: 0.3 },
          ],
          lootTable: [
            {
              itemName: "Escama de Dragón Espectral",
              quantity: [1, 2],
              chance: 0.4,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [200, 250],
              chance: 1.0,
            },
          ],
        },
        draco_hueso_antiguo_boss: {
          symbol: "🐉",
          name: "Draco de Hueso Antiguo (BOSS)",
          spriteUrl: "img/draco_hueso_boss.png",
          level: 19,
          hp: 2000,
          maxHp: 2000,
          attack: 380,
          defense: 120,
          exp: 12000,
          abilities: [
            { abilityId: "intimidating_roar", chance: 0.8 },
            { abilityId: "mana_curse", chance: 0.5 },
            { abilityId: 'fire_breath', chance: 0.3 }
          ],
          lootTable: [
            {
              itemName: "Escama de Dragón Espectral",
              quantity: [1, 2],
              chance: 0.4,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [1000, 1200],
              chance: 1.0,
            },
          ],
        },
        espectro_tifonico: {
          symbol: "🌪️",
          name: "Espectro Tifónico",
          spriteUrl: "img/espectro_tifon.png",
          level: 18,
          hp: 1200,
          maxHp: 1200,
          attack: 700,
          defense: 80,
          exp: 1500,
          abilities: [
            { abilityId: "mana_curse", chance: 0.4 },
            { abilityId: "concussive_blow", chance: 0.6 },
          ],
          lootTable: [
            { itemName: "Corazón de Tifón", quantity: [1, 1], chance: 0.25 },
            {
              itemName: "Piedras Espirituales",
              quantity: [120, 250],
              chance: 1.0,
            },
          ],
        },
        emperador_lich_del_valle: {
          symbol: "👑",
          name: "Emperador Lich del Valle (Jefe)",
          spriteUrl: "img/lich_emperador.png",
          typeOverride: "monster",
          level: 19,
          hp: 5000,
          maxHp: 5000,
          attack: 900,
          defense: 120,
          exp: 5000,
          isBoss: true,
          // --- LÍNEA CLAVE AÑADIDA ---
          // Ahora el jefe tiene un ID que el sistema de misiones puede reconocer.
          npcId: "emperador_lich_del_valle",
          // --- FIN DE LA LÍNEA AÑADIDA ---
          abilities: [
              { abilityId: "life_drain", chance: 0.3 },
              { abilityId: "mana_curse", chance: 0.3 },
              { abilityId: "clone_hunter", chance: 0.2 },
          ],
          lootTable: [
              { itemName: "Filacteria del Lich", quantity: [1, 1], chance: 1.0 },
              { itemName: "Rollo: Técnica de Anciano Aleatoria", quantity: [1, 1], chance: 1.0 },
              { itemName: "Piedras Espirituales", quantity: [200, 250], chance: 1.0 },
          ],
          fixedLocation: { x: 200, y: 42 },
      },

        // -- Nivel Gran Anciano (Nivel 50-60) --
        demonio_de_la_fisura: {
          symbol: "👹",
          name: "Demonio de la Fisura",
          spriteUrl: "img/demonio_fisura.png",
          level: 20,
          hp: 2500,
          maxHp: 2500,
          attack: 50000,
          defense: 350,
          exp: 3000,
          abilities: [
            {
              abilityId: "fire_breath",
              chance: 0.5,
              effect: { burnDamagePerTurn: 5000, duration: 3 },
            },
            { abilityId: "armor_break", chance: 0.6 },
            { abilityId: "shattering_curse", chance: 0.4 },
            { abilityId: "armor_piercing_strike", chance: 0.6 },
          ],
          lootTable: [
            {
              itemName: "Fragmento de la Fisura",
              quantity: [1, 1],
              chance: 0.4,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [250, 400],
              chance: 1.0,
            },
          ],
        },
        guardian_celestial_caido: {
          symbol: "👼",
          name: "Guardián Celestial Caído",
          spriteUrl: "img/guardian_caido.png",
          level: 25,
          hp: 4000,
          maxHp: 4000,
          attack: 30500,
          defense: 450,
          exp: 4000,
          abilities: [
          { abilityId: "reality_tear", chance: 0.3 },
            { abilityId: "stone_skin_1", chance: 0.3 },
            { abilityId: "basic_heal", chance: 0.6 },
            { abilityId: "armor_piercing_strike", chance: 0.2 },
          ],
          lootTable: [
            { itemName: "Lágrima Celestial", quantity: [1, 1], chance: 0.2 },
            {
              itemName: "Piedras Espirituales",
              quantity: [300, 500],
              chance: 1.0,
            },
          ],
        },
        general_demoniaco_abismal: {
          symbol: "😈",
          name: "General Demoníaco Abismal (Jefe)",
          spriteUrl: "img/general_abismal.png",
          typeOverride: "monster",
          level: 65,
          hp: 10000,
          maxHp: 10000,
          attack: 58600,
          defense: 500,
          exp: 10000,
          isBoss: true,
          abilities: [
            { abilityId: "abyssal_drain", chance: 0.4 }, 
            { abilityId: "shattering_curse", chance: 0.3 }, 
            { abilityId: "intimidating_roar", chance: 0.4 },
            { abilityId: "thorns_aura", chance: 0.3 },
            { abilityId: "fire_breath", chance: 0.2 },
          ],
          lootTable: [
            { itemName: "Corazón del Abismo", quantity: [1, 1], chance: 1.0 },
            {
              itemName: "Rollo: Técnica de Gran Anciano Aleatoria",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [2000, 3000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 425, y: 35 }, // Ubicación en la Fisura
        },

        // -- Nivel Maestro de Secta (Nivel 70+) --
        avatar_del_dao_corrupto: {
          symbol: "☯️",
          name: "Avatar del Dao Corrupto (Jefe Final)",
          spriteUrl: "img/avatar_dao.png",
          typeOverride: "monster",
          level: 80,
          hp: 25000,
          maxHp: 25000,
          attack: 800,
          defense: 300,
          exp: 50000,
          isBoss: true,
          abilities: [
            { abilityId: "mana_curse", chance: 0.5 },
            { abilityId: "life_drain", chance: 0.4 },
            { abilityId: "thorns_aura", chance: 0.3 },
            { abilityId: "concussive_blow", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Semilla del Dao Verdadero",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [10000, 10000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 15, y: 12 }, // Aparece cerca de la secta para el enfrentamiento final
        },

        //BOSSES
        jabali_colmilludo_alfa: {
          symbol: "🐗",
          name: "Jabalí Colmilludo Alfa (BOSS)",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 400,
          level: 10,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,
          isBoss: true,
          healChance: 0.2,
          lootTable: [
            {
              itemName: "Colmillo de Jabalí Alfa",
              quantity: [1, 1],
              chance: 0.9,
            },
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },
            { itemName: "Piel Resistente", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [6, 10], chance: 1 },
          ],
          fixedLocation: { x: 57, y: 28 },
        },

        golem_de_piedra: {
          symbol: "🗿",
          name: "Golem de piedra",
          spriteUrl: "img/golem_jade.png",
          typeOverride: "monster",
          hp: 800,
          level: 11,
          attack: 55,
          defense: 50,
          exp: 500,
          maxHp: 800,
          abilities: [
            {
              name: "Golpe Sísmico",
              damageMultiplier: 2.0,
              chance: 0.1,
              type: "area_attack_simulated",
            },
            { name: "Restauración Pétrea", healPercentage: 0.2, chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 15],
              chance: 1.0,
            },
            {
              itemName: "Corazón de Golem de Jade",
              quantity: [1, 1],
              chance: 0.9,
            },

            { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
            {
              itemName: "Núcleo Elemental",
              quantity: [1, 2],
              chance: 0.3,
              extraData: { elementalType: "earth" },
            },
          ],
        },

        lider_renegado_1: {
          symbol: "👤",
          name: "Líder Cultor Renegado Kai",
          typeOverride: "monster",
          hp: 500,
          level: 15,
          attack: 70,
          defense: 25,
          exp: 250,
          maxHp: 500,
          isMiniBoss: true,
          specialChance: 0.25,
          specialAttackMultiplier: 1.6,
          lootTable: [
            {
              itemName: "Compás Espiritual Antiguo",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Píldora de Qi Condensado",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 20],
              chance: 0.8,
            },
          ],
          fixedLocation: { x: 17, y: 12 },
        },

        //BOSSES

        boss_dem: {
          symbol: "👿",
          name: "General Demonio",
          spriteUrl: "img/boss_dem.png",
          typeOverride: "monster",
          hp: 500,
          level: 10,
          attack: 45,
          defense: 20,
          exp: 1000,
          maxHp: 500,
          isBoss: true,
          npcId: "boss_dem",
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          healChance: 0.15,
          abilities: [{ abilityId: "fire_breath", chance: 0.3 }],

          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [20, 100],
              chance: 1.0,
            },
            {
              itemName: "Núcleo Demoníaco Mayor",
              quantity: [1, 1],
              chance: 0.8,
            },
       

        
          ],
          
          fixedLocation: { x: 9, y: 36 },
        },

        boss_ancient_golem: {
          symbol: "🗿",
          name: "Golem Ancestral de Jade",
          spriteUrl: "img/golem_jade.png",
          typeOverride: "monster",
          hp: 800,
          level: 11,
          attack: 65,
          defense: 50,
          exp: 500,
          maxHp: 800,
          isBoss: true,
          npcId: "boss_ancient_golem",
          abilities: [
            {
              name: "Golpe Sísmico",
              damageMultiplier: 2.0,
              chance: 0.2,
              type: "area_attack_simulated",
            },
            { name: "Restauración Pétrea", healPercentage: 0.2, chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 15],
              chance: 1.0,
            },
            {
              itemName: "Corazón de Golem de Jade",
              quantity: [1, 1],
              chance: 0.9,
            },

            { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
            {
              itemName: "Núcleo Elemental",
              quantity: [1, 2],
              chance: 0.3,
              extraData: { elementalType: "earth" },
            },
            { itemName: "Diagrama: Hexagrama Devastador", quantity: [1, 1], chance: 1.0 }, // 
          ],
          
          fixedLocation: { x: 72, y: 51 },
        },
      };
      //------------------------   ITEMS ---------------------------------------------------
      const itemData = {
        "Tinta Rúnica": {
            description: "Tinta especial para inscribir runas de poder. No se puede usar directamente.",
            canUse: () => false, // No es un consumible normal
        },
        "Diagrama: Hexagrama Devastador": {
            description: "Un trozo de pergamino antiguo. Muestra un diagrama de seis puntos rodeando un centro [0, 0, 0, 0, 0][1, 0, 2, 0, 1][0, 0, 0, 0, 0][0, 1, 0, 1, 0] con notas que dicen: 'El sello del caparazón se rompe cuando la estrella lo abraza.'",
            canUse: () => false, // Es un objeto de lore, no se consume
        },
        "Hierbas Medicinales": {
          description: "Restaura un 30 de HP.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al máximo.";
            const h = 30;
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Usada Píldora, recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Cristales de Qi": {
          description: "Restaura un 30% de tu Maná Máximo.",
          effect: (ps) => {
            if (ps.mana >= ps.maxMana) return "Maná al máximo.";
            const h = Math.floor(ps.maxMana * 0.3);
            const o = ps.mana;
            ps.mana = Math.min(ps.maxMana, ps.mana + h);
            return `Recuperado ${ps.mana - o} Maná.`;
          },
          canUse: (ps) => ps.mana < ps.maxMana,
        },
        "Piedras Espirituales": {
          description: "Imbuida de energía. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Piedra Espiritual y ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Flor de Luna Escarchada": {
          description: "Flor brillante usada en alquimia.Item de misión",
          canUse: () => false,
        },
        "Raíz de Fuego Terrenal": {
          description: "Raíz que irradia calor, ingrediente alquímico.",
          canUse: () => false,
        },
        "Píldora de Recuperación Menor": {
          description: "Píldora alquímica que restaura 50 HP.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al máximo.";
            const h = 50;
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Usada Píldora, recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Esencia Espectral": {
          description:
            "Un residuo etéreo dejado por un espectro. Se usa en rituales y alquimia avanzada. Item de Misión.",
          canUse: () => false, // No es un consumible
        },
        "Talismán de Percepción": {
          description: "Agudiza sentidos. Otorga EXP.",
          effect: (ps, gex) => {
            gex(100);
            return `Estudiado Talismán, ganado 100 EXP.`;
          },
          canUse: () => true,
        },
        "Colmillo de Jabalí Alfa": {
          description:
            "Colmillo intacto de Jabalí Alfa. Item de misión de caza.",
          canUse: () => false,
        },
        "Carne de Bestia Exótica": {
          description: "Nutritiva. Restaura 25% HP y 10% Maná.",
          effect: (ps) => {
            let m = "";
            const hA = Math.floor(ps.maxHp * 0.25);
            if (ps.hp < ps.maxHp) {
              const o = ps.hp;
              ps.hp = Math.min(ps.maxHp, ps.hp + hA);
              m += `Recuperado ${ps.hp - o} HP. `;
            }
            const mA = Math.floor(ps.maxMana * 0.1);
            if (ps.mana < ps.maxMana) {
              const o = ps.mana;
              ps.mana = Math.min(ps.maxMana, ps.mana + mA);
              m += `Recuperado ${ps.mana - o} Maná.`;
            }
            return m || "HP y Maná al máximo.";
          },
          canUse: (ps) => ps.hp < ps.maxHp || ps.mana < ps.maxMana,
        },
        "Mapa del Tesoro Fragmentado": {
          description: "Fragmento de mapa antiguo. ¿Otras partes?",
          effect: (ps, gex) => {
            gex(50);
            return `Examinado fragmento, ganado 50 EXP. Indica zona montañosa...`;
          },
          canUse: () => true,
        },
        "Compás Espiritual Antiguo": {
          description: "Artefacto de secta que resuena con energías.",
          canUse: () => false,
        },
        "Manual de Formación Básica": {
          description: "Enseña principios de formaciones defensivas.",
          effect: (ps) => {
            ps.baseDefense += 2;
            recalculatePlayerStats();
            return `Estudiado Manual. Defensa base +2.`;
          },
          canUse: () => true,
        },
        "Núcleo de Bestia Menor": {
          description: "Núcleo de bestia demoníaca. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido Núcleo, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Insignia de Secta Rival": {
          description:
            "Una insignia de la Secta de la Llama Negra. Prueba de tus victorias.",
          canUse: () => false,
        },
        "Cristal de Sangre Puro": {
          description:
            "Un cristal que pulsa con energía vital. Valioso para la alquimia de alto nivel.",
          canUse: () => false,
        },
        "Manual de Técnica de Diácono": {
          description:
            "Un manual que detalla una técnica de nivel Diácono. Contiene profundos conocimientos.",
          effect: (ps, gex) => {
            gex(1000); // Da una buena cantidad de EXP
            return `Has estudiado el manual del diácono renegado. Ganas 1000 EXP y una nueva comprensión del combate.`;
          },
          canUse: () => true,
        },
        "Escama de Dragón Espectral": {
          description:
            "Una escama etérea y resistente, imbuida con el resentimiento de un dragón.",
          canUse: () => false,
        },
        "Corazón de Tifón": {
          description:
            "El núcleo arremolinado de un espectro elemental. Irradia un poder inmenso.",
          canUse: () => false,
        },
        "Filacteria del Lich": {
          description:
            "El recipiente del alma del Emperador Lich. Su destrucción asegura su final. Irradia poder oscuro.",
          effect: (ps, gex) => {
            gex(5000);
            return `Al destruir la filacteria, una oleada de energía pura te recorre. Ganas 5000 EXP.`;
          },
          canUse: () => true,
        },
        "Fragmento de la Fisura": {
          description:
            "Un trozo de realidad de un plano demoníaco. Es inestable y peligroso.",
          canUse: () => false,
        },
        "Lágrima Celestial": {
          description:
            "Una lágrima cristalizada de un ser celestial. Contiene una pureza increíble.",
          canUse: () => false,
        },
        "Corazón del Abismo": {
          description:
            "El corazón de un general demoníaco. Es la fuente de su poder abismal.",
          effect: (ps, gex) => {
            gex(10000);
            player.baseMaxHp += 500;
            recalculatePlayerStats();
            return `Has purificado el Corazón del Abismo, fortaleciendo tu propia base vital. Ganas 10000 EXP y 500 HP Máximo base.`;
          },
          canUse: () => true,
        },
        "Rollo: Técnica de Gran Anciano Aleatoria": {
          description: "Un rollo que contiene el conocimiento de una poderosa técnica de nivel Gran Anciano.",
          effect: (ps) => {
              // Lógica para dar una técnica aleatoria de nivel 5
              const t5_techniques = ["sword_t5", "body_t5", "fire_t5", "lightning_t5", "formation_t5", "movement_t5"];
              const availableTechniques = t5_techniques.filter(t => !ps.learnedTechniques[t]);
              if (availableTechniques.length > 0) {
                  const randomTechId = availableTechniques[Math.floor(Math.random() * availableTechniques.length)];
                  return learnTechniqueFromRoll(ps, randomTechId);
              }
              return "Ya conoces todas las técnicas de este nivel. El rollo se disipa en pura energía, otorgando 5000 EXP.";
          },
          canUse: () => true,
      },
        "Semilla del Dao Verdadero": {
          description:
            "Un fragmento del origen de toda la cultivación. Su estudio podría llevarte a la trascendencia.",
          effect: (ps) => {
            // Podría desbloquear una mecánica de post-juego o dar una mejora final masiva.
            ps.level += 5;
            levelUp(); // Simula varias subidas de nivel
            return `Has meditado sobre la Semilla del Dao, alcanzando una iluminación sin precedentes. Tu nivel y poder se disparan.`;
          },
          canUse: () => true,
        },
        
      

        "Sello del Maestro de Secta": {
          description:
            "La prueba de que has superado al Maestro anterior. Irradia una autoridad inmensa. Item de Misión.",
          canUse: () => false,
        },
        "Rollo: Técnica de Absorción de Qi Celestial": {
          description: "Enseña 'Técnica de Absorción de Qi Celestial'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_absorption_celestial_1"),
          canUse: () => true,
        },
        
        /// ========================   ROLLOS DE TÉCNICAS    ============================

        // -- Rollos Grado 1 --
        "Rollo: Inscripción Rúnica": {
            description: "Un manual antiguo que enseña el arte de trazar formaciones rúnicas en el suelo. Te permite aprender la habilidad 'Inscripción Rúnica'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "formation_scribing_1"),
            canUse: () => true, // Se puede usar desde el inventario
        },
        "Rollo: Tajo del Viento Veloz (Inferior)": {
          description: "Enseña 'Tajo del Viento Veloz'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t1"),
          canUse: () => true,
        },
        "Rollo: Físico de Buey de Piedra (Inferior)": {
          description: "Enseña 'Físico de Buey de Piedra'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t1"),
          canUse: () => true,
        },
        "Rollo: Matriz de Escudo de Qi (Inferior)": {
          description: "Enseña 'Matriz de Escudo de Qi'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t1"),
          canUse: () => true,
        },
        "Rollo: Chispa Ígnea (Inferior)": {
          description: "Enseña 'Chispa Ígnea'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t1"),
          canUse: () => true,
        },
        "Rollo: Dedo de Relámpago (Inferior)": {
          description: "Enseña 'Dedo de Relámpago'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t1"),
          canUse: () => true,
        },
        "Rollo: Paso Veloz (Inferior)": {
          description: "Enseña 'Paso Veloz'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t1"),
          canUse: () => true,
        },

        // -- Rollos Grado 2 --
        "Rollo: Estocada Perfora-Armadura (Terrenal)": {
          description: "Enseña 'Estocada Perfora-Armadura'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t2"),
          canUse: () => true,
        },
        "Rollo: Piel de Acero Fundido (Terrenal)": {
          description: "Enseña 'Piel de Acero Fundido'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t2"),
          canUse: () => true,
        },
        "Rollo: Matriz de Grilletes de Qi (Terrenal)": {
          description: "Enseña 'Matriz de Grilletes de Qi'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t2"),
          canUse: () => true,
        },
        "Rollo: Paso Etéreo (Terrenal)": {
          description: "Enseña 'Paso Etéreo'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t2"),
          canUse: () => true,
        },
        "Rollo: Aliento de Dragón Menor (Terrenal)": {
          description: "Enseña 'Aliento de Dragón Menor'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t2"),
          canUse: () => true,
        },

        // -- Rollos Grado 3 --
        "Rollo: Danza de Espada Ciclónica (Marcial)": {
          description: "Enseña 'Danza de Espada Ciclónica'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t3"),
          canUse: () => true,
        },
        "Rollo: Corazón de Voluntad Indomable (Marcial)": {
          description: "Enseña 'Corazón de Voluntad Indomable'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t3"),
          canUse: () => true,
        },
        "Rollo: Matriz de Supresión Espiritual (Marcial)": {
          description: "Enseña 'Matriz de Supresión Espiritual'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t3"),
          canUse: () => true,
        },
       "Rollo: Jaula de Rayos (Marcial)": {
          description: "Enseña 'Jaula de Rayos'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t3"),
          canUse: () => true,
        },
        "Rollo: Parpadeo de Sombra (Marcial)": {
          description: "Enseña 'Parpadeo de Sombra'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t3"),
          canUse: () => true,
        },

        // -- Rollos Grado 4 --
        "Rollo: Intento de Espada del Tirano (Soberano)": {
          description: "Enseña 'Intento de Espada del Tirano'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t4"),
          canUse: () => true,
        },
        "Rollo: Cuerpo Dorado Inmortal (Soberano)": {
          description: "Enseña 'Cuerpo Dorado Inmortal'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t4"),
          canUse: () => true,
        },
        "Rollo: Sol Abrasador (Soberano)": {
          description: "Enseña 'Sol Abrasador'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t4"),
          canUse: () => true,
        },
        "Rollo: Llamada del Juicio del Trueno (Soberano)": {
          description: "Enseña 'Llamada del Juicio del Trueno'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t4"),
          canUse: () => true,
        },
        "Rollo: Santuario Dorado Protector (Soberano)": {
          description: "Enseña 'Santuario Dorado Protector'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t4"),
          canUse: () => true,
        },
        // -- Rollos Grado 5 --
        "Rollo: Corte que Divide Cielos y Tierra (Trascendente)": {
          description: "Enseña 'Corte que Divide Cielos y Tierra'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"),
          canUse: () => true,
        },
        "Rollo: Constitución de Dragón Ancestral (Trascendente)": {
          description: "Enseña 'Constitución de Dragón Ancestral'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"),
          canUse: () => true,
        },
        "Rollo: Llama del Fénix Renaciente (Trascendente)": {
          description: "Enseña 'Llama del Fénix Renaciente'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"),
          canUse: () => true,
        },
        "Rollo: Tribulación de los Nueve Cielos (Trascendente)": {
          description: "Enseña 'Tribulación de los Nueve Cielos'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"),
          canUse: () => true,
        },
        "Rollo: Matriz de Reversión del Cosmos (Trascendente)": {
          description: "Enseña 'Matriz de Reversión del Cosmos'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"),
          canUse: () => true,
        },
        "Rollo: Paso del Vacío Infinito (Trascendente)": {
          description: "Enseña 'Paso del Vacío Infinito'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"),
          canUse: () => true,
        },

        // -- Rollos Grado 6 --
        "Rollo: Espada del Emperador (Celestial)": {
          description: "Enseña 'Espada del Emperador Celestial'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"),
          canUse: () => true,
        },
        "Rollo: Cuerpo Inmortal de Jade (Celestial)": {
          description: "Enseña 'Cuerpo Inmortal de Jade'.",
          
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
      },
        "Rollo: Incineración del Mundo Mortal (Celestial)": {
          description: "Enseña 'Incineración del Mundo Mortal'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Decreto del Señor del Trueno (Celestial)": {
          description: "Enseña 'Decreto del Señor del Trueno'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz del Sello del Demonio (Celestial)": {
          description: "Enseña 'Matriz del Sello del Demonio'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Omnipresencia Divina (Celestial)": {
          description: "Enseña 'Omnipresencia Divina'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        // -- Rollos Grado 7 --
        "Rollo: Lamento del Fin del Mundo": {
          description: "Enseña 'Lamento del Fin del Mundo'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Forma del Ancestro Primordial": {
          description: "Enseña 'Forma del Ancestro Primordial'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Génesis Ígneo": {
          description: "Enseña 'Génesis Ígneo'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Cólera del Emperador Celestial": {
          description: "Enseña 'Cólera del Emperador Celestia'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz del Caos Primordial": {
          description: "Enseña 'Matriz del Caos Primordial'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Danza del Tejido Espacio-Tiempo": {
          description: "Enseña 'Danza del Tejido Espacio-Tiempo'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },

        // -- Rollos Grado 8 --
        "Rollo: Decreto Imperial: Extinción": {
          description: "Decreto Imperial: Extinción'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Avatar del Dao Eterno": {
          description: "Enseña 'Avatar del Dao Eterno'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Apocalipsis de Llamas Divinas": {
          description: "Enseña 'Apocalipsis de Llamas Divinas'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Tribulación del Fin de los Tiempos": {
          description: "Enseña 'Tribulación del Fin de los Tiempos'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz de Reescritura de la Realidad": {
          description: "Enseña 'Matriz de Reescritura de la Realidad'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Trascendencia Dimensional": {
          description: "Enseña 'Trascendencia Dimensional'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        // -- Rollos Grado 9 --
        "Rollo: Corte del Origen Absoluto": {
          description: "Enseña 'Corte del Origen Absoluto'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Constitución de Dragón Ancestral": {
          description: "Enseña 'Constitución de Dragón Ancestral'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Llama del Fénix Renaciente": {
          description: "Enseña 'Llama del Fénix Renaciente'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Tribulación de los Nueve Cielos": {
          description: "Enseña 'Tribulación de los Nueve Cielos'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz de Reversión del Cosmos": {
          description: "Enseña 'Matriz de Reversión del Cosmos'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Paso del Vacío Infinito": {
          description: "Enseña 'Paso del Vacío Infinito'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },

        

        "Rollo: Absorción de Qi Menor": {
          description: "Enseña 'Técnica de Absorción de Qi Menor'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_absorption_boost_1"),
          canUse: () => true,
        },

        "Rollo: Fortificación Corporal Básica": {
          description: "Enseña 'Fortificación Corporal Básica'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_fortification_1"),
          canUse: () => true,
        },
     
        "Rollo: Conversión de Qi": {
          description: "Enseña 'Técnica de Conversión de Qi'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_to_hp_conversion_1"),
          canUse: () => true,
        },
    
    
    
    
        "Rollo: Paso de las Sombras": {
          description: "Enseña 'Paso de las Sombras'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "shadow_step_1"),
          canUse: () => true,
        },
 
   
   
  
        "Rollo: Voluntad de Hierro": {
          description: "Enseña 'Voluntad de Hierro'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "iron_will_1"),
          canUse: () => true,
        },
  

        "Rollo: Clon Fantasma": {
          description: "Enseña 'Clon Fantasma'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "phantom_clone_1"),
          canUse: () => true,
        },
        "Rollo: Cambio Temporal": {
          description: "Enseña 'Cambio Temporal'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "temporal_shift_1"),
          canUse: () => true,
        },
  
 
  
        "Cristal de Hielo": {
          description: "Cristal gélido. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Cristal de Hielo, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia de Fuego": {
          description: "Energía ígnea concentrada. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Esencia de Fuego, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Núcleo de Tormenta": {
          description: "Corazón de tormenta. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Núcleo de Tormenta, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Venenos Mortales": {
          description: "Venenos potentes. Otorga 15 EXP.",
          effect: (ps, gex) => {
            gex(15);
            return `Estudiado Venenos Mortales, ganado 15 EXP.`;
          },
          canUse: () => true,
        },
        "Fragmentos de Jade": {
          description: "Jade imbuido de energía. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido Fragmentos de Jade, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia Oscura": {
          description: "Energía de sombras. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Absorbido Esencia Oscura, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Almas Condenadas": {
          description: "Ecos de almas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Liberado Almas Condenadas, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "Núcleo de Vórtice": {
          description: "Energía caótica. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Núcleo de Vórtice, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Rocío Celestial": {
          description: "Gotas de energía celestial. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Bebido Rocío Celestial, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "Cristales Psíquicos": {
          description: "Resuenan con poder mental. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Meditado con Cristales Psíquicos, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "Mineral de Hierro Espiritual": {
          description: "Hierro imbuido con Qi. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Refinado Mineral, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Plumas de Fénix": {
          description: "Imbuidas con esencia de renovación. Otorga 60 EXP.",
          effect: (ps, gex) => {
            gex(60);
            return `Meditado con Plumas de Fénix, ganado 60 EXP.`;
          },
          canUse: () => true,
        },
        "Semillas Ancestrales": {
          description: "Llenas de vitalidad. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Plantado Semillas en dantian, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Escamas de Dragón": {
          description: "Imbuidas con poder dracónico. Otorga 70 EXP.",
          effect: (ps, gex) => {
            gex(70);
            return `Estudiado Escamas de Dragón, ganado 70 EXP.`;
          },
          canUse: () => true,
        },
        "Espejos Astrales": {
          description: "Reflejan otros planos. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Meditado con Espejos Astrales, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "Relojes de Arena": {
          description: "Manipulan flujo del tiempo. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Estudiado Relojes de Arena, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Sangre de Demonio": {
          description: "Sangre corrupta pero potente. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Analizado Sangre de Demonio, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "Lágrimas de Unicornio": {
          description:
            "Purificadoras con propiedades curativas. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Usado Lágrimas para purificar Qi, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "Núcleo Elemental": {
          description: "Esencia de poder elemental. Otorga 65 EXP.",
          effect: (ps, gex) => {
            gex(65);
            return `Absorbido Núcleo Elemental, ganado 65 EXP.`;
          },
          canUse: () => true,
        },
        "Polvo de Arcano": {
          description: "Brillante con propiedades mágicas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Utilizado Polvo de Arcano en ritual, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
      };

      let zoneNotificationTimeout = null;

      ///======================   FUNCIONES ========================================
      function updateGameOverlayVisibility() {
        const overlay = document.getElementById("game-overlay");
        if (!overlay) {
          console.error("No se encontró el elemento #game-overlay.");
          return;
        }

        // El velo debe estar activo si la batalla está activa O si cualquier modal está abierto.
        const shouldBeActive = gameState.battle.active || isAnyModalOpen();

        if (shouldBeActive) {
          overlay.classList.add("active");
        } else {
          overlay.classList.remove("active");
        }
      }
      function getStoryNpcDialogue(npcId) {
        const player = gameState.player;
        const flags = player.worldState.storyFlags;

        switch (npcId) {
        case "anciana_su":
            if (!flags.metAncianaSu) {
                return "Joven discípulo... tu flujo de Qi es... peculiar. Me recuerda a las viejas leyendas. Sigue entrenando, estaré observando.";
            }
            if (flags.knowsAboutCalamity && !flags.knowsAboutSoberano) {
                return "La Gran Calamidad fue una herida profunda para nuestra secta. Siento que sus ecos aún resuenan. Ten cuidado en tus misiones.";
            }
            if (flags.knowsAboutSoberano) {
                return "Así que el Maestro te ha contado... El peso sobre tus hombros es grande. Busca la verdad completa, el Santuario del Eco en el Valle del Dragón Caído podría tener respuestas.";
            }
            return "El conocimiento del pasado es la llave del futuro. Si tienes preguntas, los archivos siempre están abiertos.";

        case "maestro_jian":
            if (flags.knowsFullTruth) {
                return `La carga que llevas es inmensa. Toda la secta confía en ti. No dudes de tu camino. El destino del mundo está en tus manos.`;
            }
            if (flags.knowsAboutSoberano) {
                return `Ahora que conoces parte del secreto, debes entender la gravedad de la situación. El sello se debilita. Cada victoria tuya nos da más tiempo.`;
            }
            return "El camino del cultivador es largo y arduo. Que el Viento Azure guíe tus pasos.";
    }
    return "..."; // Diálogo por defecto
}
      function showZoneNotification(zoneName) {
      
        const notificationElement =
          document.getElementById("zone-notification");

        if (!notificationElement) {
        
          return;
        }
      

        if (zoneNotificationTimeout) {
          clearTimeout(zoneNotificationTimeout);
         
        }

        notificationElement.textContent = `Has entrado en: ${zoneName}`;
      

        notificationElement.classList.add("show");
        
       

        zoneNotificationTimeout = setTimeout(() => {
          notificationElement.classList.remove("show");
         
        }, 3000);
      
      }
      // --- FUNCIONES HELPER PARA UI MÓVIL ---
      function isMobileView() {
        return (
          window.matchMedia("(max-width: 768px)").matches ||
          window.matchMedia("(hover: none) and (pointer: coarse)").matches
        );
      }

      /// <!-- CAMBIO TAMAÑO MAPA MÓVIL -->
      //TAMAÑO TILE
      function calculateAndSetTileSize() {
        
        // Usamos las dimensiones de la ventana directamente, que es más fiable en móviles.
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;
        // ===================================

        // Las constantes que definiste para la cantidad de tiles deseada.
        // ¡He actualizado los valores para que coincidan con los que proporcionaste!
        const TILES_VISIBLE_X_PORTRAIT = 7; 
        const TILES_VISIBLE_Y_PORTRAIT = 10; // En vertical, queremos ver más arriba/abajo

        const TILES_VISIBLE_X_LANDSCAPE = 11; // Aprovechamos el ancho
        const TILES_VISIBLE_Y_LANDSCAPE = 5;  // Reducimos drásticamente el alto

        // Determina si estamos en modo horizontal (landscape) o vertical (portrait)
        const isLandscape = availableWidth > availableHeight;

        let tileSizeBasedOnWidth;
        let tileSizeBasedOnHeight;

        if (isLandscape) {
            tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_LANDSCAPE;
            tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_LANDSCAPE;
        } else {
            tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_PORTRAIT;
            tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_PORTRAIT;
        }

        // El tamaño del tile será el menor de los dos cálculos para asegurar que todo quepa.
        currentTileSize = Math.floor(
            Math.min(tileSizeBasedOnWidth, tileSizeBasedOnHeight)
        );
        currentTileSize = Math.max(20, currentTileSize); // Asegurar un tamaño mínimo razonable

        console.log(
            `Viewport W: ${availableWidth}, H: ${availableHeight}. Orientation: ${isLandscape ? 'Landscape' : 'Portrait'}. Calculated Tile Size: ${currentTileSize}`
        );
        
        return currentTileSize;
    }
      // <!-- FIN CAMBIO TAMAÑO MAPA MÓVIL -->

      function isAnyModalOpen() {
        const modals = [
          "interactionModal",
          "activeCultivationModal",
          "shopModal",
          "sectHallModal",
          "cultivationChoiceModal",
          "techniqueModal",
        ];
        for (const modalId of modals) {
          const modalElement = document.getElementById(modalId);
          if (modalElement && modalElement.style.display === "flex") {
            return true;
          }
        }
        return false;
      }

      // NUEVA FUNCIÓN para controlar la visibilidad de la barra inferior
      function updateTopNavVisibility() {
        // Renombramos la función para claridad
        if (!topNavBar) return;

        if (gameState.battle.active || isAnyModalOpen()) {
          topNavBar.classList.add("hidden");
        } else {
          topNavBar.classList.remove("hidden");
        }
      }

      function openMissionsModal() {
          const container = document.getElementById("missionsContainer");
          container.innerHTML = "";
          const player = gameState.player;

          if (player.secta.misionesActivas.length === 0) {
              container.innerHTML = "<p style='text-align: center; opacity: 0.7;'>No tienes misiones activas en este momento.</p>";
          } else {
              player.secta.misionesActivas.forEach((misionActiva) => {
                  const misionData = MISIONES_DATA[misionActiva.id];
                  if (!misionData) return;

                  // ¡Llamamos a nuestra nueva función centralizada!
                  const progresoTexto = getMissionProgressText(misionActiva);

                  const div = document.createElement("div");
                  div.style.border = "1px solid #d4af37";
                  div.style.borderRadius = "8px";
                  div.style.padding = "10px";
                  div.style.marginBottom = "10px";
                  div.style.background = "rgba(0,0,0,0.2)";

                  div.innerHTML = `
                      <h4>${misionData.titulo}</h4>
                      <p style="font-size: 0.9em; margin-top: 5px;">${misionData.descripcion}</p>
                      <p style="font-size: 0.8em; color: #f4d03f; margin-top: 8px;">${progresoTexto}</p>
                  `;
                  container.appendChild(div);
              });
          }

          document.getElementById("missionsModal").style.display = "flex";
          hideTouchControls();
          updateStatsPanelVisibility();
      }

      function closeMissionsModal() {
        document.getElementById("missionsModal").style.display = "none";
        showTouchControls();
        updateStatsPanelVisibility();
      }
      function showTouchControls() {
        const controlsOverlay = document.getElementById('touch-controls-overlay');
        const toggleBtn = document.getElementById('toggleMapControlsBtn');

        if (!controlsOverlay || !toggleBtn) return;

        // === CORRECCIÓN CLAVE ===
        // Comprobamos si el navegador está en modo de pantalla completa.
        const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        
        // Los controles deben mostrarse si estamos en vista móvil O si el juego está en pantalla completa.
        const forceShowDueToDeviceOrMode = isMobileView() || isFullscreen;

        // La condición final para mostrar los controles
        const shouldShow = forceShowDueToDeviceOrMode && !mapControlsManuallyHidden && !gameState.battle.active && !isAnyModalOpen();

        if (shouldShow) {
            controlsOverlay.style.display = 'block';
            toggleBtn.style.display = 'block';
        } else {
            controlsOverlay.style.display = 'none';
            // También ocultamos el botón de toggle si no estamos en una vista que los requiera
            if (!forceShowDueToDeviceOrMode) {
                toggleBtn.style.display = 'none';
            }
        }
    }

      function hideTouchControls() {
          const controlsOverlay = document.getElementById('touch-controls-overlay');
          if (controlsOverlay) {
              controlsOverlay.style.display = 'none';
          }
      }

      function toggleMapControlsVisibility() {
          mapControlsManuallyHidden = !mapControlsManuallyHidden;
          const btn = document.getElementById("toggleMapControlsBtn");
          
          if (mapControlsManuallyHidden) {
              btn.textContent = "Mostrar Controles";
              hideTouchControls(); // Esta función ahora oculta el overlay completo
          } else {
              btn.textContent = "Ocultar Controles";
              showTouchControls(); // Esta función ahora muestra el overlay completo si se cumplen las condiciones
          }
      }
      function handleTeleporterInteraction(entity) {
        if (!entity.teleporterId) return;

        const teleporterId = entity.teleporterId;
        const teleporterInfo = TELEPORTER_DATA[teleporterId];
        const player = gameState.player;

        if (!teleporterInfo) {
          console.error(
            `Datos no encontrados para el teletransportador con ID: ${teleporterId}`
          );
          return;
        }

        // Comprobar si ya está activado
        if (!player.unlockedTeleporters[teleporterId]) {
          // ¡Primera activación!
          player.unlockedTeleporters[teleporterId] = true;
          showModal(
            "Matriz Sintonizada",
            `Has canalizado tu Qi en la matriz. ¡Ahora puedes viajar hacia y desde "${teleporterInfo.name}"!`
          );
          // Podríamos abrir el menú de teletransporte directamente después,
          // pero un mensaje de feedback primero es mejor.
        } else {
          // Si ya está activado, simplemente abrimos el menú de viaje.
          openTeleportModal();
        }
      }

      function handleFullscreenChange() {
          updateFullscreenButton();
          // Vuelve a comprobar si los controles deben ser visibles después de cambiar de modo.
          showTouchControls(); 
      }

      function openTeleportModal() {
        const container = document.getElementById("teleportOptionsContainer");
        const player = gameState.player;
        container.innerHTML = ""; // Limpiar opciones anteriores

        let hasDestinations = false;

        for (const id in player.unlockedTeleporters) {
          // No mostrar la ubicación actual como un destino
          const currentTeleporter = getTeleporterAt(player.x, player.y);
          if (currentTeleporter && currentTeleporter.id === id) {
            continue;
          }

          hasDestinations = true;
          const destinationInfo = TELEPORTER_DATA[id];
          const button = document.createElement("button");
          button.className = "cultivation-option-btn";
          button.textContent = `Viajar a: ${destinationInfo.name}`;
          button.onclick = () => teleportPlayer(id);
          container.appendChild(button);
        }

        if (!hasDestinations) {
          container.innerHTML =
            "<p>No has sintonizado otras Matrices de Teletransporte todavía. ¡Explora para activarlas!</p>";
        }

        document.getElementById("teleportModal").style.display = "flex";
        hideTouchControls();
      }

      function teleportPlayer(destinationId) {
        const destination = TELEPORTER_DATA[destinationId];
        if (!destination) return;

        // Actualizar coordenadas del jugador
        gameState.player.x = destination.x;
        gameState.player.y = destination.y;

        closeTeleportModal();

        // Mostrar un feedback visual rápido
        showModal("Viaje Espiritual", "Te materializas en tu destino...", true);
        setTimeout(() => {
          closeModal();
        }, 1200);

        // ¡Muy importante! Actualizar la vista del mapa
        updatePlayerPosition("teleport");
      }

      function closeTeleportModal() {
        document.getElementById("teleportModal").style.display = "none";
        showTouchControls();
        updateStatsPanelVisibility();
      }

      // Pequeña función de ayuda para saber si el jugador está en un teletransportador
      function getTeleporterAt(x, y) {
        for (const id in TELEPORTER_DATA) {
          const tp = TELEPORTER_DATA[id];
          if (tp.x === x && tp.y === y) {
            return { ...tp, id: id };
          }
        }
        return null;
      }
      // --- FUNCIONES DEL JUEGO (MODIFICADAS Y EXISTENTES) ---

      /**
 * FUNCIÓN DE APRENDER TÉCNICA (MEJORADA)
 * Aprende una técnica basándose en el nombre del rollo, no en un ID pasado manualmente.
 * @param {object} playerState - El estado del jugador.
 * @param {string} itemName - El nombre del rollo que se está usando (ej: "Rollo: Cuerpo Inmortal de Jade").
 * @returns {string} Un mensaje de feedback para el jugador.
 */
    function learnTechniqueFromRoll(playerState, itemName) {
      console.group(`[learnTechniqueFromRoll] Procesando el rollo: "${itemName}"`);
        if (!itemName.startsWith("Rollo: ")) {
          console.error("Fallo: El nombre del ítem no empieza con 'Rollo: '.");
          console.groupEnd();
            return "Error: Este objeto no es un rollo de técnica válido.";
        }

        const techNameToLearn = itemName.substring(7); // Extrae "Cuerpo Inmortal de Jade"
        console.log(`Paso 1: Nombre de la técnica a aprender extraído -> "${techNameToLearn}"`);
        // Busca en TODOS los datos de técnicas cuál tiene el nombre que coincide.
        const techId = Object.keys(techniqueData).find(
            (id) => techniqueData[id].name === techNameToLearn
        );
        console.log(`Paso 2: Búsqueda en techniqueData por nombre...`);

        if (!techId) {
          console.error(`¡FALLO CRÍTICO! No se encontró ninguna técnica con el nombre exacto "${techNameToLearn}" en el objeto techniqueData.`);
        console.groupEnd();
            return `Error: No se encontró la definición de la técnica llamada '${techNameToLearn}'.`;
        }
        console.log(`   -> Éxito. ID de la técnica encontrado: "${techId}"`);
        const techInfo = techniqueData[techId];
        console.log(`Paso 3: Comprobando si el jugador ya conoce la técnica "${techId}"...`);
        // El resto de la función (comprobaciones de nivel, etc.) no cambia.
        if (playerState.learnedTechniques[techId]) {
          console.warn("Fallo: El jugador ya tiene esta técnica en su libro.");
        console.groupEnd();
            return `Ya conoces esta técnica: ${techInfo.name}.`;
        }
        console.log("   -> El jugador NO conoce la técnica. Continuando...");
    
        console.log(`Paso 4: Verificando requisitos de rango... (Requerido: ${techInfo.requiredRank || 'Ninguno'})`);
        if (techInfo.requiredRank) {
            const playerRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === playerState.secta.rango);
            const requiredRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === techInfo.requiredRank);
            if (playerRankIndex < requiredRankIndex) {
              console.error(`Fallo: Rango insuficiente. Jugador: ${playerState.secta.rango} (${playerRankIndex}), Requerido: ${techInfo.requiredRank} (${requiredRankIndex})`);
            console.groupEnd();
                return `Rango insuficiente. Necesitas ser al menos <strong>${techInfo.requiredRank}</strong> para aprender '${techInfo.name}'.`;
            }
            console.log("   -> Rango suficiente. Continuando...");
        }else {
        console.log("   -> No se requiere rango. Continuando...");
        }
        console.log(`Paso 5: Añadiendo la técnica al estado del jugador...`);
        playerState.learnedTechniques[techId] = {
            level: 1, 
            currentCultivationProgress: 0,
            cultivationTimeToNextLevel: techInfo.cultivationSettings?.baseTimeToLevelUp || 120,
        };
        console.log("   -> Técnica añadida con éxito:", playerState.learnedTechniques[techId])  
        recalculatePlayerStats(); 
        console.log("Proceso completado con éxito.");
        console.groupEnd();
        return `Has aprendido '${techInfo.name}' (Nivel 1). Puedes cultivarla para mejorarla.`;
    }

      function showModal(title, text, nonInteractive = false) {
        document.querySelector(".stats-panel").style.display = "none";
        const modalElement = document.getElementById("interactionModal");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalTextEl = document.getElementById("modalText");

        if (!modalElement || !modalTitleEl || !modalTextEl) {
          console.error(
            "CRITICAL: Modal o sus elementos internos no encontrados."
          );
          alert(`Error UI: Modal no encontrado.\nMensaje: ${title} - ${text}`);
          return;
        }

        modalTitleEl.textContent = title;
        modalTextEl.innerHTML = text.replace(/\n/g, "<br>");

        const closeButton = modalElement.querySelector(
          "button.close-modal-btn"
        ); // Busca por clase

        if (closeButton) {
          if (nonInteractive) {
            closeButton.style.display = "none"; // Ocultar si es no interactivo
          } else {
            closeButton.style.display = "block"; // Asegurar que sea visible si es interactivo
            // El onclick="closeModal()" ya está en el HTML, por lo que no necesitamos reasignarlo.
          }
        } else if (!nonInteractive) {
          console.warn(
            "#interactionModal no tiene un botón de cierre con clase .close-modal-btn y no es nonInteractive."
          );
        }

        modalElement.style.display = "flex";
        hideTouchControls();
        updateTopNavVisibility();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function closeModal() {
        const modalElement = document.getElementById("interactionModal");
        if (modalElement) {
          modalElement.style.display = "none";
        }

        if (!gameState.battle.active) {
          document.querySelector(".stats-panel").style.display = "block";
        }

        updatePlayerBarsOnMap();
        showTouchControls();
        updateTopNavVisibility();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }
      //ENEMIGOS Y NPC FIJOS
      function ensureFixedEntities() {
        const player = gameState.player;
        let entities = gameState.map.entities;
        let baseIds = [
        "shop", "tutorial_formation_mural",
        "secta_entrada_principal", "secta_entrada_principal_2", "secta_entrada_principal_3", "secta_entrada_principal_4",
        "npc_secta_guia", "npc_secta_admin", "npc_maestro_jian", "npc_anciana_su",
        "transition_ruins_entrance", "transition_ruins_exit",
        "transition_valley_entrance", "transition_valley_exit",
        "transition_fisura_entrance", "transition_fisura_exit",
        "tp_sect_hub", "tp_forest_shrine", "tp_desert_oasis", "tp_swamp_ruin", "tp_desfiladero", "tp_dragon_valley",
        "mural_circulo_vital",
        ];
        const defeated = player.worldState.defeatedBosses || {};
        const activeMissions = player.secta.misionesActivas.map(m => m.id);
        let bossIdsToProcess = [];

        // Lógica para los primeros jefes de la historia
        if (!defeated.boss_dem) {
            bossIdsToProcess.push("boss_dem");
        } else if (!defeated.boss_ancient_golem) {
            // El golem solo aparece si el demonio ha sido derrotado
            bossIdsToProcess.push("boss_ancient_golem");
        }
        // Lógica para jefes de misión de secta (el sistema actual ya los maneja bien, pero podemos ser explícitos)
        activeMissions.forEach(misionId => {
            const misionData = MISIONES_DATA[misionId];
            if (misionData?.objetivo?.tipo === "derrotar_npc_especifico") {
                const npcId = misionData.objetivo.npcId;
                if (npcId && !bossIdsToProcess.includes(npcId)) {
                    bossIdsToProcess.push(npcId);
                }
            }
        });
        // --- LÓGICA CLAVE PARA EL JEFE FINAL ---
        // El Avatar solo aparecerá si la misión final 'mision_maestro_1' está activa.
        if (activeMissions.includes('mision_maestro_1')) {
            if (!bossIdsToProcess.includes('avatar_del_dao_corrupto')) {
                bossIdsToProcess.push('avatar_del_dao_corrupto');
            }
        }
        // Unimos la lista base con los jefes que deben aparecer
          const idsParaProcesar = [...new Set([...baseIds, ...bossIdsToProcess])];

          console.log("[EnsureFixed] IDs a procesar en este ciclo:", idsParaProcesar);

        

       
  
        // Lógica para rivales de desafío de secta (actuales)
        player.secta.misionesActivas.forEach((misionActiva) => {
          const misionData = MISIONES_DATA[misionActiva.id];
          if (
            misionData?.objetivo?.tipo === "derrotar_npc_especifico" &&
            misionData.objetivo.npcId
          ) {
            const rivalId = misionData.objetivo.npcId;
            if (
              entityTypes[rivalId]?.fixedLocation &&
              !player.secta.misionesCompletadas[misionActiva.id]
            ) {
              if (!idsParaProcesar.includes(rivalId)) {
                idsParaProcesar.push(rivalId);
              }
            }
          }
        });

        // Nueva lógica: Añadir entidades fijas que podrían estar ligadas a misiones activas
        // (si implementas `missionRequirementId`)
        player.secta.misionesActivas.forEach((misionActiva) => {
          // Ejemplo: Si la misión "mision_cazar_bestia_especifica_1" está activa
          // y el jabalí tiene un `missionRequirementId: "mision_cazar_bestia_especifica_1"`
          // y aún no está en idsParaProcesar, lo añadirías.
          // Este es un ejemplo, necesitarías iterar sobre `entityTypes` para encontrar tales entidades.
          // Por ahora, como lo añadiste directamente a `idsParaProcesar`, esto es más simple.
        });

        console.log(
          "[EnsureFixed] IDs a procesar:",
          JSON.parse(JSON.stringify(idsParaProcesar))
        );

        idsParaProcesar.forEach((entityTypeId) => {
          const definition = entityTypes[entityTypeId];
          if (!definition) {
            console.warn(
              `[EnsureFixed] Definición no encontrada para ${entityTypeId}`
            );
            return;
          }

          if (!definition.fixedLocation) {
            // Si una entidad en idsParaProcesar no tiene fixedLocation, no podemos colocarla así.
            // Esto es un error de configuración o la entidad no debería estar en esta lista.
            console.warn(
              `[EnsureFixed] La entidad ${entityTypeId} está en idsParaProcesar pero no tiene 'fixedLocation' en su definición.`
            );
            return;
          }

          const fixedX = definition.fixedLocation.x;
          const fixedY = definition.fixedLocation.y;

          const existingEntityInstance = entities.find(
            (e) =>
              (e.x === fixedX &&
                e.y === fixedY &&
                (e.type === (definition.typeOverride || entityTypeId) ||
                  e.originalEntityTypeId === entityTypeId)) ||
              (definition.npcId && e.npcId === definition.npcId) // Para NPCs
          );

          let debeExistir = true;

          // Lógica de si debe existir (para jefes, rivales, o entidades ligadas a misiones)
          if (definition.isSectChallengeRival && definition.npcId) {
            const desafioMision = Object.values(MISIONES_DATA).find(
              (m) =>
                m.objetivo?.tipo === "derrotar_npc_especifico" &&
                m.objetivo?.npcId === definition.npcId
            );
            const misionId = desafioMision
              ? Object.keys(MISIONES_DATA).find(
                  (key) => MISIONES_DATA[key] === desafioMision
                )
              : null;
            if (misionId) {
              if (player.secta.misionesCompletadas[misionId])
                debeExistir = false;
              else if (
                !player.secta.misionesActivas.some((m) => m.id === misionId)
              )
                debeExistir = false;
            } else debeExistir = false;
          } else if (definition.isBoss || definition.isMiniBoss) {
            // Tratar MiniBoss de forma similar a Boss para 'defeated'
            // Usaremos una nueva propiedad en player.worldState para rastrear minibosses fijos derrotados
            // si no quieres que reaparezcan inmediatamente.
            if (
              player.worldState.defeatedFixedEntities &&
              player.worldState.defeatedFixedEntities[entityTypeId]
            ) {
              // Si tiene un tiempo de respawn, podría reaparecer
              const lastDefeatedTime =
                player.worldState.defeatedFixedEntities[entityTypeId].time;
              const respawnTimeSeconds = definition.respawnTime; // ej. 300 segundos
              if (
                respawnTimeSeconds &&
                (Date.now() - lastDefeatedTime) / 1000 < respawnTimeSeconds
              ) {
                debeExistir = false; // Aún no es tiempo de reaparecer
              } else if (respawnTimeSeconds) {
                debeExistir = true; // Tiempo de respawn cumplido
                // Opcional: remover de defeatedFixedEntities para que no se re-evalue el tiempo hasta la próxima derrota
                // delete player.worldState.defeatedFixedEntities[entityTypeId];
              } else {
                debeExistir = false; // No tiene respawnTime, así que si está derrotado, no reaparece.
              }
            }
          } else if (definition.missionRequirementId) {
            // Lógica para entidades que dependen de una misión activa
            if (
              !player.secta.misionesActivas.some(
                (m) => m.id === definition.missionRequirementId
              )
            ) {
              debeExistir = false; // La misión requerida no está activa
            }
            // Podrías añadir una comprobación de si la misión ya fue completada y la entidad debe desaparecer.
            if (
              player.secta.misionesCompletadas[
                definition.missionRequirementId
              ] &&
              !definition.respawnTime
            ) {
              // Si la misión está completada y la entidad no tiene respawn, no debe existir.
              debeExistir = false;
            }
          }

          if (debeExistir) {
            if (!existingEntityInstance) {
             
              const newEntityData = {
                ...definition,
                x: fixedX,
                y: fixedY,
                type: definition.typeOverride || entityTypeId,
                symbol: definition.symbol,
                name: definition.name,
                interaction: definition.interaction,
                npcId: definition.npcId,
                discovered:
                  definition.discovered === true ||
                  definition.isBoss ||
                  definition.isMiniBoss, // Los jefes/minibosses suelen estar descubiertos
                isFixed: true,
                id: `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                  .toString(16)
                  .slice(2)}`,
                originalEntityTypeId: entityTypeId,
                // Copiar stats de combate y loot
              };
              if (newEntityData.hp && !newEntityData.maxHp)
                newEntityData.maxHp = newEntityData.hp;

              // No necesitamos `...definition` aquí porque ya estamos copiando explícitamente y de entityTypes
              const finalEntity = { ...newEntityData };
              // delete finalEntity.fixedLocation; // No es necesario porque newEntityData no lo incluye

              entities.push(finalEntity);
            } else {
              // Actualizar propiedades de la instancia existente si es necesario
              existingEntityInstance.isFixed = true;
              if (
                definition.discovered === true ||
                definition.isBoss ||
                definition.isMiniBoss
              ) {
                existingEntityInstance.discovered = true;
              }
              if (!existingEntityInstance.id) {
                existingEntityInstance.id = `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                  .toString(16)
                  .slice(2)}`;
              }
              if (!existingEntityInstance.originalEntityTypeId) {
                existingEntityInstance.originalEntityTypeId = entityTypeId;
              }
              // Asegurar que las stats estén actualizadas si se recarga el juego
              // (esto puede ser importante si las definiciones cambian entre versiones)
              if (definition.hp) existingEntityInstance.hp = definition.hp;
              if (definition.maxHp)
                existingEntityInstance.maxHp = definition.maxHp;
              else if (definition.hp && !existingEntityInstance.maxHp)
                existingEntityInstance.maxHp = definition.hp;
              // ... podrías actualizar otras stats aquí si es necesario ...
            }
          } else {
            // No debe existir
            if (existingEntityInstance) {
              console.log(
                `[EnsureFixed] ELIMINANDO instancia existente de ${entityTypeId} en (${fixedX}, ${fixedY}) porque 'debeExistir' es false.`
              );
              entities = entities.filter(
                (e) => e.id !== existingEntityInstance.id
              );
            }
          }
        });
        gameState.map.entities = entities; // Reasignar por si se filtraron entidades
      }
      //GENERAR MAPA!
      function generateMap(isFullReset = true) {
        calculateAndSetTileSize();

        if (isFullReset) {
          // Limpiar entidades que no son fijas
          gameState.map.entities = gameState.map.entities.filter(
            (e) => e.isFixed && !e.isDecorative
          ); // Quitamos también las decoraciones viejas

          // Resetear contadores de spawn
          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings && zone.spawnSettings.targetEntities) {
              zone.spawnSettings.targetEntities.forEach((target) => {
                target.currentCount = 0;
              });
              zone.spawnSettings.respawnTimer = 0;
              zone.spawnSettings.lastSpawnCheck = 0;
            }
          });

          // Poblar cada zona con monstruos/recursos y luego con decoraciones
          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings) {
              console.log(
                `generateMap: Poblando spawns para la zona "${zone.name}".`
              );
              populateZoneWithObjects(zone, true);
            }
            // === LÓGICA MODIFICADA ===
            if (zone.decorations) {
              console.log(
                `generateMap: Poblando decoraciones para la zona "${zone.name}".`
              );
              populateZoneWithDecorations(zone); // Llamamos a la nueva función
            }
            // === FIN DE LA MODIFICACIÓN ===
          });

          // Ya no necesitamos la función global y aleatoria de decoraciones.
          // populateDecorativeElements(50); // <-- ELIMINA O COMENTA ESTA LÍNEA
        } else {
          gameState.map.entities = gameState.map.entities.filter(
            (e) => e.isFixed || e.isDecorative || (!e.zoneOrigin && !e.isFixed)
          );
        }

        updatePlayerPosition();
        showTouchControls();
        ensureFixedEntities();
      }

      function dev_defeatEnemy(entityTypeId) {
        console.log(`[DEV] Intentando forzar la derrota de: ${entityTypeId}`);

        const enemyInstance = gameState.map.entities.find(
            (e) => (e.originalEntityTypeId === entityTypeId || e.npcId === entityTypeId) && !e.isDecorative
        );

        if (!enemyInstance) {
            const message = `[DEV] Error: No se encontró una instancia activa de '${entityTypeId}' en el mapa.`;
            console.error(message);
            alert(message);
            return;
        }

        console.log("[DEV] Enemigo encontrado en el mapa:", enemyInstance);

        // --- CORRECCIÓN CLAVE ---
        // Obtenemos la definición maestra del enemigo.
        const enemyDefinition = entityTypes[entityTypeId];
        if (!enemyDefinition) {
            console.error(`[DEV] Error: No se encontró la definición maestra para '${entityTypeId}' en entityTypes.`);
            return;
        }

        // Construimos el objeto del enemigo de la forma correcta:
        // 1. Copiamos la definición maestra completa (que tiene el npcId).
        // 2. Sobrescribimos con los datos de la instancia del mapa (como el HP actual si fuera relevante).
        gameState.battle.enemy = {
            ...enemyDefinition,
            ...enemyInstance
        };
        // --- FIN DE LA CORRECIÓN ---

        gameState.battle.enemy.hp = 0;
        
        // Ahora, cuando llamemos a handleEnemyDefeat, el objeto 'enemy' tendrá la propiedad 'npcId'.
        handleEnemyDefeat();

        console.log(`[DEV] La derrota de '${entityTypeId}' ha sido procesada con éxito.`);
    }

      function populateZoneWithDecorations(zone) {
        if (!zone.decorations || zone.decorations.length === 0) {
          return; // No hay nada que decorar en esta zona
        }

        console.log(`[Decor] Poblando decoraciones para la zona: ${zone.name}`);

        // Recorremos cada celda de la zona
        for (let y = zone.y1; y <= zone.y2; y++) {
          for (let x = zone.x1; x <= zone.x2; x++) {
            // Verificamos si la celda ya está ocupada por algo importante
            const isOccupied = gameState.map.entities.some(
              (e) => e.x === x && e.y === y
            );
            if (isOccupied) {
              continue; // Si ya hay un monstruo o recurso, no ponemos decoración encima
            }

            // Iteramos sobre los tipos de decoración definidos para la zona
            for (const deco of zone.decorations) {
              // Usamos Math.random() para decidir si colocar esta decoración
              if (Math.random() < deco.density) {
                const decoDefinition = entityTypes[deco.entityTypeId];
                if (decoDefinition) {
                  const newDeco = {
                    ...decoDefinition,
                    x: x,
                    y: y,
                    type: deco.entityTypeId,
                    id: `${deco.entityTypeId}_${x}_${y}_${Math.random()}`,
                    discovered: true,
                    isFixed: true,
                    isDecorative: true,
                  };
                  gameState.map.entities.push(newDeco);
                  // IMPORTANTE: Una vez que ponemos una decoración, salimos del bucle
                  // para no poner múltiples decoraciones (ej. un árbol y una roca) en la misma celda.
                  break;
                }
              }
            }
          }
        }
      }

      function populateDecorativeElements(numberOfElements = 3000) {
        const decorativeKeys = Object.keys(entityTypes).filter(
          (key) => entityTypes[key].isDecorative
        );
        if (decorativeKeys.length === 0) {
          console.log("[Decor] No decorative entity types found."); // LOG
          return;
        }
        // MODIFICACIÓN: Añadir las claves encontradas al log
        console.log(
          `[Decor] Attempting to populate ${numberOfElements} decorative elements. Found ${decorativeKeys.length} types:`,
          decorativeKeys.join(", ")
        );

        let addedCount = 0;
        for (let i = 0; i < numberOfElements; i++) {
          let spawnX,
            spawnY,
            attempts = 0;
          let positionFound = false;
          const randomDecoKey =
            decorativeKeys[Math.floor(Math.random() * decorativeKeys.length)];

          while (attempts < 20 && !positionFound) {
            // Intentos para encontrar posición
            spawnX = Math.floor(Math.random() * gameState.map.width);
            spawnY = Math.floor(Math.random() * gameState.map.height);

            // Para decorativos, la condición de "caminable" puede ser menos estricta
            // Lo importante es que la celda no esté ya ocupada.
            const isOccupied = gameState.map.entities.some(
              (e) => e.x === spawnX && e.y === spawnY
            );
            const isPlayerPos =
              spawnX === gameState.player.x && spawnY === gameState.player.y;

            if (!isOccupied && !isPlayerPos) {
              positionFound = true;
            }
            attempts++;
          }

          if (positionFound) {
            const decoDefinition = entityTypes[randomDecoKey];
            if (!decoDefinition || !decoDefinition.symbol) {
              console.warn(
                `[Decor] Definition or symbol missing for deco key: ${randomDecoKey}`
              );
              continue;
            }
            const newDeco = {
              ...decoDefinition, // Copia todas las propiedades de la definición
              x: spawnX,
              y: spawnY,
              type: randomDecoKey, // El tipo ES la clave original de entityTypes
              id: `${randomDecoKey}_${Date.now()}_${i}_${Math.random()
                .toString(16)
                .slice(2)}`,
              discovered: true, // Importante: los decorativos suelen estar descubiertos
              isFixed: true, // Importante: para que no se limpien fácilmente
              isDecorative: true, // Asegura que sea true, incluso si la definición lo omite
            };

            gameState.map.entities.push(newDeco);
            addedCount++;
            // MODIFICACIÓN: Log más detallado, incluyendo si isDecorative es true en la instancia
            console.log(
              `[Decor] Added: ${newDeco.name} (Symbol: ${newDeco.symbol}, Type: ${newDeco.type}, IsDecorative: ${newDeco.isDecorative}) at ${spawnX},${spawnY}. ID: ${newDeco.id}`
            );
          } else {
            // console.log(`[Decor] Could not find position for a decorative element of type ${randomDecoKey} after 20 attempts.`);
          }
        }
        console.log(
          `[Decor] Finished populating. Added ${addedCount} decorative elements out of ${numberOfElements} attempts.`
        );
      }

      function populateZoneWithObjects(zone, initialPopulation = false) {
        if (!zone.spawnSettings) {
          console.log(
            `populateZoneWithObjects: Zone "${zone.name}" has no spawnSettings. Skipping.`
          );
          return;
        }

        console.log(
          `populateZoneWithObjects: Called for zone "${zone.name}". InitialPopulation: ${initialPopulation}`
        );

        zone.spawnSettings.targetEntities.forEach((targetSpawnInfo) => {
          console.log(
            `  Zone "${zone.name}": Processing target spawn info for entityTypeId "${targetSpawnInfo.entityTypeId}", count: ${targetSpawnInfo.count}, currentCount: ${targetSpawnInfo.currentCount}`
          );

          const entityTypeDefinition =
            entityTypes[targetSpawnInfo.entityTypeId];
          if (!entityTypeDefinition) {
            console.warn(
              `  Zone "${zone.name}": Definition for entityTypeId "${targetSpawnInfo.entityTypeId}" NOT FOUND in entityTypes.`
            );
            return;
          }

          let attemptSpawns =
            targetSpawnInfo.count - targetSpawnInfo.currentCount;
          console.log(
            `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Need to spawn ${attemptSpawns} (target: ${targetSpawnInfo.count}, current: ${targetSpawnInfo.currentCount})`
          );

          if (!initialPopulation && zone.spawnSettings.respawnTimer > 0) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Zone in cooldown (timer: ${zone.spawnSettings.respawnTimer}). Skipping spawn.`
            );
            return;
          }

          if (attemptSpawns <= 0 && !initialPopulation) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": No spawns needed and not initial population. Skipping.`
            );
            return;
          }
          if (
            attemptSpawns <= 0 &&
            initialPopulation &&
            targetSpawnInfo.currentCount >= targetSpawnInfo.count
          ) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Initial population, but already at target count. Skipping.`
            );
            return;
          }

          let spawnedThisCycle = 0;
          for (let i = 0; i < attemptSpawns; i++) {
            if (targetSpawnInfo.currentCount >= targetSpawnInfo.count) {
              console.log(
                `    Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Reached target count (${targetSpawnInfo.currentCount}/${targetSpawnInfo.count}). Stopping spawns for this type.`
              );
              break;
            }

            let spawnX,
              spawnY,
              attempts = 0;
            let positionFound = false;
            while (attempts < 20 && !positionFound) {
              spawnX =
                zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1 + 1));
              spawnY =
                zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1 + 1));

              const targetTerrainId = getTerrainTypeAt(spawnX, spawnY);
              const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
              const terrainWalkable =
                !targetTerrainData || targetTerrainData.walkable !== false;

              const isOccupied = gameState.map.entities.some(
                (e) => e.x === spawnX && e.y === spawnY
              );
              const isPlayerPos =
                spawnX === gameState.player.x && spawnY === gameState.player.y;

              if (terrainWalkable && !isOccupied && !isPlayerPos) {
                positionFound = true;
              }
              attempts++;
            }

            if (positionFound) {
              let newEntity;
              newEntity = {
                ...entityTypeDefinition, // <--- COPIAR TODAS LAS PROPIEDADES DE LA DEFINICIÓN PRIMERO
                x: spawnX,
                y: spawnY,
                type:
                  entityTypeDefinition.typeOverride ||
                  targetSpawnInfo.entityTypeId,
                id: `${
                  targetSpawnInfo.entityTypeId
                }_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                zoneOrigin: zone.name,
                originalEntityTypeId: targetSpawnInfo.entityTypeId,
                discovered: false,
                //name: entityTypeDefinition.name,
                //symbol: entityTypeDefinition.symbol,
                //interaction: entityTypeDefinition.interaction,
                //reward: entityTypeDefinition.reward,
              };
              // Asegurar HP/MaxHP para entidades de combate y limpiar para no combatientes
              if (
                G_COMBAT_ENTITY_TYPES.includes(newEntity.type) ||
                newEntity.isBoss ||
                newEntity.isSectChallengeRival
              ) {
                // Si entityTypeDefinition ya tiene hp/maxHp, el spread ya los copió.
                // Este bloque es más para asegurar que existan o para poner valores por defecto.
                newEntity.hp = newEntity.hp ?? entityTypeDefinition.hp ?? 50;
                newEntity.maxHp = newEntity.maxHp ?? newEntity.hp;
                // Aquí 'attack', 'defense', 'exp', 'lootTable' ya deberían estar copiados por el spread de entityTypeDefinition
              } else {
                // Para recursos u otras entidades no combativas
                delete newEntity.hp;
                delete newEntity.maxHp;
                delete newEntity.attack; // Asegurarse de que no tengan stats de combate
                delete newEntity.defense;
                delete newEntity.exp;
                // lootTable podría ser relevante para recursos si lo usaras para definir múltiples items de un nodo.
              }

              // Corrección específica si es un recurso, para que su 'type' en el mapa sea solo 'resource' si así lo deseas
              // para la lógica de interacción, o mantener el tipo específico si prefieres.
              // La lógica actual en handleEntityInteraction ya maneja bien `targetSpawnInfo.entityTypeId` como type.
              // if (entityTypeDefinition.type === "resource") newEntity.type = "resource";

              gameState.map.entities.push(newEntity);
              targetSpawnInfo.currentCount++;
              spawnedThisCycle++;
              console.log(
                `    SUCCESS: Spawned "${newEntity.name}" (Attack: ${newEntity.attack}, Final Type: ${newEntity.type}, OrigTypeID: ${newEntity.originalEntityTypeId}) in zone "${zone.name}" at (${spawnX},${spawnY}).`
              );
            } else {
              // console.log(`    FAILED: Could not find position for "${targetSpawnInfo.entityTypeId}" ...`);
              break;
            }
          }
          if (spawnedThisCycle > 0 && !initialPopulation) {
            zone.spawnSettings.respawnTimer =
              zone.spawnSettings.respawnCooldown;
            console.log(
              `  Zone "${zone.name}": Spawned ${spawnedThisCycle} of "${targetSpawnInfo.entityTypeId}". Setting respawn timer to ${zone.spawnSettings.respawnCooldown}s.`
            );
          }
        });
      }

      // Función para llamar en el bucle principal del juego o con setInterval
      function gameTickUpdater() {
      
        // Definimos la variable 'player' para que apunte al estado del jugador.
        const player = gameState.player; 
        

        const now = Date.now();
        const deltaTime = (now - gameState.lastGameTimeUpdate) / 1000;
        gameState.gameTime += deltaTime;
        gameState.lastGameTimeUpdate = now;

        if (player.passiveHpRegen > 0 && player.hp < player.maxHp && !gameState.battle.active && !player.isCultivating) {
          const regenAmount = player.passiveHpRegen * deltaTime;
          player.hp = Math.min(
            player.maxHp,
            player.hp + regenAmount
          );
          // Actualizamos solo las barras para no spamear la UI completa
          updateUI();
        }

    

        gameState.map.terrainZones.forEach((zone) => {
          if (zone.spawnSettings) {
            if (zone.spawnSettings.respawnTimer > 0) {
              zone.spawnSettings.respawnTimer -= deltaTime;
              if (zone.spawnSettings.respawnTimer < 0)
                zone.spawnSettings.respawnTimer = 0;
            }

            let needsRespawn = false;
            for (const target of zone.spawnSettings.targetEntities) {
              if (target.currentCount < target.count) {
                needsRespawn = true;
                break;
              }
            }
            
            const SPAWN_CHECK_COOLDOWN = 10;
            if (
              needsRespawn &&
              zone.spawnSettings.respawnTimer <= 0 &&
              gameState.gameTime - (zone.spawnSettings.lastSpawnCheck || 0) >
                SPAWN_CHECK_COOLDOWN
            ) {
              zone.spawnSettings.lastSpawnCheck = gameState.gameTime; 
              populateZoneWithObjects(zone, false);
            }
          }
        });
      }

      let animationFrameIndex = 0; // Para ciclar a través de PLAYER_WALK_CYCLE
      let lastPlayerMoveTime = 0; // Para controlar el tiempo de la animación

      function movePlayer(dx, dy) {
        movePlayerCallCount++;
        const callId = movePlayerCallCount;

        const now = Date.now();
        if (now - lastSuccessfulMoveTime < PLAYER_MOVE_COOLDOWN) {
          return;
        }

        const newX = gameState.player.x + dx;
        const newY = gameState.player.y + dy;
        let canMove = true;

        // Lógica de colisiones y movimiento (esta parte es correcta)
        if (
          newX < 0 ||
          newX >= gameState.map.width ||
          newY < 0 ||
          newY >= gameState.map.height
        ) {
          canMove = false;
        }
        if (canMove) {
          const targetTerrainId = getTerrainTypeAt(newX, newY);
          if (G_TERRAIN_TYPES[targetTerrainId]?.walkable === false) {
            canMove = false;
          }
        }
        if (canMove) {
          const entityAtNewPosition = gameState.map.entities.find(
            (e) => e.x === newX && e.y === newY
          );
          if (entityAtNewPosition) {
            if (
              G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) ||
              entityAtNewPosition.isBoss ||
              entityAtNewPosition.isSectChallengeRival
            ) {
              startBattle(entityAtNewPosition);
              return;
            }
            const entityTypeToCheck =
              entityAtNewPosition.originalEntityTypeId ||
              entityAtNewPosition.type;
            if (G_BLOCKING_ENTITY_TYPES.includes(entityTypeToCheck)) {
              canMove = false;
            }
          }
        }

        // Si el movimiento es válido, ejecutamos la lógica de zona
        if (canMove) {
          

          // 1. Obtenemos la zona ANTES de actualizar la posición del jugador
          const oldZone = getPlayerCurrentZone();
          const oldZoneName = oldZone ? oldZone.name : "Tierras Salvajes";
          

          // 2. ACTUALIZAMOS la posición del jugador en el gameState
          gameState.player.x = newX;
          gameState.player.y = newY;
          // === TRIGGER DE MISIÓN DE LLEGAR A PUNTO ===
          const misionesActivas = [...gameState.player.secta.misionesActivas]; // Copia para evitar problemas al modificar
          misionesActivas.forEach(misionActiva => {
              const misionData = MISIONES_DATA[misionActiva.id];
              if (misionData?.objetivo?.tipo === 'llegar_a_punto') {
                  const objetivo = misionData.objetivo;
                  // Comprobamos si las coordenadas del jugador coinciden con el objetivo
                  if (gameState.player.x === objetivo.x && gameState.player.y === objetivo.y) {
                      // Comprobamos si la misión no ha sido ya completada en este ciclo
                      if (misionActiva.progreso !== 1) {
                          misionActiva.progreso = 1; // Marcamos el objetivo como cumplido
                          logBattle(`Has llegado a ${objetivo.nombreArea || 'la ubicación designada'}.`); // Usamos logBattle para que se vea en el resumen
                          
                          const npcEntregaNombre = SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre || "el NPC correspondiente";
                          
                          showModal("Objetivo Alcanzado", 
                              `Has llegado a: <strong>${objetivo.nombreArea}</strong>.<br><br>Ahora debes reportar tu hallazgo a <strong>${npcEntregaNombre}</strong> en la secta para completar la misión.`);
                          
                          // Al llegar, el marcador visual ya no es necesario, así que repintamos el mapa
                          renderMap(); 
                      }
                  }
              }
          });
          // 3. Obtenemos la nueva zona AHORA que el jugador se ha movido
          const newZone = getPlayerCurrentZone();
          const newZoneName = newZone ? newZone.name : "Tierras Salvajes";
          

          // 4. La comparación clave
         
          if (newZoneName !== oldZoneName) {
           
            showZoneNotification(newZoneName);
          } else {
            console.log(`   ==> NO, el jugador sigue en la misma zona.`);
          }

          // 5. Actualizamos la propiedad del jugador para la UI del panel de estado.
          gameState.player.currentZoneName = newZoneName;

          // Actualizar el resto del juego
          updatePlayerPosition(`movePlayer_success_call_${callId}`);
          updateUI();
          lastSuccessfulMoveTime = now;

        }
      }

      //FIN FUNCION MOVE PLAYER
      function checkForAggressiveEnemies() {
        if (gameState.battle.active || isAnyModalOpen()) {
          return; // No iniciar combate si ya estamos en uno o en un modal.
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;

        // Comprobamos las 8 casillas adyacentes y la casilla actual
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue; // No comprobar la propia casilla del jugador

            const checkX = playerX + dx;
            const checkY = playerY + dy;

            const entity = gameState.map.entities.find(
              (e) => e.x === checkX && e.y === checkY
            );

            if (entity) {
              const isHostile =
                G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
                entity.isBoss ||
                entity.isMiniBoss;

              // Si la entidad es hostil, iniciamos la batalla
              if (isHostile) {
                showModal(
                  "¡Emboscada!",
                  `¡Un ${entity.name} te ataca al acercarte demasiado!`,
                  true
                );
                setTimeout(() => {
                  closeModal();
                  startBattle(entity);
                }, 1500);
                return; // Detenemos la función para no iniciar múltiples combates
              }
            }
          }
        }
      }

      function getEnemyNameColor(playerLevel, enemyLevel) {
        const levelDiff = enemyLevel - playerLevel;

        if (levelDiff >= 5) {
          return { color: "#ff4d4d", fontWeight: "bold" }; // Rojo (Muy Peligroso)
        } else if (levelDiff >= 3) {
          return { color: "#ff9b57", fontWeight: "normal" }; // Naranja (Peligroso)
        } else if (levelDiff >= 1) {
          return { color: "#f4d03f", fontWeight: "normal" }; // Amarillo (Más fuerte)
        } else if (levelDiff <= -5) {
          return { color: "#a0a0a0", fontWeight: "normal" }; // Gris (Trivial)
        } else {
          return { color: "#f4e4bc", fontWeight: "normal" }; // Blanco (Normal)
        }
      }

      function gameLoop() {
        if (
          isAnyModalOpen() ||
          gameState.battle.active ||
          gameState.player.isCultivating
        ) {
          gameState.player.isMoving = false; // Detener animación si el juego está pausado
          return;
        }

        handleMovement(); // Maneja la lógica de movimiento
        checkForAggressiveEnemies();
        // Actualiza el frame de la animación basado en el estado
        if (gameState.player.isMoving) {
          // Cicla entre los frames 1, 2, 3...
          const frameCount = gameState.player.animationFrames - 1; // e.g., si hay 4 frames, cicla entre 1,2,3
          gameState.player.currentFrame =
            (gameState.player.currentFrame % frameCount) + 1;
        } else {
          gameState.player.currentFrame = 0; // Frame 0 es quieto
        }

        updatePlayerSpriteVisual(); // Actualiza el sprite visualmente
      }

      // Ajuste menor en window.addEventListener('resize')
      window.addEventListener("resize", () => {
        calculateAndSetTileSize();
        // renderMap(); // updatePlayerPosition se encarga de esto
        updatePlayerPosition();
      });

      function getTerrainTypeAt(x, y) {
        if (
          x < 0 ||
          x >= gameState.map.width ||
          y < 0 ||
          y >= gameState.map.height
        ) {
          return null; // Fuera de los límites del mapa
        }

        // Opción A: Si usas terrainGrid directamente
        if (
          gameState.map.terrainGrid &&
          gameState.map.terrainGrid[y] &&
          gameState.map.terrainGrid[y][x]
        ) {
          return gameState.map.terrainGrid[y][x];
        }

        // Opción B: Usando terrainZones
        for (const zone of gameState.map.terrainZones) {
          if (x >= zone.x1 && x <= zone.x2 && y >= zone.y1 && y <= zone.y2) {
            return zone.type;
          }
        }
        return gameState.map.defaultTerrain; // Devuelve el terreno por defecto
      }

      function renderMap(callerId = "unknown") {
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!mapElement || !mapContainerElement) {
            return;
        }
        
     
        const currentZone = getPlayerCurrentZone();
        let currentAmbientColor = "#1a3d2e";
        if (currentZone && currentZone.isIsolated) {
            mapContainerElement.style.backgroundColor = currentZone.ambientColor || "#000";
        } else {
            mapContainerElement.style.backgroundColor = "#1a3d2e";
        }
        const currentContainerWidth = mapContainerElement.clientWidth;
        const currentContainerHeight = mapContainerElement.clientHeight;
        const playerScreenX = currentContainerWidth / 2 - currentTileSize / 2;
        const playerScreenY = currentContainerHeight / 2 - currentTileSize / 2;
        const mapExpectedScrollX = -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapExpectedScrollY = -(gameState.player.y * currentTileSize) + playerScreenY;
        const viewWorldXStart = Math.floor(-mapExpectedScrollX / currentTileSize);
        const viewWorldYStart = Math.floor(-mapExpectedScrollY / currentTileSize);
        const tilesInViewX = Math.ceil(currentContainerWidth / currentTileSize) + 2;
        const tilesInViewY = Math.ceil(currentContainerHeight / currentTileSize) + 2;
        const viewWorldXEnd = viewWorldXStart + tilesInViewX;
        const viewWorldYEnd = viewWorldYStart + tilesInViewY;

        mapElement.innerHTML = ""; 
        
       
        // 1. Renderizar TERRENO BASE
        for (let y = viewWorldYStart; y < viewWorldYEnd; y++) {
          for (let x = viewWorldXStart; x < viewWorldXEnd; x++) {
            let shouldDrawVoid = false;

            if (currentZone && currentZone.isIsolated) {
              if (
                x < currentZone.x1 ||
                x > currentZone.x2 ||
                y < currentZone.y1 ||
                y > currentZone.y2
              ) {
                shouldDrawVoid = true;
              }
            } else {
              // Si no estamos en una zona aislada, el "vacío" es cualquier cosa fuera de los límites del mapa.
              if (
                x < 0 ||
                x >= gameState.map.width ||
                y < 0 ||
                y >= gameState.map.height
              ) {
                shouldDrawVoid = true;
              }
            }
            if (shouldDrawVoid) {
              const voidTile = document.createElement("div");
              voidTile.className = "tile void-tile";
              voidTile.style.left = `${x * currentTileSize}px`;
              voidTile.style.top = `${y * currentTileSize}px`;
              voidTile.style.width = `${currentTileSize}px`;
              voidTile.style.height = `${currentTileSize}px`;
              voidTile.style.backgroundColor = currentAmbientColor; // Rellena con el color de ambiente
              voidTile.style.zIndex = "0";
              const voidTerrainData = G_TERRAIN_TYPES.VOID;
              if (voidTerrainData && voidTerrainData.textureUrl) {
                voidTile.style.backgroundImage = `url('${voidTerrainData.textureUrl}')`;
                voidTile.style.backgroundSize = "cover";
              } else {
                // Si la textura del vacío no se encuentra, vuelve a usar el color ambiental
                voidTile.style.backgroundColor = currentAmbientColor;
              }
              mapElement.appendChild(voidTile);
              continue; // Pasa al siguiente tile del bucle
            }
            const terrainId = getTerrainTypeAt(x, y);
            const terrainData = G_TERRAIN_TYPES[terrainId];
            if (terrainData) {
              const terrainTile = document.createElement("div");
              terrainTile.className = "tile terrain-tile";
              terrainTile.style.left = `${x * currentTileSize}px`;
              terrainTile.style.top = `${y * currentTileSize}px`;
              terrainTile.style.width = `${currentTileSize}px`;
              terrainTile.style.height = `${currentTileSize}px`;
              terrainTile.style.zIndex = "1";

              if (terrainData.textureUrl) {
                terrainTile.style.backgroundImage = `url('${terrainData.textureUrl}')`;
                terrainTile.style.backgroundSize = "cover";
              } else {
                terrainTile.style.backgroundColor = terrainData.color;
              }

              mapElement.appendChild(terrainTile);
              // === INICIO DEL CÓDIGO NUEVO: MARCADOR DE MISIÓN ===
              gameState.player.secta.misionesActivas.forEach(misionActiva => {
                  const misionData = MISIONES_DATA[misionActiva.id];
                  if (misionData?.objetivo?.tipo === 'llegar_a_punto' && misionActiva.progreso !== 1) {
                      const objetivo = misionData.objetivo;
                      // Si la casilla actual (x, y) es la del objetivo de la misión
                      if (x === objetivo.x && y === objetivo.y) {
                          const missionMarker = document.createElement('div');
                          missionMarker.style.position = 'absolute';
                          missionMarker.style.left = `${x * currentTileSize}px`;
                          missionMarker.style.top = `${y * currentTileSize}px`;
                          missionMarker.style.width = `${currentTileSize}px`;
                          missionMarker.style.height = `${currentTileSize}px`;
                          missionMarker.style.pointerEvents = 'none'; // Para que no interfiera con clics
                          missionMarker.style.zIndex = '2'; // Justo encima del terreno
                          missionMarker.style.animation = 'pulse-mission-marker 2s infinite';
                          
                          // Usamos un borde brillante para marcar la casilla
                          missionMarker.style.border = '3px solid rgba(255, 223, 0, 0.7)';
                          missionMarker.style.boxSizing = 'border-box';
                          missionMarker.style.borderRadius = '4px';

                          mapElement.appendChild(missionMarker);
                      }
                  }
              });
            }
          }
        }

        // 2. Renderizar ENTIDADES
        gameState.map.entities.forEach((entity) => {
          if (entity.discovered) {
            if (
              entity.x >= viewWorldXStart &&
              entity.x < viewWorldXEnd &&
              entity.y >= viewWorldYStart &&
              entity.y < viewWorldYEnd
            ) {
              const entityContainer = document.createElement("div");
              entityContainer.style.position = "absolute";
              entityContainer.style.left = `${entity.x * currentTileSize}px`;
              entityContainer.style.top = `${entity.y * currentTileSize}px`;
              entityContainer.style.width = `${currentTileSize}px`;
              entityContainer.style.height = `${currentTileSize}px`;
              entityContainer.style.display = "flex";
              entityContainer.style.alignItems = "center";
              entityContainer.style.justifyContent = "center";
              entityContainer.style.zIndex = "5";

              const definition =
                entityTypes[entity.originalEntityTypeId] ||
                entityTypes[entity.type] ||
                (entity.typeOverride && entityTypes[entity.typeOverride]);

              // La URL del sprite se toma de la instancia, o de la definición encontrada.
              const spriteUrl =
                entity.spriteUrl || (definition ? definition.spriteUrl : null);
              if (spriteUrl) {
                entityContainer.style.backgroundImage = `url('${spriteUrl}')`;

                if (entity.originalEntityTypeId === "secta_entrada_principal") {
                  entityContainer.style.backgroundSize = "120%";
                  entityContainer.style.top = `${
                    (entity.y - 1.2) * currentTileSize
                  }px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                  // 1. Aumentamos el ancho del contenedor para que quepa el sprite
                  entityContainer.style.width = `${currentTileSize * 3}px`;

                  // 2. Ajustamos la posición izquierda para centrar el nuevo contenedor ancho
                  // Posición original: entity.x * currentTileSize
                  // Nuevo ancho: currentTileSize * 2.5
                  // Para centrarlo, debemos desplazarlo a la izquierda la mitad de su ancho extra.
                  // Ancho extra = (2.5 - 1) = 1.5. Mitad del ancho extra = 0.75.
                  entityContainer.style.left = `${
                    (entity.x - 0.75) * currentTileSize
                  }px`;
                } else if (entity.originalEntityTypeId === "shop") {
                  entityContainer.style.backgroundSize = "120%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.height = `${currentTileSize * 2}px`;
                  entityContainer.style.width = `${currentTileSize * 2}px`;
                  entityContainer.style.left = `${
                    (entity.x - 0.75) * currentTileSize
                  }px`;
                } else if (
                  entity.originalEntityTypeId === "deco_arbol_grande"
                ) {
                  entityContainer.style.backgroundSize = "120%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.height = `${currentTileSize * 1.2}px`;
                }else if (
                  entity.originalEntityTypeId === "deco_montaña_large"
                ) {
                  entityContainer.style.backgroundSize = "180%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 4}px`;
                  entityContainer.style.height = `${currentTileSize * 1}px`;
                }
                 else if (entity.originalEntityTypeId === "boss_dem") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (entity.originalEntityTypeId === "tp_sect_hub") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (entity.originalEntityTypeId === "tp_forest_shrine") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (entity.originalEntityTypeId === "tp_desert_oasis") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (
                  entity.originalEntityTypeId === "osa_mayor_esmeralda"
                ) {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1.5) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 1}px`;
                  entityContainer.style.height = `${currentTileSize * 2}px`;
                } else if (
                  entity.originalEntityTypeId === "monster_desierto_golem_arena"
                ) {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1.5) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 1}px`;
                  entityContainer.style.height = `${currentTileSize * 2}px`;
                } else if (entity.originalEntityTypeId === "tp_swamp_ruin") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                }else if (entity.originalEntityTypeId === "tp_desfiladero") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                }else if (entity.originalEntityTypeId === "tp_dragon_valley") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                }
                 else {
                  entityContainer.style.backgroundSize = "80%";
                }

                entityContainer.style.backgroundPosition = "center bottom";
                entityContainer.style.backgroundRepeat = "no-repeat";
              } else {
                entityContainer.textContent =
                  entity.symbol || (definition ? definition.symbol : "?");
                entityContainer.style.fontSize = `${
                  currentTileSize * (entity.isDecorative ? 0.5 : 0.6)
                }px`;
              }

              if (entity.isDecorative) {
                entityContainer.style.opacity = "0.7";
                entityContainer.style.zIndex = "3";
              }

              mapElement.appendChild(entityContainer);

              const isHostile =
                G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
                entity.isBoss ||
                entity.isMiniBoss;
              const isImportantNPC = entity.npcId && !isHostile;

              if (isHostile || isImportantNPC) {
                const namePlate = document.createElement("div");
                namePlate.className = "entity-name-plate";

                let displayText = entity.name;

                if (isHostile) {
                  // 1. Añadir etiqueta de estatus si existe
                  if (entity.isBoss) {
                    displayText += ` (Jefe)`;
                  } else if (entity.isMiniBoss) {
                    displayText += ` (Élite)`;
                  }

                  // 2. Añadir SIEMPRE el nivel si la entidad lo tiene
                  if (entity.level) {
                    displayText += ` (Nv. ${entity.level})`;
                  }

                  // 3. Aplicar color
                  if (entity.isBoss) {
                    namePlate.style.color = "#ff4d4d"; // Rojo para Jefes
                    namePlate.style.fontWeight = "bold";
                  } else {
                    // Para todos los demás enemigos (miniboss y comunes), usar la escala de color
                    const nameStyle = getEnemyNameColor(
                      gameState.player.level,
                      entity.level || 1
                    );
                    namePlate.style.color = nameStyle.color;
                    namePlate.style.fontWeight = nameStyle.fontWeight;
                  }
                }

                namePlate.textContent = displayText;
                entityContainer.appendChild(namePlate);
              }
            }
          }
        });
        // --- DIBUJAR RUNAS DE COMBATE (LIGADAS A ENEMIGOS) ---
        gameState.map.entities.forEach(entity => {
        if (entity.formationRunes) {
            Object.keys(entity.formationRunes).forEach(runeKey => {
                const [x, y] = runeKey.split(',').map(Number);
                if (x >= viewWorldXStart && x < viewWorldXEnd && y >= viewWorldYStart && y < viewWorldYEnd) {
                    const runeMarker = document.createElement('div');
                    runeMarker.className = 'tile rune-marker';
                    runeMarker.style.left = `${x * currentTileSize}px`;
                    runeMarker.style.top = `${y * currentTileSize}px`;
                    runeMarker.style.width = `${currentTileSize * 0.6}px`;
                    runeMarker.style.height = `${currentTileSize * 0.6}px`;
                    runeMarker.style.margin = `${currentTileSize * 0.2}px`;
                    runeMarker.style.zIndex = '4';
                    runeMarker.style.pointerEvents = 'none';
                    mapElement.appendChild(runeMarker);
                }
            });
        }
    });

    // --- DIBUJAR RUNAS DE UTILIDAD (NO LIGADAS A ENEMIGOS) ---
    Object.keys(gameState.utilityRunes).forEach(runeKey => {
        const [x, y] = runeKey.split(',').map(Number);
        
        if (x >= viewWorldXStart && x < viewWorldXEnd && y >= viewWorldYStart && y < viewWorldYEnd) {
            const runeMarker = document.createElement('div');
            runeMarker.className = 'tile rune-marker'; 
            runeMarker.style.left = `${x * currentTileSize}px`;
            runeMarker.style.top = `${y * currentTileSize}px`;
            runeMarker.style.width = `${currentTileSize * 0.6}px`;
            runeMarker.style.height = `${currentTileSize * 0.6}px`;
            runeMarker.style.margin = `${currentTileSize * 0.2}px`;
            runeMarker.style.zIndex = '4';
            runeMarker.style.pointerEvents = 'none';
            // Damos un color diferente para distinguirlas visualmente
            runeMarker.style.borderColor = '#66ccff';
            runeMarker.style.boxShadow = '0 0 15px #66ccff, inset 0 0 10px #66ccff';
            mapElement.appendChild(runeMarker);
        }
    });

        updatePlayerVisualSize();
      }
    
      function checkAndApplyFormation(enemyEntity) {
        // La función ahora se enfoca en aplicar los efectos ya guardados
        if (!enemyEntity.pendingFormationEffects || enemyEntity.pendingFormationEffects.length === 0) {
            return; // No hay efectos de formación pendientes para este enemigo
        }

        logBattle("¡Las formaciones rúnicas preestablecidas se activan!");
        const scribingTech = gameState.player.learnedTechniques["formation_scribing_1"];
        let amplification = 1.0; // Por defecto, sin amplificación
        if (scribingTech && scribingTech.level > 1) {
            const baseAmplification = techniqueData.formation_scribing_1.effect.amplificationPerLevel;
            amplification += (scribingTech.level - 1) * baseAmplification;
        }
        // Iteramos sobre cada efecto acumulado y lo aplicamos
        enemyEntity.pendingFormationEffects.forEach(effect => {
            const formationName = Object.keys(FORMATION_PATTERNS).find(key => FORMATION_PATTERNS[key].effect === effect)?.name || "Formación Desconocida";
            
            switch(effect.type) {
              case 'enemy_debuff':
                if (effect.stat === 'defense') {
                    // Aplicamos la amplificación
                    const defenseReduction = Math.floor(effect.amount * amplification);
                    gameState.battle.enemy.defense -= defenseReduction;
                    if(gameState.battle.enemy.defense < 0) gameState.battle.enemy.defense = 0;
                    let logMsg = `"${formationName}" quiebra las defensas del enemigo, reduciéndolas en ${defenseReduction}`;
                    if (amplification > 1.0) logMsg += " (¡Amplificado!)";
                    logBattle(logMsg + ".");
                    showFloatingText(document.getElementById('enemySprite'), `Defensa ↓↓`, 'debuff');
                }
                break;
                case 'player_buff':
                if (effect.stat === 'hpRegenPerTurn') {
                    // Aplicamos la amplificación
                    const hpRegen = Math.floor(effect.amount * amplification);
                    gameState.player.hpRegenPerTurn = (gameState.player.hpRegenPerTurn || 0) + hpRegen;
                    let logMsg = `"${formationName}" te envuelve en energía vital, curándote ${hpRegen} HP cada turno`;
                    if (amplification > 1.0) logMsg += " (¡Amplificado!)";
                    logBattle(logMsg + ".");
                    showFloatingText(document.querySelector('.character-sprite'), `Regeneración+`, 'ability');
                }else if (effect.stat === 'defenseBoost') {
                    const defenseBonus = Math.floor(effect.amount * amplification);
                    gameState.player.defense += defenseBonus;
                    logBattle(`La "${formationName}" endurece tu cuerpo, ¡ganas ${defenseBonus} de Defensa para este combate!`);
                    showFloatingText(document.querySelector('.character-sprite'), `Defensa +${defenseBonus}`, 'ability');
                }else if (effect.stat === 'manaRegenPerTurn') {
                    const manaRegenBonus = Math.floor(effect.amount * amplification);
                    gameState.player.manaRegenPerTurn = (gameState.player.manaRegenPerTurn || 0) + manaRegenBonus;
                    logBattle(`El "${formationName}" crea un pozo de energía, restaurando ${manaRegenBonus} Maná cada turno.`);
                    showFloatingText(document.querySelector('.character-sprite'), `Flujo de Qi`, 'ability');
                }
                // =======================================
        
                    break;
                // Aquí puedes añadir más tipos de efectos en el futuro
            }
        });

        // Limpiamos los efectos pendientes después de aplicarlos
        enemyEntity.pendingFormationEffects = [];
        // También limpiamos cualquier runa restante que no formara un patrón
        enemyEntity.formationRunes = {};
    }

      function updatePlayerSpriteVisual() {
        // Asegúrate que el nombre sea este
        const player = gameState.player;
        const playerElement = document.getElementById("player");
        if (!playerElement) return;

        // Verificación para depurar el error de la línea 2263
        if (
          !player.directionRowMap ||
          typeof player.currentDirection === "undefined"
        ) {
          console.error(
            "CRITICAL: player.directionRowMap o player.currentDirection no están definidos en updatePlayerSpriteVisual.",
            player
          );
          // Podrías establecer valores por defecto aquí como un parche temporal,
          // pero lo ideal es que estén bien inicializados en gameState.
          // player.currentDirection = player.currentDirection || 'down';
          // player.directionRowMap = player.directionRowMap || { 'down': 0, 'left': 1, 'right': 2, 'up': 3 };
          // player.currentFrame = player.currentFrame || 0;
          // player.frameWidth = player.frameWidth || 64;
          // player.frameHeight = player.frameHeight || 64;
          return; // Salir si faltan datos cruciales para evitar más errores
        }

        const row = player.directionRowMap[player.currentDirection];
        const col = player.currentFrame;

        // Otra verificación
        if (typeof row === "undefined" || typeof col === "undefined") {
          console.error(
            "CRITICAL: 'row' o 'col' son undefined en updatePlayerSpriteVisual.",
            {
              playerDir: player.currentDirection,
              playerFrame: player.currentFrame,
              map: player.directionRowMap,
            }
          );
          return;
        }

        const offsetX = col * player.frameWidth;
        const offsetY = row * player.frameHeight;

        playerElement.style.backgroundPosition = `-${offsetX}px -${offsetY}px`;

        if (gameState.battle.active) {
          const battlePlayerSprite = document.querySelector(
            ".battle-area .character-sprite"
          );
          if (battlePlayerSprite) {
            const battleRow = player.directionRowMap["down"];
            const battleFrame = 0;
            const battleOffsetX = battleFrame * player.frameWidth;
            const battleOffsetY = battleRow * player.frameHeight;
            battlePlayerSprite.style.backgroundPosition = `-${battleOffsetX}px -${battleOffsetY}px`;
          }
        }
      }

      function updatePlayerVisualSize() {
        const playerElement = document.getElementById("player");
        if (playerElement) {
          // ESTO ES CRUCIAL: El tamaño del div del jugador DEBE ser el tamaño de UN FRAME
          // Si currentTileSize representa el tamaño deseado del jugador en pantalla,
          // y tus frames en la hoja de sprites son de un tamaño fijo (ej. 64x64),
          // entonces el div del jugador también debe ser de ese tamaño fijo para que background-position funcione.
          // O, si quieres que el jugador se reescale con currentTileSize, entonces frameWidth/Height
          // deben ser iguales a currentTileSize, y background-size debe escalar la hoja completa.

          // Opción A: El jugador mantiene el tamaño del frame original, y currentTileSize es solo para el mapa.
          playerElement.style.width = `${gameState.player.frameWidth}px`;
          playerElement.style.height = `${gameState.player.frameHeight}px`;
        }
      }

      function updatePlayerPosition(callerId = "unknown") {
        const playerElement = document.getElementById("player");
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!playerElement || !mapElement || !mapContainerElement) {
          console.error(
            "UpdatePlayerPosition: Elemento(s) clave no encontrado(s)."
          );
          return;
        }

        const playerVisualWidth = gameState.player.frameWidth; // Usar el tamaño real del frame del sprite
        const playerVisualHeight = gameState.player.frameHeight;

        const playerScreenX =
          mapContainerElement.clientWidth / 2 - playerVisualWidth / 2;
        const playerScreenY =
          mapContainerElement.clientHeight / 2 - playerVisualHeight / 2;

        playerElement.style.left = `${playerScreenX}px`;
        playerElement.style.top = `${playerScreenY}px`;

        const mapScrollX =
          -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapScrollY =
          -(gameState.player.y * currentTileSize) + playerScreenY;

        mapElement.style.transform = `translate(${mapScrollX}px, ${mapScrollY}px)`;

        gameState.map.entities.forEach((entity) => {
          const distance =
            Math.abs(entity.x - gameState.player.x) +
            Math.abs(entity.y - gameState.player.y);
          if (distance <= G_PLAYER_DISCOVERY_RANGE) {
            if (!entity.discovered) entity.discovered = true;
          }
        });

        renderMap(callerId);
        updatePlayerSpriteVisual();
        updatePlayerVisualSize();
        updatePlayerBarsOnMap();
        updateExtraStatsUI();
        updateGrid();
      }

      function updateUI() {
        const player = gameState.player;
        document.getElementById("playerLevel").textContent = player.level;
        document.getElementById("playerRealm").textContent = player.realm;
        document.getElementById("hpText").textContent = `${Math.floor(
          player.hp
        )}/${player.maxHp}`;
        document.getElementById("manaText").textContent = `${Math.floor(
          player.mana
        )}/${player.maxMana}`;
        document.getElementById("expText").textContent = `${Math.floor(
          player.exp
        )}/${player.expToNext}`;

        // Barras del Sidebar
        const hpBarSidebar = document.getElementById("hpBar");
        const manaBarSidebar = document.getElementById("manaBar");
        const expBarSidebar = document.getElementById("expBar");

        if (hpBarSidebar)
          hpBarSidebar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        if (manaBarSidebar)
          manaBarSidebar.style.width = `${
            (player.mana / player.maxMana) * 100
          }%`;
        if (expBarSidebar)
          expBarSidebar.style.width = `${
            (player.exp / player.expToNext) * 100
          }%`;

        document.getElementById(
          "playerCoords"
        ).textContent = `X: ${player.x}, Y: ${player.y}`;

        updateExtraStatsUI();
        updateInventoryUI(); // Asumo que esta función existe y es correcta
        updateSectUI(); // Asumo que esta función existe y es correcta

        updatePlayerBarsOnMap(); // <--- LLAMADA AÑADIDA para las barras sobre el jugador
      }

      function updateInventoryUI() {
        const inventoryDisplay = document.getElementById("inventory");
        inventoryDisplay.innerHTML = "";
        Object.entries(gameState.inventory).forEach(([itemName, count]) => {
          if (count <= 0 && itemName !== "Piedras Espirituales") return;

          const itemDiv = document.createElement("div");
          itemDiv.className = "inventory-item";

          const itemInfo = itemData[itemName];
          const description = itemInfo
            ? itemInfo.description
            : "Un objeto misterioso.";
          itemDiv.innerHTML = `<strong>${itemName}: ${count}</strong><br><small><em>${description}</em></small>`;

          if (count > 0 && itemInfo && itemInfo.effect) {
            const canBeUsedNow = itemInfo.canUse
              ? itemInfo.canUse(gameState.player)
              : true;
            itemDiv.style.cursor = canBeUsedNow ? "pointer" : "not-allowed";
            itemDiv.style.opacity = canBeUsedNow ? 1 : 0.6;
            itemDiv.title = canBeUsedNow
              ? `Usar ${itemName}`
              : `No puedes usar ${itemName} ahora.`;
            if (canBeUsedNow) {
              itemDiv.onclick = () => useItem(itemName);
            }
          } else {
            itemDiv.style.opacity = 0.8;
            itemDiv.style.cursor = "default";
          }
          inventoryDisplay.appendChild(itemDiv);
        });
      }

      function updateRefinementUI() {}

      let lastPlayerAnimationUpdateTime = 0; // Renombrado para claridad

      function handleMovement() {
        let dx = 0;
        let dy = 0;
        let newDirection = null;

        // Determina la dirección del movimiento
        if (playerMovementKeysDown.up) {
          dy = -1;
          newDirection = "up";
        } else if (playerMovementKeysDown.down) {
          dy = 1;
          newDirection = "down";
        } else if (playerMovementKeysDown.left) {
          dx = -1;
          newDirection = "left";
        } else if (playerMovementKeysDown.right) {
          dx = 1;
          newDirection = "right";
        }

        // Si hay una dirección presionada, intenta mover al jugador
        if (newDirection) {
          gameState.player.currentDirection = newDirection;
          movePlayer(dx, dy); // La lógica de cooldown y colisión está dentro
        }

        // Lógica de animación visual (separada de la lógica de movimiento)
        const isActuallyMoving =
          playerMovementKeysDown.up ||
          playerMovementKeysDown.down ||
          playerMovementKeysDown.left ||
          playerMovementKeysDown.right;
        gameState.player.isMoving = isActuallyMoving;
      }

      function interact() {
        if (gameState.player.isCultivating) {
          showModal(
            "Acción no permitida",
            "Detén tu cultivo antes de interactuar."
          );
          return;
        }
        if (gameState.battle.active) {
          showModal(
            "Acción no permitida",
            "No puedes interactuar durante el combate."
          );
          return;
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        const offsets = [
          { dx: 0, dy: 0 },
          { dx: 0, dy: -1 },
          { dx: 1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: -1, dy: 0 },
        ];

        for (const offset of offsets) {
          const targetX = playerX + offset.dx;
          const targetY = playerY + offset.dy;
          const entity = gameState.map.entities.find(
            (e) => e.x === targetX && e.y === targetY
          );

          if (entity) {
            if (
              G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
              entity.isBoss ||
              entity.isSectChallengeRival
            ) {
              const desafioMision = gameState.player.secta.misionesActivas.find(
                (m) =>
                  MISIONES_DATA[m.id]?.objetivo?.tipo ===
                    "derrotar_npc_especifico" &&
                  MISIONES_DATA[m.id]?.objetivo?.npcId === entity.npcId
              );
              if (entity.isSectChallengeRival) {
                if (desafioMision) {
                  showModal(
                    "¡Desafío Aceptado!",
                    `Te preparas para enfrentar a ${entity.name}.`,
                    true
                  );
                  setTimeout(() => {
                    closeModal();
                    startBattle(entity);
                  }, 1500);
                } else {
                  showModal(
                    "Paz, por ahora...",
                    `${entity.name} te observa, pero no hay razón para luchar.`
                  );
                }
              } else {
                showModal(
                  "¡A la Batalla!",
                  `Decides enfrentar a ${entity.name}.`,
                  true
                );
                setTimeout(() => {
                  closeModal();
                  startBattle(entity);
                }, 1000);
              }
              return;
            } else if (
              entity.interaction ||
              entityTypes[entity.type]?.interaction ||
              [
                "resource",
                "master",
                "cultivation",
                "shop",
                "secta_entrada_principal",
              ].includes(entity.type)
            ) {
              handleEntityInteraction(entity);
              return;
            }
          }
        }
      }

      function handleEntityInteraction(entity) {
        if (!entity) return;

        let interactionType = entity.interaction; // Priorizar la interacción de la instancia

        // Si no hay interacción en la instancia, buscar en la definición de entityTypes
        // usando entity.originalEntityTypeId si está disponible, sino entity.type
        const definitionKey = entity.originalEntityTypeId || entity.type;
        if (!interactionType && entityTypes[definitionKey]) {
          interactionType = entityTypes[definitionKey].interaction;
        }
        // === INICIO DE LA NUEVA LÓGICA DE TRANSICIÓN ===
        if (interactionType === "transition") {
          const definition = entityTypes[definitionKey];
          if (
            definition &&
            typeof definition.targetX === "number" &&
            typeof definition.targetY === "number"
          ) {
            // Función que se ejecutará si el jugador confirma
            const doTransition = () => {
              gameState.player.x = definition.targetX;
              gameState.player.y = definition.targetY;
              updatePlayerPosition(`transition_to_${definitionKey}`); // ¡Muy importante!
              showModal(
                "Transición Completa",
                `Has llegado a ${definition.name}.`
              );
            };

            // Mostramos el modal de confirmación
            showConfirmationModal(
              `Entrar a ${entity.name}`,
              "¿Deseas pasar a la siguiente zona?",
              doTransition // Pasamos la función como callback
            );
          } else {
            console.warn(
              `La entidad de transición ${definitionKey} no tiene coordenadas de destino (targetX, targetY).`
            );
          }
          return; // Detenemos la ejecución para no procesar otros switches
        }
        if (interactionType === "activate_teleporter") {
          handleTeleporterInteraction(entity);
          return; // Detener para no procesar otros switches
        }
        if (interactionType) {
          switch (interactionType) {
            case "browse":
              if (entity.type === "shop") {
                openShop();
                return;
              }
              break;
            case "talk_story_npc":
            if (entity.npcId) {
                    const dialogue = getStoryNpcDialogue(entity.npcId);
                    showModal(`Hablando con ${entity.name}`, dialogue);
                }
              return;
            case "read_formation_tutorial":
              openFormationTutorial();
              return;
            case "interact_shrine": // <-- NUEVO CASO
                if (entity.type === 'story_shrine') {
                    const player = gameState.player;
                    const flags = player.worldState.storyFlags;
                    if (flags.knowsAboutSoberano && !flags.knowsFullTruth) {
                        flags.knowsFullTruth = true;
                        showModal("Un Eco del Pasado",
                            "Al tocar el santuario, una voz antigua resuena en tu mente...<br><br><em>'El Soberano Silente... fue nuestro mayor héroe, Longwei. Su poder amenazó con consumir todo, y lo sellamos. Pero el sello no es eterno... La resonancia en tu alma... el Arte del Corazón Celeste... no es para sellar, sino para purificar. Esa es tu verdadera prueba.'</em><br><br><strong>La verdad completa te ha sido revelada.</strong>"
                        );
                    } else if (flags.knowsFullTruth) {
                        showModal("Santuario del Eco", "El santuario permanece en silencio, su propósito cumplido. El camino ahora es tuyo.");
                    } else {
                        showModal("Santuario del Eco", "Sientes una energía antigua y melancólica, pero no puedes descifrar su significado... todavía.");
                    }
                }
                return;
            case "read_lore":
              if (entity.loreText) {
                  showModal(entity.name, `<em>${entity.loreText}</em>`);
              }
              return;
            case "talk_secta_npc":
              if (entity.npcId) {
                interactWithSectNPC(entity.npcId);
                return;
              }
              break;
            case "access_sect_hall":
              if (entity.type === "secta_entrada_principal") {
                openSectHallInterface();
                return;
              }
              break;
            case "collect_resource":
              const rewardItem =
                entity.reward ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].reward
                  : null) ||
                "Piedras Espirituales"; // Último fallback

              const itemNameDisplay =
                entity.name ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].name
                  : entity.type);

              gameState.inventory[rewardItem] =
                (gameState.inventory[rewardItem] || 0) + 1;
              showModal(
                "Recurso Encontrado",
                `Has obtenido: 1 ${rewardItem}! (de ${itemNameDisplay})`
              );
              removeEntity(entity);
              updateInventoryUI();
              return;
            case "learn_from_master":
              const expGain =
                entity.expGain || entityTypes[entity.type]?.expGain || 50;
              gainExperience(expGain);
              showModal(
                "Encuentro con Maestro",
                `El ${entity.name} te ha enseñado sabiduría. Ganas ${expGain} EXP!`
              );
              removeEntity(entity);
              return;
            case "meditate_spot":
              const manaGain =
                entity.manaGain || entityTypes[entity.type]?.manaGain || 20;
              gameState.player.mana = Math.min(
                gameState.player.maxMana,
                gameState.player.mana + manaGain
              );
              showModal(
                "Lugar de Cultivo",
                `Has meditado en '${entity.name}'. Recuperas ${manaGain} Maná.`
              );
              removeEntity(entity);
              updateUI();
              return;
            default:
              console.warn(
                `Interacción '${interactionType}' desconocida para ${entity.name} (Tipo: ${entity.type}, ID: ${entity.id}).`
              );
              break;
          }
        } else {
          console.log(
            `No hay acción definida para tipo '${entity.type}' (Entidad: ${entity.name}, ID: ${entity.id}, OrigTypeID: ${entity.originalEntityTypeId}).`
          );
        }
      }

      // REEMPLAZA tu función interactWithSectNPC con esta versión completa y corregida

    function interactWithSectNPC(npcId) {
        const npcData = SECTA_DATA.npcs[npcId];
        const player = gameState.player;
        if (!npcData) {
            console.error(`[interactWithSectNPC] NPC Data no encontrada para npcId: ${npcId}`);
            return;
        }

        let modalContentHTML = `<h3>${npcData.nombre} (${npcData.rol})</h3>`;
        modalContentHTML += `<p><em>"${npcData.dialogoInicial}"</em></p><hr>`;

        const elementsToProcess = [];

        // --- SECCIÓN: MISIONES PARA COMPLETAR ---
        modalContentHTML += `<h4>Misiones para Entregar/Reportar:</h4>`;
        let algunaMisionParaCompletar = false;

        player.secta.misionesActivas.forEach((misionActiva) => {
            const misionDef = MISIONES_DATA[misionActiva.id];
            if (!misionDef || !misionDef.objetivo || !misionActiva.objetivoOriginal) {
                return;
            }

            const objetivo = misionActiva.objetivoOriginal;

            if (objetivo.npcEntrega === npcId) {
                let listaParaEntregar = false;
                let objetivoStatus = "";

                switch (objetivo.tipo) {
                    case "entregar_item":
                        const playerHasItem = gameState.inventory[objetivo.item] || 0;
                        if (playerHasItem >= objetivo.cantidad) {
                            listaParaEntregar = true;
                        }
                        objetivoStatus = `(Necesitas ${objetivo.cantidad} ${objetivo.item})`;
                        break;

                    case "eliminar_enemigo":
                        if ((misionActiva.progreso || 0) >= objetivo.cantidad) {
                            listaParaEntregar = true;
                        }
                        objetivoStatus = `(Elimina ${objetivo.cantidad} ${objetivo.nombreDisplay})`;
                        break;

                    case "recolectar_multiples_items":
                        let todosRecolectados = true;
                        objetivo.items.forEach(itemReq => {
                            if ((gameState.inventory[itemReq.nombre] || 0) < itemReq.cantidad) {
                                todosRecolectados = false;
                            }
                        });
                        if (todosRecolectados) {
                            listaParaEntregar = true;
                        }
                        objetivoStatus = `(Recolecta los materiales requeridos)`;
                        break;
                    
                    // --- INICIO DE LA LÓGICA AÑADIDA ---
                    case "llegar_a_punto":
                        // La misión está lista para entregar si el progreso es 1 (lo que significa que el jugador ha llegado al punto).
                        if (misionActiva.progreso === 1) {
                            listaParaEntregar = true;
                            objetivoStatus = `(Has llegado a ${objetivo.nombreArea || 'la ubicación designada'})`;
                        } else {
                            objetivoStatus = `(Debes ir a ${objetivo.nombreArea || 'la ubicación designada'})`;
                        }
                        break;
                    // --- FIN DE LA LÓGICA AÑADIDA ---

                    case "derrotar_npc_especifico":
                        if (misionActiva.progreso === 1) {
                            listaParaEntregar = true;
                        }
                        const rivalName = entityTypes[objetivo.npcId]?.name || "el guardián";
                        objetivoStatus = `(Debes derrotar a ${rivalName})`;
                        break;
                    
                    case "cazar_y_recuperar_item_de_loot":
                        const playerHasLootItem = (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba;
                        if (misionActiva.progreso === 1 && playerHasLootItem) {
                            listaParaEntregar = true;
                        }
                        objetivoStatus = `(Caza a ${entityTypes[objetivo.enemigoTipo]?.name} para obtener ${objetivo.itemPrueba})`;
                        break;

                    default:
                        console.warn(`[NPC Interaction] Unhandled objective type "${objetivo.tipo}" for mission "${misionDef.titulo}" completion check with NPC.`);
                        objetivoStatus = `(Objetivo: ${objetivo.tipo} - estado no verificado aquí)`;
                        break;
                }

                if (listaParaEntregar) {
                    const buttonId = `complete-mission-btn-${misionActiva.id.replace(/\W/g, "_")}`;
                    modalContentHTML += `<div style="padding: 5px; border: 1px solid #55cc55; margin-bottom: 5px; background-color: rgba(85,204,85,0.1);">
                                              <strong>${misionDef.titulo}</strong> ${getMissionProgressText(misionActiva)}<br>
                                              <button id="${buttonId}">Completar Misión</button>
                                          </div>`;
                    elementsToProcess.push({
                        buttonId: buttonId,
                        action: () => {
                            if (completeMission(misionActiva.id, npcId)) {
                                interactWithSectNPC(npcId);
                            }
                        },
                    });
                    algunaMisionParaCompletar = true;
                } else {
                    modalContentHTML += `<div style="padding: 5px; border: 1px solid #777; margin-bottom: 5px; background-color: rgba(100,100,100,0.1);">
                                              <strong>${misionDef.titulo}</strong><br>
                                              <small><em>${getMissionProgressText(misionActiva)}</em></small>
                                          </div>`;
                }
            }
        });

        if (!algunaMisionParaCompletar && !player.secta.misionesActivas.some(m => MISIONES_DATA[m.id]?.objetivo?.npcEntrega === npcId)) {
            modalContentHTML += "<p>No tienes misiones para entregarme o reportarme en este momento.</p>";
        } else if (!algunaMisionParaCompletar) {
            modalContentHTML += "<p>Revisa los objetivos de tus misiones activas. Parece que aún no están listas para entregar/reportar.</p>";
        }
        modalContentHTML += "<hr>";

        // El resto de la función para mostrar misiones disponibles y entregar recursos no necesita cambios.
        // ... (El código restante de la función va aquí, sin modificaciones)
        // --- SECCIÓN: MISIONES DISPONIBLES (CON FILTRO DE NIVEL Y RANGO) ---
            if (npcData.misionesOfrecidas && npcData.misionesOfrecidas.length > 0) {
              modalContentHTML += "<h4>Misiones Disponibles:</h4>";
              modalContentHTML += `<div id="npc-dynamic-content-missions" style="max-height: 200px; overflow-y: auto; border: 1px solid #444; padding: 10px; margin-bottom:10px;">`;
              let algunaMisionDisponibleMostrada = false;
              npcData.misionesOfrecidas.forEach((misionId, index) => {
                const mision = MISIONES_DATA[misionId];
                if (
                  mision &&
                  !player.secta.misionesActivas.some((m) => m.id === misionId) &&
                  !player.secta.misionesCompletadas[misionId]
                ) {
                  const nivelRequerido = mision.requisitoNivel || 0;
                  const rangoRequeridoNombre = mision.requisitoRango;
                  let cumpleRequisitos = true;

                  if (player.level < nivelRequerido) {
                    cumpleRequisitos = false;
                  }
                  if (rangoRequeridoNombre) {
                    const indiceRangoJugador = SECTA_DATA.rangos.findIndex(
                      (r) => r.nombre === player.secta.rango
                    );
                    const indiceRangoRequerido = SECTA_DATA.rangos.findIndex(
                      (r) => r.nombre === rangoRequeridoNombre
                    );
                    if (indiceRangoJugador < indiceRangoRequerido) {
                      cumpleRequisitos = false;
                    }
                  }

                  if (cumpleRequisitos) {
                    let recompensaTextoResumido = `Recompensa: ${
                      mision.recompensa.pcs || 0
                    } PCS, ${mision.recompensa.exp || 0} EXP`;
                    if (mision.recompensa.items)
                      recompensaTextoResumido += ", Objetos";
                    if (mision.recompensa.nuevoRango)
                      recompensaTextoResumido += `, Ascenso a ${mision.recompensa.nuevoRango}`;

                    const buttonId = `accept-mission-btn-${misionId.replace(
                      /\W/g,
                      "_"
                    )}-${index}`;
                    const botonHTML = `<button id="${buttonId}">Aceptar Misión</button>`;

                    modalContentHTML += `<div style="padding: 5px; border: 1px solid #555; margin-bottom: 5px;">
                                                  <strong>${
                                                    mision.titulo
                                                  }</strong> (Req. Nv: ${
                      nivelRequerido > 0 ? nivelRequerido : "Ninguno"
                    }${
                      rangoRequeridoNombre ? ", Rango: " + rangoRequeridoNombre : ""
                    })<br><small>${mision.descripcion}</small><br>
                                                  <small style="color: #aaa;"><em>${recompensaTextoResumido}</em></small><br>
                                                  ${botonHTML}
                                              </div>`;
                    elementsToProcess.push({
                      buttonId: buttonId,
                      missionIdToAccept: misionId,
                    });
                    algunaMisionDisponibleMostrada = true;
                  }
                }
              });
              if (!algunaMisionDisponibleMostrada)
                modalContentHTML +=
                  "<p>No hay nuevas misiones para ti en este momento que cumplan tus requisitos.</p>";
              modalContentHTML += `</div>`;
              modalContentHTML += "<hr>";
            } else {
              modalContentHTML +=
                "<p>No tengo misiones para ti en este momento.</p><hr>";
            }

        
        
        showModal("Interacción con " + npcData.nombre, modalContentHTML);

        const modalTextEl = document.getElementById("modalText");
        if (modalTextEl) {
            elementsToProcess.forEach((item) => {
                const buttonElement = modalTextEl.querySelector("#" + item.buttonId);
                if (buttonElement) {
                    if (item.missionIdToAccept) {
                        buttonElement.addEventListener("click", () => {
                            acceptMission(item.missionIdToAccept);
                            interactWithSectNPC(npcId);
                        });
                    } else if (item.action) {
                        buttonElement.addEventListener("click", item.action);
                    }
                } else {
                    console.warn("[NPC Interaction] Could not find button with ID:", item.buttonId);
                }
            });
        }
    }
          

    function sanitizeActiveMissions(player) {
    if (!player || !player.secta || !player.secta.misionesActivas) {
        console.warn("[Sanitize] No se encontraron misiones activas para sanitizar.");
        return;
    }

    console.log("[Sanitize] Iniciando la revisión y actualización de misiones activas...");
    
    // Usamos filter para crear una nueva lista de misiones saneadas y eliminar las obsoletas.
    const saneadasYValidas = player.secta.misionesActivas.filter(misionActiva => {
        const masterMissionData = MISIONES_DATA[misionActiva.id];
        
        // Si la misión ya no existe en los datos maestros, la eliminamos del guardado.
        if (!masterMissionData || !masterMissionData.objetivo) {
            console.warn(`[Sanitize] Misión obsoleta '${misionActiva.id}' eliminada del guardado.`);
            return false; // 'filter' descartará este elemento.
        }

        // --- LÓGICA DE ACTUALIZACIÓN CLAVE ---
        // Comparamos el objetivo guardado con el maestro. Si son diferentes, lo actualizamos.
        // Usamos JSON.stringify para una comparación profunda y sencilla de los objetos.
        const guardadoJSON = JSON.stringify(misionActiva.objetivoOriginal);
        const maestroJSON = JSON.stringify(masterMissionData.objetivo);

        if (guardadoJSON !== maestroJSON) {
            console.warn(`[Sanitize] ¡INCONSISTENCIA DETECTADA! Misión: '${misionActiva.id}'.`);
            console.warn(`           -> Objetivo Guardado: ${guardadoJSON}`);
            console.warn(`           -> Objetivo Maestro:  ${maestroJSON}`);
            console.log(`[Sanitize]   CORRIGIENDO: Se reemplazará el objetivo guardado con la versión más reciente.`);
            
            // Reemplazamos el objetivo corrupto o desactualizado con una copia nueva y correcta del maestro.
            misionActiva.objetivoOriginal = JSON.parse(maestroJSON);
        }
        
        return true; // Mantenemos la misión en la lista.
    });

    // Reemplazamos la lista de misiones del jugador por la versión saneada.
    player.secta.misionesActivas = saneadasYValidas;
    
    console.log("[Sanitize] Revisión de misiones completada.");
}
      function openFormationTutorial() {
        const modal = document.getElementById('formationTutorialModal');
        const gridContainer = document.getElementById('formation-pattern-grid');
        gridContainer.innerHTML = ''; // Limpiar la cuadrícula

        // Usamos el patrón de ejemplo "Hexagrama Devastador"
        const examplePattern = FORMATION_PATTERNS.shattering_hexagram.pattern;

        for (let r = 0; r < examplePattern.length; r++) {
            for (let c = 0; c < examplePattern[r].length; c++) {
                const cellValue = examplePattern[r][c];
                const cellDiv = document.createElement('div');
                cellDiv.className = 'grid-cell';

                if (cellValue === 1) {
                    cellDiv.classList.add('rune');
                    cellDiv.textContent = '●'; // Símbolo para la runa
                } else if (cellValue === 2) {
                    cellDiv.classList.add('enemy');
                    cellDiv.textContent = 'X'; // Símbolo para el enemigo
                }
                gridContainer.appendChild(cellDiv);
            }
        }
        
        modal.style.display = 'flex';
        hideTouchControls();
        updateStatsPanelVisibility();
    }

    function closeFormationTutorial() {
        const modal = document.getElementById('formationTutorialModal');
        modal.style.display = 'none';
        showTouchControls();
        updateStatsPanelVisibility();
    }


      function entregarRecursoSecta(itemName, cantidad, pcsGanados) {
        if ((gameState.inventory[itemName] || 0) < cantidad) {
          showModal("Error", "No tienes suficientes objetos.");
          return;
        }
        gameState.inventory[itemName] -= cantidad;
        gameState.player.secta.puntosContribucion += pcsGanados;
        showModal(
          "Recurso Entregado",
          `Entregaste ${cantidad} ${itemName} y ganaste ${pcsGanados} PCS.`
        );
        updateSectUI();
        updateInventoryUI();
        checkAndActivateRankChallengeMissions();
        closeModal();
      }

      function acceptMission(misionId) {
        const misionData = MISIONES_DATA[misionId];
        const player = gameState.player;
        if (!misionData || !misionData.objetivo) {
            showModal("Error de Misión", "Datos de misión no encontrados o corruptos.");
            return;
        }
        if (player.secta.misionesActivas.some((m) => m.id === misionId) || player.secta.misionesCompletadas[misionId]) {
            showModal("Error de Misión", "Ya has aceptado o completado esta misión.");
            return;
        }

        // Creamos el objeto de la misión activa
        const nuevaMisionActiva = {
            id: misionId,
            progreso: 0,
            objetivoOriginal: JSON.parse(JSON.stringify(misionData.objetivo)),
        };

        // --- LOG DE INICIO DE MISIÓN ---
        console.group(`[LOG INICIO MISIÓN] Misión Aceptada: ${misionId}`);
        console.log("Datos guardados en el estado del jugador:", nuevaMisionActiva);
        console.groupEnd();
        // --- FIN DEL LOG ---

        player.secta.misionesActivas.push(nuevaMisionActiva);
        showModal("Misión Aceptada", `Has aceptado: ${misionData.titulo}`);
        updateSectUI();

        const npcInteractionModal = document.getElementById("interactionModal");
        if (npcInteractionModal.style.display === "flex") {
            closeModal();
        }
    }

      function removeEntity(entityToRemove) {
        const index = gameState.map.entities.findIndex(
          (e) => e.id === entityToRemove.id
        ); // Usar ID único

        if (index > -1) {
          const removedEntity = gameState.map.entities.splice(index, 1)[0];

          // Si la entidad provenía de una zona de spawn, actualizar el contador de esa zona
          if (removedEntity.zoneOrigin) {
            const originZone = gameState.map.terrainZones.find(
              (z) => z.name === removedEntity.zoneOrigin && z.spawnSettings
            );
            if (originZone) {
              const targetSpawnInfo =
                originZone.spawnSettings.targetEntities.find(
                  (t) => t.entityTypeId === removedEntity.originalEntityTypeId // <-- USAR ESTO
                );
              if (targetSpawnInfo && targetSpawnInfo.currentCount > 0) {
                targetSpawnInfo.currentCount--;
                // console.log(`Entidad ${removedEntity.name} eliminada de zona ${originZone.name}. Restantes de tipo ${targetSpawnInfo.entityTypeId}: ${targetSpawnInfo.currentCount}`);

                // Si el contador baja y el timer estaba en cooldown, podemos resetear el timer
                // para que intente reaparecer antes si la zona está por debajo del objetivo.
                // Opcional: Podrías querer que el cooldown siempre se cumpla.
                // if (originZone.spawnSettings.respawnTimer > 10) { // Si estaba en cooldown largo
                //    originZone.spawnSettings.respawnTimer = 10; // Poner un cooldown corto para el próximo chequeo
                // }
              }
            }
          }
          renderMap(); // Actualizar visualización
        }
      }

      function isRespawnNeeded() {
        const player = gameState.player;
        const activeBoss = gameState.map.entities.find(
          (e) =>
            e.isBoss &&
            !player.worldState.defeatedBosses[e.id || e.type] &&
            Math.abs(e.x - player.x) <= 5 &&
            Math.abs(e.y - player.y) <= 5
        );
        return !activeBoss;
      }

      function toggleCultivation() {
        if (gameState.battle.active) {
          showModal("Acción no permitida", "No puedes cultivar en combate.");
          return;
        }
        if (gameState.player.isCultivating) {
          showActiveCultivationModal();
        } else {
          openCultivationChoiceModal();
        }
      }

      function openCultivationChoiceModal() {
        const player = gameState.player;
        const techniquesListDiv = document.getElementById(
          "cultivableTechniquesList"
        );

        // Comprobación de seguridad
        if (!techniquesListDiv) {
          console.error(
            "Error: El contenedor 'cultivableTechniquesList' no se encontró en el HTML."
          );
          return;
        }

        techniquesListDiv.innerHTML = ""; // Limpiar contenido anterior
        let hasCultivableTechniques = false;

        for (const techId in player.learnedTechniques) {
          const playerTech = player.learnedTechniques[techId];
          const techData = techniqueData[techId];
          if (
            techData &&
            techData.cultivationSettings &&
            playerTech.level < techData.maxLevel
          ) {
            hasCultivableTechniques = true;
            const techButton = document.createElement("button");
            techButton.className = "cultivation-option-btn";
            techButton.textContent = `${techData.name} (Nv. ${playerTech.level})`;

            // --- LA CORRECCIÓN CLAVE ESTÁ AQUÍ ---
            techButton.onclick = () => {
              // 1. Primero, cerramos el modal actual.
              closeCultivationChoiceModal();
              // 2. Después, iniciamos el nuevo modo de cultivo.
              startCultivationMode("technique", techId);
            };
            // --- FIN DE LA CORRECCIÓN ---

            techniquesListDiv.appendChild(techButton);
          }
        }

        if (!hasCultivableTechniques) {
          techniquesListDiv.innerHTML =
            "<p>No tienes técnicas que requieran más cultivo.</p>";
        }

        document.getElementById("cultivationChoiceModal").style.display =
          "flex";
        hideTouchControls();
      }

      function closeCultivationChoiceModal() {
        document.getElementById("cultivationChoiceModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
      }

      function startCultivationMode(type, targetId = null) {
        // --- INICIO DE LA CORRECCIÓN ---
        // Siempre que se inicie un modo de cultivo, cerramos el modal de elección.
        closeCultivationChoiceModal();
        // --- FIN DE LA CORRECCIÓN ---

        console.log(
          `[Cultivo LOG] ==> INTENTO DE INICIAR CULTIVO (Tipo: '${type}', Técnica: '${targetId}')`
        );
        if (gameState.player.isCultivating || gameState.cultivationInterval) {
          stopCultivation();
        }

        gameState.player.isCultivating = true;
        gameState.player.cultivationMode = {
          type,
          targetId,
          startTime: Date.now(),
          isConversionCultivation: false,
        };

        gameState.cultivationInterval = setInterval(
          processCultivationTick,
          1000
        );
        console.log(
          `[Cultivo LOG] -> NUEVO INTERVALO CREADO. ID: ${gameState.cultivationInterval}`
        );

        showActiveCultivationModal();
        renderQuickSlotBar();
      }

      function stopCultivation(
        showFeedbackModal = false,
        feedbackMessage = {}
      ) {
        const player = gameState.player;
        console.log(`[Cultivo LOG] ==> INTENTO DE DETENER CULTIVO`);

        if (!gameState.cultivationInterval) {
          console.log(
            `[Cultivo LOG]   -> No hay intervalo que detener. El cultivo ya estaba parado.`
          );
          // Aún así, reseteamos el estado del jugador por si está desincronizado.
          player.isCultivating = false;
          player.cultivationMode = {
            type: null,
            targetId: null,
            startTime: 0,
            isConversionCultivation: false,
          };
          console.log(
            `[Cultivo LOG]   -> Estado del jugador reseteado por seguridad.`
          );
          return;
        }

        const intervalToClear = gameState.cultivationInterval;
        console.log(
          `[Cultivo LOG]   -> Limpiando intervalo con ID: ${intervalToClear}`
        );
        clearInterval(intervalToClear);
        gameState.cultivationInterval = null;
        console.log(
          `[Cultivo LOG]   -> Intervalo limpiado. gameState.cultivationInterval ahora es: ${gameState.cultivationInterval}`
        );

        player.isCultivating = false;
        player.cultivationMode = {
          type: null,
          targetId: null,
          startTime: 0,
          isConversionCultivation: false,
        };
        console.log(
          `[Cultivo LOG]   -> Estado del jugador reseteado: isCultivating = ${player.isCultivating}`
        );

        closeActiveCultivationModal();
        renderQuickSlotBar();
        updateUI();

        if (showFeedbackModal) {
          console.log(
            `[Cultivo LOG]   -> Mostrando modal de feedback: "${feedbackMessage.title}"`
          );
          showModal(
            feedbackMessage.title || "Cultivo Detenido",
            feedbackMessage.text || "Has dejado de cultivar."
          );
        }
      }

      function showActiveCultivationModal() {
        const player = gameState.player;
        const modal = document.getElementById("activeCultivationModal");
        if (!modal) return; // Salida temprana si el modal no existe.

        // Ocultar todas las secciones primero
        const techUI = document.getElementById("activeCultivationProgressUI");
        const recoveryUI = document.getElementById(
          "recoveryCultivationProgressUI"
        );
        const boostUI = document.getElementById("cultivationBoostSection");

        if (techUI) techUI.style.display = "none";
        if (recoveryUI) recoveryUI.style.display = "none";
        if (boostUI) boostUI.style.display = "none";

        if (!player.isCultivating) {
          modal.style.display = "none";
          return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        const titleEl = document.getElementById("activeCultivationTitle");
        const descEl = document.getElementById("activeCultivationDescription");
        if (!titleEl || !descEl) return;

        if (mode === "technique" && targetId) {
          const techData = techniqueData[targetId];
          const playerTech = player.learnedTechniques[targetId];

          if (techData && playerTech && techUI) {
            techUI.style.display = "block";
            if (boostUI) boostUI.style.display = "block";

            titleEl.textContent = `Cultivando: ${techData.name}`;
            descEl.textContent = techData.description;

            // Actualizar UI de la técnica
            const nameSpan = document.getElementById(
              "activeCultivationTargetName"
            );
            const levelSpan = document.getElementById(
              "activeCultivationTargetLevel"
            );
            if (nameSpan) nameSpan.textContent = techData.name;
            if (levelSpan) levelSpan.textContent = playerTech.level;

            // Lógica de la barra de progreso
            const progressBar = document.getElementById(
              "activeCultivationProgressBar"
            );
            const progressText = document.getElementById(
              "activeCultivationProgressText"
            );
            if (progressBar && progressText) {
              const progress = playerTech.currentCultivationProgress || 0;
              const timeToNext =
                playerTech.cultivationTimeToNextLevel || Infinity;
              let percent =
                timeToNext > 0 && timeToNext !== Infinity
                  ? (progress / timeToNext) * 100
                  : playerTech.level >= techData.maxLevel
                  ? 100
                  : 0;

              progressBar.style.width = `${Math.min(100, percent)}%`;
              progressText.textContent =
                timeToNext === Infinity
                  ? "Nivel Máximo"
                  : `${Math.floor(progress)}s / ${timeToNext}s`;
            }

            // Actualizar sección de aceleración
            const stonesDisplay = document.getElementById("cultivationModalPlayerStones");
            const boostButton1 = document.getElementById("boostCultivationButton1");
            const boostButton10 = document.getElementById("boostCultivationButton10");
            const currentStones = gameState.inventory["Piedras Espirituales"] || 0;
            if (stonesDisplay) stonesDisplay.textContent = currentStones;
            if (boostButton1) {
                boostButton1.disabled = currentStones < 1 || playerTech.level >= techData.maxLevel;
            }
            if (boostButton10) {
                boostButton10.disabled = currentStones < 10 || playerTech.level >= techData.maxLevel;
            }
          
          
              }

          
        } else if (mode === "recovery") {
          if (recoveryUI) {
            recoveryUI.style.display = "block";
            titleEl.textContent = "Meditación Restauradora";
            descEl.textContent = "Recuperando energía...";

            // Actualizar barras de HP/Maná del modal
            const hpText = document.getElementById("modalHpText");
            const hpBar = document.getElementById("modalHpBar");
            const manaText = document.getElementById("modalManaText");
            const manaBar = document.getElementById("modalManaBar");
            if (hpText)
              hpText.textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
            if (hpBar)
              hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
            if (manaText)
              manaText.textContent = `${Math.floor(player.mana)}/${
                player.maxMana
              }`;
            if (manaBar)
              manaBar.style.width = `${(player.mana / player.maxMana) * 100}%`;
          }
        }

        modal.style.display = "flex";
        hideTouchControls();
      }

      function updateStatsPanelVisibility() {
        const statsPanel = document.querySelector(".stats-panel");
        if (!statsPanel) {
          console.error(
            "No se encontró el elemento .stats-panel para actualizar su visibilidad."
          );
          return;
        }

        // El panel debe estar oculto si la batalla está activa O si cualquier modal está abierto.
        const shouldBeHidden = gameState.battle.active || isAnyModalOpen();

        if (shouldBeHidden) {
          statsPanel.classList.add("hidden");
        } else {
          statsPanel.classList.remove("hidden");
        }
      }

      function closeActiveCultivationModal() {
        document.getElementById("activeCultivationModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
      }

      function processCultivationTick() {
        const player = gameState.player;

        // Medida de seguridad: si el tick se ejecuta cuando no debería, se detiene.
        if (!player.isCultivating || !gameState.cultivationInterval) {
          stopCultivation();
          return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        // --- CULTIVO DE TÉCNICA (sin cambios, ya funciona bien) ---
        if (mode === "technique" && targetId) {
          const playerTech = player.learnedTechniques[targetId];
          const techData = techniqueData[targetId];
          if (playerTech && techData && playerTech.level < techData.maxLevel) {
            playerTech.currentCultivationProgress =
              (playerTech.currentCultivationProgress || 0) + 1;
            const progress = playerTech.currentCultivationProgress;
            const required = playerTech.cultivationTimeToNextLevel || Infinity;

            if (progress >= required) {
              playerTech.level++;
              playerTech.currentCultivationProgress = 0;
              playerTech.cultivationTimeToNextLevel =
                playerTech.level < techData.maxLevel
                  ? Math.floor(
                      techData.cultivationSettings.baseTimeToLevelUp *
                        Math.pow(
                          techData.cultivationSettings.levelTimeMultiplier,
                          playerTech.level
                        )
                    )
                  : Infinity;
              applyTechniqueEffect(targetId, playerTech.level);
              recalculatePlayerStats();
              stopCultivation(true, {
                title: "¡Técnica Mejorada!",
                text: `¡'${techData.name}' ha subido al Nivel ${playerTech.level}!`,
              });
              return;
            }
          } else {
            stopCultivation(true, {
              title: "Cultivo Detenido",
              text: "La técnica ha alcanzado su máximo potencial.",
            });
            return;
          }

          // --- CULTIVO DE RECUPERACIÓN ---
        } else if (mode === "recovery") {
          // =========================================================================
          // === CORRECCIÓN CLAVE: Lógica de Conversión de Qi (SI ESTÁ ACTIVA) ===
          // =========================================================================
          if (player.cultivationMode.isConversionCultivation) {
            const conversionTechInfo = techniqueData["qi_to_hp_conversion_1"];
            const playerConversionTech =
              player.learnedTechniques["qi_to_hp_conversion_1"];

            if (conversionTechInfo?.effect && playerConversionTech?.level > 0) {
              const effectDef = conversionTechInfo.effect;
              const techLevel = playerConversionTech.level;

              const manaCost = Math.max(
                0.1,
                effectDef.baseManaCostPerSecond -
                  (effectDef.manaCostReductionPerLevel || 0) * (techLevel - 1)
              );
              const hpGain =
                effectDef.baseHpGainPerSecond +
                (effectDef.hpGainIncreasePerLevel || 0) * (techLevel - 1);

              // Si se puede convertir, se hace y se termina el tick.
              if (player.mana >= manaCost && player.hp < player.maxHp) {
                player.mana -= manaCost; // <-- Se resta el maná.
                player.hp = Math.min(player.maxHp, player.hp + hpGain);
                // IMPORTANTE: No se ejecuta nada más de recuperación en este tick.
              } else {
                // Si no se puede, se detiene el cultivo con un mensaje.
                stopCultivation(true, {
                  title: "Conversión Detenida",
                  text: "Maná insuficiente o vida al máximo.",
                });
                return; // Salimos del tick para no hacer nada más.
              }
            } else {
              // Si por alguna razón falta la técnica, se detiene para evitar errores.
              stopCultivation(true, {
                title: "Error de Técnica",
                text: "No se encontró la técnica de Conversión de Qi.",
              });
              return;
            }

            // ==================================================================================
            // === Lógica de Meditación Restauradora Normal (SOLO SI LA CONVERSIÓN NO ESTÁ ACTIVA) ===
            // ==================================================================================
          } else {
            if (player.hp < player.maxHp) {
              player.hp = Math.min(
                player.maxHp,
                player.hp + player.hpPerSecondBase
              );
            }
            if (player.mana < player.maxMana) {
              player.mana = Math.min(
                player.maxMana,
                player.mana + player.qiPerSecondBase
              );
            }
            gainExperience(player.expPerSecondBase);
          }
        }

        // Al final del tick, se actualiza la UI con los nuevos valores.
        updateUI();
        showActiveCultivationModal();
      }

      function boostCultivationProgress(amount = 1) { // Acepta un argumento 'amount', con 1 como valor por defecto
        const player = gameState.player;
        const mode = player.cultivationMode;
        const timePerStone = 10; // 10 segundos de progreso por cada piedra

        if (!player.isCultivating || mode.type !== 'technique' || !mode.targetId) return;

        // Comprobamos si el jugador tiene suficientes piedras
        if ((gameState.inventory["Piedras Espirituales"] || 0) < amount) {
            showModal("Piedras Insuficientes", `Necesitas al menos ${amount} Piedras Espirituales para hacer esto.`);
            return;
        }

        const techId = mode.targetId;
        const playerTech = player.learnedTechniques[techId];
        const techData = techniqueData[techId];

        if (!playerTech || !techData || !techData.cultivationSettings || playerTech.level >= techData.maxLevel) {
            showModal("Límite Alcanzado", "Esta técnica ya está en su nivel máximo.");
            return;
        }

        // Restamos la cantidad de piedras y añadimos el progreso correspondiente
        gameState.inventory["Piedras Espirituales"] -= amount;
        playerTech.currentCultivationProgress = (playerTech.currentCultivationProgress || 0) + (amount * timePerStone);
        
        let leveledUpThisBoost = false;
        let firstLevelUpMessage = "";

        // Bucle para comprobar si se sube de nivel (puede subir varios niveles de golpe)
        while (
            playerTech.currentCultivationProgress >= playerTech.cultivationTimeToNextLevel &&
            playerTech.level < techData.maxLevel
        ) {
            leveledUpThisBoost = true;
            const progressNeeded = playerTech.cultivationTimeToNextLevel;
            playerTech.currentCultivationProgress -= progressNeeded;
            playerTech.level++;

            if (!firstLevelUpMessage) {
                firstLevelUpMessage = `¡Aceleraste '${techData.name}' al Nivel ${playerTech.level}!`;
                if (playerTech.level >= techData.maxLevel) {
                    firstLevelUpMessage += " (¡Nivel Máximo alcanzado!)";
                }
            }

            if (playerTech.level < techData.maxLevel) {
                playerTech.cultivationTimeToNextLevel = Math.floor(
                    techData.cultivationSettings.baseTimeToLevelUp *
                    Math.pow(techData.cultivationSettings.levelTimeMultiplier, playerTech.level)
                );
            } else {
                playerTech.cultivationTimeToNextLevel = Infinity;
                playerTech.currentCultivationProgress = 0;
            }
            applyTechniqueEffect(techId, playerTech.level);
        }
        
        recalculatePlayerStats();
        updateUI();
        renderQuickSlotBar(); 

        if (leveledUpThisBoost) {
            stopCultivation();
            showModal("¡Técnica Mejorada con Aceleración!", firstLevelUpMessage + "\n\nEl cultivo se ha detenido para que puedas ver los cambios.");
            return;
        }

        if (playerTech.level >= techData.maxLevel) {
            stopCultivation();
            showModal("Nivel Máximo Alcanzado", `La técnica ${techData.name} ya está en su máximo potencial.`);
            return;
        }
        
        // Si no se subió de nivel, solo actualizamos la UI del modal
        if (document.getElementById("activeCultivationModal").style.display === "flex") {
            showActiveCultivationModal();
        }
    }

      function toggleQiConversion() {
        const player = gameState.player;

        // Si ya hay un cultivo de CUALQUIER tipo activo...
        if (player.isCultivating) {
          // ...y ese cultivo es específicamente el de conversión...
          if (player.cultivationMode.isConversionCultivation) {
            // ...entonces lo detenemos.
            console.log("Deteniendo cultivo de conversión de Qi activo.");
            stopCultivation(true, {
              title: "Conversión Detenida",
              text: "Has detenido la conversión de Maná a Vida.",
            });
          } else {
            // Si es otro tipo de cultivo (ej. de técnica), avisamos al jugador.
            showModal(
              "Acción no permitida",
              "Debes detener tu cultivo actual para iniciar la conversión de Qi."
            );
          }
          return;
        }

        // Si no hay ningún cultivo activo, iniciamos el de conversión.
        console.log("Iniciando cultivo con CONVERSIÓN DE QI.");

        // CORRECCIÓN CLAVE 1:
        // Iniciamos el modo de cultivo de recuperación, pero inmediatamente después,
        // marcamos que es un modo especial de conversión.
        startCultivationMode("recovery");
        player.cultivationMode.isConversionCultivation = true; // <-- Esta es la marca especial.

        // También actualizamos la UI para que el botón refleje el estado activo.
        renderQuickSlotBar();
      }

      function toggleGrid() {
        isGridVisible = !isGridVisible;
        const gridOverlay = document.querySelector('.grid-overlay');
        const toggleBtn = document.getElementById('toggleGridBtn');

        if (gridOverlay) {
            if (isGridVisible) {
                gridOverlay.classList.add('active');
                if (toggleBtn) toggleBtn.textContent = "Ocultar Rejilla";
            } else {
                gridOverlay.classList.remove('active');
                if (toggleBtn) toggleBtn.textContent = "Mostrar Rejilla";
            }
            updateGrid(); // Actualiza el estado inicial de la rejilla
        }
    }

    // === AÑADE ESTA NUEVA FUNCIÓN HELPER ===
    function updateGrid() {
      if (!isGridVisible) return;
      
      const gridOverlay = document.querySelector('.grid-overlay');
      const mapElement = document.getElementById("gameMap");
      
      if (gridOverlay && mapElement) {
          // Actualizamos el tamaño del fondo de la rejilla para que coincida con el tamaño del tile
          gridOverlay.style.backgroundSize = `${currentTileSize}px ${currentTileSize}px`;
          
          // Hacemos que la posición del fondo de la rejilla se mueva en sentido opuesto al mapa
          // para que las líneas parezcan estáticas sobre el mundo.
          const mapTransform = new DOMMatrix(window.getComputedStyle(mapElement).transform);
          gridOverlay.style.backgroundPosition = `${mapTransform.e}px ${mapTransform.f}px`;
      }
  }

      function useItem(itemName) {
        console.group(`[useItem] Intento de usar: "${itemName}"`);
        if (gameState.battle.active) {
          console.warn("Acción bloqueada: en combate.");
          console.groupEnd();
          showModal(
            "Acción no permitida",
            "No puedes usar objetos del inventario en combate desde aquí."
          );
          return;
        }
        if (
          !gameState.inventory[itemName] ||
          gameState.inventory[itemName] <= 0
        ) {
          showModal("Inventario Vacío", `No tienes ${itemName}.`);
          return;
        }
        const itemInfo = itemData[itemName];
        if (!itemInfo || !itemInfo.effect) {
          console.error("Fallo: El objeto no tiene una definición o una función de efecto en itemData.");
        console.groupEnd();
          showModal(
            "Error",
            `${itemName} no tiene efecto o no se puede usar así.`
          );
          return;
        }
        console.log("Llamando a la función de efecto del objeto...");
        
        
        if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
          let reason = "No puedes usar esto ahora.";
          if (
            itemName === "Hierbas Medicinales" &&
            gameState.player.hp >= gameState.player.maxHp
          )
            reason = "Vida al máximo.";
          if (
            itemName === "Cristales de Qi" &&
            gameState.player.mana >= gameState.player.maxMana
          )
            reason = "Maná al máximo.";
          showModal("No se puede usar", reason);
          return;
        }
        const message = itemInfo.effect(gameState.player, gainExperience, itemName);
        console.log(`Función de efecto retornó: "${message}"`);

        // Solo decrementar si el mensaje no indica un error (por si el efecto mismo retorna un error)
        if (
          message &&
          !message.toLowerCase().includes("error") &&
          !message.toLowerCase().includes("al máximo")
        ) {
          gameState.inventory[itemName]--;
        }
        console.groupEnd();
        showModal("Objeto Usado", message);
        updateUI();
      }

      function gainExperience(amount) {
        if (amount <= 0) return;
        gameState.player.exp += amount;
        while (gameState.player.exp >= gameState.player.expToNext) {
          levelUp();
        }
      }

      function levelUp() {
        const player = gameState.player;
        player.exp -= player.expToNext;
        player.level++;

        const hpIncrease = 20 + Math.floor(player.level / 2);
        const manaIncrease = 10 + Math.floor(player.level / 3);
        const attackIncrease = 2 + Math.floor(player.level / 4);
        const defenseIncrease = 1 + Math.floor(player.level / 5);

        player.baseMaxHp += hpIncrease;
        player.baseMaxMana += manaIncrease;
        player.baseAttack += attackIncrease;
        player.baseDefense += defenseIncrease;

        player.hp = player.baseMaxHp; // Rellenar HP y Mana al subir de nivel
        player.mana = player.baseMaxMana;
        player.expToNext = Math.floor(
          player.expToNext * (1.3 + player.level * 0.02)
        );

        const oldRealm = player.realm;
        const realms = [
          "Mortal",
          "Forjado del Cuerpo",
          "Condensación de Qi",
          "Fundación",
          "Núcleo Dorado",
          "Alma Naciente",
          "Espíritu Primordial",
        ];
        const realmIndex = Math.min(
          Math.floor((player.level - 1) / 5),
          realms.length - 1
        );
        player.realm = realms[realmIndex];
        let realmChangeMessage = "";
        if (player.realm !== oldRealm) {
          realmChangeMessage = `\n\n¡Has avanzado al Reino de ${player.realm}! Sientes una profunda transformación...`;
          generateMap(true);
        }
        recalculatePlayerStats();

        showModal(
          "¡Nivel Aumentado!",
          `Nivel ${player.level}!\nReino: ${player.realm}\n+${hpIncrease} HP, +${manaIncrease} Maná\n+${attackIncrease} Atk, +${defenseIncrease} Def${realmChangeMessage}`
        );
      }

      function recalculatePlayerStats() {
        const player = gameState.player;
        
        // 1. Reiniciar TODAS las estadísticas a sus valores base.
        player.maxHp = player.baseMaxHp;
        player.maxMana = player.baseMaxMana;
        player.attack = player.baseAttack;
        player.defense = player.baseDefense;
        // === REINICIO DE STATS PASIVOS 
        player.damageReduction = 0; // Reiniciamos la reducción de daño
        player.passiveHpRegen = 0;   // Reiniciamos la regeneración pasiva
        player.statusResistChance = 0;
         // ===============================================
        // Reseteamos las estadísticas de cultivo a sus valores por defecto antes de aplicar los bonos.
        player.qiPerSecondBase = 1;     // Valor base de Qi por segundo.
        player.expPerSecondBase = 0.5;   // Valor base de EXP por segundo.
        player.hpPerSecondBase = 1;      // Valor base de HP por segundo.
        // Limpiamos la lista de habilidades activas para reconstruirla.
        
        gameState.activeCombatAbilities = [];
        
        // 2. Iteramos sobre TODAS las técnicas aprendidas por el jugador.
        for (const techId in player.learnedTechniques) {
            const playerTech = player.learnedTechniques[techId];
            const techInfo = techniqueData[techId];

            if (!techInfo || playerTech.level === 0) {
                continue; // Saltar si la técnica no existe o no tiene nivel.
            }
            
            // 3. Aplicamos los efectos según el tipo de técnica.
            switch (techInfo.type) {
              case 'passive_stat':
                if (techInfo.effect) {
                    if (techInfo.effect.statToBoost && techInfo.effect.value) {
                         const effectValue = techInfo.effect.value * playerTech.level;
                         const statToBoost = techInfo.effect.statToBoost;
                         if (player.hasOwnProperty(statToBoost)) {
                            player[statToBoost] += effectValue;
                         } else {
                            player[statToBoost] = (player[statToBoost] || 0) + effectValue;
                         }
                    }
                    
                    // === NUEVA LÓGICA PARA CALCULAR LA RESISTENCIA ===
                    if (techInfo.effect.statusResistChanceBase) {
                        const baseChance = techInfo.effect.statusResistChanceBase;
                        const perLevelChance = techInfo.effect.statusResistChancePerLevel || 0;
                        player.statusResistChance += baseChance + (perLevelChance * (playerTech.level - 1));
                    }
                    // ===============================================

                    if (techInfo.effect.passiveHpRegen) {
                        player.passiveHpRegen += techInfo.effect.passiveHpRegen * playerTech.level;
                    }
                }
                break;
                case 'passive_cultivation':
                    // Multiplicamos el valor del efecto por el nivel de la técnica.
                    const cultivationBonus = techInfo.effect.value * playerTech.level;
                    const cultivationStatToBoost = techInfo.effect.statToBoost;
                    if (player.hasOwnProperty(cultivationStatToBoost)) {
                        player[cultivationStatToBoost] += cultivationBonus;
                    }
                    break;
                    
                case 'active_ability':
                    // Si es una habilidad activa, la añadimos a la lista para el combate.
                    gameState.activeCombatAbilities.push({
                        id: techInfo.abilityId,
                        name: techInfo.name,
                        sourceTechniqueId: techId
                    });
                    break;
                
                // Puedes añadir más casos para otros tipos de técnicas si es necesario.
            }
        }
          // Aseguramos que la probabilidad no supere un límite (ej. 90%)
        player.statusResistChance = Math.min(0.9, player.statusResistChance);
        // 4. Asegurarse de que HP/Mana no excedan el nuevo máximo.
        player.hp = Math.min(player.hp, player.maxHp);
        player.mana = Math.min(player.mana, player.maxMana);
        
        // 5. Finalmente, actualizamos la UI con los valores correctos y recalculados.
        // Ya no es necesario llamar a updateUI() desde aquí, la función que llama a recalculate se encargará.
    }

      function startBattle(mapEntity) {
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
        battleLogHistory = [];
        const toggleBtn = document.getElementById("toggleMapControlsBtn");
        if (toggleBtn) {
            toggleBtn.classList.add("hidden-during-battle");
        }
        const player = gameState.player;
        if (player.isCultivating) stopCultivation();
        hideTouchControls();
        document.getElementById('quickSlotBar').classList.add('hidden');
        player.isMoving = false;
        if (player.animationTimer) clearInterval(player.animationTimer);
        if (player.idleTimeout) clearTimeout(player.idleTimeout);
        player.currentFrame = 0;
        updatePlayerSpriteVisual();

        // Obtenemos la definición ORIGINAL y COMPLETA del enemigo.
        const enemyDefinition = entityTypes[mapEntity.originalEntityTypeId] || entityTypes[mapEntity.type];

        if (!enemyDefinition) {
            console.error(`¡CRÍTICO! No se encontró la definición para el enemigo:`, mapEntity);
            showModal("Error de Batalla", "No se pudieron cargar los datos del enemigo.");
            return;
        }

        // Construimos el objeto del enemigo de forma segura.
        gameState.battle.active = true;
        gameState.battle.enemy = {
            ...enemyDefinition,         // 1. Copiamos el "molde" completo (con spriteUrl, abilities, etc.).
            ...mapEntity,               // 2. Sobreescribimos con el estado actual (como el hp).
            entityRef: mapEntity,       // 3. Guardamos la referencia a la entidad del mapa.
            // 4. Reseteamos los estados de combate.
            frozenTurns: 0,
            stunnedTurns: 0,
            burningTurns: 0,
            burnDamage: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            defenseReductionTurns: 0,
            defenseReductionAmount: 0,
            attackReductionTurns: 0,
            attackReductionAmount: 0,
            rootedTurns: 0,
            rootDamage: 0,
            silencedTurns: 0,
            sealedTurns: 0,
        };
        checkAndApplyFormation(mapEntity);
        // ================================================

        gameState.battle.playerTurn = true;
        document.getElementById("battleScreen").style.display = "flex";
        
        
        if (!gameState.battle.enemy.maxHp) {
            gameState.battle.enemy.maxHp = gameState.battle.enemy.hp;
        }
        
        gameState.battle.playerTurn = true;
        document.getElementById("battleScreen").style.display = "flex";
        // --- LOG DE INICIO DE BATALLA ---
        console.group(`[LOG INICIO BATALLA] Enfrentando a: ${gameState.battle.enemy.name}`);
        console.log("Propiedades clave del enemigo en batalla:", {
            name: gameState.battle.enemy.name,
            npcId: gameState.battle.enemy.npcId,
            originalEntityTypeId: gameState.battle.enemy.originalEntityTypeId
        });
        console.groupEnd();
    // --- FIN DEL LOG -
        // Ahora estas funciones recibirán un objeto enemigo COMPLETO y correcto.
        populateBattleActionButtons();
        updateBattleUI(); 
        updateGameOverlayVisibility();
        logBattle(`¡Un ${gameState.battle.enemy.name} te enfrenta!`);
        updateTopNavVisibility();
        updatePlayerBarsOnMap();
    }
      function showFloatingText(targetElement, text, type) {
        // --- ¡ESTA ES LA VERIFICACIÓN CLAVE! ---
        if (
          !targetElement ||
          typeof targetElement.getBoundingClientRect !== "function"
        ) {
          console.warn(
            `[showFloatingText] Intento de mostrar texto flotante en un elemento inválido. Texto: "${text}", Tipo: "${type}". El elemento era:`,
            targetElement
          );
          return; // Salir de la función si el elemento no es válido.
        }
        // --- FIN DE LA VERIFICACIÓN ---

        const battleScreen = document.getElementById("battleScreen");
        if (!battleScreen) return; // Salida temprana si la pantalla de batalla no está

        const popup = document.createElement("div");
        popup.className = `damage-popup ${type}`;
        popup.textContent = text;

        // Lo añadimos al contenedor de la pantalla de batalla para que position:absolute funcione bien
        battleScreen.appendChild(popup);

        // Calculamos la posición inicial del popup
        const targetRect = targetElement.getBoundingClientRect();
        const battleRect = battleScreen.getBoundingClientRect();

        // Posición inicial en el centro-superior del objetivo
        const initialTop = targetRect.top - battleRect.top - 20;
        const initialLeft =
          targetRect.left -
          battleRect.left +
          targetRect.width / 2 -
          popup.offsetWidth / 2;

        popup.style.top = `${initialTop}px`;
        popup.style.left = `${initialLeft}px`;

        // Eliminar el elemento del DOM después de que termine la animación
        popup.addEventListener("animationend", () => {
          // Usamos un try-catch por si el popup ya fue eliminado por otra razón (ej. fin de batalla)
          try {
            popup.remove();
          } catch (e) {}
        });
      }

      function populateBattleActionButtons() {
        const battleActionButtons = document.getElementById("battleActionButtons");
        battleActionButtons.innerHTML = `
              <button onclick="battleAction('attack')">⚔️ Atacar</button>
              <button onclick="battleAction('defend')">🛡️ Defender</button>
              <button onclick="battleAction('qi_fist')">🧘 Puño de Qi</button>
              <button onclick="battleAction('escape')">🏃 Huir</button>
          `;
          
        // Iteramos sobre las técnicas equipadas en los slots.
        gameState.player.equippedTechniques.forEach((techId) => {
            // Si el slot está vacío (null) o la técnica no existe (por un save antiguo), lo saltamos.
            if (!techId || !techniqueData[techId]) {
                return;
            }
            
            const techDetails = techniqueData[techId];
            const playerTech = gameState.player.learnedTechniques[techId];
            
            // Comprobación de seguridad: si una técnica está equipada pero el jugador ya no la conoce, no mostramos el botón.
            if (!playerTech) {
                console.warn(`Técnica equipada '${techId}' no encontrada en el libro de hechizos del jugador.`);
                return;
            }

            const abilityButton = document.createElement("button");
            const techLevel = playerTech.level || 0;

            let buttonText = `✨ ${techDetails.name} (Nv.${techLevel})`;
            let canUse = techLevel > 0;
            let reason = canUse ? "" : "Error: Técnica equipada sin nivel";
            
            const manaCost = techDetails.manaCost || 0;
            if (canUse && gameState.player.mana < manaCost) {
                canUse = false;
                reason = "Maná insuficiente";
            }
            
            const cooldownTurns = gameState.player.abilityCooldowns[techDetails.abilityId] || 0;
            if (canUse && cooldownTurns > 0) {
                canUse = false;
                reason = `Enfriamiento: ${cooldownTurns} turnos`;
                buttonText += ` (${cooldownTurns}t)`;
            }

            abilityButton.textContent = buttonText;
            // El onclick pasa el ID de la acción a `battleAction`.
            abilityButton.onclick = () => battleAction(techDetails.abilityId);
            abilityButton.disabled = !canUse;
            abilityButton.title = reason;

            battleActionButtons.appendChild(abilityButton);
        });
    }

      function updateExtraStatsUI() {
        // Actualizar Zona
        const zoneEl = document.getElementById("playerZone");
        if (zoneEl) {
          const currentZone = getPlayerCurrentZone();
          zoneEl.textContent = currentZone
            ? currentZone.name
            : "Tierra Salvaje";
        }

        // Actualizar Piedras Espirituales
        const stonesEl = document.getElementById("playerStonesHud");
        if (stonesEl) {
          stonesEl.textContent =
            gameState.inventory["Piedras Espirituales"] || 0;
        }
      }

      function updateBattleUI() {
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const battleScreenActive = document.getElementById("battleScreen").style.display === "flex";

        // --- Declaraciones de Elementos del DOM al principio ---
        const playerBarsContainer = document.getElementById("playerInBattleSpriteBarsContainer");
        const playerSpriteInBattle = document.querySelector(".battle-area .character .character-sprite");
        const enemyInfoContainer = document.getElementById("enemyInBattleInfoContainer");
        const enemySpriteEl = document.getElementById("enemySprite");

        // --- Lógica del Jugador ---
        if (playerBarsContainer && playerSpriteInBattle && battleScreenActive) {
            playerBarsContainer.style.display = "flex";
            const spriteTop = playerSpriteInBattle.offsetTop;
            const spriteLeft = playerSpriteInBattle.offsetLeft;
            const spriteWidth = playerSpriteInBattle.offsetWidth;
            const barContainerHeight = playerBarsContainer.offsetHeight;

            playerBarsContainer.style.top = `${spriteTop - barContainerHeight - 3}px`;
            playerBarsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

            const playerHpFill = document.getElementById("playerInBattleSpriteHpFill");
            const playerManaFill = document.getElementById("playerInBattleSpriteManaFill");
            if (playerHpFill) playerHpFill.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
            if (playerManaFill) playerManaFill.style.width = `${Math.max(0, (player.mana / player.maxMana) * 100)}%`;
        } else if (playerBarsContainer) {
            playerBarsContainer.style.display = "none";
        }

        // --- Lógica del Enemigo ---
        if (enemy && enemySpriteEl && enemyInfoContainer && battleScreenActive) {
            // --- LÓGICA DEL SPRITE (AHORA DENTRO DEL BLOQUE SEGURO) ---
            if (enemy.spriteUrl) {
                enemySpriteEl.style.backgroundImage = `url('${enemy.spriteUrl}')`;
                enemySpriteEl.textContent = "";
            } else {
                enemySpriteEl.style.backgroundImage = "none";
                enemySpriteEl.textContent = enemy.symbol || "?";
            }
            
            // El resto de la lógica para las barras y el nombre del enemigo
            enemyInfoContainer.style.display = "flex";
            const spriteTop = enemySpriteEl.offsetTop;
            const spriteLeft = enemySpriteEl.offsetLeft;
            const spriteWidth = enemySpriteEl.offsetWidth;
            const infoContainerHeight = enemyInfoContainer.offsetHeight;

            enemyInfoContainer.style.top = `${spriteTop - infoContainerHeight - 5}px`;
            enemyInfoContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

            const enemyNameLevelEl = document.getElementById("enemyBattleNameLevel");
            const enemySpriteHpFill = document.getElementById("enemyInBattleSpriteHpFill");
            const enemyHpPercent = Math.max(0, (enemy.hp / (enemy.maxHp || enemy.hp)) * 100);

            if (enemyNameLevelEl) {
                let enemyDisplayName = enemy.name;
                if (enemy.isBoss) {
                    enemyDisplayName += ` (Jefe)`;
                } else if (enemy.isMiniBoss) {
                    enemyDisplayName += ` (Élite)`;
                }
                if (enemy.level) {
                    enemyDisplayName += ` - Nv. ${enemy.level}`;
                }
                enemyNameLevelEl.textContent = enemyDisplayName;

                const nameStyle = getEnemyNameColor(player.level, enemy.level || 1);
                enemyNameLevelEl.style.color = nameStyle.color;
                enemyNameLevelEl.style.fontWeight = nameStyle.fontWeight;
            }
            if (enemySpriteHpFill) enemySpriteHpFill.style.width = `${enemyHpPercent}%`;

            // Paneles de HP/Nombre principales del enemigo
            document.getElementById("enemyName").textContent = enemy.name;
            document.getElementById("enemyHp").textContent = `${Math.floor(enemy.hp)}/${enemy.maxHp || enemy.hp}`;
            document.getElementById("enemyHpBar").style.width = `${enemyHpPercent}%`;
            
        } else if (enemyInfoContainer) {
            enemyInfoContainer.style.display = "none";
        }

        // --- Lógica de los Paneles Principales del Jugador ---
        if (battleScreenActive) {
            document.getElementById("playerBattleName").textContent = `Cultivador (Nv.${player.level})`;
            document.getElementById("playerBattleHp").textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
            document.getElementById("playerBattleHpBar").style.width = `${(player.hp / player.maxHp) * 100}%`;
        }
    }

    // REEMPLAZA TU FUNCIÓN plantRune() EXISTENTE CON ESTA VERSIÓN CORREGIDA

    // REEMPLAZA por completo tu función plantRune con esta nueva versión

    // REEMPLAZA tu función plantRune completa con esta versión definitiva

// REEMPLAZA tu función plantRune completa con esta versión definitiva

function plantRune() {
    const player = gameState.player;
    const inkItem = "Tinta Rúnica";
    const MAX_ENEMY_DETECTION_RANGE = 5;

    // 1. Verificación de Recursos
    if ((gameState.inventory[inkItem] || 0) < 1) {
        showModal("Sin Materiales", `Necesitas al menos 1 ${inkItem} para inscribir una runa.`);
        return;
    }
    const manaCost = techniqueData.formation_scribing_1.manaCost || 10;
    if (player.mana < manaCost) {
        showModal("Maná Insuficiente", `Necesitas ${manaCost} de maná para trazar una runa.`);
        return;
    }

    // 2. Determinar Contexto (Combate vs. Utilidad)
    let closestEnemy = null;
    let minDistance = Infinity;
    gameState.map.entities.forEach(entity => {
        const isHostile = G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss || entity.isMiniBoss;
        if (isHostile) {
            const distance = Math.hypot(player.x - entity.x, player.y - entity.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestEnemy = entity;
            }
        }
    });
    const isCombatRune = closestEnemy && minDistance <= MAX_ENEMY_DETECTION_RANGE;
    
    // Gastar recursos y colocar la runa en el estado correcto
    gameState.inventory[inkItem]--;
    player.mana -= manaCost;
    const runeKey = `${player.x},${player.y}`;

    if (isCombatRune) {
        if (!closestEnemy.formationRunes) closestEnemy.formationRunes = {};
        closestEnemy.formationRunes[runeKey] = 1;
        gameState.utilityRunes = {}; // Limpia runas de utilidad para evitar conflictos
    } else {
        gameState.utilityRunes[runeKey] = 1;
        if (closestEnemy) closestEnemy.formationRunes = {}; // Limpia runas de combate si existen
    }

    // 3. Comprobar si se completó algún patrón
    let patternFound = null;
    const placedRunes = isCombatRune ? closestEnemy.formationRunes : gameState.utilityRunes;
    const placedKeys = Object.keys(placedRunes);

    for (const patternKey in FORMATION_PATTERNS) {
        const formation = FORMATION_PATTERNS[patternKey];
        const isUtilityPattern = formation.effect.type === 'utility_teleport';
        
        // Saltar patrones que no coincidan con el contexto
        if ((isCombatRune && isUtilityPattern) || (!isCombatRune && !isUtilityPattern)) {
            continue;
        }

        const pattern = formation.pattern;
        let requiredRunesForMatch = [];
        let isMatch = false;

        if (isCombatRune) {
            // Lógica para Combate: El centro es FIJO (el enemigo)
            const patternCenterX = Math.floor(pattern[0].length / 2);
            const patternCenterY = Math.floor(pattern.length / 2);
            
            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[r].length; c++) {
                    if (pattern[r][c] === 1) {
                        const requiredX = closestEnemy.x + (c - patternCenterX);
                        const requiredY = closestEnemy.y + (r - patternCenterY);
                        requiredRunesForMatch.push(`${requiredX},${requiredY}`);
                    }
                }
            }
            if (placedKeys.length === requiredRunesForMatch.length && requiredRunesForMatch.every(k => placedKeys.includes(k))) {
                isMatch = true;
            }
        } else {
            // Lógica para Utilidad: El centro es VARIABLE (cualquiera de las runas puestas)
            for (const centralRuneKey of placedKeys) {
                const [cx, cy] = centralRuneKey.split(',').map(Number);
                const patternCenterX = Math.floor(pattern[0].length / 2);
                const patternCenterY = Math.floor(pattern.length / 2);
                
                let tempRequired = [];
                for (let r = 0; r < pattern.length; r++) {
                    for (let c = 0; c < pattern[r].length; c++) {
                        if (pattern[r][c] === 1) {
                            const requiredX = cx + (c - patternCenterX);
                            const requiredY = cy + (r - patternCenterY);
                            tempRequired.push(`${requiredX},${requiredY}`);
                        }
                    }
                }
                if (placedKeys.length === tempRequired.length && tempRequired.every(k => placedKeys.includes(k))) {
                    isMatch = true;
                    requiredRunesForMatch = tempRequired;
                    break;
                }
            }
        }

        if (isMatch) {
            patternFound = formation;
            break;
        }
    }

    // 4. Procesar el resultado
    if (patternFound) {
        // ¡Éxito! Aplicar efecto y limpiar runas
        if (isCombatRune) {
            if (!closestEnemy.pendingFormationEffects) closestEnemy.pendingFormationEffects = [];
            closestEnemy.pendingFormationEffects.push(patternFound.effect);
            closestEnemy.formationRunes = {}; // Limpiar todas las runas del enemigo
            showModal("¡Formación Completa!", `Has completado la formación de combate: <strong>"${patternFound.name}"</strong>.`);
        } else {
            teleportPlayer(patternFound.effect.destinationId);
            gameState.utilityRunes = {}; // Limpiar las runas de utilidad
            showModal("¡Portal Abierto!", `La ${patternFound.name} se activa...`, true);
            setTimeout(() => closeModal(), 2000);
        }
    } else {
        // Aún no se completa un patrón. Aquí podrías re-implementar la lógica de "patrón incorrecto" si lo deseas,
        // pero por ahora, solo confirmamos la colocación.
        const message = isCombatRune ? `Has trazado una runa de combate cerca de ${closestEnemy.name}.` : "Has trazado parte de una matriz de utilidad.";
        showModal("Runa Inscrita", message);
    }
    
    updateUI();
    renderMap();
    renderQuickSlotBar();
}
    function checkUtilityPatterns() {
      for (const patternKey in FORMATION_PATTERNS) {
          const formation = FORMATION_PATTERNS[patternKey];
          if (formation.effect.type !== 'utility_teleport') continue;

          const pattern = formation.pattern;
          const patternHeight = pattern.length;
          const patternWidth = pattern[0].length;
          const patternCenterX = Math.floor(patternWidth / 2);
          const patternCenterY = Math.floor(patternHeight / 2);

          // Intenta hacer coincidir el patrón con cada runa de utilidad como posible centro
          for (const placedRuneKey in gameState.utilityRunes) {
              const [centerX, centerY] = placedRuneKey.split(',').map(Number);
              let isMatch = true;
              for (let r = 0; r < patternHeight; r++) {
                  for (let c = 0; c < patternWidth; c++) {
                      if (pattern[r][c] === 1) {
                          const requiredX = centerX + (c - patternCenterX);
                          const requiredY = centerY + (r - patternCenterY);
                          if (!gameState.utilityRunes[`${requiredX},${requiredY}`]) {
                              isMatch = false;
                              break;
                          }
                      }
                  }
                  if (!isMatch) break;
              }
              if (isMatch) return formation;
          }
      }
      return null;
  }

    function battleAction(action) {
      
        if (!gameState.battle.playerTurn || !gameState.battle.active) return;
        
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const playerSprite = document.querySelector('.character-sprite');
        const enemySprite = document.getElementById('enemySprite');
        let actionTaken = true;

         // Regeneración de vida por formaciones
          if (player.hpRegenPerTurn > 0 && player.hp < player.maxHp) {
              const healAmount = player.hpRegenPerTurn;
              player.hp = Math.min(player.maxHp, player.hp + healAmount);
              logBattle(`La formación rúnica te cura ${healAmount} HP.`);
              showFloatingText(playerSprite, `+${healAmount}`, 'heal');
          }
          // ===  REGENERACIÓN DE MANÁ ===
          if (player.manaRegenPerTurn > 0 && player.mana < player.maxMana) {
              const manaHealAmount = player.manaRegenPerTurn;
              player.mana = Math.min(player.maxMana, player.mana + manaHealAmount);
              logBattle(`La formación arcana restaura ${manaHealAmount} de tu Maná.`);
              showFloatingText(playerSprite, `+${manaHealAmount}`, 'mana'); // Usamos el tipo 'mana' para el color azul
          }
              // Inmunidad de Santuario Dorado Protector
          if (player.intangibleTurns > 0) {
            player.intangibleTurns--;
            console.log(`[battleAction] intangibleTurns DESPUÉS de reducir: ${player.intangibleTurns}`);
            if (player.intangibleTurns === 0) {
                logBattle("La protección del Santuario Dorado se desvanece.");
                showFloatingText(playerSprite, 'Vulnerable', 'debuff');
            }
          }

          // Duración del Escudo de Qi
          if (player.magicShieldTurns > 0) {
              player.magicShieldTurns--;
              if (player.magicShieldTurns === 0 && player.magicShieldValue > 0) {
                  logBattle("La energía de tu escudo de Qi se disipa.");
                  player.magicShieldValue = 0; // El escudo se agota por tiempo
              }
          }

          // Duración de la Matriz de Reversión
          if (player.damageToHealingTurns > 0) {
              player.damageToHealingTurns--;
              if (player.damageToHealingTurns === 0) {
                  logBattle("La Matriz de Reversión del Cosmos vuelve a su estado normal.");
              }
          }

          // Desgaste de debuffs aplicados AL JUGADOR
          if (player.defenseReductionTurns > 0) {
              player.defenseReductionTurns--;
              if (player.defenseReductionTurns === 0) {
                  player.defense += player.defenseReductionAmount; // Restaura la defensa
                  logBattle("Tu defensa vuelve a la normalidad.");
                  player.defenseReductionAmount = 0;
              }
          }
        // Reducir enfriamientos al inicio del turno del jugador
        for (const abilityId in player.abilityCooldowns) {
            if (player.abilityCooldowns[abilityId] > 0) {
                player.abilityCooldowns[abilityId]--;
            }
            if (player.abilityCooldowns[abilityId] <= 0) {
                delete player.abilityCooldowns[abilityId];
            }
        }
        populateBattleActionButtons(); // Actualizar botones para reflejar cooldowns reducidos

        // Procesar DoTs/HoTs y efectos en el jugador
        // (Esta lógica se mantiene como está, no es necesario cambiarla)
        if (player.burningTurns > 0) { /* ... */ }
        // ... el resto de la lógica de DoTs y Debuffs para el jugador ...

        if (player.hp <= 0) {
            // Lógica de derrota si el DoT lo derrota antes de actuar
            return;
        }

        // --- INICIO DE LA LÓGICA DE HABILIDADES REFACTORIZADA ---
        
        // Buscamos si la acción corresponde a una habilidad definida
        const techInfoEntry = Object.entries(techniqueData).find(([key, value]) => value.abilityId === action);

        if (techInfoEntry) {
            // Si es una habilidad, ejecutamos la lógica de técnica
            const [sourceTechniqueId, techDetails] = techInfoEntry;
            const playerTech = player.learnedTechniques[sourceTechniqueId];
            
            if (!playerTech || playerTech.level === 0) {
                logBattle(`Intentas usar ${techDetails.name}, pero no la has dominado (Nivel 0).`);
                return; // No consume el turno, permite elegir otra acción
            }

            const playerTechLevel = playerTech.level;
            const manaCost = techDetails.manaCost || 0;

            if ((player.abilityCooldowns[action] || 0) > 0) {
                logBattle(`¡La técnica ${techDetails.name} aún está en enfriamiento!`);
                return; // No consume el turno
            }

            if (player.mana < manaCost) {
                logBattle(`Maná insuficiente para ${techDetails.name}.`);
                actionTaken = false;
            } else {
                player.mana -= manaCost;
                if (techDetails.cooldown) {
                    player.abilityCooldowns[action] = techDetails.cooldown;
                }

                let damageDealt = 0;
                let logMessage = "";
                const effect = techDetails.effect;

                // Delegamos al switch-case que ya tenías, pero ahora 'playerTechLevel' es correcto.
                // El código interno de cada 'case' usará 'playerTechLevel' para el cálculo.
                // El siguiente bloque 'switch' debe contener TODA tu lógica de habilidades existente.
                // Lo que sigue es un ejemplo de cómo debe quedar el caso de 'sword_t1'.

                switch (action) {
                  
                  case "sword_t1"://Tajo del Viento Veloz
                    const swordTechDetails = techniqueData["sword_t1"];
                    const swordManaCost = swordTechDetails.manaCost || 10;
                    if (player.mana >= swordManaCost) {
                      player.mana -= swordManaCost;
                      // Calculamos el multiplicador de daño de forma genérica, leyendo los valores de la definición.
                      const damageMultiplier =
                        swordTechDetails.effect.baseDamageMultiplier +
                        (playerTechLevel - 1) * (swordTechDetails.effect.multiplierIncreasePerLevel || 0);

                      const swordDamage = Math.max(
                        1,
                        Math.floor(player.attack * damageMultiplier) -
                          (enemy.defense || 0)
                      );
                      enemy.hp -= swordDamage;
                      logBattle(
                        `¡${swordTechDetails.name} (Nv.${playerTechLevel}) causa ${swordDamage} daño!`
                      );
                      showFloatingText(
                        document.querySelector(".character-sprite"),
                        `Tajo Veloz`,
                        "ability"
                      );
                      showFloatingText(
                        document.getElementById("enemySprite"),
                        ` -${swordDamage}`,
                        "damage"
                      );
                    } else {
                      logBattle(`Maná insuficiente para ${swordTechDetails.name}.`);
                      actionTaken = false;
                    }

                    break;
                  case "sword_t2"://Estocada Perfora-Armadura
                              // Obtenemos los detalles de la técnica y su nivel
                    const estocadaDetails = techniqueData["sword_t2"];
                    const estocadaLevel = player.learnedTechniques["sword_t2"]?.level || 1;

                    // --- CÁLCULOS MEJORADOS ---
                    // El multiplicador de daño y la penetración ahora escalan con el nivel de la técnica
                    const damageMultiplier = estocadaDetails.effect.baseDamageMultiplier + ((estocadaLevel - 1) * 0.1);
                    const penetrationPercent = estocadaDetails.effect.defensePenetration + ((estocadaLevel - 1) * 0.02); // +2% por nivel

                    // Calculamos el daño
                    const defenseToIgnore = (enemy.defense || 0) * penetrationPercent;
                    const baseDamage = player.attack * damageMultiplier;
                    damageDealt = Math.max(1, Math.floor(baseDamage - ((enemy.defense || 0) - defenseToIgnore)));
                    
                    enemy.hp -= damageDealt;

                    logMessage = `¡${estocadaDetails.name} (Nv.${estocadaLevel}) ignora ${Math.floor(defenseToIgnore)} de defensa y causa ${damageDealt} de daño!`;
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');

                    // --- LÓGICA PARA LA HEMORRAGIA (BLEED) ---
                    const bleedChance = estocadaDetails.effect.bleedChance + ((estocadaLevel - 1) * 0.05); // La probabilidad de sangrado también mejora
                    if (Math.random() < bleedChance) {
                        const bleedDmg = estocadaDetails.effect.bleedDamagePerTurn + (estocadaLevel * 2); // El daño de sangrado escala
                        const bleedDur = estocadaDetails.effect.bleedDuration;

                        // Para no crear una nueva propiedad, podemos reutilizar la de "poison" o "burn".
                        // Usemos "poison" como si fuera "bleed" para no añadir más complejidad al enemyTurn.
                        enemy.poisonedTurns = Math.max(enemy.poisonedTurns, bleedDur);
                        enemy.poisonDamage = Math.max(enemy.poisonDamage, bleedDmg);
                        
                        logMessage += ` ¡El golpe causa una herida abierta que sangra!`;
                        showFloatingText(enemySprite, 'Hemorragia', 'debuff');
                    }

                    logBattle(logMessage);
                    break;
                  case "sword_t3": { // Danza de Espada Ciclónica
                        const hits = Math.round(effect.baseHits + (playerTechLevel - 1) * effect.hitsIncreasePerLevel);
                        let totalDamage = 0;
                        for (let i = 0; i < hits; i++) {
                            const damageDealt = Math.max(1, Math.floor((player.attack * effect.baseDamageMultiplier) - enemy.defense));
                            enemy.hp -= damageDealt;
                            totalDamage += damageDealt;
                        }
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) golpea ${hits} veces, causando ${totalDamage} de daño!`;
                        showFloatingText(enemySprite, `-${totalDamage}`, 'damage');
                        break;
                    }
                  case "sword_t4": { // Intento de Espada del Tirano
                        const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.multiplierIncreasePerLevel;
                        const damageDealt = Math.max(1, Math.floor(player.attack * currentMultiplier) - enemy.defense);
                        enemy.hp -= damageDealt;
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) golpea con ${damageDealt} de daño!`;
                        const stunChance = effect.baseStunChance + (playerTechLevel - 1) * effect.stunChanceIncreasePerLevel;
                        if (Math.random() < stunChance) {
                            enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                            logMessage += " ¡El enemigo queda aturdido!";
                        }
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }
                  case "sword_t5": // Corte que Divide Cielos y Tierra
                    const sword5DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.floor(player.attack * sword5DmgMultiplier);
                    enemy.hp -= damageDealt;
                    logMessage = `¡${techDetails.name} corta la realidad misma, infligiendo ${damageDealt} de daño absoluto!`;

                    const critChance = techDetails.effect.criticalChance + (playerTechLevel - 1) * (techDetails.effect.criticalChanceIncreasePerLevel || 0);
                    if (Math.random() < critChance) {
                        const critDamage = Math.floor(damageDealt * 0.5); // 50% extra de daño crítico
                        enemy.hp -= critDamage;
                        logMessage += ` ¡Fue un golpe crítico, causando ${critDamage} de daño extra!`;
                        damageDealt += critDamage;
                    }

                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    break;
                  case "sword_t6": // Espada del Emperador Celestial
                        const executeThreshold = techDetails.effect.executeThreshold + (playerTechLevel - 1) * (techDetails.effect.executeThresholdIncreasePerLevel || 0);
                        logMessage = `¡${techDetails.name} desata un poder absoluto!`;
                        if (enemy.hp / enemy.maxHp <= executeThreshold) {
                            damageDealt = enemy.hp;
                            enemy.hp = 0;
                            logMessage += " ¡El enemigo es ejecutado por decreto celestial!";
                            showFloatingText(enemySprite, '¡EJECUTADO!', 'damage');
                        } else {
                            const sword6DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                            damageDealt = Math.floor(player.attack * sword6DmgMultiplier);
                            enemy.hp -= damageDealt;
                            logMessage += ` Causa ${damageDealt} de daño que ignora toda protección.`;
                            showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        }
                        break;
                  
                  case "fire_t1"://Chispa Ígnea
                    const fireDamageMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * fireDamageMultiplier) - (enemy.defense || 0));
                    enemy.hp -= damageDealt;

                    const burnDamage = techDetails.effect.burnDamagePerTurn + (playerTechLevel - 1) * (techDetails.effect.burnDamageIncreasePerLevel || 0);
                    enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                    enemy.burnDamage = Math.max(enemy.burnDamage, burnDamage);
                    
                    logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} de daño y quema al enemigo!`;
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    break;

                  case "fire_t2"://Aliento de Dragón Menor
                    const fire2DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * fire2DmgMultiplier) - (enemy.defense || 0));
                    enemy.hp -= damageDealt;
                    
                    const burn2Damage = techDetails.effect.burnDamagePerTurn + (playerTechLevel - 1) * (techDetails.effect.burnDamageIncreasePerLevel || 0);
                    enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                    enemy.burnDamage = Math.max(enemy.burnDamage, burn2Damage);

                    logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} de daño e inflige una quemadura intensa!`;
                    break;
                  
                  case "fire_t4": { // Sol Abrasador
                        const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.multiplierIncreasePerLevel;
                        const damageDealt = Math.max(1, Math.floor(player.attack * currentMultiplier) - enemy.defense);
                        enemy.hp -= damageDealt;
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) inflige ${damageDealt} de daño masivo!`;
                        
                        // --- INICIO DE LA MODIFICACIÓN ---
                        // Calculamos el daño de la quemadura, incluyendo el escalado por nivel.
                        const burnDamage = effect.burnDamagePerTurn + (playerTechLevel - 1) * (effect.burnIncreasePerLevel || 0);
                        
                        // Aplicamos la quemadura al enemigo. Usamos Math.max para no reemplazar una quemadura más fuerte.
                        enemy.burningTurns = Math.max(enemy.burningTurns, effect.burnDuration);
                        enemy.burnDamage = Math.max(enemy.burnDamage, burnDamage);
                        
                        // Actualizamos el mensaje del log y mostramos un texto flotante.
                        logMessage += ` ¡El enemigo queda envuelto en llamas, sufriendo una quemadura intensa!`;
                        showFloatingText(enemySprite, '¡Quemadura!', 'debuff');
                        // --- FIN DE LA MODIFICACIÓN ---

                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }
                  case "fire_t5": // Llama del Fénix Renaciente
                            damageDealt = Math.max(1, Math.floor(player.attack * techDetails.effect.baseDamageMultiplier) - enemy.defense);
                            enemy.hp -= damageDealt;
                            const reviveChance = techDetails.effect.reviveChance + (playerTechLevel - 1) * (techDetails.effect.reviveChanceIncreasePerLevel || 0);
                            if (Math.random() < reviveChance) {
                                player.canRevive = true;
                            }
                            logMessage = `¡${techDetails.name} incinera al enemigo con ${damageDealt} de daño y te imbuye con la esencia del Fénix!`;
                            showFloatingText(playerSprite, 'Fénix Interior', 'ability');
                            showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                            break; 
                  

                  case "lightning_t1": // Dedo de Relámpago
                      const lightningDmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                      damageDealt = Math.max(1, Math.floor(player.attack * lightningDmgMultiplier) - enemy.defense);
                      enemy.hp -= damageDealt;

                      const stunChance = techDetails.effect.stunChance + (playerTechLevel - 1) * (techDetails.effect.stunChanceIncreasePerLevel || 0);
                      logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) golpea con ${damageDealt} de daño!`;
                      
                      if (Math.random() < stunChance) {
                          enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                          logMessage += " ¡El enemigo queda aturdido!";
                          showFloatingText(enemySprite, '¡Aturdido!', 'debuff');
                      }
                      showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                      break;
                  case "lightning_t2": // Látigo de Trueno
                    const lightning2DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * lightning2DmgMultiplier) - enemy.defense);
                    
                    const defenseReduction = techDetails.effect.defenseReduction + (playerTechLevel - 1) * (techDetails.effect.defenseReductionIncreasePerLevel || 0);
                    const duration = techDetails.effect.duration;
                    
                    enemy.hp -= damageDealt;
                    enemy.defenseReductionTurns = Math.max(enemy.defenseReductionTurns, duration);
                    enemy.defenseReductionAmount = Math.max(enemy.defenseReductionAmount, defenseReduction);

                    logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} de daño y reduce la defensa del enemigo en ${defenseReduction}!`;
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    showFloatingText(enemySprite, 'Defensa ↓', 'debuff');
                    break;
                  case "lightning_t3": { // Jaula de Rayos
                      const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.damageMultiplierIncreasePerLevel;
                      const damageDealt = Math.max(1, Math.floor(player.attack * currentMultiplier) - enemy.defense);
                      enemy.hp -= damageDealt;
                      logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) electrocuta con ${damageDealt} de daño!`;
                      const stunChance = effect.baseStunChance + (playerTechLevel - 1) * effect.stunChanceIncreasePerLevel;
                      if (Math.random() < stunChance) {
                          enemy.stunnedTurns = Math.max(enemy.stunnedTurns, effect.duration);
                          logMessage += ` ¡El enemigo queda paralizado!`;
                          showFloatingText(enemySprite, '¡Paralizado!', 'debuff');
                      }
                      showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                      break;
                  }
                  case "lightning_t4": { // Llamada del Juicio del Trueno
                        const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.multiplierIncreasePerLevel;
                        const damageDealt = Math.floor(player.attack * currentMultiplier); // Ignora defensa
                        enemy.hp -= damageDealt;
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) ignora la defensa, causando ${damageDealt} de daño verdadero!`;
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }          
                  case "lightning_t5": // Tribulación de los Nueve Cielos
                    const lightning5DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * lightning5DmgMultiplier) - enemy.defense);
                    enemy.hp -= damageDealt;
                    logMessage = `¡Invocas la ${techDetails.name}, causando ${damageDealt} de daño celestial!`;

                    const paralyzeChance = techDetails.effect.paralyzeChance + (playerTechLevel - 1) * (techDetails.effect.paralyzeChanceIncreasePerLevel || 0);
                    if (Math.random() < paralyzeChance) {
                        enemy.stunnedTurns = Math.max(enemy.stunnedTurns, techDetails.effect.duration || 2);
                        logMessage += ` ¡El poder de la tribulación lo deja paralizado por ${enemy.stunnedTurns} turnos!`;
                        showFloatingText(enemySprite, '¡Paralizado!', 'debuff');
                    }
                    showFloatingText(playerSprite, '¡Tribulación!', 'ability');
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    break;

                  case "movement_t1": { // Paso Veloz (TIER 1)
                      const defenseBonus = techDetails.effect.tempDefenseBuff + ((playerTechLevel - 1) * techDetails.effect.buffIncreasePerLevel);
                      
                      if(player.tempDefenseBoostAmount > 0) {
                          player.defense -= player.tempDefenseBoostAmount;
                      }
                      player.defense += defenseBonus;
                      player.tempDefenseBoostAmount = defenseBonus;
                      player.tempDefenseBoostTurns = techDetails.effect.buffDuration;
                      
                      logMessage = `¡Ejecutas un ${techDetails.name}! Tu defensa aumenta en ${defenseBonus} por ${player.tempDefenseBoostTurns} turnos.`;
                      showFloatingText(playerSprite, `Defensa +${defenseBonus}`, 'ability');
                      break;
                  }
                  case "movement_t2"://Paso Etéreo
                    const etereoDetails = techniqueData["movement_t2"];
                    const etereoLevel = player.learnedTechniques["movement_t2"]?.level || 1;

                    // --- LÓGICA PARA APLICAR ESQUIVA Y BUFF ---
                    player.dodgeNextAttack = true;

                    // Calculamos y aplicamos el buff de defensa
                    const defenseBonus = etereoDetails.effect.tempDefenseBuff + (etereoDetails.effect.buffIncreasePerLevel * (etereoLevel - 1));
                    
                    // Evitamos acumular el mismo buff, lo refrescamos
                    if (player.tempDefenseBoostAmount > 0) {
                        player.defense -= player.tempDefenseBoostAmount; // Quita el buff anterior
                    }
                    player.defense += defenseBonus;
                    player.tempDefenseBoostAmount = defenseBonus;
                    player.tempDefenseBoostTurns = etereoDetails.effect.buffDuration;
                    
                    logMessage = `¡Usas ${etereoDetails.name} (Nv.${etereoLevel})! Te preparas para esquivar y tu defensa aumenta en ${defenseBonus} por ${player.tempDefenseBoostTurns} turnos.`;
                    showFloatingText(playerSprite, '¡Esquiva!', 'ability');
                    showFloatingText(playerSprite, `Defensa +${defenseBonus}`, 'ability');
                    
                    logBattle(logMessage);
                    break;              
                  case "movement_t3": { // Parpadeo de Sombra
                        const effect = techDetails.effect;
                        
                        // Calculamos el multiplicador actual: Base + (Nivel - 1) * AumentoPorNivel
                        const currentMultiplier = effect.baseDamageMultiplier + ((playerTechLevel - 1) * (effect.multiplierIncreasePerLevel || 0));
                        
                        let baseDamage = player.attack * currentMultiplier;

                        // Aplicamos el multiplicador de crítico si la técnica lo especifica
                        if (effect.isCritical) {
                            baseDamage *= 1.5; // Multiplicador de crítico estándar (150%)
                        }

                        const damageDealt = Math.max(1, Math.floor(baseDamage) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;

                        logMessage = `¡Con ${techDetails.name} (Nv.${playerTechLevel}), apareces para un golpe crítico de ${damageDealt}!`;
                        showFloatingText(playerSprite, '¡Golpe Súbito!', 'ability');
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }              
                  case "movement_t4": // Danza del Viento Espectral
                        const move4DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                        damageDealt = Math.max(1, Math.floor(player.attack * move4DmgMultiplier) - enemy.defense);
                        enemy.hp -= damageDealt;
                        player.dodgeNextAttack = true;
                        logMessage = `¡Ejecutas la ${techDetails.name}! Causas ${damageDealt} de daño y te preparas para esquivar.`;
                        showFloatingText(playerSprite, '¡Esquiva!', 'ability');
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                  case "movement_t5": // Paso del Vacío Infinito
                    player.intangibleTurns = techDetails.effect.intangibleTurns;
                    const numHits = techDetails.effect.multiHit;
                    let totalVoidDamage = 0;
                    for (let i = 0; i < numHits; i++) {
                        damageDealt = Math.max(1, Math.floor((player.attack * (techDetails.effect.baseDamageMultiplier / numHits)) - enemy.defense));
                        enemy.hp -= damageDealt;
                        totalVoidDamage += damageDealt;
                    }
                    logMessage = `¡Con ${techDetails.name} te vuelves intangible por ${player.intangibleTurns} turnos y golpeas ${numHits} veces, causando un total de ${totalVoidDamage} de daño!`;
                    showFloatingText(enemySprite, `-${totalVoidDamage}`, 'damage');
                    break;        

                  case "formation_t1":
                      const shieldDetails = techniqueData["formation_t1"];
                      const shieldLevel = player.learnedTechniques["formation_t1"]?.level || 1;

                      // --- CÁLCULO DE ESCUDO MEJORADO ---
                      const shieldBase = shieldDetails.effect.shieldValue;
                      const shieldBonusPerLevel = shieldDetails.effect.shieldIncreasePerLevel;
                      const shieldValue = shieldBase + (shieldBonusPerLevel * (shieldLevel - 1));
                      const shieldDuration = shieldDetails.effect.duration;

                      // Aplicamos el escudo
                      player.magicShieldValue = (player.magicShieldValue || 0) + shieldValue;
                      player.magicShieldTurns = Math.max(player.magicShieldTurns || 0, shieldDuration);

                      logMessage = `¡${shieldDetails.name} (Nv.${shieldLevel}) crea un escudo que absorbe ${shieldValue} de daño! (Total: ${Math.floor(player.magicShieldValue)})`;
                      showFloatingText(playerSprite, `Escudo +${shieldValue}`, 'ability');

                      // --- LÓGICA PARA LA CURACIÓN SECUNDARIA ---
                      const healReqLevel = shieldDetails.effect.healOnCastLevelReq;
                      if (shieldLevel >= healReqLevel) {
                          const healBase = shieldDetails.effect.healOnCastAmount;
                          // La curación también puede escalar un poco
                          const healAmount = healBase + ((shieldLevel - healReqLevel) * 5);
                          
                          player.hp = Math.min(player.maxHp, player.hp + healAmount);
                          
                          logMessage += ` El flujo de Qi regenera ${healAmount} de vida.`;
                          showFloatingText(playerSprite, `+${healAmount}`, 'heal');
                      }
                      
                      logBattle(logMessage);
                      break;
                  case "formation_t2":
                    const rootTechDetails = techniqueData["formation_t2"];
                    const rootTechLevel = player.learnedTechniques["formation_t2"]?.level || 1;
                    const rootChance = (rootTechDetails.effect.rootChance || 0.7) + (rootTechLevel - 1) * 0.03;

                    if (Math.random() < rootChance) {
                      const rootDuration = rootTechDetails.effect.rootDuration;
                      const rootDmgPerTurn = rootTechDetails.effect.damagePerTurn + (rootTechLevel - 1) * (rootTechDetails.effect.damagePerTurnIncreasePerLevel || 0);
                      const shacklesHealth = rootTechDetails.effect.shacklesHP + (rootTechLevel - 1) * (rootTechDetails.effect.shacklesHPIncreasePerLevel || 0);

                      enemy.rootedTurns = rootDuration;
                      enemy.rootDamage = rootDmgPerTurn;

                      player.activeChanneledAbility.id = "formation_t2";
                      player.activeChanneledAbility.hp = shacklesHealth;
                      
                      logMessage = `¡${rootTechDetails.name} (Nv.${rootTechLevel}) atrapa al enemigo con grilletes de ${shacklesHealth} de resistencia!`;
                      showFloatingText(enemySprite, "¡Atrapado!", "debuff");
                    } else {
                      logMessage = `¡${rootTechDetails.name} (Nv.${rootTechLevel}) falla y el enemigo esquiva los grilletes!`;
                      showFloatingText(enemySprite, "¡Falló!", "ability");
                    }
                    logBattle(logMessage);
                    break;
                  case "formation_t3": { // Matriz de Supresión Espiritual
                        const reduction = effect.baseReduction + (playerTechLevel - 1) * effect.reductionIncreasePerLevel;
                        enemy.defenseReductionTurns = Math.max(enemy.defenseReductionTurns, effect.duration);
                        enemy.defenseReductionAmount = Math.max(enemy.defenseReductionAmount, reduction);
                        enemy.attackReductionTurns = Math.max(enemy.attackReductionTurns, effect.duration);
                        enemy.attackReductionAmount = Math.max(enemy.attackReductionAmount, reduction);
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) debilita al enemigo! Su Ataque y Defensa se reducen en ${reduction}.`;
                        showFloatingText(enemySprite, 'Ata/Def ↓', 'debuff');
                        break;
                    }      
                  case "formation_t4": { // Santuario Dorado Protector
                      const duration = effect.baseDuration + (playerTechLevel >= effect.levelForExtraTurn ? 1 : 0);
                      player.intangibleTurns = duration;
                      logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) te hace inmune al daño por ${duration} turnos!`;
                      showFloatingText(playerSprite, '¡Invulnerable!', 'ability');
                      break;
                  }
                  case "formation_t5": // Matriz de Reversión del Cosmos
                    player.damageToHealingTurns = techDetails.effect.damageToHealingDuration;
                    logMessage = `¡Activaste ${techDetails.name}! Durante ${player.damageToHealingTurns} turnos, el daño recibido te curará.`;
                    showFloatingText(playerSprite, 'Inversión Cósmica', 'ability');
                    break;                  
                  case "formation_t6": // Matriz del Sello del Demonio
                          enemy.sealedTurns = techDetails.effect.sealDuration;
                          logMessage = `¡${techDetails.name} sella completamente al enemigo por ${enemy.sealedTurns} turnos! No podrá realizar ninguna acción.`;
                          showFloatingText(enemySprite, '¡SELLADO!', 'debuff');
                          break; 

                    
                  default:
                        // Este bloque ahora se encarga de TODAS las habilidades que hemos estandarizado
                        logMessage = `Usando ${techDetails.name} (Nv.${playerTechLevel})...`;
                        let tempDamage = 0;
                        
                        // Daño base
                        if (effect.baseDamageMultiplier) {
                             const multiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * (effect.multiplierIncreasePerLevel || 0);
                             tempDamage = Math.max(1, Math.floor(player.attack * multiplier) - (enemy.defense || 0));
                             enemy.hp -= tempDamage;
                             logMessage += ` ¡Causa ${tempDamage} de daño!`;
                             showFloatingText(enemySprite, `-${tempDamage}`, "damage");
                        }
                        // Aquí puedes añadir la lógica genérica para DoTs, stuns, etc. si lo deseas en el futuro
                        break;
                }
                 if(logMessage) logBattle(logMessage);
            }
        } else {
            // --- FIN DE LA LÓGICA DE HABILIDADES ---
            // Si no es una habilidad, es una acción básica (ataque, defensa, huida)
            switch (action) {
              case "attack":
                const damage = Math.max(
                  1,
                  player.attack -
                    (enemy.defense || 0) +
                    Math.floor(Math.random() * 5 - 2)
                );
                enemy.hp -= damage;
                logBattle(`Atacas causando ${damage} daño.`);
                showFloatingText(
                  document.getElementById("enemySprite"),
                  `-${damage}`,
                  "damage"
                );

                // ESTA LÍNEA DEBERÍA SER logBattle, NO showFloatingText.
                // O es un resto de una depuración anterior que hay que eliminar.
                if (player.hp <= 0) {
                  logBattle("Has sucumbido antes de actuar.");
                  // ... Lógica de derrota ...
                }
                break; // <-- Fin del caso de ataque
              case "qi_fist":
                const qiFistCost = 10;
                if (player.mana >= qiFistCost) {
                  player.mana -= qiFistCost;
                  const magicDamage = Math.max(
                    1,
                    Math.floor(player.attack * 0.8 + player.maxMana * 0.2) -
                      (enemy.defense || 0)
                  );
                  enemy.hp -= magicDamage;
                  logBattle(`Puño de Qi causa ${magicDamage} daño mágico.`);
                  showFloatingText(
                    document.querySelector(".character-sprite"),
                    `Puño de QI`,
                    "ability"
                  );
                  showFloatingText(
                    document.getElementById("enemySprite"),
                    `-${magicDamage}`,
                    "damage"
                  );
                } else {
                  logBattle("Maná insuficiente para Puño de Qi.");
                  actionTaken = false;
                }

                break;
              case "defend":
                let healAmount = Math.floor(player.maxHp * 0.1);
                player.hp = Math.min(player.maxHp, player.hp + healAmount);
                showFloatingText(
                  document.querySelector(".character-sprite"),
                  `+${healAmount}`,
                  "heal"
                );
                logBattle(`Te defiendes y recuperas ${healAmount} HP.`);
                break;
              case "escape":
                if (enemy.isBoss) {
                  logBattle(`¡No puedes huir de un ${enemy.name}!`);
                  showFloatingText(
                    document.querySelector(".character-sprite"),
                    "¡Imposible!",
                    "debuff"
                  );
                  actionTaken = false; // La acción falló, no se consume el turno
                } else if (Math.random() < 0.7) {
                  // Probabilidad de éxito de huida

                  const escapeTile = findEscapeTile(player, enemy);

                  if (escapeTile) {
                    logBattle("¡Escapaste con éxito!");
                    showFloatingText(
                      document.querySelector(".character-sprite"),
                      "¡Huida!",
                      "ability"
                    );

                    // Mover al jugador a la casilla segura ANTES de terminar la batalla
                    player.x = escapeTile.x;
                    player.y = escapeTile.y;

                    // Esperar un breve momento para que el texto flotante se vea
                    setTimeout(() => {
                      endBattle(false); // false = no fue una victoria
                      updatePlayerPosition("escape_success"); // Actualizar la posición visual en el mapa
                    }, 500);
                  } else {
                    logBattle("¡Intentaste huir, pero no hay a dónde ir!");
                    showFloatingText(
                      document.querySelector(".character-sprite"),
                      "¡Atrapado!",
                      "debuff"
                    );
                    actionTaken = true; // El intento de huir consume el turno
                  }

                  // Como la huida (exitosa o no) ya manejó el flujo, salimos de la función
                  return;
                } else {
                  logBattle("¡No pudiste escapar!");
                  showFloatingText(
                    document.querySelector(".character-sprite"),
                    "¡Falló!",
                    "debuff"
                  );
                  actionTaken = true; // El intento fallido también consume el turno
                }
                break;
              default:
                logBattle("Acción desconocida.");
                actionTaken = false;
                break;
          }
        
        }
        
        if (!actionTaken) {
          updateBattleUI();
          return;
        }

        gameState.battle.playerTurn = false;
        updateBattleUI();

        if (enemy.hp <= 0) {
          handleEnemyDefeat();
        } else {
          let enemyDiedToDot = false;
          if (enemy.burningTurns > 0) {
            enemy.hp -= enemy.burnDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.burnDamage
              } por quemadura. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.poisonedTurns > 0) {
            enemy.hp -= enemy.poisonDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.poisonDamage
              } por veneno. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.rootedTurns > 0) {
            enemy.hp -= enemy.rootDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.rootDamage
              } por enredo. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }

          if (enemyDiedToDot) {
            handleEnemyDefeat();
          } else {
            setTimeout(enemyTurn, 1000);
          }
        }
      }


      /**
 * FUNCIÓN CENTRALIZADA (Reemplazar la existente)
 * Genera el texto de progreso para una misión activa.
 * @param {object} misionActiva - El objeto de la misión activa del jugador.
 * @returns {string} El texto formateado del progreso de la misión.
 */
      function getMissionProgressText(misionActiva) {
          const misionData = MISIONES_DATA[misionActiva.id];
          if (!misionData || !misionActiva.objetivoOriginal) {
              return "(Error: Datos de misión no encontrados)";
          }

          const objetivo = misionActiva.objetivoOriginal;
          const progreso = misionActiva.progreso || 0;
          const npcEntregaNombre = SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre || "el NPC correspondiente";
          let texto = "";
          let completado = false;

          switch (objetivo.tipo) {
              case "eliminar_enemigo":
                  completado = progreso >= objetivo.cantidad;
                  texto = `Eliminados: ${progreso}/${objetivo.cantidad} ${objetivo.nombreDisplay || "objetivos"}`;
                  break;

              case "entregar_item":
                  const tiene = gameState.inventory[objetivo.item] || 0;
                  completado = tiene >= objetivo.cantidad;
                  texto = `Reunidos: ${tiene}/${objetivo.cantidad} ${objetivo.item}`;
                  break;
                  
              case "derrotar_npc_especifico":
                  const rivalName = entityTypes[objetivo.npcId]?.name || "objetivo";
                  completado = progreso === 1;
                  texto = completado ? `Derrotado: ${rivalName}` : `Pendiente: Derrotar a ${rivalName}`;
                  break;

              case "recolectar_multiples_items":
                  let todosListos = true;
                  const itemsStatus = objetivo.items.map(itemReq => {
                      const tiene = gameState.inventory[itemReq.nombre] || 0;
                      if (tiene < itemReq.cantidad) todosListos = false;
                      return `${tiene}/${itemReq.cantidad} ${itemReq.nombre}`;
                  }).join(', ');
                  completado = todosListos;
                  texto = `Recolectar: ${itemsStatus}`;
                  break;
              
              case "cazar_y_recuperar_item_de_loot":
                  const tieneItem = (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba;
                  completado = progreso === 1 && tieneItem;
                  texto = `Cazar y obtener: ${objetivo.cantidadItemPrueba} ${objetivo.itemPrueba}`;
                  break;
                  
              case "llegar_a_punto":
                  completado = progreso === 1;
                  texto = completado ? `Ubicación encontrada: ${objetivo.nombreArea}` : `Objetivo: Llegar a ${objetivo.nombreArea}`;
                  break;

              default:
                  // Si llega aquí, es porque el 'tipo' de objetivo en MISIONES_DATA está mal escrito o falta.
                  return "(Progreso no rastreable)";
          }

          if (completado) {
              texto += ` <strong>(¡Listo para entregar a ${npcEntregaNombre}!)</strong>`;
          }

          return texto;
      }
      // REEMPLAZA tu función handleEnemyDefeat completa con esta versión

// REEMPLAZA tu función handleEnemyDefeat completa con esta versión definitiva

function handleEnemyDefeat() {
    // 1. Obtenemos el objeto de batalla, que puede estar incompleto.
    const battleEnemy = gameState.battle.enemy;
    const player = gameState.player;

    // --- LA CORRECCIÓN CLAVE ---
    // No confiamos ciegamente en battleEnemy. Usamos su ID para buscar la definición maestra.
    const enemyDefinition = entityTypes[battleEnemy.originalEntityTypeId] || entityTypes[battleEnemy.npcId] || {};
    
    // Creamos un objeto "completo" del enemigo, combinando la definición maestra con el estado actual de la batalla.
    // Esto GARANTIZA que 'npcId' y todas las demás propiedades maestras estén presentes.
    const enemy = {
        ...enemyDefinition,
        ...battleEnemy
    };
    // --- FIN DE LA CORRECCIÓN ---

    logBattle(`¡Has derrotado al ${enemy.name}!`);
    gainExperience(enemy.exp);

    // Ahora, el resto de la función usará el objeto 'enemy' completo y correcto.
    const misionesActivasDelJugador = [...player.secta.misionesActivas];
    misionesActivasDelJugador.forEach((misionActiva) => {
        const misionData = MISIONES_DATA[misionActiva.id];
        if (!misionData || !misionData.objetivo) return;

        const objetivo = misionData.objetivo;

        if (objetivo.tipo === "derrotar_npc_especifico" && enemy.npcId === objetivo.npcId) {
            misionActiva.progreso = 1;
            console.log(`[handleEnemyDefeat] Misión '${misionActiva.id}' actualizada: Progreso = 1.`);
            logBattle(`¡Has completado el objetivo de derrotar a ${enemy.name}!`);
        }
        
        if (objetivo.tipo === "eliminar_enemigo" && enemy.originalEntityTypeId === objetivo.enemigoTipo) {
             misionActiva.progreso = (misionActiva.progreso || 0) + 1;
             logBattle(`Progreso '${misionData.titulo}': ${misionActiva.progreso}/${objetivo.cantidad}`);
        }
        
        if (objetivo.tipo === "cazar_y_recuperar_item_de_loot" && enemy.originalEntityTypeId === objetivo.enemigoTipo) {
            misionActiva.progreso = 1;
            logBattle(`Has derrotado a un ${enemy.name}. Busca el ${objetivo.itemPrueba} entre el botín.`);
        }
    });

    // La lógica de botín y fin de batalla no cambia.
    let lootObtenidoTexto = "Botín Obtenido: ";
    let algoObtenido = false;
    if (enemy.lootTable) {
        enemy.lootTable.forEach((loot) => {
            if (Math.random() < loot.chance) {
                const cantidad = loot.quantity[0] + Math.floor(Math.random() * (loot.quantity[1] - loot.quantity[0] + 1));
                gameState.inventory[loot.itemName] = (gameState.inventory[loot.itemName] || 0) + cantidad;
                lootObtenidoTexto += `${cantidad} ${loot.itemName}, `;
                algoObtenido = true;
            }
        });
    }
    if (!algoObtenido) lootObtenidoTexto += "Nada.";
    else lootObtenidoTexto = lootObtenidoTexto.slice(0, -2) + ".";
    
    if (enemy.isBoss && enemy.originalEntityTypeId) {
        player.worldState.defeatedBosses[enemy.originalEntityTypeId] = true;
    }
    
    // El objeto original de batalla (battleEnemy) tiene la referencia al mapa.
    if (battleEnemy.entityRef) {
        removeEntity(battleEnemy.entityRef);
    } else {
        // Fallback por si la referencia se pierde, busca por ID en el mapa.
        const entityOnMap = gameState.map.entities.find(e => e.id === battleEnemy.id);
        if(entityOnMap) removeEntity(entityOnMap);
    }
    
    setTimeout(() => {
        endBattle(true);
        showModal("¡Victoria!", `Has ganado el combate.\n\n${lootObtenidoTexto}\n\nRevisa tu diario de misiones para ver el progreso.`);
        updateSectUI();
    }, 500);
}
function dev_resetMission(missionId) {
    const player = gameState.player;
    if (!player || !player.secta) {
        console.error("[DEV] No se puede resetear la misión, estado del jugador no encontrado.");
        return;
    }

    // Eliminar de misiones activas
    const initialActiveCount = player.secta.misionesActivas.length;
    player.secta.misionesActivas = player.secta.misionesActivas.filter(m => m.id !== missionId);
    const finalActiveCount = player.secta.misionesActivas.length;

    if (initialActiveCount > finalActiveCount) {
        console.log(`[DEV] Misión '${missionId}' eliminada de la lista de misiones activas.`);
    }

    // Eliminar de misiones completadas
    if (player.secta.misionesCompletadas[missionId]) {
        delete player.secta.misionesCompletadas[missionId];
        console.log(`[DEV] Misión '${missionId}' eliminada del historial de misiones completadas.`);
    }
    
    // Actualizar toda la interfaz para reflejar el cambio.
    updateUI();
    updateSectUI();
    openMissionsModal(); // Abrimos el diario para ver que ha desaparecido.

    const message = `El estado de la misión '${missionId}' ha sido reseteado. Ahora puedes volver a aceptarla del NPC correspondiente.`;
    console.log(message);
    alert(message);
}
function dev_forceCompleteMission(missionId) {
    const player = gameState.player;
    const misionActiva = player.secta.misionesActivas.find(m => m.id === missionId);

    if (!misionActiva) {
        const message = `[DEV] Error: La misión '${missionId}' no está activa. No se puede forzar su finalización.`;
        console.error(message);
        alert(message);
        return;
    }

    const misionData = MISIONES_DATA[missionId];
    if (!misionData) {
        const message = `[DEV] Error: No se encontraron datos para la misión '${missionId}' en MISIONES_DATA.`;
        console.error(message);
        alert(message);
        return;
    }

    console.log(`[DEV] Forzando la finalización de: "${misionData.titulo}"`);

    // --- 1. OTORGAR RECOMPENSAS (Lógica copiada de completeMission) ---
    player.secta.puntosContribucion += misionData.recompensa.pcs || 0;
    gainExperience(misionData.recompensa.exp || 0);
    if (misionData.recompensa.items) {
        for (const itemName in misionData.recompensa.items) {
            gameState.inventory[itemName] = (gameState.inventory[itemName] || 0) + misionData.recompensa.items[itemName];
        }
    }
    console.log("[DEV] Recompensas otorgadas.");

    // --- 2. MOVER LA MISIÓN DE ACTIVA A COMPLETADA ---
    player.secta.misionesActivas = player.secta.misionesActivas.filter(m => m.id !== missionId);
    player.secta.misionesCompletadas[missionId] = true;
    console.log(`[DEV] Misión movida de 'activas' a 'completadas'.`);

    // --- 3. LIMPIAR EL JEFE DEL MAPA ---
    const objetivo = misionData.objetivo;
    if (objetivo.tipo === 'derrotar_npc_especifico' && objetivo.npcId) {
        const bossInstance = gameState.map.entities.find(e => e.npcId === objetivo.npcId);
        if (bossInstance) {
            removeEntity(bossInstance); // Llama a la función que ya tienes para borrar entidades
            player.worldState.defeatedBosses[objetivo.npcId] = true;
            console.log(`[DEV] Jefe asociado '${objetivo.npcId}' eliminado del mapa y marcado como derrotado.`);
        }
    }
    
    // --- 4. ACTUALIZAR TODA LA INTERFAZ ---
    updateUI();
    updateSectUI();
    renderMap(); // Para que el jefe desaparezca visualmente

    const message = `La misión '${misionData.titulo}' ha sido marcada como completada por la fuerza.`;
    showModal("Finalización Forzada", message);
    console.log(message);
}
      function completeMission(misionId, npcIdEntregaManual = null) {
        const player = gameState.player;
        const misionActiva = player.secta.misionesActivas.find(
          (m) => m.id === misionId
        );
        const misionDataOriginal = MISIONES_DATA[misionId];

        if (!misionActiva || !misionDataOriginal) {
          showModal("Error de Misión", "Datos de la misión no encontrados.");
          return false;
        }

        const objetivo = misionActiva.objetivoOriginal;
        let objetivosCumplidos = false;

        switch (objetivo.tipo) {
          case "entregar_item":
            if (
              (gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad
            ) {
              if (
                npcIdEntregaManual &&
                npcIdEntregaManual === objetivo.npcEntrega
              ) {
                gameState.inventory[objetivo.item] -= objetivo.cantidad;
                updateInventoryUI();
                objetivosCumplidos = true;
              }
            } else {
              showModal(
                "Objetivo Incompleto",
                `Aún necesitas ${
                  objetivo.cantidad - (gameState.inventory[objetivo.item] || 0)
                } ${objetivo.item}.`
              );
              return false;
            }
            break;
          case "eliminar_enemigo":
            if (misionActiva.progreso >= objetivo.cantidad) {
              objetivosCumplidos = true;
            }
            break;
          case "derrotar_npc_especifico":
            if (misionActiva.progreso === 1) {
              objetivosCumplidos = true;
            } else {
              showModal(
                "Objetivo Incompleto",
                "Aún no has derrotado al oponente del desafío."
              );
              return false;
            }
            break;
          case "recolectar_multiples_items":
            let todosItemsRecolectados = true;
            for (const itemReq of objetivo.items) {
              if (
                (gameState.inventory[itemReq.nombre] || 0) < itemReq.cantidad
              ) {
                todosItemsRecolectados = false;
                break;
              }
            }
            if (todosItemsRecolectados) {
              if (npcIdEntregaManual === objetivo.npcEntrega) {
                for (const itemReq of objetivo.items) {
                  gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                }
                updateInventoryUI();
                objetivosCumplidos = true;
              }
            }
            break;
          case "cazar_y_recuperar_item_de_loot":
            if (
              misionActiva.progreso === 1 &&
              (gameState.inventory[objetivo.itemPrueba] || 0) >=
                objetivo.cantidadItemPrueba
            ) {
              if (npcIdEntregaManual === objetivo.npcEntrega) {
                gameState.inventory[objetivo.itemPrueba] -=
                  objetivo.cantidadItemPrueba;
                updateInventoryUI();
                objetivosCumplidos = true;
              }
            }
            break;
          case "llegar_a_punto":
            // Si el progreso es 1, significa que el jugador ya visitó el lugar.
            if (misionActiva.progreso === 1) {
                objetivosCumplidos = true;
            }
            break;
          default:
            showModal("Error de Misión", "Tipo de objetivo no reconocido.");
            return false;
        }

        if (!objetivosCumplidos) {
          console.log(
            `Objetivos no cumplidos para ${misionDataOriginal.titulo} al intentar completar.`
          );
          return false;
        }

        // --- Dar Recompensas ---
        player.secta.puntosContribucion +=
          misionDataOriginal.recompensa.pcs || 0;
        gainExperience(misionDataOriginal.recompensa.exp || 0);
        let recompensaItemsTexto = "";
        if (misionDataOriginal.recompensa.items) {
          for (const itemName in misionDataOriginal.recompensa.items) {
            gameState.inventory[itemName] =
              (gameState.inventory[itemName] || 0) +
              misionDataOriginal.recompensa.items[itemName];
            recompensaItemsTexto += `${misionDataOriginal.recompensa.items[itemName]} ${itemName}, `;
          }
          updateInventoryUI();
          if (recompensaItemsTexto)
            recompensaItemsTexto = recompensaItemsTexto.slice(0, -2);
        }

        let recompensaTextoGlobal = `Recompensas: ${
          misionDataOriginal.recompensa.pcs || 0
        } PCS, ${misionDataOriginal.recompensa.exp || 0} EXP`;
        if (recompensaItemsTexto)
          recompensaTextoGlobal += `, ${recompensaItemsTexto}`;

        player.secta.misionesActivas = player.secta.misionesActivas.filter(
          (m) => m.id !== misionId
        );
        player.secta.misionesCompletadas[misionId] = true;

        showModal(
          "¡Misión Completada!",
          `Completaste: ${misionDataOriginal.titulo}.\n${recompensaTextoGlobal}`
        );

        if (misionDataOriginal.recompensa.nuevoRango) {
          const newRankName = misionDataOriginal.recompensa.nuevoRango;
          player.secta.rango = newRankName;
          let rankUpMessage = `¡Felicidades! Ascendiste a ${player.secta.rango}.`;
        let specialRewardText = "";

          // Recompensa específica para el rango de Anciano
          if (newRankName === "Anciano") {
              const scrollItem = "Rollo: Inscripción Rúnica";
              gameState.inventory[scrollItem] = (gameState.inventory[scrollItem] || 0) + 1;
              specialRewardText = `<br><br><strong>¡Has obtenido un manual antiguo!</strong><br>Revisa tu inventario para aprender el <em>"${scrollItem}"</em>.`;
          }

          setTimeout(() => {
                showModal("¡Ascenso en la Secta!", rankUpMessage + specialRewardText);
            }, 2500);

          applyRankBenefits(player.secta.rango);

          // === INICIO DE LA MODIFICACIÓN CLAVE ===
          // Comprobamos si el nuevo rango tiene una elección de técnica como recompensa.
          const rankData = SECTA_DATA.rangos.find(
            (r) => r.nombre === newRankName
          );
          if (rankData && rankData.techniqueChoice) {
            // Esperamos un poco más para que no se solape con el modal de ascenso.
            setTimeout(() => {
              openRankUpRewardModal(newRankName);
            }, 4500);
          }
          // === FIN DE LA MODIFICACIÓN CLAVE ===
        }

        updateSectUI();
        checkAndActivateRankChallengeMissions();
        // --- DISPARADORES DE HISTORIA POST-MISIÓN ---
        const flags = player.worldState.storyFlags;

        // Hito 1: La Anciana Su se fija en ti
        if (misionId === "mision_desafio_interno_1" && !flags.metAncianaSu) {
            flags.metAncianaSu = true;
            setTimeout(() => {
                showModal("Una Invitación Inesperada", 
                "Poco después de tu ascenso, recibes una nota de la Anciana Su, la archivista de la secta. Te pide que la visites.<br><br><em>'Tu control sobre el Qi... es especial. Visítame en los archivos cuando puedas. Hay cosas que deberías saber sobre el pasado de nuestra secta.'</em>");
            }, 2000);
        }

        // Hito 2: El Maestro Jian te revela el secreto
        if (misionId === "mision_desafio_diacono_1" && !flags.knowsAboutSoberano) {
            flags.knowsAboutSoberano = true;
            setTimeout(() => {
                showModal("La Convocatoria del Maestro", 
                "Tu ascenso a Diácono no ha pasado desapercibido. El Maestro de Secta Jian te convoca a sus aposentos privados.<br><br><em>'Joven Diácono, debo confiarte un terrible secreto. La Gran Calamidad que hirió a nuestra secta no fue un accidente. Fue obra de nuestro más grande patriarca, corrompido por un poder prohibido. Lo sellamos, pero ese sello... se está rompiendo.'</em><br><br><strong>Has aprendido sobre el Soberano Sellado.</strong>");
            }, 2000);
        }

        // Hito del Santuario (Acto III) - El jugador lo descubre por sí mismo, pero lo activamos aquí.
       // Hito 3: Se revela la ubicación del Santuario
        if (misionId === "mision_desafio_anciano_1") {
            const santuario = gameState.map.entities.find(e => e.type === 'story_shrine');
            if (santuario) {
                santuario.discovered = true;
                renderMap(); // Actualiza el mapa para mostrar el santuario
                setTimeout(() => {
                    showModal("Un Susurro en el Viento",
                    "Al derrotar al Anciano Guardián, sientes una extraña llamada desde el Valle del Dragón Caído. Un lugar de poder oculto te está esperando. El Maestro Jian asiente, como si supiera que este momento llegaría.");
                }, 2000);
            }
        }
        return true;
      }

      function openRankUpRewardModal(newRankName) {
        const modal = document.getElementById("rankUpRewardModal");
        const titleEl = document.getElementById("rankUpRewardTitle");
        const optionsContainer = document.getElementById(
          "rankUpRewardOptionsContainer"
        );

        if (!modal || !titleEl || !optionsContainer) {
          console.error(
            "Elementos del modal de recompensa de rango no encontrados."
          );
          return;
        }

        const rankData = SECTA_DATA.rangos.find(
          (r) => r.nombre === newRankName
        );
        if (
          !rankData ||
          !rankData.techniqueChoice ||
          rankData.techniqueChoice.length === 0
        ) {
          console.log(
            `No hay recompensas de técnica para el rango ${newRankName}.`
          );
          return;
        }

        titleEl.textContent = `Recompensa por ascender a ${newRankName}`;
        optionsContainer.innerHTML = ""; // Limpiar opciones anteriores

        rankData.techniqueChoice.forEach((techId) => {
          const techInfo = techniqueData[techId];
          if (techInfo) {
            const button = document.createElement("button");
            button.className = "cultivation-option-btn";
            button.innerHTML = `
                      <strong>${techInfo.icon || "📜"} ${techInfo.name}</strong>
                      <br>
                      <small style="opacity: 0.8;">${
                        techInfo.description
                      }</small>
                  `;
            button.onclick = () => claimRankUpReward(techId);
            optionsContainer.appendChild(button);
          }
        });

        modal.style.display = "flex";
        hideTouchControls();
      }

      function claimRankUpReward(techId) {
        // Buscamos el nombre del "Rollo" que enseña esta técnica
        let scrollItemName = null;
        const techDefinition = techniqueData[techId];

        // Este bucle asume que el nombre de la técnica en la definición y en el nombre del rollo coinciden.
        // Ej: techniqueData.sword_slash_1.name es "Corte de Espada Básico"
        // y el item se llama "Rollo: Corte de Espada Básico"
        if (techDefinition) {
          const expectedScrollName = `Rollo: ${techDefinition.name}`;
          if (itemData[expectedScrollName]) {
            scrollItemName = expectedScrollName;
          }
        }

        if (scrollItemName) {
          gameState.inventory[scrollItemName] =
            (gameState.inventory[scrollItemName] || 0) + 1;
          updateInventoryUI();
          closeRankUpRewardModal();
          showModal(
            "¡Recompensa Obtenida!",
            `Has recibido el "${scrollItemName}".\nRevisa tu inventario para aprender la técnica.`
          );
        } else {
          console.error(
            `No se pudo encontrar el objeto 'Rollo' para la técnica con ID: ${techId}`
          );
          showModal(
            "Error de Recompensa",
            "No se pudo otorgar la recompensa. Contacta a un Anciano de la Secta (o al desarrollador)."
          );
        }
      }

      function closeRankUpRewardModal() {
        const modal = document.getElementById("rankUpRewardModal");
        if (modal) modal.style.display = "none";
        showTouchControls();
      }

      function updateSectUI() {
        const player = gameState.player;
        document.getElementById("sectaNombreDisplay").textContent = player.secta.nombre;
        document.getElementById("playerSectRank").textContent = player.secta.rango;
        document.getElementById("playerPCS").textContent = player.secta.puntosContribucion;

        const missionsListDiv = document.getElementById("activeMissionsList");
        missionsListDiv.innerHTML = "";

        if (player.secta.misionesActivas.length === 0) {
            missionsListDiv.innerHTML = "<p>Ninguna misión activa.</p>";
        } else {
            player.secta.misionesActivas.forEach((misionActiva) => {
                const misionDataOriginal = MISIONES_DATA[misionActiva.id];
                if (misionDataOriginal) {
                    // ¡Llamamos a nuestra nueva función centralizada también aquí!
                    const progresoTexto = getMissionProgressText(misionActiva);

                    const p = document.createElement("p");
                    p.innerHTML = `<strong>${misionDataOriginal.titulo}</strong><br><small style="font-style: italic;">${progresoTexto}</small>`;
                    missionsListDiv.appendChild(p);
                }
            });
        }
        updateStatsPanelVisibility();
    }

      function checkAndActivateRankChallengeMissions() {
        const player = gameState.player;
        const currentRankIndex = SECTA_DATA.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );

        if (currentRankIndex === -1) {
          console.error(
            "Error: Rango actual del jugador no encontrado en SECTA_DATA.rangos"
          );
          return;
        }

        if (currentRankIndex + 1 >= SECTA_DATA.rangos.length) {
          return;
        }

        const nextRankData = SECTA_DATA.rangos[currentRankIndex + 1];

        if (player.secta.puntosContribucion >= nextRankData.pcsRequeridos) {
          if (nextRankData.desafioRivalId) {
            // --- LÓGICA MEJORADA PARA ENCONTRAR LA MISIÓN ---
            const desafioMisionId = Object.keys(MISIONES_DATA).find((mId) => {
              const mision = MISIONES_DATA[mId];
              return (
                mision.autoActivarAlCumplirRequisitos === true &&
                mision.recompensa?.nuevoRango === nextRankData.nombre &&
                mision.objetivo?.npcId === nextRankData.desafioRivalId
              );
            });
            // --- FIN DE LA LÓGICA MEJORADA ---

            if (desafioMisionId) {
              const isMissionActive = player.secta.misionesActivas.some(
                (m) => m.id === desafioMisionId
              );
              const isMissionCompleted =
                player.secta.misionesCompletadas[desafioMisionId];

              if (!isMissionActive && !isMissionCompleted) {
                acceptMission(desafioMisionId);
                const misionData = MISIONES_DATA[desafioMisionId];
                showModal(
                  "¡Nuevo Desafío de Rango!",
                  `Has alcanzado los requisitos de PCS para el rango de ${nextRankData.nombre}.\n` +
                    `Se ha activado la misión de desafío: "${misionData.titulo}".\n` +
                    `¡Prepárate y busca a tu oponente en la arena de la secta!`
                );

                // La función ensureFixedEntities se encargará de hacer aparecer al guardián
                // porque la misión está ahora activa.
                ensureFixedEntities();
                renderMap();
              }
            } else {
              console.warn(
                `No se encontró una misión de desafío auto-activable para el rival ${nextRankData.desafioRivalId} del rango ${nextRankData.nombre}.`
              );
            }
          }
        }
        updateSectUI();
      }

      function applyRankBenefits(newRankName) {
        const rankData = SECTA_DATA.rangos.find(
          (r) => r.nombre === newRankName
        );
        if (rankData) {
          showModal(
            "Beneficios de Rango",
            `Has obtenido beneficios de ${newRankName}: ${rankData.beneficios}`
          );
        }
        updateUI();
      }

      function enemyTurn() {
        if (!gameState.battle.active || gameState.battle.playerTurn) return;

        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const playerSprite = document.querySelector('.character-sprite');
        const enemySprite = document.getElementById('enemySprite');

        // --- PROCESAR EFECTOS DE ESTADO EN EL ENEMIGO AL INICIO DE SU TURNO ---
        let canEnemyAct = true;
        let reasonForInaction = "";
        let chosenAbility = null;
        const enemyBaseDamage = enemy.attack;

        // --- PROCESAMIENTO DE EFECTOS DE ESTADO (DoTs, Stuns, etc.) ---

        // 1. DAÑO POR TURNO de efectos como Grilletes, Veneno, Quemadura
        if (enemy.rootedTurns > 0) {
            enemy.hp -= enemy.rootDamage;
            logBattle(`${enemy.name} sufre ${enemy.rootDamage} de daño por los grilletes. HP: ${Math.floor(enemy.hp)}`);
            showFloatingText(enemySprite, `-${enemy.rootDamage}`, 'damage');
            if (enemy.hp <= 0) { handleEnemyDefeat(); return; }
        }
        if (enemy.burningTurns > 0) {
            enemy.hp -= enemy.burnDamage;
            logBattle(`${enemy.name} sufre ${enemy.burnDamage} por quemadura. HP: ${Math.floor(enemy.hp)}`);
            showFloatingText(enemySprite, `-${enemy.burnDamage}`, 'damage');
            if (enemy.hp <= 0) { handleEnemyDefeat(); return; }
        }
        if (enemy.poisonedTurns > 0) {
            enemy.hp -= enemy.poisonDamage;
            logBattle(`${enemy.name} sufre ${enemy.poisonDamage} por veneno. HP: ${Math.floor(enemy.hp)}`);
            showFloatingText(enemySprite, `-${enemy.poisonDamage}`, 'damage');
            if (enemy.hp <= 0) { handleEnemyDefeat(); return; }
        }

        // 2. LÓGICA DE CONTROL (Stun, Seal, Freeze) - Impiden la acción completamente
        if (enemy.sealedTurns > 0) {
            canEnemyAct = false;
            reasonForInaction = "¡Sellado!";
            enemy.sealedTurns--;
        } else if (enemy.frozenTurns > 0) {
            canEnemyAct = false;
            reasonForInaction = "¡Congelado!";
            enemy.frozenTurns--;
        } else if (enemy.stunnedTurns > 0) {
            canEnemyAct = false;
            reasonForInaction = "¡Aturdido!";
            enemy.stunnedTurns--;
        }

        if (!canEnemyAct) {
            logBattle(`¡${enemy.name} está ${reasonForInaction.toLowerCase().replace('!','')} y no puede actuar!`);
            showFloatingText(enemySprite, reasonForInaction, 'debuff');
            endEnemyTurn();
            return;
        }

        // 3. LÓGICA DE GRILLETES (ROOTED) - Impide la acción si resisten
        if (enemy.rootedTurns > 0) {
            logBattle(`${enemy.name} intenta liberarse de los grilletes...`);
            player.activeChanneledAbility.hp -= enemyBaseDamage;

            if (player.activeChanneledAbility.hp <= 0) {
                logBattle(`¡Con un golpe poderoso, ${enemy.name} rompe los grilletes!`);
                showFloatingText(enemySprite, '¡Liberado!', 'ability');
                enemy.rootedTurns = 0;
                enemy.rootDamage = 0;
                player.activeChanneledAbility.id = null;
                player.activeChanneledAbility.hp = 0;
                canEnemyAct = false;
            } else {
                logBattle(`Los grilletes resisten el ataque. (Resistencia: ${Math.floor(player.activeChanneledAbility.hp)})`);
                showFloatingText(enemySprite, '¡Atrapado!', 'debuff');
                canEnemyAct = false;
            }

            enemy.rootedTurns--;
            if (enemy.rootedTurns === 0 && player.activeChanneledAbility.id === 'formation_t2') {
                logBattle("Los grilletes de Qi se disipan por el paso del tiempo.");
                player.activeChanneledAbility.id = null;
                player.activeChanneledAbility.hp = 0;
            }
        }
        
        // 2. Reducir duración de debuffs
        if(enemy.defenseReductionTurns > 0) {
            enemy.defenseReductionTurns--;
            if (enemy.defenseReductionTurns === 0) {
                logBattle(`La defensa de ${enemy.name} vuelve a la normalidad.`);
                // La restauración de la estadística se maneja mejor en el momento de la aplicación para evitar errores.
            }
        }
        if(enemy.attackReductionTurns > 0) {
            enemy.attackReductionTurns--;
            if (enemy.attackReductionTurns === 0) {
                logBattle(`El ataque de ${enemy.name} vuelve a la normalidad.`);
            }
        }
        // 4. EJECUCIÓN DE LA ACCIÓN DEL ENEMIGO
        if (canEnemyAct) {
            if (enemy.abilities && enemy.silencedTurns <= 0) {
                for (const abilityInfo of enemy.abilities) {
                    if (Math.random() < abilityInfo.chance) {
                        chosenAbility = enemyAbilityData[abilityInfo.abilityId];
                        if (chosenAbility) break;
                    }
                }
            }

            if (chosenAbility) {
             
                showFloatingText(enemySprite, chosenAbility.name, 'ability');
                const effect = chosenAbility.effect;
                let damage = 0;
                let finalDamage = 0;
                let heal = 0;

                // --- SWITCH COMPLETO PARA HABILIDADES DE ENEMIGO ---
                switch (chosenAbility.type) {
                    case 'buff_stat':
                        if (enemy.defenseBoostTurns === 0) {
                            enemy.defenseBoostAmount = effect.amount;
                            enemy.defense += effect.amount;
                            enemy.defenseBoostTurns = effect.duration;
                            logBattle(chosenAbility.logMessage(enemy.name, effect.amount, effect.duration));
                        } else {
                            logBattle(`${enemy.name} intenta fortalecerse, ¡pero ya lo está!`);
                        }
                        break;

                    case 'debuff_stat':
                    case 'dot_damage':
                    case 'heal_damage':
                        damage = Math.floor(enemy.attack * (effect.baseDamageMultiplier || 1.0));
                        finalDamage = applyDamageToPlayer(damage, chosenAbility.name); // Usamos el daño real aplicado

                        if (effect.debuff && player.defenseReductionTurns === 0) {
                            player.defenseReductionAmount = effect.debuff.amount;
                            player.defense -= effect.debuff.amount;
                            player.defenseReductionTurns = effect.debuff.duration;
                            showFloatingText(playerSprite, 'Defensa ↓', 'debuff');
                        }
                        if (effect.dot) {
                            if (effect.dot.type === 'burn') {
                                player.burningTurns = Math.max(player.burningTurns, effect.dot.duration);
                                player.burnDamage = Math.max(player.burnDamage, effect.dot.damagePerTurn);
                                showFloatingText(playerSprite, 'Quemadura', 'debuff');
                            } else if (effect.dot.type === 'poison') {
                                player.poisonedTurns = Math.max(player.poisonedTurns, effect.dot.duration);
                                player.poisonDamage = Math.max(player.poisonDamage, effect.dot.damagePerTurn);
                                showFloatingText(playerSprite, 'Envenenado', 'debuff');
                            }
                        }
                        if (effect.lifesteal) {
                            heal = Math.floor(finalDamage * effect.lifesteal);
                            enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                            showFloatingText(enemySprite, `+${heal}`, 'heal');
                        }
                        logBattle(chosenAbility.logMessage(enemy.name, finalDamage, heal || effect.debuff?.amount || effect.dot?.damagePerTurn, effect.debuff?.duration || effect.dot?.duration));
                        break;

                    case 'piercing_damage':
                        const defenseToIgnore = player.defense * (effect.armorPenetration || 0);
                        damage = Math.max(0, Math.floor(enemy.attack * (effect.baseDamageMultiplier || 1.0)) - (player.defense - defenseToIgnore));
                        applyDamageToPlayer(damage, chosenAbility.name);
                        logBattle(chosenAbility.logMessage(enemy.name, damage));
                        break;

                    case 'stun_chance':
                        damage = Math.floor(enemy.attack * (effect.baseDamageMultiplier || 1.0));
                        finalDamage = applyDamageToPlayer(damage, chosenAbility.name);

                        
                        const didStun = Math.random() < (effect.stunChance || 0);
                        let stunSuccessful = false; // Bandera para el log

                        // Comprobamos si el aturdimiento tiene éxito Y el jugador no es inmune
                        if (didStun) {
                            if (player.statusResistChance > 0 && Math.random() < player.statusResistChance) {
                                logBattle(`¡${enemy.name} intenta aturdirte, pero tu Constitución de Dragón te protege!`);
                                showFloatingText(playerSprite, '¡Resistido!', 'ability');
                            } else if (player.stunnedTurns === 0) {
                                player.stunnedTurns = 1;
                                showFloatingText(playerSprite, '¡Aturdido!', 'debuff');
                                stunSuccessful = true;
                            }
                        }
                        
                        // --- CORRECCIÓN: Llamamos al log DESPUÉS de saber el resultado ---
                        logBattle(chosenAbility.logMessage(enemy.name, finalDamage, stunSuccessful));
                        break;

                    case 'dot_resource':
                      // === INICIO DE LA LÓGICA DE RESISTENCIA ===
                        if (player.statusResistChance > 0 && Math.random() < player.statusResistChance) {
                            logBattle(`¡Tu Constitución de Dragón te permite resistir el efecto de ${chosenAbility.name}!`);
                            showFloatingText(playerSprite, '¡Resistido!', 'ability');
                            
                            if (effect.baseDamageMultiplier) {
                                const damage = Math.floor(enemy.attack * effect.baseDamageMultiplier);
                                applyDamageToPlayer(damage, chosenAbility.name);
                            }
                            break; // El efecto se resiste, pero el daño (si lo hay) se aplica.
                        }
                        // === FIN DE LA LÓGICA DE RESISTENCIA ===
                        if (effect.dot.resource === 'mana' && player.manaDrainTurns === 0) {
                            player.manaDrainTurns = effect.dot.duration;
                            player.manaDrainAmount = effect.dot.drainPerTurn;
                            showFloatingText(playerSprite, 'Maldición de Maná', 'debuff');
                            logBattle(chosenAbility.logMessage(enemy.name, player.manaDrainAmount, player.manaDrainTurns));
                        } else {
                            logBattle(`${enemy.name} intenta maldecirte, ¡pero ya estás bajo un efecto similar!`);
                        }
                        break;

                    case 'heal':
                        heal = effect.healAmount;
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                        showFloatingText(enemySprite, `+${heal}`, 'heal');
                        logBattle(chosenAbility.logMessage(enemy.name, heal));
                        break;
                    
                    // Añade aquí más 'case' si defines nuevas habilidades de enemigo
                    
                    default:
                        logBattle(`(${chosenAbility.name}) ¡La habilidad del enemigo no tuvo efecto!`);
                        break;
                }
            } else {
               
                // Ataque básico si no se usa habilidad
                const damage = Math.max(0, enemy.attack - player.defense);
                applyDamageToPlayer(damage, `${enemy.name}`);
            }
        }

        endEnemyTurn();
    }

  
      function endEnemyTurn() {
          const player = gameState.player;
          
          // --- LÓGICA DE MANTENIMIENTO (UPKEEP) ---
          // Se ejecuta al final del turno del enemigo, antes de devolver el control al jugador.
          if (player.activeChanneledAbility.id === 'formation_t2') {
              const upkeepCost = techniqueData['formation_t2'].effect.manaUpkeep;
              if (player.mana >= upkeepCost) {
                  player.mana -= upkeepCost;
                  logBattle(`Mantener los Grilletes de Qi consume ${upkeepCost} maná.`);
              } else {
                  logBattle(`¡Maná insuficiente para mantener los grilletes! Se disipan.`);
                  gameState.battle.enemy.rootedTurns = 0;
                  gameState.battle.enemy.rootDamage = 0;
                  player.activeChanneledAbility.id = null;
                  player.activeChanneledAbility.hp = 0;
              }
          }
          
          // --- LÓGICA DE DERROTA ---
          // Comprobamos si el jugador fue derrotado por el ataque del enemigo.
          if (player.hp <= 0) {
            player.hp = 0;
            updateBattleUI(); // Actualiza la UI para mostrar HP 0

            // Lógica de derrota centralizada
            setTimeout(() => {
              const expLoss = Math.floor(gameState.player.exp * 0.1);
              gameState.player.hp = Math.floor(gameState.player.maxHp * 0.1);
              gameState.player.mana = Math.floor(gameState.player.maxMana * 0.1);
              gameState.player.exp = Math.max(0, gameState.player.exp - expLoss);

              const safeCoords = findSafeRespawnLocation(G_SAFE_RESPAWN_X, G_SAFE_RESPAWN_Y);
              gameState.player.x = safeCoords.x;
              gameState.player.y = safeCoords.y;

              updatePlayerPosition("player_defeat_respawn");
              endBattle(false);
              showModal("Derrota", `Caíste en combate. Pierdes ${expLoss} EXP.`);
            }, 2000);
            return; // Detener la función aquí.
          }
          
          // Devolvemos el control al jugador
          gameState.battle.playerTurn = true;
          
          updateBattleUI();
          populateBattleActionButtons();
      }

    function applyDamageToPlayer(damageAmount, sourceName = "Ataque") {
      const player = gameState.player;
      const playerSprite = document.querySelector('.character-sprite');
      let incomingDamage = damageAmount; 
      
    // 1. INMUNIDAD TOTAL (por Santuario Dorado, etc.)
    if (player.intangibleTurns > 0) {
        
        logBattle(`¡Tu Santuario Dorado anula completamente el ataque de ${sourceName}!`);
        showFloatingText(playerSprite, '¡Inmune!', 'ability');
        return 0; // No se recibe daño
    }
      // 2. CONVERSIÓN DE DAÑO A CURACIÓN (por Matriz de Reversión)
      if (player.damageToHealingTurns > 0) {
            const healingAmount = Math.floor(incomingDamage * 1.2); // Convierte a 120% de curación
            player.hp = Math.min(player.maxHp, player.hp + healingAmount);
            logBattle(`¡La Matriz de Reversión convierte ${Math.floor(incomingDamage)} de daño en ${healingAmount} de curación!`);
            showFloatingText(playerSprite, `+${healingAmount}`, 'heal');
            return 0; // No se recibe daño, al contrario
        }
      // 3. LÓGICA DE ESQUIVAR ---
      // Ahora 'incomingDamage' ya está definido y se puede usar en la condición.
      if (player.dodgeNextAttack && incomingDamage > 0) {
          
          const etereoDetails = techniqueData["movement_t2"];
          const etereoLevel = player.learnedTechniques["movement_t2"]?.level || 1;
          // La mejora de "no consumir" (Opción 2) la implementaremos aquí
          const noConsumeChance = (etereoDetails.effect.noConsumeChancePerLevel || 0) * (etereoLevel - 1);

          logBattle(`¡Esquivas por completo el ataque de ${sourceName}!`);
          showFloatingText(playerSprite, '¡Esquivado!', 'ability');

          // Comprobamos si el efecto se mantiene
          if (Math.random() > noConsumeChance) {
              player.dodgeNextAttack = false; // Se consume normalmente
          } else {
              logBattle("¡Tu movimiento fue tan fluido que sigues listo para esquivar!");
              showFloatingText(playerSprite, '¡Aún Etéreo!', 'ability');
          }

          return 0; // Anulamos todo el daño y terminamos la función.
      }
      
      // --- LÓGICA DE ABSORCIÓN DE DAÑO POR ESCUDO ---
      if (incomingDamage > 0 && player.magicShieldValue > 0 && player.magicShieldTurns > 0) {
          
          const absorbedByShield = Math.min(incomingDamage, player.magicShieldValue);
          player.magicShieldValue -= absorbedByShield;
          incomingDamage -= absorbedByShield;

          logBattle(`¡Tu escudo absorbe ${absorbedByShield} de daño! (Restante: ${Math.floor(player.magicShieldValue)})`);
          showFloatingText(playerSprite, `Absorbe ${absorbedByShield}`, 'ability');

          if (player.magicShieldValue <= 0) {
              logBattle("¡Tu barrera mágica se ha roto!");
              player.magicShieldTurns = 0;
          }
      }

      // --- APLICAR DAÑO RESTANTE ---
      if (incomingDamage > 0) {
          const reductionMultiplier = 1 - (player.damageReduction || 0);
          incomingDamage *= reductionMultiplier;
          player.hp -= incomingDamage;
          logBattle(`Recibes ${Math.floor(incomingDamage)} de daño de ${sourceName}.`);
          showFloatingText(playerSprite, `-${Math.floor(incomingDamage)}`, 'damage');
      } else if (damageAmount > 0) {
          logBattle(`¡Tu defensa absorbió completamente el ataque de ${sourceName}!`);
          showFloatingText(playerSprite, '¡Bloqueado!', 'ability');
      }

      return incomingDamage;
  }
      function showBattleReview() {
        const reviewLog = document.getElementById("battleReviewLog");
        reviewLog.innerHTML = ""; // Limpiar contenido anterior

        // Unimos todos los mensajes del historial con un salto de línea
        const formattedLog = battleLogHistory.join("<br>");
        reviewLog.innerHTML = formattedLog;

        document.getElementById("battleReviewModal").style.display = "flex";
      }

      function closeBattleReviewModal() {
        document.getElementById("battleReviewModal").style.display = "none";
      }

      function endBattle(victory) {
       // --- MODIFICACIÓN PARA RESETEAR ESTADOS DE COMBATE ---
       const player = gameState.player;
        
        // Resetea todos los buffs/debuffs temporales del jugador al final del combate
        player.abilityCooldowns = {};
        player.defenseBoostTurns = 0;
        player.defenseBoostAmount = 0;
        player.dodgeNextAttack = false;
        player.healingRainTurns = 0;
        player.magicShieldValue = 0;
        player.magicShieldTurns = 0;
        player.canRevive = false; // El poder del Fénix se desvanece fuera del combate
        player.intangibleTurns = 0;
        player.damageToHealingTurns = 0;
        player.hpRegenPerTurn = 0;
        player.manaRegenPerTurn = 0;
        

        gameState.battle.active = false;
        document.getElementById("battleScreen").style.display = "none";
        document.getElementById("battleLog").innerHTML = "";
        document.getElementById('quickSlotBar').classList.remove('hidden');
        // Ocultar las barras sobre el sprite en batalla explícitamente al finalizar
        const barsInBattleContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        if (barsInBattleContainer) {
          barsInBattleContainer.style.display = "none";
        }
        if (victory && gameState.battle.enemy?.entityRef) {
          removeEntity(gameState.battle.enemy.entityRef);
        }
        gameState.battle.enemy = null;

        // Restaurar sprite a idle después de la batalla
        player.currentDirection = "down"; // O la última dirección antes de la batalla
        player.currentFrame = 0;
        player.isMoving = false; // Asegurarse de que no esté en estado de movimiento
        updatePlayerSpriteVisual();

        recalculatePlayerStats();
        updateUI();
        updateTopNavVisibility();
        showTouchControls();
        updatePlayerBarsOnMap();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function findEscapeTile(player, enemy) {
        const playerX = player.x;
        const playerY = player.y;

        // Calcular la dirección opuesta al enemigo
        const dx = playerX - enemy.x;
        const dy = playerY - enemy.y;

        // Normalizar la dirección para obtener un vector unitario (aproximado)
        let escapeX = playerX + Math.sign(dx);
        let escapeY = playerY + Math.sign(dy);

        const checkTile = (x, y) => {
          if (
            x < 0 ||
            x >= gameState.map.width ||
            y < 0 ||
            y >= gameState.map.height
          )
            return false;
          const terrain = G_TERRAIN_TYPES[getTerrainTypeAt(x, y)];
          if (terrain && terrain.walkable === false) return false;
          const isOccupied = gameState.map.entities.some(
            (e) => e.x === x && e.y === y
          );
          return !isOccupied;
        };

        // 1. Intentar moverse a la casilla directamente opuesta
        if (checkTile(escapeX, escapeY)) {
          return { x: escapeX, y: escapeY };
        }

        // 2. Si no es posible, buscar en las 8 casillas adyacentes una que esté vacía
        const possibleMoves = [
          { x: playerX, y: playerY - 1 },
          { x: playerX, y: playerY + 1 }, // Arriba, Abajo
          { x: playerX - 1, y: playerY },
          { x: playerX + 1, y: playerY }, // Izquierda, Derecha
          { x: playerX - 1, y: playerY - 1 },
          { x: playerX + 1, y: playerY - 1 }, // Diagonales
          { x: playerX - 1, y: playerY + 1 },
          { x: playerX + 1, y: playerY + 1 },
        ];

        for (const move of possibleMoves) {
          if (checkTile(move.x, move.y)) {
            return move;
          }
        }

        return null; // No se encontró ninguna casilla segura para huir
      }

      function findSafeRespawnLocation(preferredX, preferredY) {
        const isHostile = (entity) =>
          G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss;
        let preferredSpotOccupiedByHostile = gameState.map.entities.some(
          (e) => e.x === preferredX && e.y === preferredY && isHostile(e)
        );
        if (!preferredSpotOccupiedByHostile)
          return { x: preferredX, y: preferredY };
        for (let r = 1; r <= G_SAFE_RESPAWN_SEARCH_RADIUS; r++) {
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
              const cx = preferredX + dx;
              const cy = preferredY + dy;
              if (
                cx < 0 ||
                cx >= gameState.map.width ||
                cy < 0 ||
                cy >= gameState.map.height
              )
                continue;
              const isCompletelyEmpty = !gameState.map.entities.some(
                (e) => e.x === cx && e.y === cy
              );
              if (isCompletelyEmpty) return { x: cx, y: cy };
            }
          }
        }
        return { x: preferredX, y: preferredY };
      }

      function logBattle(message) {
        battleLogHistory.push(message);
      }

      function showTechniquePanel() {
        const container = document.getElementById("learnedTechniquesContainer");
        container.innerHTML = ""; // Limpiar contenido anterior
        
        const player = gameState.player;
        if (Object.keys(player.learnedTechniques).length === 0) {
            container.innerHTML = "<p style='text-align: center; opacity: 0.7;'>Aún no has aprendido ninguna técnica.</p>";
        } else {
            // Ordenamos las técnicas para una mejor visualización (opcional)
            const sortedTechIds = Object.keys(player.learnedTechniques).sort();

            sortedTechIds.forEach(techId => {
                const techInfo = techniqueData[techId];
                const playerTech = player.learnedTechniques[techId];
                if (!techInfo) return; // Salto de seguridad

                const div = document.createElement("div");
                // Usamos la misma clase que los ítems del inventario para un estilo consistente
                div.className = "inventory-modal-item"; 
                
                let levelText = playerTech.level >= techInfo.maxLevel 
                    ? `<span style="color: #f4d03f;">(MAX)</span>`
                    : `(Nv. ${playerTech.level} / ${techInfo.maxLevel})`;
                
                // --- LLAMADA A LA NUEVA FUNCIÓN DE DETALLES ---
                const detailsText = getTechniqueDetailsAsText(techInfo, playerTech.level);
                
                let cultivationProgressText = '';
                if (techInfo.cultivationSettings && playerTech.level < techInfo.maxLevel) {
                    const progress = playerTech.currentCultivationProgress || 0;
                    const timeToNext = playerTech.cultivationTimeToNextLevel || (techInfo.cultivationSettings.baseTimeToLevelUp || Infinity);
                    cultivationProgressText = `<div style="font-size: 0.8em; opacity: 0.7; margin-top: 5px;">Progreso de Cultivo: ${Math.floor(progress)}s / ${timeToNext}s</div>`;
                }

                div.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${techInfo.icon || "📜"} ${techInfo.name} ${levelText}</div>
                        <div class="item-description">${techInfo.description}</div>
                        ${detailsText}
                        ${cultivationProgressText}
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        document.getElementById("techniqueModal").style.display = "flex";
        hideTouchControls();
    }

    function getTechniqueDetailsAsText(techInfo, currentLevel) {
      if (!techInfo) return "";

      const effect = techInfo.effect || {};
      let details = [];
      const isMaxLevel = currentLevel >= techInfo.maxLevel;
      const nextLevel = currentLevel + 1;

      // Función de ayuda interna para calcular valores y generar texto
      const createDetailLine = (label, baseValue, increasePerLevel, unit = '', decimals = 2, isPercentage = false) => {
          if (baseValue === undefined) return null;

          const scaleFactor = isPercentage ? 100 : 1;
          const currentVal = baseValue + ((currentLevel - 1) * (increasePerLevel || 0));
          const nextVal = baseValue + ((nextLevel - 1) * (increasePerLevel || 0));
          
          let text = `${label}: ${(currentVal * scaleFactor).toFixed(decimals)}${unit}`;
          
          if (!isMaxLevel && nextVal.toFixed(decimals + 2) !== currentVal.toFixed(decimals + 2)) {
              text += ` <span style="color:#66ff66;">(Próx: ${(nextVal * scaleFactor).toFixed(decimals)}${unit})</span>`;
          }
          return text;
      };
      
      // --- LÓGICA DE DETALLES REFACTORIZADA ---

      // 1. Daño
      let damageLine = createDetailLine("Daño", effect.baseDamageMultiplier, effect.multiplierIncreasePerLevel, 'x Ataque', 2);
      if (damageLine) details.push(damageLine);
      
      // 2. Daño por Turno (DoT)
      let dotLine = createDetailLine("Daño/Turno", effect.damagePerTurn || effect.burnDamagePerTurn || effect.bleedDamagePerTurn, 2, '', 0); // Asumiendo un escalado fijo de +2 por nivel
      if (dotLine) details.push(dotLine);

      // 3. Probabilidad de Efecto
      let chanceLine = createDetailLine("Prob. Efecto", effect.baseStunChance || effect.bleedChance || effect.stunChance, effect.stunChanceIncreasePerLevel || 0.03, '%', 0, true);
      if (chanceLine) details.push(chanceLine);

      // 4. Reducción de Stats
      let reductionLine = createDetailLine("Reducción Stats", effect.baseReduction, effect.reductionIncreasePerLevel, '', 0);
      if (reductionLine) details.push(reductionLine);

      // 5. Duración
      if (effect.duration || effect.baseDuration) {
          const currentDuration = effect.duration || effect.baseDuration;
          let text = `Duración: ${currentDuration} turnos`;
          if (!isMaxLevel && effect.levelForExtraTurn && nextLevel >= effect.levelForExtraTurn && currentLevel < effect.levelForExtraTurn) {
              text += ` <span style="color:#66ff66;">(Próx: ${currentDuration + 1} turnos)</span>`;
          }
          details.push(text);
      }

      // 6. Golpes Múltiples
      if (effect.baseHits) {
          const currentHits = Math.round(effect.baseHits + (currentLevel - 1) * (effect.hitsIncreasePerLevel || 0));
          const nextHits = Math.round(effect.baseHits + (nextLevel - 1) * (effect.hitsIncreasePerLevel || 0));
          let text = `Golpes: ${currentHits}`;
          if (!isMaxLevel && nextHits > currentHits) text += ` <span style="color:#66ff66;">(Próx: ${nextHits})</span>`;
          details.push(text);
      }
      
      // 7. Habilidades Pasivas que mejoran STATS BASE (ej. Piel de Acero)
      if (techInfo.type === 'passive_stat' && effect.statToBoost) {
          // Las pasivas se aplican una vez por cada nivel que se sube, no tienen un "próximo nivel" visible.
          // Mostramos el beneficio total que se obtiene por cada nivel de la técnica.
          details.push(`Efecto Pasivo: +${effect.value} a ${effect.statToBoost.replace('base','').replace('Max',' Máximo ')} por nivel.`);
      }

      // 8. Habilidades Pasivas de CULTIVO (ej. Absorción de Qi)
      if (techInfo.type === 'passive_cultivation' && effect.statToBoost) {
          details.push(`Efecto de Cultivo: +${effect.value} a ${effect.statToBoost.replace('Base','/s')} por nivel.`);
      }

      // 9. Efectos Únicos y Fijos
      if (effect.isCritical) details.push("Especial: Siempre es un Golpe Crítico.");
      if (effect.ignoreDefense) details.push("Especial: Ignora la defensa del enemigo.");
      if (effect.dodgeNextAttack) details.push("Especial: Esquiva el próximo ataque.");
      
      // Construir el string final
      if (details.length > 0) {
          return `<div style="margin-top: 8px; padding-left: 10px; border-left: 2px solid #555; font-size: 0.85em; line-height: 1.6;">
                      ${details.join('<br>')}
                  </div>`;
      }

      return "";
  }

      function startTechniqueRefinement(techId) {}

      function stopTechniqueRefinement() {}

      function applyTechniqueEffect(techId, newLevel) {
        // La lógica de aplicar efectos específicos se ha movido a `recalculatePlayerStats`.
        // Esta función ahora solo necesita asegurarse de que, después de que una técnica
        // suba de nivel, todas las estadísticas del jugador se actualicen correctamente
        // para reflejar el cambio.
        
        recalculatePlayerStats(); // Esto recalculará todo basado en los niveles actuales.
        updateUI(); // Actualiza la interfaz para mostrar los cambios.
      }

      function closeTechniqueModal() {
        document.getElementById("techniqueModal").style.display = "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
      }

      let currentShopPage = 1;
      const shopItemsPerPage = 6;

      function openShop() {
        document.getElementById(
          "playerSpiritualStones"
        ).textContent = `Piedras Espirituales: ${
          gameState.inventory["Piedras Espirituales"] || 0
        }`;
        document.getElementById("shopModal").style.display = "flex";
        renderShopProducts();
        hideTouchControls();
      }

      function renderShopProducts() {
        const shopProductsEl = document.getElementById("shopProducts");
        shopProductsEl.innerHTML = "";
        const activeCategory =
          document.querySelector("#shopCategories .active")?.dataset.category ||
          "all";
        const searchTerm = document
          .getElementById("shopSearch")
          .value.toLowerCase();
        const priceVal = parseInt(document.getElementById("priceRange").value);
        document.getElementById(
          "priceRangeValue"
        ).textContent = `${priceVal} PS`;
        const playerRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === gameState.player.secta.rango);

        let filteredItems = shopData.inventory.filter((item) => {
          const itemNameLower = item.itemName.toLowerCase();
          const itemCategory = item.category || "other";
          const itemTypeForFilter =
            item.type ||
            (itemNameLower.includes("rollo:") ? "scroll" : "other");

          if (
            searchTerm &&
            !itemNameLower.includes(searchTerm) &&
            !(
              item.description &&
              item.description.toLowerCase().includes(searchTerm)
            )
          )
            return false;
          if (item.price > priceVal) return false;
          if (itemNameLower.startsWith("rollo: ")) {
              const techName = item.itemName.substring(7);
              const techId = Object.keys(techniqueData).find(id => techniqueData[id].name === techName);
              
              if (techId && techniqueData[techId].requiredRank) {
                  const requiredRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === techniqueData[techId].requiredRank);
                  
                  // El jugador debe tener un rango igual o superior al requerido.
                  if (playerRankIndex < requiredRankIndex) {
                      return false; // No mostrar si el rango es insuficiente.
                  }
              }
          }

          if (activeCategory !== "all") {
            if (activeCategory === "combat" && !techIsCombat(item.itemName))
              return false;
            if (
              activeCategory === "cultivation" &&
              !techIsCultivation(item.itemName)
            )
              return false;
            if (
              activeCategory === "scroll" &&
              !itemNameLower.startsWith("rollo: ")
            )
              return false;
            if (
              activeCategory === "consumable" &&
              itemTypeForFilter !== "consumable" &&
              ![
                "Hierbas Medicinales",
                "Cristales de Qi",
                "Píldora de Recuperación Menor",
              ].includes(item.itemName)
            )
              return false;
            if (activeCategory === "weapon" && itemCategory !== "weapon")
              return false;
            if (activeCategory === "armor" && itemCategory !== "armor")
              return false;
            if (activeCategory === "material" && !isMaterial(item.itemName))
              return false;
          }
          return true;
        });

        const totalPages = Math.ceil(filteredItems.length / shopItemsPerPage);
        const startIndex = (currentShopPage - 1) * shopItemsPerPage;
        const pageItems = filteredItems.slice(
          startIndex,
          startIndex + shopItemsPerPage
        );

        pageItems.forEach((item) => {
          const itemInfo = itemData[item.itemName] || {};
          const productCard = document.createElement("div");
          productCard.className = "product-card";
          let itemIcon = getItemIcon(item.itemName, item.category);
          let itemType = getItemShopType(
            item.itemName,
            item.category,
            item.type
          );

          productCard.innerHTML = `
                  <div class="product-header">
                      <div>
                          <div class="product-name">${itemIcon} ${
            item.itemName
          }</div>
                          <span class="product-type">${itemType}</span>
                      </div>
                      <div class="product-price">${item.price} PS</div>
                  </div>
                  <div class="product-description">${
                    itemInfo.description ||
                    item.description ||
                    "Un objeto misterioso."
                  }</div>
                  ${
                    item.levelRequirement
                      ? `<div><strong>Req:</strong> Nv ${item.levelRequirement}</div>`
                      : ""
                  }
                  ${
                    typeof item.stock === "number"
                      ? `<div><strong>Disp:</strong> ${item.stock}</div>`
                      : ""
                  }
                  <div class="product-actions">
                      <button class="buy-btn" data-item="${
                        item.itemName
                      }" data-price="${item.price}">Comprar</button>
                  </div>`;
          const buyBtn = productCard.querySelector(".buy-btn");
          if (
            (gameState.inventory["Piedras Espirituales"] || 0) < item.price ||
            item.stock === 0
          ) {
            buyBtn.disabled = true;
            buyBtn.title =
              item.stock === 0 ? "Agotado" : "Piedras insuficientes";
          }
          buyBtn.addEventListener("click", () => buyFromShop(item.itemName));
          shopProductsEl.appendChild(productCard);
        });
        renderShopPagination(totalPages);
      }

      function techIsCombat(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "active_ability" ||
            techniqueData[techId].abilityId)
        );
      }

      function techIsCultivation(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "passive_cultivation" ||
            techniqueData[techId].type === "passive_stat" ||
            techniqueData[techId].type === "active_refinement_effect")
        );
      }

      function isMaterial(itemName) {
        const knownMaterials = [
          "Cristal de Hielo",
          "Esencia de Fuego",
          "Núcleo de Tormenta",
          "Venenos Mortales",
          "Fragmentos de Jade",
          "Esencia Oscura",
          "Almas Condenadas",
          "Núcleo de Vórtice",
          "Rocío Celestial",
          "Cristales Psíquicos",
          "Mineral de Hierro Espiritual",
          "Plumas de Fénix",
          "Semillas Ancestrales",
          "Escamas de Dragón",
          "Espejos Astrales",
          "Relojes de Arena",
          "Sangre de Demonio",
          "Lágrimas de Unicornio",
          "Núcleo Elemental",
          "Polvo de Arcano",
          "Piedras Espirituales",
          "Cristales de Qi",
          "Hierbas Medicinales",
        ];
        return knownMaterials.includes(itemName);
      }

      function getItemIcon(itemName, category) {
        if (itemName.includes("Espada") || category === "weapon") return "⚔️";
        if (itemName.includes("Armadura") || category === "armor") return "🛡️";
        if (itemName.includes("Hierba")) return "🌿";
        if (itemName.includes("Cristal")) return "💎";
        if (itemName.includes("Piedra")) return "💎";
        if (itemName.startsWith("Rollo:")) return "📜";
        return "📦";
      }

      function getItemShopType(itemName, category, type) {
        if (itemName.startsWith("Rollo: ")) return "Técnica";
        if (category === "weapon") return "Arma";
        if (category === "armor") return "Armadura";
        if (
          type === "consumable" ||
          [
            "Hierbas Medicinales",
            "Cristales de Qi",
            "Píldora de Recuperación Menor",
          ].includes(itemName)
        )
          return "Consumible";
        if (isMaterial(itemName)) return "Material";
        return "Objeto";
      }

      function renderShopPagination(totalPages) {
        const pagination = document.getElementById("shopPagination");
        pagination.innerHTML = "";
        if (totalPages <= 1) return;
        const prevBtn = document.createElement("button");
        prevBtn.className = "page-btn";
        prevBtn.textContent = "«";
        prevBtn.addEventListener("click", () => {
          if (currentShopPage > 1) {
            currentShopPage--;
            renderShopProducts();
          }
        });
        pagination.appendChild(prevBtn);
        const startPage = Math.max(1, currentShopPage - 1);
        const endPage = Math.min(totalPages, currentShopPage + 1);
        for (let i = startPage; i <= endPage; i++) {
          const pageBtn = document.createElement("button");
          pageBtn.className = `page-btn ${
            i === currentShopPage ? "active" : ""
          }`;
          pageBtn.textContent = i;
          pageBtn.addEventListener("click", () => {
            currentShopPage = i;
            renderShopProducts();
          });
          pagination.appendChild(pageBtn);
        }
        const nextBtn = document.createElement("button");
        nextBtn.className = "page-btn";
        nextBtn.textContent = "»";
        nextBtn.addEventListener("click", () => {
          if (currentShopPage < totalPages) {
            currentShopPage++;
            renderShopProducts();
          }
        });
        pagination.appendChild(nextBtn);
      }

      function closeShopModal() {
        document.getElementById("shopModal").style.display = "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function buyFromShop(itemName) {
        const itemToBuy = shopData.inventory.find(
          (i) => i.itemName === itemName
        );
        const playerStones = gameState.inventory["Piedras Espirituales"] || 0;
        if (
          !itemToBuy ||
          itemToBuy.stock === 0 ||
          playerStones < itemToBuy.price
        ) {
          showModal(
            "Error Compra",
            "No se puede comprar (fondos insuficientes, agotado o no existe)."
          );
          return;
        }
        gameState.inventory["Piedras Espirituales"] -= itemToBuy.price;
        if (itemToBuy.type === "equipment" && itemToBuy.attackBonus) {
          gameState.player.baseAttack += itemToBuy.attackBonus;
          recalculatePlayerStats();
          showModal(
            "¡Equipo Comprado!",
            `Compraste ${itemName}. Ataque base +${itemToBuy.attackBonus}.`
          );
        } else {
          gameState.inventory[itemName] =
            (gameState.inventory[itemName] || 0) + 1;
          if (
            itemData[itemName] &&
            itemData[itemName].effect &&
            itemName.startsWith("Rollo: ")
          ) {
            showModal(
              "¡Rollo Comprado!",
              `Has comprado ${itemName}. Úsalo desde tu inventario para aprender la técnica.`
            );
          } else {
            showModal("¡Objeto Comprado!", `Has comprado ${itemName}.`);
          }
        }
        if (typeof itemToBuy.stock === "number" && itemToBuy.stock > 0)
          itemToBuy.stock--;
        openShop();
        updateUI();
      }
      
    function openManageTechniquesModal() {
        // Primero cerramos el modal de visualización para evitar que se superpongan.
        closeTechniqueModal();

        const player = gameState.player;
        const equippedList = document.getElementById('equipped-techniques-list');
        const availableList = document.getElementById('available-techniques-list');
        
        equippedList.innerHTML = '';
        availableList.innerHTML = '';

        // --- Rellenar los slots de técnicas equipadas ---
        for (let i = 0; i < 3; i++) {
            const techId = player.equippedTechniques[i];
            const slotDiv = document.createElement('div');
            slotDiv.className = 'inventory-modal-item';
            slotDiv.style.cursor = 'pointer';

            if (techId && techniqueData[techId]) {
                const techInfo = techniqueData[techId];
                slotDiv.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${techInfo.icon || '📜'} ${techInfo.name}</div>
                        <div class="item-description">Slot ${i + 1} - Clic para desequipar</div>
                    </div>
                `;
                slotDiv.onclick = () => unequipTechnique(i);
            } else {
                slotDiv.innerHTML = `
                    <div class="item-details" style="opacity: 0.5;">
                        <div class="item-name">Slot ${i + 1} (Vacío)</div>
                    </div>
                `;
            }
            equippedList.appendChild(slotDiv);
        }

        // --- Rellenar la lista de técnicas disponibles ---
        for (const techId in player.learnedTechniques) {
            const techInfo = techniqueData[techId];
            const playerTech = player.learnedTechniques[techId];

            if (techInfo && techInfo.type === 'active_ability' && playerTech.level > 0) {
                if (player.equippedTechniques.includes(techId)) {
                    continue;
                }

                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventory-modal-item assignable-item';
                itemDiv.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${techInfo.icon || '📜'} ${techInfo.name} (Nv. ${playerTech.level})</div>
                        <div class="item-description">${techInfo.description}</div>
                    </div>
                `;
                itemDiv.onclick = () => equipTechnique(techId);
                availableList.appendChild(itemDiv);
            }
        }
        
        document.getElementById('manageTechniquesModal').style.display = 'flex';
        hideTouchControls();
    }
    function closeManageTechniquesModal() {
        document.getElementById('manageTechniquesModal').style.display = 'none';
        showTouchControls();
        // Al cerrar, volvemos a mostrar el panel de técnicas para una experiencia fluida.
        showTechniquePanel();
    }

    function equipTechnique(techId) {
        const player = gameState.player;
        const firstEmptySlot = player.equippedTechniques.indexOf(null);

        if (firstEmptySlot !== -1) {
            player.equippedTechniques[firstEmptySlot] = techId;
            openManageTechniquesModal(); // Refrescar el modal
        } else {
            showModal("Slots Llenos", "No tienes más slots de técnicas disponibles. Desequipa una para hacer espacio.");
            setTimeout(() => closeModal(), 2000);
        }
    }

    function unequipTechnique(slotIndex) {
        gameState.player.equippedTechniques[slotIndex] = null;
        openManageTechniquesModal(); // Refrescar el modal
    }  
    function sellToShop(itemName, quantityToSell, totalStonesEarned) {}

      function saveGame() {
        try {
          const gameStateToSave = JSON.parse(JSON.stringify(gameState));
          const gameDataJson = JSON.stringify(gameStateToSave, null, 2);
          const blob = new Blob([gameDataJson], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "camino_del_cultivador_save.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showModal("Partida Guardada", "Progreso guardado como archivo JSON.");
        } catch (error) {
          showModal("Error al Guardar", `Hubo un problema: ${error.message}`);
        }
      }

      function triggerFileUpload() {
        document.getElementById("fileInput").click();
      }

      // --- CARGA DE PARTIDA ---

      // Reemplaza tu función 'loadGameFromFile(event)' existente con esta versión mejorada.

      function loadGameFromFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                if (gameState.player.isCultivating) stopCultivation();
                if (gameState.battle.active) endBattle(false);

                const loadedGameState = JSON.parse(e.target.result);

                if (!loadedGameState.player || !loadedGameState.map || !loadedGameState.inventory) {
                    throw new Error("Formato de guardado incorrecto o datos esenciales faltantes.");
                }
                sanitizeActiveMissions(loadedGameState.player);
                // --- INICIO DE LA LÓGICA DE COMPATIBILIDAD MEJORADA ---

                const loadedPlayer = loadedGameState.player;

                // 1. Saneamiento Básico de propiedades del jugador
                if (!loadedPlayer.abilityCooldowns) loadedPlayer.abilityCooldowns = {};
                if (!loadedPlayer.equippedTechniques) loadedPlayer.equippedTechniques = [null, null, null, null, null];

                // 2. Saneamiento profundo de las TÉCNICAS APRENDIDAS
                const techniquesToSanitize = loadedPlayer.learnedTechniques || {};
                const sanitizedTechniques = {}; 

                for (const techId in techniquesToSanitize) {
                    // Si la técnica ya no existe en la versión actual del juego, la ignoramos.
                    if (techniqueData[techId]) {
                        const savedTechData = techniquesToSanitize[techId];
                        const masterTechData = techniqueData[techId];

                        // Creamos una nueva copia saneada de la técnica del jugador.
                        const sanitizedPlayerTech = { ...savedTechData };
                        
                        // Aseguramos que las propiedades básicas de cultivo existan
                        if (typeof sanitizedPlayerTech.level === 'undefined') sanitizedPlayerTech.level = 0;
                        if (typeof sanitizedPlayerTech.currentCultivationProgress === 'undefined') sanitizedPlayerTech.currentCultivationProgress = 0;
                        if (typeof sanitizedPlayerTech.cultivationTimeToNextLevel === 'undefined') {
                            sanitizedPlayerTech.cultivationTimeToNextLevel = masterTechData.cultivationSettings?.baseTimeToLevelUp || Infinity;
                        }

                        // ¡Este es el paso clave! Comparamos con la definición maestra.
                        // Si en el futuro añades más propiedades a 'effect', esta lógica las cubrirá.
                        if (masterTechData.effect) {
                             // Si el objeto de efecto no existe en el guardado, lo creamos.
                            if (!sanitizedPlayerTech.effect) {
                                sanitizedPlayerTech.effect = {};
                            }
                            // Recorremos las propiedades del efecto maestro...
                            for (const effectProp in masterTechData.effect) {
                                // ...y si una propiedad no existe en el guardado, la añadimos.
                                if (typeof sanitizedPlayerTech.effect[effectProp] === 'undefined') {
                                    sanitizedPlayerTech.effect[effectProp] = masterTechData.effect[effectProp];
                                    console.warn(`Partida antigua: Añadida propiedad faltante '${effectProp}' a la técnica '${techId}'.`);
                                }
                            }
                        }
                        sanitizedTechniques[techId] = sanitizedPlayerTech;
                    } else {
                        console.warn(`Técnica obsoleta '${techId}' eliminada del guardado.`);
                    }
                }
                loadedPlayer.learnedTechniques = sanitizedTechniques;

                // 3. Asignamos los datos saneados al estado del juego
                gameState.player = loadedPlayer;
                gameState.inventory = JSON.parse(JSON.stringify(loadedGameState.inventory));
                gameState.map.entities = loadedGameState.map.entities ? JSON.parse(JSON.stringify(loadedGameState.map.entities)) : [];
                
                // --- FIN DE LA LÓGICA DE COMPATIBILIDAD ---

                // Resetear estados transitorios
                gameState.player.isCultivating = false;
                if (gameState.cultivationInterval) {
                    clearInterval(gameState.cultivationInterval);
                    gameState.cultivationInterval = null;
                }

                // Reconstruir el juego con los datos actualizados
                generateMap(true);
                recalculatePlayerStats(); // Es crucial recalcular stats DESPUÉS de sanear los datos
                renderQuickSlotBar();
                updatePlayerPosition("loadGameFromFile_end");

                showModal("Partida Cargada", "¡Partida restaurada con éxito! (Se aplicaron actualizaciones de compatibilidad)");

            } catch (error) {
                showModal("Error al Cargar", `Hubo un problema: ${error.message}`);
                console.error("Error loading game:", error);
            } finally {
                event.target.value = null; // Permite cargar el mismo archivo de nuevo
            }
        };
        reader.onerror = () => {
            showModal("Error de Lectura", "No se pudo leer el archivo de guardado.");
            event.target.value = null;
        };
        reader.readAsText(file);
    }

    function renderQuickSlotBar() {
        const bar = document.getElementById("quickSlotBar");
        if (!bar) return;
        bar.innerHTML = "";

        const player = gameState.player;
        const LONG_PRESS_DURATION = 700; // Un poco más rápido para mejorar la sensación en móvil
        const MOVE_THRESHOLD = 10; // El jugador debe mover el dedo más de 10px para que se considere un arrastre
        // Contamos cuántos botones especiales se mostrarán
        let specialButtonCount = 1; // El de Cultivo siempre está
        if (player.canUseQiConversion) specialButtonCount++;
        if (player.learnedTechniques["formation_scribing_1"]) specialButtonCount++;

        // Determinamos cuántos slots de ítems mostrar (máximo 5, menos los especiales)
        const itemSlotCount = 5 - specialButtonCount;

        // --- RENDERIZAR SLOTS DE ÍTEMS ---
        for (let index = 0; index < itemSlotCount; index++) {
            const itemName = player.quickSlots[index];
            const slot = document.createElement("div");
            slot.className = "quick-slot";
            
            // ... (TODA la lógica de TAP vs LONG PRESS que ya tenías para los slots de ítems va aquí, sin cambios)
            let pressTimer = null;
            let isLongPress = false;
            let startX = 0;
            let startY = 0;

            const handlePressStart = (e) => {
              isLongPress = false;
              // Guardamos la posición inicial del toque
              if (e.type === 'touchstart') {
                  startX = e.changedTouches[0].clientX;
                  startY = e.changedTouches[0].clientY;
              }
              
              // Iniciamos el temporizador para el toque largo
              pressTimer = setTimeout(() => {
                  isLongPress = true;
                  openItemAssignmentModal(index);
              }, LONG_PRESS_DURATION);
            };
            const handlePressEnd = () => {
              clearTimeout(pressTimer);
              // Solo se "usa" el item si no fue un toque largo
              if (!isLongPress) {
                  useQuickSlotItem(index);
              }
            };
            
            const handlePressCancel = () => clearTimeout(pressTimer);
            // --- NUEVO MANEJADOR INTELIGENTE PARA touchmove ---
            const handlePressMove = (e) => {
                if (e.type === 'touchmove') {
                    const moveX = e.changedTouches[0].clientX;
                    const moveY = e.changedTouches[0].clientY;
                    // Calculamos la distancia que se ha movido el dedo
                    const distance = Math.hypot(moveX - startX, moveY - startY);
                    
                    // Si la distancia supera nuestro umbral, es un arrastre, no un toque largo.
                    if (distance > MOVE_THRESHOLD) {
                        clearTimeout(pressTimer);
                    }
                }
            };

            // Asignar los listeners
            slot.addEventListener("mousedown", handlePressStart);
            slot.addEventListener("mouseup", handlePressEnd);
            slot.addEventListener("mouseleave", handlePressCancel);
            
            // Usamos { passive: false } para poder prevenir el scroll del navegador si es necesario
            slot.addEventListener("touchstart", handlePressStart, { passive: false });
            slot.addEventListener("touchend", handlePressEnd);
            slot.addEventListener("touchcancel", handlePressCancel);
            // El nuevo listener inteligente
            slot.addEventListener("touchmove", handlePressMove, { passive: false });


            const keyHint = document.createElement("span");

            keyHint.className = "slot-key-hint";
            keyHint.textContent = index + 1;
            slot.appendChild(keyHint);

            if (itemName && itemData[itemName]) {
                  const itemCount = gameState.inventory[itemName] || 0;
                  slot.innerHTML += getItemIcon(itemName); // Mantenemos el ícono
                  slot.appendChild(keyHint); // Re-añadimos el hint que se borra con innerHTML

                  const countDisplay = document.createElement("span");
                  countDisplay.className = "slot-item-count";
                  countDisplay.textContent = itemCount;
                  slot.appendChild(countDisplay);

                  if (itemCount === 0) {
                      slot.style.opacity = 0.5;
                      slot.title = `Slot ${index + 1}: ${itemName} (Agotado)\nToque largo para reasignar.`;
                  } else {
                      slot.title = `Slot ${index + 1}: ${itemName} (x${itemCount})\nToque para usar, toque largo para reasignar.`;
                  }
              } else {
                  slot.classList.add("empty");
                  slot.title = `Slot ${index + 1} (Vacío)\nToque para asignar.`;
              }
              bar.appendChild(slot);
          }


        // --- RENDERIZAR BOTONES DE ACCIÓN ESPECIALES ---

        // Botón de Cultivo (siempre visible)
        const cultivateSlot = document.createElement("div");
        cultivateSlot.className = "quick-slot cultivate-slot";
        cultivateSlot.title = "Cultivar (🧘)";
        cultivateSlot.innerHTML = "🧘";
        cultivateSlot.onclick = () => toggleCultivation();
        if (player.isCultivating) {
            cultivateSlot.classList.add("active-cultivation");
            cultivateSlot.title = "Ver/Detener Cultivo";
        }
        bar.appendChild(cultivateSlot);

        // Botón de Conversión de Qi (condicional)
        if (player.canUseQiConversion) {
            const conversionSlot = document.createElement("div");
            conversionSlot.className = "quick-slot conversion-slot";
            conversionSlot.innerHTML = "☯️";
            conversionSlot.onclick = () => toggleQiConversion();
            if (player.isCultivating && player.cultivationMode.isConversionCultivation) {
                conversionSlot.classList.add("active-conversion");
                conversionSlot.title = "Conversión ACTIVA (clic para detener)";
            } else {
                conversionSlot.title = "Iniciar Conversión de Maná a Vida";
            }
            bar.appendChild(conversionSlot);
        }
        
        // === INICIO DEL CÓDIGO NUEVO: BOTÓN DE RUNAS (CONDICIONAL) ===
        // Comprobamos si el jugador ha aprendido la técnica específica
        if (player.learnedTechniques["formation_scribing_1"]) {
            const runeSlot = document.createElement("div");
            runeSlot.className = "quick-slot rune-slot";
            runeSlot.innerHTML = "✍️"; // O el ícono que prefieras para las runas
            runeSlot.title = "Inscribir Runa (Consume 1 Tinta Rúnica)";
            
            // Al hacer clic, se intenta plantar una runa. La función plantRune ya comprueba si hay tinta y un enemigo cerca.
            runeSlot.onclick = () => {
                // No usamos battleAction aquí porque plantar runas es una acción del mapa, no de combate.
                plantRune(); 
            };
            bar.appendChild(runeSlot);
        }
        // === FIN DEL CÓDIGO NUEVO ===
    }

      function unassignQuickSlot(slotIndex) {
        gameState.player.quickSlots[slotIndex] = null;
        closeModal();
        renderQuickSlotBar();
      }

      function useQuickSlotItem(slotIndex) {
    // 1. Obtener el nombre del objeto desde la ranura
    const itemName = gameState.player.quickSlots[slotIndex];
    if (!itemName) {
        openItemAssignmentModal(slotIndex); // Si la ranura está vacía, abrir el menú de asignación
        return;
    }

    // 2. Obtener la definición maestra del objeto y la cantidad actual
    // Usaremos un nombre de variable claro: "itemDefinition"
    const itemDefinition = itemData[itemName];
    const itemCount = gameState.inventory[itemName] || 0;

    // 3. Comprobar si el objeto está agotado
    if (itemCount <= 0) {
        showModal("Agotado", `No te quedan más ${itemName}.`);
        gameState.player.quickSlots[slotIndex] = null; // Limpiar la ranura vacía
        renderQuickSlotBar();
        return;
    }

    // 4. Comprobar si el objeto tiene una definición y si se puede usar
    if (!itemDefinition) {
        showModal("Error", `El objeto "${itemName}" no se encontró en la base de datos.`);
        return;
    }

    if (itemDefinition.canUse && !itemDefinition.canUse(gameState.player)) {
        showModal("No se puede usar", `No puedes usar ${itemName} ahora.`);
        return;
    }

    // 5. Comprobar si el objeto tiene un efecto y ejecutarlo
    if (itemDefinition.effect) {
        // Llamar al efecto, pasando todos los argumentos necesarios
        const message = itemDefinition.effect(gameState.player, gainExperience, itemName);

        // 6. Procesar el resultado de la acción
        if (message && !message.toLowerCase().includes("error") && !message.toLowerCase().includes("al máximo")) {
            gameState.inventory[itemName]--; // Reducir del inventario
            const newCount = gameState.inventory[itemName] || 0;
            if (newCount <= 0) {
                gameState.player.quickSlots[slotIndex] = null; // Limpiar si fue el último
            }
        }
        showModal("Objeto Usado", message);
        updateUI();
        renderQuickSlotBar(); // Actualizar siempre la UI y la barra rápida
    } else {
        showModal("Sin efecto", `El objeto "${itemName}" no tiene un efecto utilizable.`);
    }
}

      function showHelp() {
        showModal(
          "Ayuda - Camino del Cultivador",
          "Explora y conviértete en un cultivador poderoso.\n\n" +
            '🧘 Cultiva (Botón "Cultivar") para mejorar HP/Maná/EXP y tus Técnicas.\n' +
            "📖 Aprende y Refina Técnicas para obtener nuevas habilidades y mejoras pasivas.\n" +
            "⬆️ Sube de Nivel para aumentar tus estadísticas base.\n" + // Actualizado
            "👹 Combate demonios y rivales.\n" +
            "💎 Recolecta recursos y tesoros.\n" +
            "📜 Busca o compra rollos de técnicas para volverte más fuerte\n\n" + // Eliminada mención al árbol de habilidades
            "Controles (Teclado):\n" +
            "  WASD/Flechas: Moverse\n" +
            "  ESPACIO: Interactuar\n\n" +
            "Controles (Táctil):\n" +
            "  Joystick: Moverse\n" +
            '  Botón "Acción": Interactuar'
        );
        updateStatsPanelVisibility();
      }
      //ACTUALIZAR BARRAS DEL JUGADOR
      function updatePlayerBarsOnMap() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerOnMapBarsContainer"
        );
        const hpFill = document.getElementById("playerOnMapHpFill");
        const manaFill = document.getElementById("playerOnMapManaFill");
        const playerElement = document.getElementById("player"); // El sprite del jugador

        if (!barsContainer || !hpFill || !manaFill || !playerElement) {
          // console.warn("Elementos de barras sobre el jugador no encontrados en el DOM.");
          return;
        }

        // Ocultar barras si el jugador está en batalla o si algún modal principal está abierto.
        if (gameState.battle.active || isAnyModalOpen()) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // La posición del playerElement (sprite) ya está calculada y centrada en updatePlayerPosition.
        // Usamos su 'top' y 'left' (que son relativos al map-container) como referencia.
        const playerVisualTop = parseFloat(playerElement.style.top) || 0;
        const playerVisualLeft = parseFloat(playerElement.style.left) || 0;
        const playerVisualWidth = playerElement.offsetWidth;

        // Posicionar las barras ligeramente encima del sprite del jugador.
        const barHeightWithGap = barsContainer.offsetHeight || 13; // Alto total aprox. de las 2 barras + gap
        barsContainer.style.top = `${playerVisualTop - barHeightWithGap - 5}px`; // 5px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // El 'transform: translateX(-50%)' en el CSS ayuda con esto si 'left' es el centro.
        barsContainer.style.left = `${
          playerVisualLeft + playerVisualWidth / 2
        }px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      function updatePlayerBarsInBattle() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        const hpFill = document.getElementById("playerInBattleSpriteHpFill");
        const manaFill = document.getElementById(
          "playerInBattleSpriteManaFill"
        );
        const playerSpriteInBattle = document.querySelector(
          ".battle-area .character .character-sprite"
        );

        if (!barsContainer || !hpFill || !manaFill || !playerSpriteInBattle) {
          // console.warn("Elementos de barras sobre el sprite del jugador en batalla no encontrados.");
          if (barsContainer) barsContainer.style.display = "none"; // Ocultar si faltan elementos
          return;
        }

        // Solo mostrar si la pantalla de batalla está activa
        if (
          !gameState.battle.active ||
          document.getElementById("battleScreen").style.display !== "flex"
        ) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // Posicionar las barras ligeramente encima del sprite del jugador en batalla.
        // El sprite (.character-sprite) es un div, necesitamos su offsetTop y offsetLeft
        // relativo a su padre (.character) que ahora es 'position: relative'.

        const spriteTop = playerSpriteInBattle.offsetTop; // Distancia desde el borde superior del .character
        const spriteLeft = playerSpriteInBattle.offsetLeft; // Distancia desde el borde izquierdo del .character
        const spriteWidth = playerSpriteInBattle.offsetWidth;

        const barHeightWithGap = barsContainer.offsetHeight || 12; // Alto total aprox. de las 2 barras + gap

        // El 'top' de las barras será el 'top' del sprite menos la altura de las barras y un pequeño margen.
        barsContainer.style.top = `${spriteTop - barHeightWithGap - 3}px`; // 3px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // 'left' será el 'left' del sprite más la mitad del ancho del sprite.
        // El 'transform: translateX(-50%)' en CSS centra el contenedor de barras.
        barsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      const joystickContainer = document.getElementById("joystick-container");
      const joystickPad = document.getElementById("joystick-pad");
      const joystickHandle = document.getElementById("joystick-handle");
      const actionButtonTouch = document.getElementById("action-button-touch");
      let joystickActive = false;
      let joystickCurrentDx = 0; // Guardar la dirección actual del joystick
      let joystickCurrentDy = 0;

      const JOYSTICK_THRESHOLD = 15;
      const JOYSTICK_GAME_MOVE_INTERVAL = 300;
      let joystickGameMoveTimerId = null;
      let lastJoystickMoveTime = 0;
      let joystickLoopId = null;
      let joystickTouchIdentifier = null; // <!-- CAMBIO JOYSTICK: Para seguir el dedo correcto -->

      function initJoystick() {
        if (
          !joystickContainer ||
          !joystickPad ||
          !joystickHandle ||
          !actionButtonTouch
        ) {
          console.error(
            "Error inicializando joystick: Elementos no encontrados."
          );
          return;
        }
        resetJoystickHandle();

        joystickPad.addEventListener(
          "touchstart",
          (event) => {
            if (
              gameState.player.isCultivating ||
              gameState.battle.active ||
              joystickActive
            )
              return;
            const touch = event.changedTouches[0];
            if (!touch) return;
            const padRect = joystickPad.getBoundingClientRect();
            if (
              touch.clientX < padRect.left ||
              touch.clientX > padRect.right ||
              touch.clientY < padRect.top ||
              touch.clientY > padRect.bottom
            ) {
              return;
            }
            event.preventDefault();
            joystickActive = true;
            joystickTouchIdentifier = touch.identifier;
            document.addEventListener("touchmove", handleJoystickMove, {
              passive: false,
            });
            document.addEventListener("touchend", handleJoystickEnd, {
              passive: false,
            });
            document.addEventListener("touchcancel", handleJoystickEnd, {
              passive: false,
            });

            // No iniciar el gameMoveTimer aquí, la animación la maneja handlePlayerMovementInput
            // updateJoystickHandlePosition y determinar dirección inicial
            updateJoystickHandlePosition(touch, true); // true para indicar que es el inicio
          },
          { passive: false }
        );

        actionButtonTouch.addEventListener("click", () => {
          if (!gameState.player.isCultivating && !gameState.battle.active) {
            interact();
          }
        });
      }
      function resetJoystickHandle() {
        if (joystickHandle)
          joystickHandle.style.transform = "translate(0px, 0px)";
        joystickCurrentDx = 0;
        joystickCurrentDy = 0;
      }
      // <!-- CAMBIO JOYSTICK: Modificaciones en los manejadores -->
      function handleJoystickStart(event) {
        if (
          gameState.player.isCultivating ||
          gameState.battle.active ||
          joystickActive
        )
          return;

        // Solo procesar el primer toque en el pad
        const touch = event.changedTouches[0];
        if (!touch) return;

        // Comprobar si el toque está realmente dentro del joystickPad (opcional, pero bueno para evitar activaciones accidentales)
        const padRect = joystickPad.getBoundingClientRect();
        if (
          touch.clientX < padRect.left ||
          touch.clientX > padRect.right ||
          touch.clientY < padRect.top ||
          touch.clientY > padRect.bottom
        ) {
          return;
        }

        event.preventDefault(); // Prevenir scroll/zoom si el toque es para el joystick

        joystickActive = true;
        joystickTouchIdentifier = touch.identifier; // Guardar el ID del dedo

        // Añadir listeners de movimiento y fin al documento para seguir el dedo fuera del pad
        document.addEventListener("touchmove", handleJoystickMove, {
          passive: false,
        });
        document.addEventListener("touchend", handleJoystickEnd, {
          passive: false,
        });
        document.addEventListener("touchcancel", handleJoystickEnd, {
          passive: false,
        });

        // if (!joystickGameMoveTimerId) {
        //   joystickGameMoveTimerId = setInterval(
        //     processJoystickGameMove,
        //     JOYSTICK_GAME_MOVE_INTERVAL
        //   );
        // }
        updateJoystickHandlePosition(touch);
        // console.log("Joystick Start, ID:", joystickTouchIdentifier);
      }
      function handleJoystickMove(event) {
        if (!joystickActive) return;

        // Encontrar el toque correcto
        let touch = null;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touch = event.changedTouches[i];
            break;
          }
        }

        if (touch) {
          event.preventDefault(); // Prevenir scroll si el movimiento es del dedo del joystick
          updateJoystickHandlePosition(touch);
          // console.log("Joystick Move");
        }
      }

      function updateJoystickHandlePosition(touch) {
        const padRect = joystickPad.getBoundingClientRect();
        if (padRect.width === 0) return;

        const joystickCenterX = padRect.left + padRect.width / 2;
        const joystickCenterY = padRect.top + padRect.height / 2;

        const currentX = touch.clientX - joystickCenterX;
        const currentY = touch.clientY - joystickCenterY;

        const angle = Math.atan2(currentY, currentX);
        const maxDistance =
          joystickPad.offsetWidth / 2 - joystickHandle.offsetWidth / 2;
        if (maxDistance <= 0) return;

        const distance = Math.min(maxDistance, Math.hypot(currentX, currentY));
        const limitedX = distance * Math.cos(angle);
        const limitedY = distance * Math.sin(angle);
        if (joystickHandle) {
          joystickHandle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
        }

        // --- LÓGICA DE CONTROL SIMPLIFICADA ---
        // Primero, reseteamos todas las direcciones del joystick.
        playerMovementKeysDown.up = false;
        playerMovementKeysDown.down = false;
        playerMovementKeysDown.left = false;
        playerMovementKeysDown.right = false;

        // Ahora, activamos la dirección correcta si el joystick está lo suficientemente inclinado.
        const magnitude = Math.hypot(currentX, currentY);
        if (magnitude > JOYSTICK_THRESHOLD) {
          if (Math.abs(currentX) > Math.abs(currentY)) {
            // Movimiento horizontal (izquierda o derecha)
            if (currentX > 0) {
              playerMovementKeysDown.right = true;
            } else {
              playerMovementKeysDown.left = true;
            }
          } else {
            // Movimiento vertical (arriba o abajo)
            if (currentY > 0) {
              playerMovementKeysDown.down = true;
            } else {
              playerMovementKeysDown.up = true;
            }
          }
        }
      }

      function handleJoystickEnd(event) {
        if (!joystickActive) return;

        let touchEndedIsOurs = false;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touchEndedIsOurs = true;
            break;
          }
        }

        if (touchEndedIsOurs) {
          joystickActive = false;
          joystickTouchIdentifier = null;
          resetJoystickHandle();

          // --- LIMPIEZA DE BANDERAS ---
          // Al soltar el joystick, nos aseguramos de que ninguna tecla de movimiento quede "presionada"
          playerMovementKeysDown.up = false;
          playerMovementKeysDown.down = false;
          playerMovementKeysDown.left = false;
          playerMovementKeysDown.right = false;

          document.removeEventListener("touchmove", handleJoystickMove);
          document.removeEventListener("touchend", handleJoystickEnd);
          document.removeEventListener("touchcancel", handleJoystickEnd);
        }
      }
      // processJoystickGameMove se mantiene igual
      // <!-- FIN CAMBIO JOYSTICK -->
      function processJoystickGameMove() {
        // Esta función se llama cada JOYSTICK_GAME_MOVE_INTERVAL
        if (
          joystickActive &&
          (joystickCurrentDx !== 0 || joystickCurrentDy !== 0)
        ) {
          // console.log(`[processJoystickGameMove] Effective move: dx=${joystickCurrentDx}, dy=${joystickCurrentDy}. Calling movePlayer.`);
          movePlayer(joystickCurrentDx, joystickCurrentDy);
        }
      }
      function joystickLoop() {
        if (!joystickActive) {
          joystickLoopId = null;
          return;
        }
        const now = Date.now();
        if (now - lastJoystickMoveTime > JOYSTICK_MOVE_INTERVAL) {
          let dx = 0,
            dy = 0;
          const magnitude = Math.hypot(joystickCurrentX, joystickCurrentY);
          if (magnitude > JOYSTICK_THRESHOLD) {
            if (Math.abs(joystickCurrentX) > Math.abs(joystickCurrentY)) {
              dx = joystickCurrentX > 0 ? 1 : -1;
            } else {
              dy = joystickCurrentY > 0 ? 1 : -1;
            }
          }
          if (dx !== 0 || dy !== 0) {
            movePlayer(dx, dy);
            lastJoystickMoveTime = now;
          }
        }
        joystickLoopId = requestAnimationFrame(joystickLoop);
      }
      // --- NUEVAS FUNCIONES PARA LOS MODALES DE INVENTARIO Y PERSONAJE (EJEMPLOS) ---

      // Modal para Inventario Detallado (si decides usar un modal en lugar del sidebar)
      function openInventoryModal() {
    let inventoryContent = `
        <h2 style="text-align: center; margin-bottom: 20px;">Inventario</h2>
        <div id="inventory-modal-list" style="text-align: left;">
    `;

    const itemsToShow = Object.entries(gameState.inventory).filter(([itemName, count]) => count > 0);

    if (itemsToShow.length === 0) {
        inventoryContent += "<p style='text-align: center; opacity: 0.7;'>No tienes ningún objeto.</p>";
    } else {
        itemsToShow.forEach(([itemName, count]) => {
            const itemInfo = itemData[itemName] || {};
            
            // --- INICIO DE LA LÓGICA CORREGIDA ---
            let isUsable = false;
            let isDisabled = false;
            let disabledReason = "";

            // Un objeto es usable si tiene un efecto.
            if (itemInfo.effect) {
                isUsable = true;
                // Si además tiene una condición 'canUse', la evaluamos.
                if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
                    isDisabled = true;
                    disabledReason = "No se puede usar ahora";
                }
            }
            // --- FIN DE LA LÓGICA CORREGIDA ---

            inventoryContent += `
                <div class="inventory-modal-item">
                    <div class="item-details">
                        <div class="item-name">${getItemIcon(itemName, "")} ${itemName} (x${count})</div>
                        <div class="item-description">${itemInfo.description || "Un objeto misterioso."}</div>
                    </div>
                    <div class="item-actions">
                        ${
                          isUsable
                            ? `<button class="use-item-btn" data-itemname="${itemName}" ${
                                isDisabled ? "disabled" : ""
                              } title="${
                                isDisabled ? disabledReason : "Usar objeto"
                              }">Usar</button>`
                            : ""
                        }
                    </div>
                </div>
            `;
        });
    }

    inventoryContent += "</div>";
    showModal("Detalles del Inventario", inventoryContent);
    document.getElementById("modalTitle").style.display = "none";

    // Los listeners no cambian, siguen funcionando igual.
    document.querySelectorAll(".use-item-btn").forEach((button) => {
        button.addEventListener("click", function () {
            const itemName = this.dataset.itemname;
            useItem(itemName);
            closeModal();
            openInventoryModal();
        });
    });
    updateStatsPanelVisibility();
}

      function openItemAssignmentModal(slotIndex) {
        let assignmentContent = `
              <h2 style="text-align: center; margin-bottom: 20px;">Asignar al Slot ${
                slotIndex + 1
              }</h2>
              <p style="text-align: center; opacity: 0.8; margin-bottom: 15px;">Selecciona un objeto consumible para este acceso rápido.</p>
              <div id="assignment-modal-list" style="text-align: left;">
          `;

        // Filtrar para mostrar solo los ítems consumibles que el jugador posee
        const assignableItems = Object.entries(gameState.inventory).filter(
          ([itemName, count]) => {
            const itemInfo = itemData[itemName];
            return count > 0 && itemInfo && itemInfo.canUse; // 'canUse' es nuestro indicador de consumible
          }
        );

        if (assignableItems.length === 0) {
          assignmentContent +=
            "<p style='text-align: center; opacity: 0.7;'>No tienes objetos consumibles para asignar.</p>";
        } else {
          assignableItems.forEach(([itemName, count]) => {
            const itemInfo = itemData[itemName];
            assignmentContent += `
                      <div class="inventory-modal-item assignable-item" data-itemname="${itemName}">
                          <div class="item-details">
                              <div class="item-name">${getItemIcon(
                                itemName,
                                ""
                              )} ${itemName} (x${count})</div>
                              <div class="item-description">${
                                itemInfo.description
                              }</div>
                          </div>
                      </div>
                  `;
          });
        }

        // --- AÑADIMOS EL BOTÓN DE DESASIGNAR ---
        assignmentContent += `</div><button onclick="unassignQuickSlot(${slotIndex})" style="margin-top:20px; background-color: #883333;">Quitar Objeto del Slot</button>`;

        // Mostramos el modal
        showModal("Asignar Objeto", assignmentContent);
        document.getElementById("modalTitle").style.display = "none";

        // Añadimos listeners a los ítems clicables
        document.querySelectorAll(".assignable-item").forEach((itemDiv) => {
          itemDiv.addEventListener("click", function () {
            const itemName = this.dataset.itemname;
            // Asignar el ítem al slot correspondiente
            gameState.player.quickSlots[slotIndex] = itemName;
            // Cerrar el modal y actualizar la barra
            closeModal();
            renderQuickSlotBar();
          });
        });
        updateStatsPanelVisibility();
      }
      function unassignQuickSlot(slotIndex) {
        gameState.player.quickSlots[slotIndex] = null;
        closeModal();
        renderQuickSlotBar();
      }

      // Modal para Personaje (Stats, Equipo, etc.)
      function openCharacterModal() {
        const player = gameState.player;
        let characterContent = `
                  <h2>${player.realm} - Nivel ${player.level}</h2>
                  <div style="text-align: left; margin-top: 15px;">
                  <p><strong>Vida:</strong> ${Math.floor(player.hp)} / ${
          player.maxHp
        }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill hp-fill" style="width: ${
                    (player.hp / player.maxHp) * 100
                  }%;"></div></div>
                  <p><strong>Maná:</strong> ${Math.floor(player.mana)} / ${
          player.maxMana
        }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill mana-fill" style="width: ${
                    (player.mana / player.maxMana) * 100
                  }%;"></div></div>
                  <p><strong>Experiencia:</strong> ${Math.floor(
                    player.exp
                  )} / ${player.expToNext}</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill exp-fill" style="width: ${
                    (player.exp / player.expToNext) * 100
                  }%;"></div></div>
                  <hr style="margin: 15px 0;">
                  <p><strong>Ataque:</strong> ${player.attack}</p>
                  <p><strong>Defensa:</strong> ${player.defense}</p>
                  <p><strong>Piedras Espirituales:</strong> ${
                    gameState.inventory["Piedras Espirituales"] || 0
                  }</p>
                  <hr style="margin: 15px 0;">
                  <h4>Secta: ${player.secta.nombre}</h4>
                  <p><strong>Rango:</strong> ${player.secta.rango}</p>
                  <p><strong>Puntos de Contribución:</strong> ${
                    player.secta.puntosContribucion
                  } PCS</p>
                  </div>
                  `;
        // Aquí podrías añadir una sección para el equipo si lo implementas.
        showModal("Detalles del Personaje", characterContent);
        updateStatsPanelVisibility();
      }

      // Placeholder para un futuro modal de menú principal
      function openMainMenuModal() {
        let menuContent = `
                  <h2>Menú Principal</h2>
                  <button class="cultivation-option-btn" onclick="saveGame(); closeModal();">💾 Guardar Partida</button>
                  <button class="cultivation-option-btn" onclick="triggerFileUpload(); closeModal();">📁 Cargar Partida</button>
                  <button id="fullscreenBtn" class="cultivation-option-btn" onclick="toggleFullscreen()">
                      <span id="fullscreenIcon">⛶</span> Pantalla Completa
                  </button>
                  <button class="cultivation-option-btn" onclick="showHelp();">❓ Ayuda</button>
                  <button class="cultivation-option-btn" onclick="closeModal();">↩️ Volver al Juego</button>
              `;
        // Usamos el showModal genérico pero sin el botón de cierre por defecto, ya que "Volver al Juego" hace esa función.
        // Para ello, tu showModal necesitaría una forma de ocultar su propio botón de cierre.
        // Si showModal no lo permite, necesitarías un modal específico para el menú.
        // Por ahora, asumiré que el showModal genérico tiene un botón de cierre que se ocultará
        // o que el usuario usará el botón "Volver al Juego".

        // Modificamos el modal genérico para que no muestre su propio botón "Cerrar" si se lo indicamos
        const modalElement = document.getElementById("interactionModal");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalTextEl = document.getElementById("modalText");
        const closeButton = modalElement.querySelector(
          "button.close-modal-btn"
        );

        modalTitleEl.textContent = "Menú Principal"; // El H2 ya está en menuContent
        modalTextEl.innerHTML = menuContent.replace(
          "<h2>Menú Principal</h2>",
          ""
        ); // Quitar el H2 duplicado
        if (closeButton) closeButton.style.display = "none"; // Ocultar el botón de cierre por defecto del modal

        modalElement.style.display = "flex";
        hideTouchControls();
        updateTopNavVisibility();
        updateStatsPanelVisibility();
      }

      function toggleFullscreen() {
          if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
              openFullscreen();
          } else {
              closeFullscreen();
          }
      }
      function openFullscreen() {
          const elem = document.documentElement; // Queremos que todo el documento sea pantalla completa
          if (elem.requestFullscreen) {
              elem.requestFullscreen();
          } else if (elem.mozRequestFullScreen) { /* Firefox */
              elem.mozRequestFullScreen();
          } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
              elem.webkitRequestFullscreen();
          } else if (elem.msRequestFullscreen) { /* IE/Edge */
              elem.msRequestFullscreen();
          }
          updateFullscreenButton();
      }
      function closeFullscreen() {
          if (document.exitFullscreen) {
              document.exitFullscreen();
          } else if (document.mozCancelFullScreen) { /* Firefox */
              document.mozCancelFullScreen();
          } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
              document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) { /* IE/Edge */
              document.msExitFullscreen();
          }
          updateFullscreenButton();
      }
      function updateFullscreenButton() {
          const fullscreenBtn = document.getElementById('fullscreenBtn');
          const fullscreenIcon = document.getElementById('fullscreenIcon');
          if (!fullscreenBtn || !fullscreenIcon) return; // Salida temprana si el modal no está abierto

          // Comprobamos si algún navegador está en modo de pantalla completa
          if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
              fullscreenBtn.innerHTML = '<span id="fullscreenIcon"> keluar </span> Salir de Pantalla Completa';
          } else {
              fullscreenBtn.innerHTML = '<span id="fullscreenIcon">⛶</span> Pantalla Completa';
          }
      }

      function openSectHallInterface() {
        const player = gameState.player;
        const sectData = SECTA_DATA;

        document.getElementById(
          "sectHallModalTitle"
        ).textContent = `Salón ${player.secta.nombre}`;
        document.getElementById("sectHallPlayerRank").textContent =
          player.secta.rango;
        document.getElementById("sectHallPlayerPCS").textContent =
          player.secta.puntosContribucion;

        const availableMissionsDiv = document.getElementById(
          "sectHallAvailableMissions"
        );
        availableMissionsDiv.innerHTML =
          "<p>Habla con Guía Lin o Admin Yao para asignaciones generales.</p>";

        const rankChallengesDiv = document.getElementById(
          "sectHallRankChallenges"
        );
        rankChallengesDiv.innerHTML = "";

        const currentRankIndex = sectData.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );
        let challengeButtonAdded = false;

        if (
          currentRankIndex !== -1 &&
          currentRankIndex + 1 < sectData.rangos.length
        ) {
          const nextRankData = sectData.rangos[currentRankIndex + 1];
          const challengeButton = document.createElement("button");
          challengeButton.textContent = `Consultar Desafío para ${nextRankData.nombre}`;
          challengeButton.className = "cultivation-option-btn";
          challengeButton.style.marginBottom = "10px";

          // --- INICIO DE LA CORRECCIÓN CLAVE ---
          challengeButton.onclick = () => {
            // 1. Cerramos el modal actual del Salón de la Secta.
            closeSectHallModal();

            // 2. Preparamos y mostramos el NUEVO modal con la información del desafío.
            // (La lógica interna para generar el mensaje no cambia)
            const pcsNecesarios = nextRankData.pcsRequeridos;
            const tieneSuficientesPCS =
              player.secta.puntosContribucion >= pcsNecesarios;
            const rivalIdParaDesafio = nextRankData.desafioRivalId;
            let mensajeDesafio = `<strong>Desafío para ascender a ${nextRankData.nombre}:</strong><br>`;
            let misionDesafioActiva = null;
            let misionDesafioDataObj = null;
            let idDeLaMisionAsociada = null;

            if (rivalIdParaDesafio) {
              const misionEntry = Object.entries(MISIONES_DATA).find(
                ([mKey, mVal]) =>
                  mVal.autoActivarAlCumplirRequisitos === true &&
                  mVal.recompensa?.nuevoRango === nextRankData.nombre &&
                  mVal.objetivo?.npcId === rivalIdParaDesafio
              );

              if (misionEntry) {
                idDeLaMisionAsociada = misionEntry[0];
                misionDesafioDataObj = misionEntry[1];
                misionDesafioActiva = player.secta.misionesActivas.find(
                  (m) => m.id === idDeLaMisionAsociada
                );
                mensajeDesafio += `<em>"${misionDesafioDataObj.descripcion}"</em><br>`;
                mensajeDesafio += `Oponente: <strong>${
                  entityTypes[rivalIdParaDesafio]?.name ||
                  "Guardián Desconocido"
                }</strong>.<br>`;
                mensajeDesafio += `Recompensas: ${
                  misionDesafioDataObj.recompensa.pcs || 0
                } PCS, ${misionDesafioDataObj.recompensa.exp || 0} EXP, Rango ${
                  nextRankData.nombre
                }.<br><hr>`;
              }
            } else {
              mensajeDesafio += `Este rango no parece requerir un desafío de combate.<br><hr>`;
            }

            mensajeDesafio += `<strong>Requisitos Actuales:</strong><br>`;
            mensajeDesafio += `Puntos de Contribución (PCS): ${player.secta.puntosContribucion} / ${pcsNecesarios} PCS. `;
            mensajeDesafio += tieneSuficientesPCS
              ? "<span style='color: #66ff66;'>(Cumplido)</span><br>"
              : `<span style='color: #ffcc66;'>(Faltan ${
                  pcsNecesarios - player.secta.puntosContribucion
                } PCS)</span><br>`;

            if (misionDesafioActiva) {
              mensajeDesafio +=
                "<br><strong style='color: #66ff66;'>¡El desafío está ACTIVO!</strong> Dirígete a la arena.";
            } else if (
              idDeLaMisionAsociada &&
              player.secta.misionesCompletadas[idDeLaMisionAsociada]
            ) {
              mensajeDesafio +=
                "<br><strong style='color: #aaa;'>Ya has completado este desafío.</strong>";
            } else if (
              tieneSuficientesPCS &&
              rivalIdParaDesafio &&
              misionDesafioDataObj &&
              idDeLaMisionAsociada
            ) {
              mensajeDesafio += `<br><button id="activar-desafio-btn-specific">Activar Misión de Desafío Ahora</button>`;
              // Guardamos la información necesaria para el listener del botón
              window.tempChallengeActivationInfo = {
                misionId: idDeLaMisionAsociada,
                nextRankName: nextRankData.nombre,
              };
            } else if (!tieneSuficientesPCS) {
              mensajeDesafio +=
                "<br>Aún no cumples los requisitos de PCS para activar este desafío.";
            }

            // 3. Mostramos el modal de información. `showModal` se encargará de gestionar el velo y los stats.
            showModal("Información del Desafío de Rango", mensajeDesafio);

            // 4. Asignamos el listener al botón de activar, si existe.
            if (
              window.tempChallengeActivationInfo &&
              document.getElementById("activar-desafio-btn-specific")
            ) {
              document.getElementById("activar-desafio-btn-specific").onclick =
                () => {
                  const info = window.tempChallengeActivationInfo;
                  acceptMission(info.misionId);
                  closeModal(); // Cierra el modal de información del desafío
                  showModal(
                    "¡Desafío Aceptado!",
                    "La misión de desafío ha sido añadida a tu diario. ¡Ve a la arena!"
                  );
                  ensureFixedEntities();
                  renderMap();
                  delete window.tempChallengeActivationInfo;
                };
            }
          };
          // --- FIN DE LA CORRECCIÓN CLAVE ---

          rankChallengesDiv.appendChild(challengeButton);
          challengeButtonAdded = true;
        }

        if (!challengeButtonAdded) {
          if (currentRankIndex === -1) {
            rankChallengesDiv.innerHTML =
              "<p>Error al determinar tu rango actual.</p>";
          } else {
            rankChallengesDiv.innerHTML =
              "<p>¡Has alcanzado el rango más alto o no hay más desafíos definidos!</p>";
          }
        }

        document.getElementById("sectHallModal").style.display = "flex";
        hideTouchControls();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function acceptMissionFromSectHall(misionId) {
        acceptMission(misionId);
        if (document.getElementById("sectHallModal").style.display === "flex") {
          openSectHallInterface();
        }
      }
      function closeSectHallModal() {
        document.getElementById("sectHallModal").style.display = "none";
        showTouchControls();
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }
      function openSectShop() {
        showModal("Tienda de Secta", "El Depósito aún está siendo abastecido.");
      }
      // Variable global para almacenar la acción a confirmar
      let onConfirmAction = null;

      function getPlayerCurrentZone() {
        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        
        for (const zone of gameState.map.terrainZones) {
          if (
            playerX >= zone.x1 &&
            playerX <= zone.x2 &&
            playerY >= zone.y1 &&
            playerY <= zone.y2
          ) {
            // console.log(`[getPlayerCurrentZone] ==> Encontrado en zona: "${zone.name}"`); // Descomenta si necesitas depurar esta función específicamente
            return zone;
          }
        }
        // console.log(`[getPlayerCurrentZone] ==> No se encontró en ninguna zona definida. Retornando null.`); // Descomenta si necesitas depurar esta función específicamente
        return null;
      }

      function showConfirmationModal(title, text, onConfirm) {
        document.getElementById("confirmationModalTitle").textContent = title;
        document.getElementById("confirmationModalText").innerHTML = text;

        onConfirmAction = onConfirm; // Guardamos la función que se ejecutará si se confirma

        const confirmButton = document.getElementById("confirmBtn");
        // Usamos .onclick para reemplazar cualquier listener anterior
        confirmButton.onclick = () => {
          if (typeof onConfirmAction === "function") {
            onConfirmAction();
          }
          closeConfirmationModal();
        };

        document.getElementById("confirmationModal").style.display = "flex";
        hideTouchControls();
      }

      function closeConfirmationModal() {
        document.getElementById("confirmationModal").style.display = "none";
        onConfirmAction = null; // Limpiamos la acción
        showTouchControls();
        updateStatsPanelVisibility();
      }
      // --- INICIALIZACIÓN ---
      document.addEventListener("DOMContentLoaded", () => {
        const mobileMenuButton = document.getElementById("mobileMenuBtn");
        const topNavBar = document.getElementById("topNavBar"); // Ya deberías tener esta variable
        if (mobileMenuButton && topNavBar) {
          mobileMenuButton.addEventListener("click", (e) => {
            e.stopPropagation(); // Evita que otros clicks se disparen
            topNavBar.classList.toggle("open");
          });
        }

        // Añadir un listener para cerrar el menú si se hace clic fuera de él
        document.addEventListener("click", (e) => {
          if (
            topNavBar.classList.contains("open") &&
            !topNavBar.contains(e.target)
          ) {
            topNavBar.classList.remove("open");
          }
        });
        renderQuickSlotBar();
        const navBtnMissions = document.getElementById("navBtnMissions");
        if (navBtnMissions) {
          navBtnMissions.addEventListener("click", openMissionsModal);
        }
        const navBtnInventory = document.getElementById("navBtnInventory");
        console.log(
          "Dentro de DOMContentLoaded, navBtnInventory:",
          navBtnInventory
        );
        if (navBtnInventory) {
          navBtnInventory.addEventListener("click", () => {
            openInventoryModal(); // Llama a nuestra nueva y mejorada función
            if (isMobileView() && topNavBar.classList.contains("open")) {
              topNavBar.classList.remove("open");
            }
          });
        }

        if (navBtnCharacter) {
          navBtnCharacter.addEventListener("click", () => {
            // Necesitas una función para abrir un MODAL de personaje
            openCharacterModal(); // Tendrías que crear esta función y el modal
          });
        }

        if (navBtnCultivate) {
          navBtnCultivate.addEventListener("click", () => {
            toggleCultivation(); // Tu función existente para iniciar/detener cultivo
          });
        }

        if (navBtnTechniques) {
          navBtnTechniques.addEventListener("click", () => {
            showTechniquePanel(); // Tu función existente para mostrar el modal de técnicas
          });
        }

        if (navBtnMenu) {
          navBtnMenu.addEventListener("click", () => {
            // Siempre abre el modal del menú principal.
            openMainMenuModal();

            // Adicional: En móvil, cierra el menú desplegable después de hacer clic.
            if (isMobileView() && topNavBar.classList.contains("open")) {
              topNavBar.classList.remove("open");
            }
          });
        }

        // Llamada inicial para asegurar el estado correcto de la barra
        updateTopNavVisibility();

        // --- INICIO DEL REEMPLAZO DE EVENT LISTENERS ---
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        document.addEventListener("keydown", (e) => {
          if (
            isAnyModalOpen() ||
            gameState.battle.active ||
            gameState.player.isCultivating
          ) {
            Object.keys(playerMovementKeysDown).forEach(
              (k) => (playerMovementKeysDown[k] = false)
            );
            return;
          }
          // --- INICIO DE LA MODIFICACIÓN PARA ACCESO RÁPIDO ---
          if (e.code.startsWith("Digit")) {
            const slotIndex = parseInt(e.code.replace("Digit", ""), 10) - 1;
            if (slotIndex >= 0 && slotIndex < 5) {
              e.preventDefault();
              useQuickSlotItem(slotIndex);
              return; // Importante para que no procese el movimiento
            }
          }
          // --- FIN DE LA MODIFICACIÓN ---
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
            case "Space":
              e.preventDefault();
              interact();
              return;
          }

          if (direction) {
            e.preventDefault();
            playerMovementKeysDown[direction] = true;
          }
        });

        document.addEventListener("keyup", (e) => {
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
          }

          if (direction) {
            e.preventDefault();
            playerMovementKeysDown[direction] = false;
          }
        });

        // Helper para convertir dirección a dx/dy para movePlayer
        function dxFromDirection(direction) {
          if (direction === "left") return -1;
          if (direction === "right") return 1;
          return 0;
        }

        function dyFromDirection(direction) {
          if (direction === "up") return -1;
          if (direction === "down") return 1;
          return 0;
        }

        const fileInput = document.getElementById("fileInput");
        if (fileInput) fileInput.addEventListener("change", loadGameFromFile);
        const toggleGridBtn = document.getElementById("toggleGridBtn");
        if (toggleGridBtn) {
            toggleGridBtn.addEventListener("click", toggleGrid);
        }
        const toggleControlsBtn = document.getElementById(
          "toggleMapControlsBtn"
        );
        if (toggleControlsBtn)
          toggleControlsBtn.addEventListener(
            "click",
            toggleMapControlsVisibility
          );

        // Listener para redimensionar y recalcular el tamaño de los tiles
        window.addEventListener("resize", () => {
          calculateAndSetTileSize();
          renderMap(); // Vuelve a dibujar con el nuevo tamaño
          updatePlayerPosition(); // Asegura que el jugador esté bien posicionado
          updateGrid();
          if (isGridVisible) {
            const gridOverlay = document.querySelector('.grid-overlay');
            if (gridOverlay) gridOverlay.style.setProperty('--tile-size', `${currentTileSize}px`);
        }
        });

        // Iniciar el bucle de actualización del juego
        setInterval(gameTickUpdater, 1000); // Llama cada segundo, ajusta según necesidad
        initJoystick();
        setInterval(gameLoop, 100);
        calculateAndSetTileSize();
        // generateMap() ahora es más simple, isRespawn = false para carga inicial completa
        gameState.lastGameTimeUpdate = Date.now(); // Inicializar antes del primer tick

        generateMap(true); // Usar true para la generación inicial completa, incluyendo decorativos

        recalculatePlayerStats();
        updatePlayerVisualSize(); // Asegura el tamaño correcto del div del jugador
        updatePlayerSpriteVisual(); // Establece el sprite inicial
        updatePlayerPosition("DOMContentLoaded_init"); // Llama después de sprite visual

        updatePlayerSpriteVisual(); // Llamar una vez para establecer el sprite inicial

        showTouchControls();
        const initialZone = getPlayerCurrentZone();
        gameState.player.currentZoneName = initialZone
          ? initialZone.name
          : "Tierras Salvajes";

        showModal(
          "Despertar del Cultivador",
          "Has despertado en un mundo de cultivadores buscando poder supremo. " +
            "Te encuentras cerca de la <strong>Secta del Viento Azure</strong>. Quizás allí encuentres tu camino.\n\n" +
            "<strong>Objetivo:</strong> Asciende en la secta, domina técnicas, derrota enemigos y desvela secretos.\n\n" +
            "Busca al <strong>Guía Lin</strong> en la secta (⛩️) para comenzar.\n\n" +
            'Usa Controles (Teclado/Táctil) para moverte e interactuar. Presiona "?" para ayuda.'
        );
        document
          .querySelectorAll("#shopCategories .category-item")
          .forEach((item) => {
            item.addEventListener("click", function () {
              document
                .querySelectorAll("#shopCategories .category-item")
                .forEach((i) => i.classList.remove("active"));
              this.classList.add("active");
              currentShopPage = 1;
              renderShopProducts();
            });
          });
        document.getElementById("shopSearch").addEventListener("input", () => {
          currentShopPage = 1;
          renderShopProducts();
        });
        document.getElementById("priceRange").addEventListener("input", (e) => {
          document.getElementById(
            "priceRangeValue"
          ).textContent = `${e.target.value} PS`;
          currentShopPage = 1;
          renderShopProducts();
        });
      });
    </script>
    <!-- BARRA DE ACCESO RÁPIDO INFERIOR -->
    <div class="quick-slot-bar" id="quickSlotBar">
      <!-- Los slots se generarán con JavaScript -->
    </div>
  </body>
</html>
