<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camino del Cultivador</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #2c1810, #8b4513);
            color: #f4e4bc;
            min-height: 100vh;
            display: flex; 
            flex-direction: column; 
        }

        .game-container {
            display: flex;
            flex-grow: 1; /* Para que ocupe el espacio que body le da */
            /* height: 100vh; /* Se gestiona mejor con flex-grow y min-height en body */
        }

        .map-container {
            flex: 1;
            position: relative;
            background: #1a3d2e;
            border: 3px solid #d4af37;
            overflow: hidden; /* MANTENER ESTO para que el mapa no se desborde si los tiles son muy grandes */
        }

        .map {
            width: 100%; /* El div del mapa interno ocupa todo el contenedor */
            height: 100%;
            position: relative; /* Tiles se posicionan relativos a este */
            /* ... el resto de tus estilos para .map ... */
        }

        .tile { /* Estilos comunes para todos los tiles, si los tienes */
            position: absolute;

            display: flex;
            align-items: center;
            justify-content: center;
         
        }

        .player {
            z-index: 10;
            color: transparent;
            font-size: 0;
            border-radius: 0;

            background-image: url('img/tu_sprite_sheet.png'); /* ¬°TU RUTA! */
            background-repeat: no-repeat;
            background-position: 0 0; /* Se actualizar√° por JS */
            
            background-size: 256px 256px; /* <--- AJUSTA ESTO AL TAMA√ëO TOTAL DE TU SPRITE SHEET */
            
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;

            /* El width y height del div se controlan por JS con updatePlayerVisualSize */
            /* La posici√≥n se controla por JS con updatePlayerSpriteVisual */
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .character-sprite { /* Sprite del jugador en batalla */
            width: 80px; 
            height: 80px;
            background-image: url('img/tu_sprite_sheet.png'); /* Tambi√©n usa la hoja de sprites */
            background-size: auto; /* O ajusta si es necesario */
            background-position: 0 0; /* Por defecto, mirando hacia abajo, frame 0 */
            background-repeat: no-repeat;
            display: inline-block; 
            color:transparent; 
            font-size: 0;
        }
        .sidebar {
            width: 300px;
            background: linear-gradient(180deg, #2c1810, #1a1a1a);
            border-left: 3px solid #d4af37;
            padding: 20px;
            overflow-y: auto;
        }

        .stats-panel, .inventory-panel, .controls-panel, .secta-panel { /* A√±adido secta-panel aqu√≠ */
            background: rgba(212, 175, 55, 0.1);
            border: 2px solid #d4af37;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); 
            gap: 8px; 
            margin-top: 10px;
            max-height: 120px; 
            overflow-y: auto;  
            padding-right: 5px; 
        }

        .inventory-item {
            font-size: 11px; 
            padding: 5px;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid #d4af37;
            border-radius: 5px;
            text-align: center;
        }


        

        .hp-fill { background: linear-gradient(90deg, #ff4444, #ff6666); }
        .mana-fill { background: linear-gradient(90deg, #4444ff, #6666ff); }
        .exp-fill { background: linear-gradient(90deg, #44ff44, #66ff66); }

        .battle-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: none;
            flex-direction: column;
            z-index: 200;
        }

        .battle-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 50px;
        }

        .character, .enemy {
            text-align: center;
            padding: 20px;
            border: 3px solid #d4af37;
            border-radius: 15px;
            background: rgba(212, 175, 55, 0.1);
        }

        .character-sprite, .enemy-sprite {
            font-size: 80px;
            margin-bottom: 20px;
        }

        .battle-actions {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-top: 3px solid #d4af37;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); /* Para m√°s botones */
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            background: linear-gradient(135deg, #d4af37, #b8941f);
            color: #2c1810;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        button:hover {
            background: linear-gradient(135deg, #f4d03f, #d4af37);
            transform: translateY(-2px);
        }

        button:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
            transform: none;
        }

        .log {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.4;
        }

        .resource { background: #228b22; }
        .monster { background: #8b0000; }
        .master { background: #4169e1; }
        .cultivation-spot { background: #daa520; }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
            padding: 10px; /* Espacio para que el modal content no pegue a los bordes */
        }

        .modal-content {
            background: linear-gradient(135deg, #2c1810, #1a1a1a);
            border: 3px solid #d4af37;
            border-radius: 15px;
            padding: 20px; /* Reducido de 30px */
            max-width: 95%; /* Para m√≥viles */
            width: 500px; /* Ancho base */
            text-align: center;
            max-height: 90vh; /* Para modales largos */
            overflow-y: auto;   /* Para modales largos */
        }
        
        /* Ajuste espec√≠fico para inventory-grid dentro de un modal si es necesario, */
        /* pero ya tiene su propio overflow y max-height. */

        /* Para pantallas m√°s peque√±as, ej. menos de 768px */
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column; 
                height: 100vh; /* Ocupa toda la altura de la ventana gr√°fica */
            }

            .sidebar {
                width: 100%;
                height: 40vh; /* Sidebar ocupa el 40% inferior */
                border-left: none;
                border-top: 3px solid #d4af37;
                overflow-y: auto; 
                flex-shrink: 0; /* Evita que se encoja */
            }

            .map-container {
                height: 60vh; /* Mapa ocupa el 60% superior */
                border-bottom: none;
                flex-shrink: 0; /* Evita que se encoja */
            }

            .tile {
                width: 30px;  
                height: 30px;
                font-size: 18px; 
            }
            
            .action-buttons { /* Botones de batalla m√°s adaptables */
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
            .battle-area { padding: 20px; } /* Menos padding en batalla */
            .character-sprite, .enemy-sprite { font-size: 60px; }
        }
        @media (max-width: 768px) {
            .character-sprite {
                width: 60px;
                height: 60px;
                /* Si la imagen del spritesheet es grande, podr√≠as necesitar ajustar background-size aqu√≠ tambi√©n */
                /* background-size: 192px 192px; /* Ejemplo si cada frame en m√≥vil es 48x48 y hay 4x4 */
            }
        }

        @media (max-width: 480px) { 
            .sidebar {
                height: 45vh; /* Un poco m√°s de espacio para el sidebar en pantallas muy peque√±as */
            }
            .map-container {
                height: 55vh; 
            }
            .tile {
                width: 25px; 
                height: 25px;
                font-size: 16px;
            }
            .modal-content { padding: 15px; }
            button { padding: 10px 15px; font-size: 0.9em; } /* Botones m√°s peque√±os */
        }

        #joystick-container {
            position: fixed; 
            bottom: 20px; /* Ajustado para no superponer tanto con sidebar en vista m√≥vil */
            left: 20px;
            width: 120px; /* M√°s peque√±o */
            height: 120px;
            z-index: 999; /* Un poco menos que el bot√≥n de acci√≥n y el de menu */
            display: none; 
            opacity: 0.7;
        }

        #joystick-pad {
            width: 100%;
            height: 100%;
            background-color: rgba(128, 128, 128, 0.5);
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.7);
        }

        #joystick-handle {
            width: 50px; /* M√°s peque√±o */
            height: 50px;
            background-color: rgba(80, 80, 80, 0.8);
            border-radius: 50%;
            position: absolute; 
            border: 2px solid rgba(200, 200, 200, 0.9);
        }
        
        #action-button-touch {
            position: fixed;
            bottom: 20px; /* Ajustado */
            right: 20px;
            width: 70px; /* M√°s peque√±o */
            height: 70px;
            border-radius: 50%;
            z-index: 1000;
            display: none;
            font-size: 0.8em; /* Texto m√°s peque√±o si lo tiene */
        }

        /* Mostrar el joystick y bot√≥n de acci√≥n solo en pantallas t√°ctiles o peque√±as */
        /* La visibilidad real se controla por JS, esta query es una gu√≠a */
        @media (hover: none) and (pointer: coarse), (max-width: 768px) {
            /* #joystick-container, #action-button-touch { } */
        }
        
        /* Bot√≥n para alternar visibilidad de controles del mapa en m√≥vil */
        #toggleMapControlsBtn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1005; 
            padding: 8px 12px;
            background-color: rgba(44, 24, 16, 0.8); 
            color: #f4e4bc;
            border: 1px solid #d4af37;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            display: none; 
        }
        /* Mostrar bot√≥n de alternar controles solo en m√≥vil (misma query que joystick) */
        @media (hover: none) and (pointer: coarse), (max-width: 768px) {
            #toggleMapControlsBtn {
                display: block;
            }
        }


        /* NUEVOS ESTILOS PARA LA TIENDA (ya existentes y adaptados) */
        #shopModal .modal-content {
            max-width: 95%; 
            width: auto; /* Permitir que se ajuste, el max-width lo limita */
            min-width: 300px; /* Para que no se colapse demasiado */
            max-height: 90vh; 
            overflow-y: auto;   
            padding: 20px;
            background: linear-gradient(135deg, #2c1810, #1a1a1a);
            border: 3px solid #d4af37;
            border-radius: 15px;
            display: flex; 
            flex-direction: column; 
        }

        .shop-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap; 
            flex-grow: 1; 
            overflow: hidden; 
        }

        .products-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* Reducido minmax para m√≥vil */
            gap: 15px;
            max-height: 50vh; /* Altura del scroll de productos */
            overflow-y: auto;
            padding-right: 10px;
            flex-grow: 1; /* Para que use el espacio en shop-products */
        }

        #shopModal .modal-content > div:last-child { /* Bot√≥n de Salir */
            margin-top: auto; 
            padding-top: 20px; 
            position: sticky; 
            bottom: 0;
            background: linear-gradient(135deg, #2c1810, #1a1a1a); 
            z-index: 10; 
        }

        @media (max-width: 768px) {
            #shopModal .modal-content {
                padding: 10px; 
            }

            .shop-container {
                flex-direction: column;
                overflow: visible; 
            }

            .shop-filters {
                min-width: unset; /* Quitar min-width en m√≥vil */
                width: 100%;
            }
            .shop-products {
                min-width: unset;
            }

            .products-grid {
                grid-template-columns: 1fr; 
                max-height: 40vh; /* Ajustar altura en m√≥viles */
            }

            #shopModal .modal-content > div:last-child {
                padding-top: 15px;
            }
        }
        .shop-header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(212, 175, 55, 0.1);
            border: 2px solid #d4af37;
            border-radius: 10px;
        }

        .shop-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 1.1rem;
        }

        .shop-stats span {
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid #d4af37;
        }

        .shop-filters {
            flex: 1;
            min-width: 250px;
            background: rgba(212, 175, 55, 0.1);
            border: 2px solid #d4af37;
            border-radius: 10px;
            padding: 20px;
            height: fit-content;
        }

        .shop-products {
            flex: 3;
            min-width: 300px;
            background: rgba(212, 175, 55, 0.1);
            border: 2px solid #d4af37;
            border-radius: 10px;
            padding: 20px;
            display: flex; /* Para que products-grid pueda crecer */
            flex-direction: column;
        }

        .section-title {
            color: #f4d03f;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #d4af37;
            font-size: 1.2rem;
        }

        .search-box {
            width: 100%;
            padding: 10px 15px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #d4af37;
            border-radius: 5px;
            color: #f4e4bc;
            font-size: 1rem;
        }

        .search-box::placeholder { color: #a99a7a; }
        .filter-group { margin-bottom: 20px; }
        .filter-title { margin-bottom: 10px; font-weight: bold; }
        .category-list { list-style: none; }
        .category-item {
            padding: 8px 12px; margin-bottom: 5px; cursor: pointer;
            border-radius: 5px; transition: all 0.2s;
        }
        .category-item:hover { background: rgba(212, 175, 55, 0.2); }
        .category-item.active { background: rgba(212, 175, 55, 0.4); font-weight: bold; }

        .products-grid::-webkit-scrollbar { width: 8px; }
        .products-grid::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.2); border-radius: 10px; }
        .products-grid::-webkit-scrollbar-thumb { background: #d4af37; border-radius: 10px; }

        .product-card {
            background: rgba(0, 0, 0, 0.3); border: 1px solid #d4af37;
            border-radius: 8px; padding: 15px; transition: all 0.3s;
        }
        .product-card:hover { transform: translateY(-5px); box-shadow: 0 5px 15px rgba(212, 175, 55, 0.2); }
        .product-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .product-name { font-weight: bold; font-size: 1.1rem; color: #f4d03f; }
        .product-price { font-size: 1.1rem; color: #f4d03f; }
        .product-type { display: inline-block; padding: 3px 8px; font-size: 0.8rem; border-radius: 10px; background: rgba(212, 175, 55, 0.3); margin-top: 5px; }
        .product-description { margin: 10px 0; font-size: 0.9rem; color: #e6d8b5; min-height: 60px; }
        .product-stats { margin: 10px 0; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px; font-size: 0.9rem; }
        .product-stats div { margin-bottom: 5px; }
        .product-actions { display: flex; justify-content: space-between; gap: 10px; }
        .buy-btn {
            flex-grow: 1; padding: 8px 15px; background: linear-gradient(135deg, #d4af37, #b8941f);
            color: #2c1810; border: none; border-radius: 5px; font-weight: bold;
            cursor: pointer; transition: all 0.2s;
        }
        .buy-btn:hover { background: linear-gradient(135deg, #f4d03f, #d4af37); }
        .buy-btn:disabled { background: #666; color: #999; cursor: not-allowed; }
        .pagination { display: flex; justify-content: center; margin-top: 20px; gap: 10px; }
        .page-btn {
            padding: 8px 15px; background: rgba(212, 175, 55, 0.2); border: 1px solid #d4af37;
            border-radius: 5px; color: #f4e4bc; cursor: pointer; transition: all 0.2s;
        }
        .page-btn:hover { background: rgba(212, 175, 55, 0.4); }
        .page-btn.active { background: rgba(212, 175, 55, 0.6); font-weight: bold; }

        .cultivation-option-btn {
            display: block; width: 100%; padding: 10px; margin-bottom: 8px; text-align: left;
        }
    </style>
</head>
<body>
    <!-- PANEL LATERAL -->
    <input type="file" id="fileInput" accept=".json" style="display: none;">
    <button id="toggleMapControlsBtn">Ocultar Controles</button> <!-- Bot√≥n para ocultar/mostrar controles -->

    <div class="game-container">
        <div class="map-container">
            <div class="map" id="gameMap"></div>
            <div class="tile player" id="player">üßò</div>
        </div>
        <div id="joystick-container">
            <div id="joystick-pad">
                <div id="joystick-handle"></div>
            </div>
        </div>
        <button id="action-button-touch">Acci√≥n</button>
        
        <div class="sidebar">
            
            <div class="stats-panel">
                <h3>Cultivador</h3>
                <p>Coords: <span id="playerCoords">X: 0, Y: 0</span></p> <!-- NUEVA L√çNEA -->
                <p>Nivel: <span id="playerLevel">1</span></p>
                <p>Reino: <span id="playerRealm">Mortal</span></p>
                
                <div>Vida: <span id="hpText">100/100</span></div>
                <div class="stat-bar">
                    <div class="stat-fill hp-fill" id="hpBar" style="width: 100%"></div>
                </div>
                
                <div>Man√°: <span id="manaText">50/50</span></div>
                <div class="stat-bar">
                    <div class="stat-fill mana-fill" id="manaBar" style="width: 100%"></div>
                </div>
                
                <div>Experiencia: <span id="expText">0/100</span></div>
                <div class="stat-bar">
                    <div class="stat-fill exp-fill" id="expBar" style="width: 0%"></div>
                </div>
            </div>

            <div class="inventory-panel">
                <h3>Inventario</h3>
                <div class="inventory-grid" id="inventory"></div>
            </div>

            <div class="controls-panel">
                <h3>Controles</h3>
                <p><strong>Escritorio:</strong></p>
                <p>WASD/Flechas: Moverse</p>
                <p>ESPACIO: Interactuar</p>
                <p style="margin-top: 5px;"><strong>M√≥vil:</strong></p>
                <p>Joystick: Moverse</p>
                <p>Bot√≥n Acci√≥n: Interactuar</p>
                <p>"Ocultar/Mostrar Controles": Alterna visibilidad de controles t√°ctiles.</p>
                
                <button id="cultivateButton" onclick="toggleCultivation()">üßò‚Äç‚ôÄÔ∏è Cultivar </button> 
                <button onclick="showTechniquePanel()">üìñ T√©cnicas</button>
                <button id="toggleQiConversionButton" onclick="toggleQiConversionMode()" style="display: none;">‚òØÔ∏è Activar Conversi√≥n Qi</button>        
                <button onclick="saveGame()">üíæ Guardar Partida</button>
                <button onclick="triggerFileUpload()">üìÅ Cargar Partida</button>
                <button onclick="showHelp()">‚ùì Ayuda</button>
            </div>
            <div class="secta-panel"> 
                <h3><span id="sectaNombreDisplay">Secta</span></h3>
                <p>Rango: <span id="playerSectRank">Disc√≠pulo Externo</span></p>
                <p>Puntos de Contribuci√≥n: <span id="playerPCS">0</span> PCS</p>
                <h4>Misiones Activas:</h4>
                <div id="activeMissionsList" style="font-size: 0.9em; max-height: 150px; overflow-y: auto;">
                    <p>Ninguna misi√≥n activa.</p>
                </div>
            </div>
        </div>
    </div>
    <!-- FIN PANEL LATERAL -->
    <!-- Pantalla de Combate -->
    <div class="battle-screen" id="battleScreen">
        <div class="battle-area">
            <div class="character">
                <div class="character-sprite">üßò</div>
                <h3 id="playerBattleName">Cultivador</h3>
                <div>Vida: <span id="playerBattleHp">100/100</span></div>
                <div class="stat-bar">
                    <div class="stat-fill hp-fill" id="playerBattleHpBar" style="width: 100%"></div>
                </div>
            </div>
            
            <div class="enemy">
                <div class="enemy-sprite" id="enemySprite">üëπ</div>
                <h3 id="enemyName">Demonio</h3>
                <div>Vida: <span id="enemyHp">80/80</span></div>
                <div class="stat-bar">
                    <div class="stat-fill hp-fill" id="enemyHpBar" style="width: 100%"></div>
                </div>
            </div>
        </div>
        
        <div class="battle-actions">
            <div class="action-buttons" id="battleActionButtons"> 
                {/* Botones de batalla se generan por JS */}
            </div>
            <div class="log" id="battleLog"></div>
        </div>
    </div>

    <!-- Modal para Cultivo Activo  -->
    <div class="modal" id="activeCultivationModal">
        <div class="modal-content" style="max-width: 450px;">
            <h3 id="activeCultivationTitle">Cultivando...</h3>
            <p id="activeCultivationDescription">Concentrando tu energ√≠a...</p>
            
            <div id="activeCultivationProgressUI" style="display: none;">
                <p>Progreso: <span id="activeCultivationTargetName">T√©cnica X</span> (Nv. <span id="activeCultivationTargetLevel">Y</span>)</p>
                <div class="stat-bar" style="background: #444; margin: 10px 0;">
                    <div class="stat-fill exp-fill" id="activeCultivationProgressBar" style="width: 0%; background: linear-gradient(90deg, #ffd700, #ffae42);"></div>
                </div>
                <p id="activeCultivationProgressText">0s / 0s</p>
            </div>

            <div id="recoveryCultivationProgressUI" style="display: none; margin-top:15px;">
                <p>Absorbiendo Qi del entorno...</p>
                <div class="stat-bar" style="background: #2c1810; margin: 10px 0; border-color: #66ccff;">
                    <div class="stat-fill" id="recoveryProgressBar" style="width: 0%; background: linear-gradient(90deg, #66ccff, #99ddff); transition: width 0.9s linear;"></div>
                </div>
                <p><span id="recoveryCycleText"></span></p>
                
                <!-- NUEVAS BARRAS DE HP Y MAN√Å PARA RECUPERACI√ìN -->
                <div style="margin-top: 15px; font-size: 0.9em;">
                    <div>Vida: <span id="modalHpText">100/100</span></div>
                    <div class="stat-bar">
                        <div class="stat-fill hp-fill" id="modalHpBar" style="width: 100%"></div>
                    </div>
                    
                    <div>Man√°: <span id="modalManaText">50/50</span></div>
                    <div class="stat-bar">
                        <div class="stat-fill mana-fill" id="modalManaBar" style="width: 100%"></div>
                    </div>
                </div>
                <!-- FIN NUEVAS BARRAS -->
            </div>
            <!-- NUEVA SECCI√ìN PARA ACELERACI√ìN -->
            <div id="cultivationBoostSection" style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #555;">
                <p>Piedras Espirituales: <span id="cultivationModalPlayerStones">0</span></p>
                <button id="boostCultivationButton" onclick="boostCultivationProgress()" style="margin-top: 8px; width:100%;">
                    ‚ö° Acelerar Cultivo (1 Piedra = 10s)
                </button>
            </div>

            <button onclick="stopCultivation()" style="margin-top: 20px;">üö´ Detener Cultivo</button>
        </div>
    </div>

    <!-- Modal para tienda -->
    <div class="modal" id="shopModal">
        <div class="modal-content"> {/* Estilos de ancho/alto ya definidos en CSS */ }
            <div class="shop-header">
                <h2 id="shopName">Pabell√≥n de Tesoros del Drag√≥n Oculto</h2>
                <div class="shop-stats">
                    <span id="playerSpiritualStones">Piedras Espirituales: 0</span>
                </div>
            </div>
            <div class="shop-container">
                <div class="shop-filters">
                    <h3 class="section-title">Filtros</h3>
                    <input type="text" class="search-box" id="shopSearch" placeholder="Buscar...">
                    <div class="filter-group">
                        <div class="filter-title">Categor√≠as</div>
                        <ul class="category-list" id="shopCategories">
                            <li class="category-item active" data-category="all">Todas</li>
                            <li class="category-item" data-category="combat">T. Combate</li>
                            <li class="category-item" data-category="cultivation">T. Cultivo</li>
                            <li class="category-item" data-category="weapon">Armas</li>
                            <li class="category-item" data-category="armor">Armaduras</li>
                            <li class="category-item" data-category="consumable">Consumibles</li>
                            <li class="category-item" data-category="material">Materiales</li>
                            <li class="category-item" data-category="scroll">Rollos</li>
                        </ul>
                    </div>
                    <div class="filter-group">
                        <div class="filter-title">Rango de Precio</div>
                        <div><input type="range" id="priceRange" min="0" max="1000" value="1000" style="width: 100%;"></div>
                        <div style="display: flex; justify-content: space-between; font-size:0.8em;">
                            <span>0 PS</span><span id="priceRangeValue">1000 PS</span>
                        </div>
                    </div>
                </div>
                <div class="shop-products">
                    <h3 class="section-title">T√©cnicas y Objetos</h3>
                    <div class="products-grid" id="shopProducts"></div>
                    <div class="pagination" id="shopPagination"></div>
                </div>
            </div>
            <div> 
                <button onclick="closeShopModal()" style="margin-top:20px;">Salir de la Tienda</button>
            </div>
        </div>
    </div>

     <!-- Modal para Secta -->
    <div class="modal" id="sectHallModal">
        <div class="modal-content" style="max-width: 600px; text-align: left;">
            <h3 id="sectHallModalTitle">Sal√≥n de la Secta del Viento Azure</h3>
            <div id="sectHallOptions">
                <p>Bienvenido, Disc√≠pulo <span id="sectHallPlayerRank">Externo</span>.</p>
                <p>Puntos de Contribuci√≥n: <span id="sectHallPlayerPCS">0</span></p>
                <hr>
                <h4>Tabl√≥n de Misiones</h4>
                <div id="sectHallAvailableMissions" style="max-height: 150px; overflow-y: auto; margin-bottom: 10px; border: 1px solid #444; padding: 5px;">
                    <p>Habla con el Gu√≠a Lin para nuevas asignaciones.</p>
                </div>
                <h4>Contribuciones a la Secta</h4>
                <div id="sectHallContributions" style="margin-bottom: 10px;">
                    <p>Visita al Administrador Yao para entregar recursos.</p>
                </div>
                <h4>Desaf√≠os de Rango</h4>
                <div id="sectHallRankChallenges" style="margin-bottom: 10px;">
                    <p id="sectHallChallengeStatus">Consulta con el Maestro de la Arena.</p>
                </div>
                <h4>Tienda de la Secta</h4>
                <button onclick="openSectShop()">Visitar Dep√≥sito de la Secta</button> 
                <hr>
            </div>
            <button onclick="closeSectHallModal()" style="display: block; margin: 20px auto 0;">Salir del Sal√≥n</button>
        </div>
    </div>
        
    

    <!-- Modal para Selecci√≥n de Cultivo -->
    <div class="modal" id="cultivationChoiceModal">
        <div class="modal-content" style="max-width: 500px; text-align: left;">
            <h3>¬øQu√© deseas cultivar?</h3>
            <div id="cultivationOptionsContainer">
                <button class="cultivation-option-btn" onclick="startCultivationMode('recovery')">üßò Meditaci√≥n Restauradora</button>
                <hr>
                <h4>Cultivar T√©cnica:</h4>
                <div id="cultivableTechniquesList" style="max-height: 200px; overflow-y: auto;"></div>
            </div>
            <button onclick="closeCultivationChoiceModal()" style="margin-top: 20px;">Cancelar</button>
        </div>
    </div>

    <!-- Modal gen√©rico para interacciones y notificaciones -->
    <div class="modal" id="interactionModal">
        <div class="modal-content" style="max-width: 450px;">
            <h3 id="modalTitle">T√≠tulo del Modal</h3>
            <p id="modalText" style="margin-top: 15px; margin-bottom: 20px; line-height: 1.5;">Texto.</p>
            <button onclick="closeModal()" class="close-modal-btn">Cerrar</button> 
        </div>
    </div>

    <!-- Modal para T√©cnicas -->
    <div class="modal" id="techniqueModal">
        <div class="modal-content" style="max-width: 600px; text-align: left;">
            <h3 style="text-align: center;">T√©cnicas Aprendidas</h3>
            <div id="learnedTechniquesContainer" style="margin-top: 15px; max-height: 400px; overflow-y: auto; padding-right: 10px;">
            </div>
            <button onclick="closeTechniqueModal()" style="display: block; margin: 20px auto 0;">Cerrar</button>
        </div>
    </div>
    
    <script>
    // --- ESTADO DEL JUEGO ---
   // --- ESTADO DEL JUEGO ---
   let gameState = { /* ... (tu gameState existente sin cambios) ... */ };
     // Estado del juego y datos principales
        gameState = {
            player:{

                x: 11,
                y: 15,
                level: 1,
                baseMaxHp: 100,
                baseMaxMana: 50,
                baseAttack: 15,
                baseDefense: 5,
                hp: 100,
                maxHp: 100,
                mana: 50,
                maxMana: 50,
                attack: 15,
                defense: 5,
                exp: 0,
                expToNext: 100,
                realm: "Mortal",
                isCultivating: false,
                cultivationMode: { 
                    type: null, 
                    targetId: null, 
                    startTime: 0, 
                },
                cultivationStartTime: 0,
                qiPerSecondBase: 1,
                expPerSecondBase: 0.5,
                hpPerSecondBase: 1,
                learnedTechniques: {}, 
                activeRefiningTechniqueId: null,
                canUseQiConversion: false,
                isQiConversionActive: false,
                worldState: {
                    defeatedBosses: {},
                    currentBossToSpawn: "boss_demon_general"
                },
                secta: {
                    nombre: "Secta del Viento Azure", 
                    rango: "Disc√≠pulo Externo",
                    puntosContribucion: 0,
                    misionesActivas: [], 
                    misionesCompletadas: {}, 
                    rivalesDerrotadosClave: {} 
                },
                // ---- PROPIEDADES DE ANIMACI√ìN DEL SPRITE - ASEG√öRATE QUE EST√âN AQU√ç Y CORRECTAS ----
                spriteSheetUrl: 'img/personaje_cultivador_spritesheet.png',
                frameWidth: 64,     // Ancho de un solo frame del sprite
                frameHeight: 64,    // Alto de un solo frame del sprite
                directionRowMap: {  // Mapeo de direcci√≥n a la fila Y en la hoja de sprites (0-indexed)
                    'down': 0,      // Fila 0 para mirar/caminar hacia abajo
                    'left': 1,      // Fila 1 para mirar/caminar hacia la izquierda
                    'right': 2,     // Fila 2 para mirar/caminar hacia la derecha
                    'up': 3         // Fila 3 para mirar/caminar hacia arriba
                },
                animationFrames: 4, // N√∫mero de frames por direcci√≥n en la hoja
                currentFrame: 0,    // Frame actual de la animaci√≥n (0 a animationFrames - 1)
                currentDirection: 'down', // Direcci√≥n inicial: 'up', 'down', 'left', 'right'
                isMoving: false,
                animationTimer: null, // Para el intervalo de la animaci√≥n de caminar
                idleTimeout: null,    // Para volver al estado idle despu√©s de moverse
                animationSpeed: 150,  // Milisegundos entre frames de animaci√≥n
                // ---- FIN PROPIEDADES DE ANIMACI√ìN ----
                // NUEVO: Para animaci√≥n de sprites
                sprites: {
                    idle: 'img/personaje_cultivador_idle.png', // O 'img/personaje_cultivador_down.png' si es tu frontal
                    up: 'img/personaje_cultivador_up.png',
                    down: 'img/personaje_cultivador_down.png',
                    left: 'img/personaje_cultivador_left.png',
                    right: 'img/personaje_cultivador_right.png'
                },
                currentSpriteKey: 'idle', // 'idle', 'up', 'down', 'left', 'right'
                movementAnimationTimeout: null,
                // FIN NUEVO
                burningTurns: 0,
                burnDamage: 0,
                poisonedTurns: 0,
                poisonDamage: 0,
                defenseBoostTurns: 0,
                defenseBoostAmount: 0, 
                dodgeNextAttack: false,
                healingRainTurns: 0,
                healingRainAmount: 0,
                // Para Ritual de Sangre
                bloodRitualTurns: 0,
                bloodRitualAttackBoost: 0,
                // Para Aura de Pureza
                immuneTurns: 0,
                // Para Clon Fantasma
                cloneActive: false,
                cloneHealth: 0,
                cloneTurns: 0,
                // Para Elemental
                elementalTurns: 0,
                tempAttackBonus: 0,
                tempDefenseBonus: 0,
                // Para Barrera M√≠stica
                magicShieldValue: 0,
                magicShieldTurns: 0,
                // Para Cambio Temporal (si se implementa un efecto directo)
                temporalShiftTurns: 0,


            },
            cultivationInterval: null,
            inventory: {
                "Piedras Espirituales": 0,
                "Hierbas Medicinales": 0,
                "Cristales de Qi": 0
            },
            map: {
                width: 200, // M√°s peque√±o para pruebas iniciales
                height: 200,
                defaultTerrain: 'GRASSLAND',
                terrainZones: [
                    // Ejemplo de Zona de Inicio cerca de la Secta (PRADERA)
                    {
                        x1: 10, y1: 10, x2: 29, y2: 29, type: 'GRASSLAND', name: 'Praderas de la Secta',
                        spawnSettings: {
                            targetEntities: [ // Lista de objetivos de spawn para esta zona
                                { entityTypeId: 'monster_secta_debil', count: 10, currentCount: 0 },
                                { entityTypeId: 'monster', count: 10, currentCount: 0 },
                                { entityTypeId: 'resource_hierbas_bosque', count: 3, currentCount: 0 },
                                { entityTypeId: 'cristal_qi', count: 3, currentCount: 0 },
                                { entityTypeId: 'cultivator_rival_low', count: 5, currentCount: 0 },
                                
                                

                            ],
                            respawnTimer: 0, // Cuando llegue a 0, puede reaparecer
                            respawnCooldown: 300, // Segundos para reaparecer despu√©s de vaciarse o parcialmente
                            lastSpawnCheck: 0 // Timestamp del √∫ltimo intento de spawn
                        }
                    },
                    // Bosque Esmeralda
                    {
                        x1: 30, y1: 10, x2: 59, y2: 39, type: 'FOREST', name: 'Bosque Esmeralda',
                        spawnSettings: {
                            targetEntities: [
                                { entityTypeId: 'monster_bosque_lobo', count: 8, currentCount: 0 },
                                { entityTypeId: 'monster_bosque_arana', count: 5, currentCount: 0 },
                                { entityTypeId: 'resource_hierbas_bosque', count: 3, currentCount: 0 },
                                { entityTypeId: 'monster_alpha', count: 5, currentCount: 0 },
                            ],
                            respawnTimer: 0,
                            respawnCooldown: 450, // M√°s lento para recursos quiz√°
                            lastSpawnCheck: 0
                        }
                    },
                    // Desierto Abrasador
                    {
                        x1: 10, y1: 40, x2: 89, y2: 69, type: 'DESERT', name: 'Desierto Abrasador',
                        spawnSettings: {
                            targetEntities: [
                                { entityTypeId: 'monster_desierto_escorpion', count: 7, currentCount: 0 },
                                { entityTypeId: 'monster_desierto_golem_arena', count: 2, currentCount: 0, isElite: true } // Golem como elite
                            ],
                            respawnTimer: 0,
                            respawnCooldown: 600,
                            lastSpawnCheck: 0
                        }
                    },
                     // RUINAS
                     {
                        x1: 10, y1: 100, x2: 45, y2: 250, type: 'RUINS', name: 'Ruinas antiguas',
                        spawnSettings: {
                            targetEntities: [
                                { entityTypeId: "boss_ancient_golem", count: 20, currentCount: 0 },
                                { entityTypeId: "esqueleto_podrido", count: 25, currentCount: 0 },
                                
                            ],
                            respawnTimer: 0,
                            respawnCooldown: 400,
                            lastSpawnCheck: 0
                        }
                    },
                    // Ci√©naga Sombr√≠a 
                    {
                        x1: 35, y1: 15, x2: 45, y2: 25, type: 'SWAMP', name: 'Ci√©naga Sombr√≠a',
                        spawnSettings: {
                            targetEntities: [
                                { entityTypeId: 'monster_cienaga_serpiente', count: 4, currentCount: 0 },
                            ],
                            respawnTimer: 0,
                            respawnCooldown: 400,
                            lastSpawnCheck: 0
                        }
                    },
                    // ... otras zonas (monta√±as, ruinas, agua sin spawns de monstruos terrestres)
                    { x1: 0,  y1: 0,  x2: 199, y2: 9, type: 'MOUNTAIN', name: 'Monta√±as del Norte' }, // Sin spawnSettings = no spawns
                    // ...
                    // ARENA DE LA SECTA
                    {
                    x1: 2, y1: 12, x2: 8, y2: 17, // Ejemplo de coordenadas (ajusta seg√∫n tu mapa)
                    type: 'ARENA', // Puedes usar 'DESERT' o crear un G_TERRAIN_TYPES.ARENA
                    name: 'Arena de la Secta',
                    // No necesita spawnSettings por ahora, a menos que quieras peque√±os mobs decorativos all√≠.
                },
                ],
                terrainGrid: null,
                entities: [],
           
            },
            battle: {
                active: false,
                enemy: null,
                playerTurn: true
            },
            gameTime: 0, // Un simple contador de segundos del juego para los temporizadores
            lastGameTimeUpdate: Date.now(),
            activeCombatAbilities: [] 

        };




    // --- CONSTANTES Y DATOS DEL JUEGO --- (sin cambios, deben estar aqu√≠)
    let G_TILE_SIZE = 100; // Valor por defecto para escritorio
    const G_PLAYER_DISCOVERY_RANGE = 3; 
    // --- VARIABLES GLOBALES ADICIONALES PARA CONTROL UI M√ìVIL ---
    let mapControlsManuallyHidden = false;
    let currentTileSize = G_TILE_SIZE; // Usaremos este para los c√°lculos de renderizado
    let recoveryProgress = 0;
    let recoveryDirection = 1; // 1 para aumentar, -1 para disminuir
    const RECOVERY_CYCLE_DURATION = 2;
    const G_COMBAT_ENTITY_TYPES = ['monster',"esqueleto_podrido","bandido_desfiladero",'monster_desierto_escorpion','monster_secta_debil', 'monster_alpha', 'cultivator_rival_low', 'cultivator_adept_hostile', 'boss_demon_general', 'boss_ancient_golem','monster_cienaga_serpiente','monster_bosque_lobo','monster_bosque_arana','monster_desierto_golem_arena'];
    const G_MAX_MAP_ENTITIES = 30;
    const G_RESPAWN_THRESHOLD = 15; 
    const G_SAFE_RESPAWN_X = 10;
    const G_SAFE_RESPAWN_Y = 10;
    const G_SAFE_RESPAWN_SEARCH_RADIUS = 3; 
    const G_TERRAIN_TYPES = {
    GRASSLAND: { symbol: 'üü©', color: '#34A853', name: 'Pradera' }, // Verde para pastizales
    FOREST:    { symbol: 'üå≤', color: '#1E824C', name: 'Bosque' },   // Verde oscuro para bosques
    MOUNTAIN:  { symbol: '‚õ∞Ô∏è', color: '#A9A9A9', name: 'Monta√±a' }, // Gris para monta√±as
    WATER:     { symbol: 'üü¶', color: '#4A86E8', name: 'Agua' },    // Azul para agua (intransitable)
    RUINS:     { symbol: 'üèõÔ∏è', color: '#706050', name: 'Ruinas' },  // Marr√≥n/Gris para ruinas
    DESERT:    { symbol: 'üü®', color: '#F9E79F', name: 'Desierto' },// Amarillo claro para desierto
    SWAMP:     { symbol: 'üü™', color: '#5D3A9A', name: 'Pantano' },  // P√∫rpura/Verde oscuro para pantano
    ARENA:     { symbol: 'üèüÔ∏è', color: '#D2B48C', name: 'Arena' } 
    // A√±ade m√°s seg√∫n necesites
    
        };

    const PLAYER_SPRITE_FRAME_WIDTH = 64;  // <--- ¬°AJUSTA ESTO AL ANCHO DE UN FRAME DE TU SPRITE!
    const PLAYER_SPRITE_FRAME_HEIGHT = 64; // <--- ¬°AJUSTA ESTO AL ALTO DE UN FRAME DE TU SPRITE!
    const PLAYER_ANIMATION_SPEED = 150; // Milisegundos entre frames de caminata (ajusta a gusto)
    const PLAYER_WALK_CYCLE = [0, 1, 0, 2]; // Los frames de columna a ciclar para caminar. 
                                            // Si tu animaci√≥n es 0-1-2-1, ser√≠a [0,1,2,1]
                                            // Si es 0-1-0-2 ser√≠a [0,1,0,2] (para un efecto de pie y luego paso)
                                            // Para tu sprite de 4 frames por direcci√≥n: [0, 1, 2, 3] y el frame 0 es el de "quieto"
                                            // o puedes usar [1,2,3,0] si el 0 es un frame de paso
                                            // Una animaci√≥n com√∫n es "quieto" -> paso1 -> "quieto" -> paso2
                                            // O para ciclo continuo: paso1 -> paso2 -> paso3 -> paso4 -> paso1 ...
                                            // Para el sprite que mostraste, parece ser:
                                            // Frame 0: Quieto
                                            // Frame 1: Paso A
                                            // Frame 2: Quieto (o un frame intermedio)
                                            // Frame 3: Paso B
                                            // Entonces un ciclo podr√≠a ser [0, 1, 0, 3] o [1,0,3,0] para animaci√≥n mientras se mueve
                                            // O si todos son frames de paso: [0,1,2,3]
                                            // VAMOS A USAR UN CICLO [1,0,3,0] (asumiendo frame 0 es el base/quieto y 1,3 son pasos)
                                            // Si el frame 0 es un paso y el personaje se "desliza" al estar quieto, cambia esto.
    // Definir las posiciones Y del sprite sheet para cada direcci√≥n
    const PLAYER_SPRITE_DIRECTIONS_Y = {
        'down': 0 * PLAYER_SPRITE_FRAME_HEIGHT,  // Fila 1 (√≠ndice 0) para caminar hacia abajo
        'left': 1 * PLAYER_SPRITE_FRAME_HEIGHT,  // Fila 2 (√≠ndice 1) para caminar hacia la izquierda
        'right': 2 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 3 (√≠ndice 2) para caminar hacia la derecha
        'up': 3 * PLAYER_SPRITE_FRAME_HEIGHT,    // Fila 4 (√≠ndice 3) para caminar hacia arriba
    };
    // Podr√≠amos a√±adir una propiedad 'walkable' a cada tipo de terreno
    G_TERRAIN_TYPES.MOUNTAIN.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
    G_TERRAIN_TYPES.WATER.walkable = false;
    // Por defecto, asumimos que son transitables si no se especifica 'walkable: false'
    const G_BLOCKING_ENTITY_TYPES = [
    'shop',
    'secta_entrada_principal',
    "npc_secta_guia",
    "npc_secta_admin",

    // A√±ade aqu√≠ otros 'originalEntityTypeId' o 'type' de entidades que deben bloquear
    // Por ejemplo, si tus NPCs tienen un 'type' espec√≠fico o los identificas por 'npcId'
    ];
    const SECTA_DATA = {
        nombre: "Secta del Viento Azure",
        rangos: [
            { nombre: "Disc√≠pulo Externo", pcsRequeridos: 0, beneficios: "Acceso b√°sico a la secta." },
            { nombre: "Disc√≠pulo Interno", pcsRequeridos: 50, desafioRivalId: "rival_interno_1", beneficios: "Acceso al Patio Interno, misiones de mayor nivel, +5% ganancia de Qi al cultivar en la secta." },
            { nombre: "Disc√≠pulo Principal", pcsRequeridos: 200, desafioRivalId: "rival_principal_1", beneficios: "Acceso a la Biblioteca de T√©cnicas (nuevas t√©cnicas), +10% ganancia de EXP en misiones de secta." },
            { nombre: "Di√°cono", pcsRequeridos: 500, desafioRivalId: "guardian_diacono_1", beneficios: "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir peque√±os grupos de disc√≠pulos (mec√°nica futura)." },
            { nombre: "Anciano", pcsRequeridos: 1500, desafioRivalId: "guardian_anciano_1", beneficios: "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir medianos grupos de disc√≠pulos (mec√°nica futura)." },
            { nombre: "Gran Anciano", pcsRequeridos: 2500, desafioRivalId: "guardian_gran_anciano_1", beneficios: "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir grandes grupos de disc√≠pulos (mec√°nica futura)." },
            { nombre: "Maestro de Secta", pcsRequeridos: 5000, desafioRivalId: "guardian_maestro_1", beneficios: "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir la secta completa (mec√°nica futura)." },
        ],
        npcs: {
            "guia_lin": {
                nombre: "Gu√≠a Lin",
                rol: "Maestro de Reclutas",
                dialogoInicial: "Bienvenido, joven aspirante... ¬øEst√°s listo para empezar?",
                misionesOfrecidas: [ 
                    "mision_recolectar_hierbas_1", // Aunque la entrega sea a Yao, Lin puede ofrecerla
                    "mision_eliminar_demonios_1",
                    "mision_lobos_bosque_1",       // Nueva misi√≥n ofrecida por Lin
                    "mision_cultivador_hostil_1", // Nueva misi√≥n ofrecida por Lin
                    "mision_componentes_alquimia_1",
                    "mision_investigar_anomalia_1",
                    "mision_cazar_bestia_especifica_1",
                    "mision_escolta_mercader_1",
                    "mision_recuperar_artefacto_1"
                    // ... a√±ade m√°s ID de misiones que Lin ofrezca
                ]
            },
            "admin_yao": {
                nombre: "Administrador Yao",
                rol: "Intendente de la Secta",
                dialogoInicial: "Entrega recursos valiosos o completa encargos para ganar Puntos de Contribuci√≥n. Tambi√©n puedes adquirir algunos suministros aqu√≠.",
                aceptaRecursos: ["Hierbas Medicinales", "Cristales de Qi", "N√∫cleo de Bestia Menor"], // ...etc.
                tiendaSectaId: "tienda_secta_basica",
                misionesOfrecidas: [
                    "mision_escorpiones_desierto_1" // Nueva misi√≥n ofrecida por Yao
                    // ... a√±ade m√°s ID de misiones que Yao ofrezca
                ]
            }
        }
    };
    const MISIONES_DATA = {
        "mision_recolectar_hierbas_1": {
            titulo: "Suministros para la Enfermer√≠a",
            descripcion: "La hermana mayor Mei necesita 10 Hierbas Medicinales para reponer las existencias de la enfermer√≠a. Recolecta Hierbas Medicinales y entr√©gaselas al Administrador Yao.",
            objetivo: { tipo: "entregar_item", item: "Hierbas Medicinales", cantidad: 10, npcEntrega: "admin_yao" },
            recompensa: { pcs: 50, exp: 100, items: { "Piedras Espirituales": 20 } },
            npcInicio: "guia_lin"
        },
        "mision_eliminar_demonios_1": {
            titulo: "Limpiando el Bosque Perif√©rico",
            descripcion: "Peque√±os demonios han estado merodeando el bosque cercano a la secta. Elimina 5 Demonios Menores para asegurar el √°rea.",
            objetivo: { tipo: "eliminar_enemigo", enemigoTipo: "monster", cantidad: 5, nombreDisplay: "Demonio Menor" },
            recompensa: { pcs: 75, exp: 150, items: { "Piedras Espirituales": 30 } },
            progreso: 0, npcInicio: "guia_lin"
        },
        "mision_componentes_alquimia_1": {
            titulo: "Medicina Urgente",
            descripcion: "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Ra√≠ces de Fuego Terrenal' para una p√≠ldora vital. Se dice que crecen en zonas con fluctuaciones elementales.",
            objetivo: { tipo: "recolectar_multiples_items", items: [ { nombre: "Flor de Luna Escarchada", cantidad: 3 }, { nombre: "Ra√≠z de Fuego Terrenal", cantidad: 2 } ], npcEntrega: "admin_yao" },
            recompensa: { pcs: 120, exp: 250, items: { "P√≠ldora de Recuperaci√≥n Menor": 2, "Piedras Espirituales": 50 } },
            npcInicio: "guia_lin", requisitoRango: "Disc√≠pulo Externo"
        },
        "mision_investigar_anomalia_1": {
            titulo: "Anomal√≠a en el Bosque Susurrante",
            descripcion: "Se han reportado extra√±os susurros y una energ√≠a inquietante proveniente del Bosque Susurrante al este. Investiga la fuente de la perturbaci√≥n y reporta tus hallazgos.",
            objetivo: { tipo: "explorar_y_reportar", areaClave: "BosqueSusurranteAnomalia", npcReporte: "guia_lin" },
            recompensa: { pcs: 100, exp: 200, items: { "Talism√°n de Percepci√≥n": 1 } },
            npcInicio: "guia_lin"
        },
        "mision_cazar_bestia_especifica_1": {
            titulo: "La Amenaza del Jabal√≠ Colmilludo",
            descripcion: "Un Jabal√≠ Colmilludo particolarmente agresivo ha estado atacando a los recolectores de la secta cerca del Ca√±√≥n Rocoso. Caza a esta bestia y trae su 'Colmillo intacto' como prueba.",
            objetivo: { tipo: "cazar_y_recuperar_item_de_loot", enemigoTipo: "jabali_colmilludo_alfa", itemPrueba: "Colmillo de Jabal√≠ Alfa", cantidadItemPrueba: 1, npcEntrega: "guia_lin" },
            recompensa: { pcs: 150, exp: 300, items: { "Piedras Espirituales": 70, "Carne de Bestia Ex√≥tica": 3 } },
            npcInicio: "guia_lin", requisitoNivel: 5
        },
        "mision_escolta_mercader_1": {
            titulo: "Protecci√≥n Mercantil",
            descripcion: "Un mercader aliado de la secta necesita una escolta para atravesar el Desfiladero Sombr√≠o, conocido por sus bandidos. Aseg√∫rate de que llegue a salvo al Puesto Comercial del Oeste.",
            objetivo: { tipoSimplificado: "eliminar_enemigos_en_area", enemigoTipo: "bandido_desfiladero", cantidad: 5, areaNombre: "Desfiladero Sombr√≠o", npcReporte: "admin_yao" },
            recompensa: { pcs: 250, exp: 500, items: { "Mapa del Tesoro Fragmentado": 1, "Piedras Espirituales": 150 } },
            npcInicio: "guia_lin", requisitoRango: "Disc√≠pulo Interno"
        },
        "mision_recuperar_artefacto_1": {
            titulo: "El Comp√°s Espiritual Perdido",
            descripcion: "Un antiguo Comp√°s Espiritual, vital para la navegaci√≥n en las Ruinas Olvidadas, fue robado por cultores renegados. Inf√≠ltrate en su campamento en las colinas y recupera el artefacto.",
            objetivo: { tipo: "derrotar_mini_boss_y_recuperar_item", enemigoMiniBossId: "lider_renegado_1", itemArtefacto: "Comp√°s Espiritual Antiguo", npcEntrega: "admin_yao" },
            recompensa: { pcs: 300, exp: 600, items: { "Manual de Formaci√≥n B√°sica": 1, "Piedras Espirituales": 200 } },
            npcInicio: "guia_lin", requisitoRango: "Disc√≠pulo Interno", requisitoNivel: 8
        },
        "mision_desafio_interno_1": {
            titulo: "Prueba de Disc√≠pulo Interno",
            descripcion: "Para ser reconocido como Disc√≠pulo Interno, debes demostrar tu fuerza venciendo al Guardi√°n de la Prueba, Han Li. Encu√©ntralo en la arena de desaf√≠os de la secta.",
            objetivo: { tipo: "derrotar_npc_especifico", npcId: "rival_interno_1"},
            recompensa: { pcs: 200, exp: 300, nuevoRango: "Disc√≠pulo Interno"},
            autoActivarAlCumplirRequisitos: true
        },
        "mision_desafio_principal_1": {
            titulo: "Prueba de Disc√≠pulo Principal",
            descripcion: "La Anciana Shui espera en la arena. Demuestra que eres digno del rango de Disc√≠pulo Principal.",
            objetivo: { tipo: "derrotar_npc_especifico", npcId: "rival_principal_1"},
            recompensa: { pcs: 500, exp: 800, nuevoRango: "Disc√≠pulo Principal"},
            autoActivarAlCumplirRequisitos: true
        },
        // Misiones de Ejemplo por Nivel:
        "mision_lobos_bosque_1": {
            titulo: "Amenaza Lupina",
            descripcion: "Una manada de Lobos del Bosque se ha vuelto agresiva. El Gu√≠a Lin te pide que elimines 3 de ellos.",
            objetivo: { tipo: "eliminar_enemigo", enemigoTipo: "monster_bosque_lobo", cantidad: 3, nombreDisplay: "Lobo del Bosque", npcEntrega: "guia_lin" },
            recompensa: { pcs: 100, exp: 200, items: { "Piedras Espirituales": 50, "Colmillo de Lobo": 1 } },
            npcInicio: "guia_lin",
            requisitoNivel: 5 // Se desbloquea al nivel 5
        },
        "mision_escorpiones_desierto_1": {
            titulo: "Aguijones Peligrosos",
            descripcion: "Los Escorpiones de las Dunas est√°n causando problemas a las caravanas. Elimina 5 y reporta al Administrador Yao.",
            objetivo: { tipo: "eliminar_enemigo", enemigoTipo: "monster_desierto_escorpion", cantidad: 5, nombreDisplay: "Escorpi√≥n de las Dunas", npcEntrega: "admin_yao" },
            recompensa: { pcs: 150, exp: 350, items: { "Piedras Espirituales": 70, "Aguij√≥n de Escorpi√≥n": 2 } },
            npcInicio: "admin_yao", // Puede ser otro NPC
            requisitoNivel: 10 // Se desbloquea al nivel 10
        },
        "mision_cultivador_hostil_1": {
            titulo: "Rivalidad Temprana",
            descripcion: "Un Cultivador Novato Hostil ha estado desafiando a disc√≠pulos de nuestra secta. El Gu√≠a Lin quiere que le des una lecci√≥n. Derr√≥talo.",
            objetivo: { tipo: "eliminar_enemigo", enemigoTipo: "cultivator_rival_low", cantidad: 1, nombreDisplay: "Cultivador Novato Hostil", npcEntrega: "guia_lin" },
            recompensa: { pcs: 200, exp: 400, items: { "P√≠ldora de Recuperaci√≥n Menor": 1, "Piedras Espirituales": 100 } },
            npcInicio: "guia_lin",
            requisitoNivel: 8
        },
         // Aseg√∫rate de que las misiones que quieres que se entreguen a un NPC tengan `npcEntrega` en su `objetivo`.
         "mision_componentes_alquimia_1": {
            titulo: "Medicina Urgente",
            descripcion: "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Ra√≠ces de Fuego Terrenal' para una p√≠ldora vital. Se dice que crecen en zonas con fluctuaciones elementales. Entr√©galas al Administrador Yao.",
            objetivo: { tipo: "recolectar_multiples_items", items: [ { nombre: "Flor de Luna Escarchada", cantidad: 3 }, { nombre: "Ra√≠z de Fuego Terrenal", cantidad: 2 } ], npcEntrega: "admin_yao" },
            recompensa: { pcs: 120, exp: 250, items: { "P√≠ldora de Recuperaci√≥n Menor": 2, "Piedras Espirituales": 50 } },
            npcInicio: "guia_lin", requisitoRango: "Disc√≠pulo Externo"
        },
        "mision_cazar_bestia_especifica_1": {
            titulo: "La Amenaza del Jabal√≠ Colmilludo",
            descripcion: "Un Jabal√≠ Colmilludo particolarmente agresivo ha estado atacando a los recolectores de la secta cerca del Ca√±√≥n Rocoso. Caza a esta bestia y trae su 'Colmillo intacto' como prueba al Gu√≠a Lin.",
            objetivo: { tipo: "cazar_y_recuperar_item_de_loot", enemigoTipo: "jabali_colmilludo_alfa", itemPrueba: "Colmillo de Jabal√≠ Alfa", cantidadItemPrueba: 1, npcEntrega: "guia_lin" },
            recompensa: { pcs: 150, exp: 300, items: { "Piedras Espirituales": 70, "Carne de Bestia Ex√≥tica": 3 } },
            npcInicio: "guia_lin", requisitoNivel: 5
        },
    };
 
    const shopData = {
        name: "Pabell√≥n de Tesoros del Drag√≥n Oculto",
        inventory: [
            { itemName: "Hierbas Medicinales", price: 1, stock: 100 },
            { itemName: "Cristales de Qi", price: 1, stock: 100 },
            { itemName: "Espada de Hierro", type: "equipment", category: "weapon", attackBonus: 5, price: 50, stock: 1, description: "Una espada b√°sica pero fiable. (+5 Ataque)" },
            { itemName: "Rollo: Absorci√≥n de Qi Menor", price: 15, stock: 10 },
            { itemName: "Rollo: Corte de Espada B√°sico", price: 50, stock: 10 },
            { itemName: "Rollo: Conversi√≥n de Qi", price: 25, stock: 10 },
            { itemName: "Rollo: Prisi√≥n de Hielo", price: 180, stock: 5 },
            { itemName: "Rollo: Golpe de Llamas", price: 170, stock: 5 },
            { itemName: "Rollo: Furia del Trueno", price: 190, stock: 5 },
            { itemName: "Rollo: Dardo Venenoso", price: 150, stock: 5 },
            { itemName: "Rollo: Piel de Piedra", price: 175, stock: 5 },
            { itemName: "Rollo: Paso de las Sombras", price: 220, stock: 3 },
            { itemName: "Rollo: Drenaje de Alma", price: 200, stock: 3 },
            { itemName: "Rollo: Golpe Cicl√≥n", price: 250, stock: 3 },
            { itemName: "Rollo: Lluvia Curativa", price: 210, stock: 3 },
            { itemName: "Rollo: Explosi√≥n Mental", price: 230, stock: 3 },
            { itemName: "Rollo: Voluntad de Hierro", price: 200, stock: 3 },
            { itemName: "Rollo: Flecha Celestial", price: 280, stock: 2 },
            { itemName: "Rollo: Abrazo de la Naturaleza", price: 190, stock: 3 },
            { itemName: "Rollo: Rugido de Drag√≥n", price: 300, stock: 2 },
            { itemName: "Rollo: Clon Fantasma", price: 240, stock: 2 },
            { itemName: "Rollo: Cambio Temporal", price: 260, stock: 2 },
            { itemName: "Rollo: Ritual de Sangre", price: 210, stock: 3 },
            { itemName: "Rollo: Aura de Pureza", price: 230, stock: 3 },
            { itemName: "Rollo: Invocar Elemental", price: 320, stock: 1 },
            { itemName: "Rollo: Barrera M√≠stica", price: 220, stock: 3 },
        ],
    };
    const techniqueData = {
        "qi_absorption_boost_1": { id: "qi_absorption_boost_1", name: "T√©cnica de Absorci√≥n de Qi Menor", description: "Aumenta la cantidad de Qi ganado por segundo al cultivar en 0.5.", type: "passive_cultivation", effect: { statToBoost: "qiPerSecondBase", value: 0.5 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 60, levelTimeMultiplier: 1.5 }, refinementCost: { baseTime: 30, materials: { "Piedras Espirituales": 20 }, levelRequirement: 1 }, icon: "üìú" },
        "body_fortification_1": { id: "body_fortification_1", name: "Fortificaci√≥n Corporal B√°sica", description: "Aumenta tu Defensa base permanentemente en 1 por nivel de refinamiento.", type: "passive_stat", effect: { statToBoost: "baseDefense", value: 1 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 90, levelTimeMultiplier: 2 }, refinementCost: { baseTime: 60, materials: { "Hierbas Medicinales": 3, "Piedras Espirituales": 10 }, levelRequirement: 3 }, icon: "üí™" },
        "sword_slash_1": { id: "sword_slash_1", name: "Corte de Espada B√°sico", description: "Desbloquea la habilidad de combate 'Corte de Espada'. Causa da√±o f√≠sico adicional. Mejora con refinamiento.", type: "active_ability", abilityId: "sword_slash", effect: { baseDamageMultiplier: 1.2 }, manaCost: 10, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 90, levelTimeMultiplier: 1.6 }, refinementCost: { baseTime: 45, materials: { "Cristales de Qi": 2, "Piedras Espirituales": 20 }, levelRequirement: 5 }, icon: "‚öîÔ∏è" },
        "qi_to_hp_conversion_1": { id: "qi_to_hp_conversion_1", name: "T√©cnica de Conversi√≥n de Qi", description: "Permite activar/desactivar la conversi√≥n de Man√° en HP al cultivar. Mejora la tasa de conversi√≥n y eficiencia con cada nivel de refinamiento.", type: "active_refinement_effect", effect: { baseManaCostPerSecond: 2.0, baseHpGainPerSecond: 1.0, hpGainIncreasePerLevel: 2, manaCostReductionPerLevel: 0.1 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 90, levelTimeMultiplier: 1.6 }, refinementCost: { baseTime: 60, materials: { "Cristales de Qi": 5, "Piedras Espirituales": 10 }, levelRequirement: 1 }, icon: "‚òØÔ∏è" },
        "ice_prison_1": { id: "ice_prison_1", name: "Prisi√≥n de Hielo", description: "Congela al enemigo, inmoviliz√°ndolo por 1-2 turnos.", type: "active_ability", abilityId: "ice_prison", effect: { freezeDuration: 1, freezeChance: 0.7, manaCost: 25 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 120, levelTimeMultiplier: 1.7 }, refinementCost: { baseTime: 40, materials: { "Cristal de Hielo": 3, "Piedras Espirituales": 40 }, levelRequirement: 8 }, icon: "‚ùÑÔ∏è" },
        "flame_strike_1": { id: "flame_strike_1", name: "Golpe de Llamas", description: "Ataque de fuego que causa da√±o inicial y quemadura continua.", type: "active_ability", abilityId: "flame_strike", effect: { baseDamageMultiplier: 0.9, burnDamagePerTurn: 5, burnDuration: 3, manaCost: 30 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 120, levelTimeMultiplier: 1.7 }, refinementCost: { baseTime: 45, materials: { "Esencia de Fuego": 2, "Piedras Espirituales": 35 }, levelRequirement: 10 }, icon: "üî•" },
        "thunder_fury_1": { id: "thunder_fury_1", name: "Furia del Trueno", description: "Ataque el√©ctrico que aturde al enemigo por 1 turno.", type: "active_ability", abilityId: "thunder_fury", effect: { baseDamageMultiplier: 1.1, stunChance: 0.6, manaCost: 35 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 130, levelTimeMultiplier: 1.8 }, refinementCost: { baseTime: 50, materials: { "N√∫cleo de Tormenta": 1, "Piedras Espirituales": 45 }, levelRequirement: 12 }, icon: "‚ö°" },
        "poison_dart_1": { id: "poison_dart_1", name: "Dardo Venenoso", description: "Envenena al enemigo causando da√±o por varios turnos.", type: "active_ability", abilityId: "poison_dart", effect: { baseDamageMultiplier: 0.4, poisonDamagePerTurn: 8, poisonDuration: 4, manaCost: 20 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 110, levelTimeMultiplier: 1.6 }, refinementCost: { baseTime: 35, materials: { "Venenos Mortales": 4, "Piedras Espirituales": 30 }, levelRequirement: 6 }, icon: "‚ò†Ô∏è" },
        "stone_skin_1": { id: "stone_skin_1", name: "Piel de Piedra", description: "Aumenta tu defensa temporalmente durante el combate.", type: "active_ability", abilityId: "stone_skin", effect: { defenseBoost: 15, duration: 3, manaCost: 25 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 125, levelTimeMultiplier: 1.7 }, refinementCost: { baseTime: 40, materials: { "Fragmentos de Jade": 5, "Piedras Espirituales": 35 }, levelRequirement: 9 }, icon: "ü™®" },
        "shadow_step_1": { id: "shadow_step_1", name: "Paso de las Sombras", description: "Teletransportaci√≥n corta que evita el pr√≥ximo ataque.", type: "active_ability", abilityId: "shadow_step", effect: { dodgeChance: 0.8, manaCost: 40 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 140, levelTimeMultiplier: 1.9 }, refinementCost: { baseTime: 55, materials: { "Esencia Oscura": 3, "Piedras Espirituales": 50 }, levelRequirement: 14 }, icon: "üë£" },
        "soul_drain_1": { id: "soul_drain_1", name: "Drenaje de Alma", description: "Roba vida del enemigo y cura al usuario.", type: "active_ability", abilityId: "soul_drain", effect: { baseDamageMultiplier: 0.7, lifeStealPercent: 0.5, manaCost: 30 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 130, levelTimeMultiplier: 1.8 }, refinementCost: { baseTime: 45, materials: { "Almas Condenadas": 2, "Piedras Espirituales": 40 }, levelRequirement: 11 }, icon: "üíÄ" },
        "cyclone_strike_1": { id: "cyclone_strike_1", name: "Golpe Cicl√≥n", description: "Ataque de √°rea que da√±a a todos los enemigos.", type: "active_ability", abilityId: "cyclone_strike", effect: { baseDamageMultiplier: 0.8, aoeDamage: true, manaCost: 45 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 150, levelTimeMultiplier: 2.0 }, refinementCost: { baseTime: 60, materials: { "N√∫cleo de V√≥rtice": 1, "Piedras Espirituales": 55 }, levelRequirement: 15 }, icon: "üå™Ô∏è" },
        "healing_rain_1": { id: "healing_rain_1", name: "Lluvia Curativa", description: "Cura al usuario y a aliados cercanos cada turno.", type: "active_ability", abilityId: "healing_rain", effect: { healPerTurn: 20, duration: 3, manaCost: 35 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 135, levelTimeMultiplier: 1.8 }, refinementCost: { baseTime: 50, materials: { "Roc√≠o Celestial": 4, "Piedras Espirituales": 40 }, levelRequirement: 12 }, icon: "üåßÔ∏è" },
        "mind_blast_1": { id: "mind_blast_1", name: "Explosi√≥n Mental", description: "Da√±o basado en man√° y reduce la defensa del enemigo.", type: "active_ability", abilityId: "mind_blast", effect: { baseDamageMultiplier: 0.6, manaDamageMultiplier: 0.3, defenseReduction: 5, manaCost: 40 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 145, levelTimeMultiplier: 1.9 }, refinementCost: { baseTime: 55, materials: { "Cristales Ps√≠quicos": 3, "Piedras Espirituales": 45 }, levelRequirement: 13 }, icon: "üß†" },
        "iron_will_1": { id: "iron_will_1", name: "Voluntad de Hierro", description: "Reduce el da√±o recibido y aumenta la resistencia a efectos.", type: "passive_stat", effect: { statToBoost: "damageReduction", value: 0.05 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 160, levelTimeMultiplier: 2.1 }, refinementCost: { baseTime: 50, materials: { "Mineral de Hierro Espiritual": 5, "Piedras Espirituales": 40 }, levelRequirement: 10 }, icon: "üõ°Ô∏è" },
        "celestial_arrow_1": { id: "celestial_arrow_1", name: "Flecha Celestial", description: "Ataque de largo alcance que ignora la defensa del enemigo.", type: "active_ability", abilityId: "celestial_arrow", effect: { baseDamageMultiplier: 1.2, ignoreDefense: true, manaCost: 50 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 170, levelTimeMultiplier: 2.2 }, refinementCost: { baseTime: 60, materials: { "Plumas de F√©nix": 2, "Piedras Espirituales": 60 }, levelRequirement: 16 }, icon: "üèπ" },
        "nature_grasp_1": { id: "nature_grasp_1", name: "Abrazo de la Naturaleza", description: "Enreda al enemigo reduciendo su velocidad y causando da√±o continuo.", type: "active_ability", abilityId: "nature_grasp", effect: { baseDamageMultiplier: 0.5, rootDuration: 2, damagePerTurn: 7, manaCost: 30 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 120, levelTimeMultiplier: 1.7 }, refinementCost: { baseTime: 45, materials: { "Semillas Ancestrales": 4, "Piedras Espirituales": 35 }, levelRequirement: 9 }, icon: "üåø" },
        "dragon_roar_1": { id: "dragon_roar_1", name: "Rugido de Drag√≥n", description: "Aturde y asusta a los enemigos, reduciendo su ataque.", type: "active_ability", abilityId: "dragon_roar", effect: { aoeStunChance: 0.4, attackReduction: 10, duration: 2, manaCost: 55 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 180, levelTimeMultiplier: 2.3 }, refinementCost: { baseTime: 65, materials: { "Escamas de Drag√≥n": 3, "Piedras Espirituales": 70 }, levelRequirement: 18 }, icon: "üêâ" },
        "phantom_clone_1": { id: "phantom_clone_1", name: "Clon Fantasma", description: "Crea un clon que distrae a los enemigos.", type: "active_ability", abilityId: "phantom_clone", effect: { cloneHealth: 30, duration: 2, aggroChance: 0.8, manaCost: 40 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 150, levelTimeMultiplier: 2.0 }, refinementCost: { baseTime: 50, materials: { "Espejos Astrales": 2, "Piedras Espirituales": 45 }, levelRequirement: 12 }, icon: "üë§" },
        "temporal_shift_1": { id: "temporal_shift_1", name: "Cambio Temporal", description: "Ralentiza a los enemigos y aumenta tu velocidad.", type: "active_ability", abilityId: "temporal_shift", effect: { enemySlow: 0.3, playerSpeedBoost: 0.4, duration: 3, manaCost: 45 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 160, levelTimeMultiplier: 2.1 }, refinementCost: { baseTime: 55, materials: { "Relojes de Arena": 3, "Piedras Espirituales": 50 }, levelRequirement: 14 }, icon: "‚è≥" },
        "blood_ritual_1": { id: "blood_ritual_1", name: "Ritual de Sangre", description: "Sacrifica vida para aumentar dr√°sticamente tu ataque.", type: "active_ability", abilityId: "blood_ritual", effect: { hpCost: 20, attackBoost: 30, duration: 3, manaCost: 25 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 130, levelTimeMultiplier: 1.8 }, refinementCost: { baseTime: 40, materials: { "Sangre de Demonio": 3, "Piedras Espirituales": 35 }, levelRequirement: 11 }, icon: "ü©∏" },
        "aura_of_purity_1": { id: "aura_of_purity_1", name: "Aura de Pureza", description: "Elimina efectos negativos y otorga inmunidad temporal.", type: "active_ability", abilityId: "aura_of_purity", effect: { cleanseEffects: true, immunityDuration: 2, manaCost: 35 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 140, levelTimeMultiplier: 1.9 }, refinementCost: { baseTime: 45, materials: { "L√°grimas de Unicornio": 2, "Piedras Espirituales": 40 }, levelRequirement: 13 }, icon: "‚ú®" },
        "summon_elemental_1": { id: "summon_elemental_1", name: "Invocar Elemental", description: "Invoca un elemental que lucha a tu lado durante el combate.", type: "active_ability", abilityId: "summon_elemental", effect: { elementalType: "fire", elementalHealth: 50, elementalAttack: 20, duration: 4, manaCost: 60 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 190, levelTimeMultiplier: 2.4 }, refinementCost: { baseTime: 65, materials: { "N√∫cleo Elemental": 1, "Piedras Espirituales": 65 }, levelRequirement: 17 }, icon: "üåã" },
        "mystic_barrier_1": { id: "mystic_barrier_1", name: "Barrera M√≠stica", description: "Crea un escudo que absorbe da√±o m√°gico.", type: "active_ability", abilityId: "mystic_barrier", effect: { magicShield: 40, duration: 3, manaCost: 35 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 135, levelTimeMultiplier: 1.8 }, refinementCost: { baseTime: 45, materials: { "Polvo de Arcano": 4, "Piedras Espirituales": 40 }, levelRequirement: 12 }, icon: "üîÆ" },
    };
    const entityTypes = {
        //FIJOS
        shop: {
        symbol: 'üè™',
        name: 'Tienda Misteriosa',
        interaction: 'browse',
        type: 'shop', // 'type' es importante para la interacci√≥n
        // fixedX: 12, // Podr√≠as tener esto
        // fixedY: 13, // O esto
        fixedLocation: { x: 12, y: 13 }, // O esto (preferiblemente esto)
        discovered: true // ¬°IMPORTANTE para que se muestre desde el inicio!
        },

        "secta_entrada_principal": { 
            symbol: '‚õ©Ô∏è', 
            name: 'Sal√≥n Principal de la Secta', 
            interaction: 'access_sect_hall', 
            // fixedX: 12, // Si ten√≠as esto antes
            // fixedY: 15, // Si ten√≠as esto antes
            // ASEG√öRATE DE TENER ESTO EN SU LUGAR:
            fixedLocation: { x: 15, y: 15 } // O las coordenadas correctas para tu secta
        },
      
        // --- ELEMENTOS DECORATIVOS ---
        "deco_arbol_grande": { symbol: 'üå≥', name: 'Arbol Ancestral', isDecorative: true, noInteraction: true,discovered: true },
        "deco_arbol_peque√±o": { symbol: 'üå≥', name: 'Pino', isDecorative: true, noInteraction: true,discovered: true },
        "deco_arbol_normal": { symbol: 'üå≥', name: 'Otro arbol', isDecorative: true, noInteraction: true,discovered: true },
        "deco_roca_musgosa": { symbol: 'ü™®', name: 'Roca Musgosa', isDecorative: true, noInteraction: true,discovered: true },
        "deco_ruina_pilar": { symbol: 'üèõ', name: 'Pilar Ca√≠do', isDecorative: true, noInteraction: true ,discovered: true}, // Usar un s√≠mbolo diferente si 'üèõÔ∏è' ya est√° en uso
        "deco_flor_rara": { symbol: 'üå∏', name: 'Flor Luminiscente', isDecorative: true, noInteraction: true,discovered: true }, // Diferente de tu lugar de cultivo
        // ... a√±ade m√°s seg√∫n necesites
        //ENEMIGOS
        monster: { symbol: 'üëπ', name: 'Demonio Menor', hp: 60, attack: 30, defense: 2, exp: 25, maxHp: 60, lootTable: [ { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 }, { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },{ itemName: "Piedras Espirituales", quantity: [1,2], chance: 1 }  ] },
        'monster_secta_debil': {
            symbol: 'üêæ', 
            name: 'Bestia Menor de Pradera', 
            hp: 40, 
            attack: 30, 
            defense: 1, 
            exp: 12, 
            maxHp: 40,
            lootTable: [ { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },{ itemName: "Piedras Espirituales", quantity: [1,2], chance: 1 }]
        },
        'monster_bosque_lobo': {
            symbol: 'üê∫', name: 'Lobo del Bosque', hp: 70, attack: 40, defense: 3, exp: 20, maxHp: 70,
            lootTable: [ { itemName: "Colmillo de Lobo", quantity: [1,1], chance: 0.4 }, { itemName: "Carne Fresca", quantity: [1,2], chance: 0.6 },{ itemName: "Piedras Espirituales", quantity: [1,2], chance: 1 } ]
        },
        'monster_bosque_arana': {
            symbol: 'üï∑Ô∏è', name: 'Ara√±a Tejesombras', hp: 50, attack: 45, defense: 5, exp: 18, maxHp: 50,
            lootTable: [ { itemName: "Seda de Ara√±a", quantity: [1,3], chance: 0.7 }, { itemName: "Veneno D√©bil", quantity: [1,1], chance: 0.2 },{ itemName: "Piedras Espirituales", quantity: [1,2], chance: 1 } ]
        },
        'resource_hierbas_bosque': {
            symbol: 'üåø', // <--- ¬°ASEG√öRATE DE QUE ESTO EST√â!
            name: 'Hierbas del Bosque Profundo',
            type: 'resource',
            reward: "Hierbas Medicinales",
            interaction: 'collect_resource',
            
        },
        'monster_desierto_escorpion': {
            symbol: 'ü¶Ç', name: 'Escorpi√≥n de las Dunas', hp: 90, attack: 30, defense: 8, exp: 35, maxHp: 90,specialChance: 0.35, specialAttackMultiplier: 1.8,
            abilities: [ { name: "Aguij√≥n venenoso", damageMultiplier: 2.0, chance: 0.2, type: "area_attack_simulated" },],
            lootTable: [ { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },{ itemName: "Aguij√≥n de Escorpi√≥n", quantity: [1,1], chance: 0.5 }, { itemName: "Quitina Resistente", quantity: [1,1], chance: 0.3 },{ itemName: "Piedras Espirituales", quantity: [2,4], chance: 1 } ]
        },
        'monster_desierto_golem_arena': {
            symbol: 'üß±', name: 'Golem de Tormenta de Arena', hp: 200, attack: 35, defense: 15, exp: 80, maxHp: 200,specialChance: 0.35, specialAttackMultiplier: 1.8,
            abilities: [ { name: "Tornado de arena", damageMultiplier: 2.0, chance: 0.2, type: "area_attack_simulated" },{ name: "stone_skin_1", effect: { defenseBoost: 15, duration: 3, manaCost: 25 }, chance: 0.2, type: "area_attack_simulated" }],
            lootTable: [ { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },{ itemName: "N√∫cleo de Arena", quantity: [1,1], chance: 0.6 }, { itemName: "Fragmento Des√©rtico", quantity: [1,2], chance: 0.4 },{ itemName: "Piedras Espirituales", quantity: [4,8], chance: 1 } ]
        },
        'monster_cienaga_serpiente': {
            symbol: 'üêç', name: 'Serpiente de Ci√©naga', hp: 60, attack: 28, defense: 2, exp: 22, maxHp: 60,specialChance: 0.35, specialAttackMultiplier: 1.8,
            abilities: [ { name: "Mordida Venenosa", damageMultiplier: 2.0, chance: 0.4, type: "area_attack_simulated" },],
            lootTable: [ { itemName: "Escama de Serpiente", quantity: [1,2], chance: 0.5 }, { itemName: "Veneno de Ci√©naga", quantity: [1,1], chance: 0.3 },{ itemName: "Piedras Espirituales", quantity: [2,4], chance: 1 } ]
        },
        cultivator_rival_low: { symbol: 'üò†', name: 'Cultivador Novato Hostil', hp: 150, attack: 50, defense: 5, exp: 80, maxHp: 150, specialChance: 0.2, specialAttackMultiplier: 1.5, lootTable: [ { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 }, { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 }, ] },
        monster_alpha: { symbol: 'üê∫', name: 'Demonio Alfa', hp: 200, attack: 60, defense: 4, exp: 35, maxHp: 200, lootTable: [ { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 }, { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 }, { itemName: "N√∫cleo de Bestia Menor", quantity: [1,1], chance: 0.25 }, { itemName: "Cristal de Hielo", quantity: [1,2], chance: 0.1 }, { itemName: "Esencia de Fuego", quantity: [1,2], chance: 0.1 },{ itemName: "Piedras Espirituales", quantity: [4,10], chance: 1 } ] },
        cultivator_adept_hostile: { symbol: 'üò°', name: 'Cultivador Adepto Agresivo', hp: 400, attack: 80, defense: 10, exp: 250, maxHp: 400, specialChance: 0.25, specialAttackMultiplier: 1.7, healChance: 0.1, lootTable:[ { itemName: "Piedras Espirituales", quantity: [1, 10], chance: 1 }, { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 }, { itemName: "Venenos Mortales", quantity: [1,3], chance: 0.05 }, { itemName: "Fragmentos de Jade", quantity: [1,2], chance: 0.02 }, { itemName: "Esencia Oscura", quantity: [1,1], chance: 0.05 }, { itemName: "Rollo: Dardo Venenoso", quantity: [1,1], chance: 0.05 }, { itemName: "Rollo: Piel de Piedra", quantity: [1,1], chance: 0.05 }, { itemName: "Rollo: Voluntad de Hierro", quantity: [1,1], chance: 0.015 }, { itemName: "Rollo: Flecha Celestial", quantity: [1,1], chance: 0.05 }, { itemName: "Rollo: Abrazo de la Naturaleza", quantity: [1,1], chance: 0.01 }, { itemName: "Rollo: Rugido de Drag√≥n", quantity: [1,1], chance: 0.01 }, { itemName: "Rollo: Clon Fantasma", quantity: [1,1], chance: 0.01 }, ], },
        "flor_luna_escarchada_guardian": { symbol: '‚ùÑÔ∏è', name: 'Esp√≠ritu de Hielo Protector', typeOverride: 'monster', hp: 120, attack: 35, defense: 10, exp: 40, maxHp: 120, lootTable: [ { itemName: "Flor de Luna Escarchada", quantity: [1, 2], chance: 0.8 }, { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 } ] },
        "raiz_fuego_terrenal_elemental": { symbol: 'üî•', name: 'Elemental de Magma Menor', typeOverride: 'monster', hp: 150, attack: 40, defense: 5, exp: 45, maxHp: 150, lootTable: [ { itemName: "Ra√≠z de Fuego Terrenal", quantity: [1, 1], chance: 0.7 }, { itemName: "Piedras Espirituales", quantity: [5, 10], chance: 0.5 } ] },
        "jabali_colmilludo_alfa": { symbol: 'üêó', name: 'Jabal√≠ Colmilludo Alfa', typeOverride: 'monster', hp: 300, attack: 55, defense: 20, exp: 120, maxHp: 300, lootTable: [ { itemName: "Colmillo de Jabal√≠ Alfa", quantity: [1, 1], chance: 0.9 }, { itemName: "Carne de Bestia Ex√≥tica", quantity: [1, 3], chance: 0.6 }, { itemName: "Piel Resistente", quantity: [1, 2], chance: 0.4 },{ itemName: "Piedras Espirituales", quantity: [4,10], chance: 1 } ], },
        
        "bandido_desfiladero": { 
            symbol: 'üò†', 
            name: 'Bandido del Desfiladero', 
            typeOverride: 'monster', 
            hp: 180, 
            attack: 45, 
            defense: 10, 
            exp: 60, 
            maxHp: 180, 
            lootTable: [ { itemName: "Piedras Espirituales", quantity: [10, 30], chance: 0.5 }, { itemName: "Daga Oxidada", quantity: [1,1], chance: 0.2 } ] },

        "esqueleto_podrido": { 
            symbol: 'üíÄ', 
            name: 'Esqueleto podrido', 
            typeOverride: 'monster', 
            hp: 180, 
            attack: 45, 
            defense: 10, 
            exp: 60, 
            maxHp: 180, 
            lootTable: [ { itemName: "Piedras Espirituales", quantity: [10, 30], chance: 0.5 }, { itemName: "Daga Oxidada", quantity: [1,1], chance: 0.2 } ] },

        "lider_renegado_1": { symbol: 'üë§', name: 'L√≠der Cultor Renegado Kai', typeOverride: 'monster', hp: 500, attack: 70, defense: 25, exp: 250, maxHp: 500, isMiniBoss: true, specialChance: 0.25, specialAttackMultiplier: 1.6, lootTable: [ { itemName: "Comp√°s Espiritual Antiguo", quantity: [1, 1], chance: 1.0 }, { itemName: "P√≠ldora de Qi Condensado", quantity: [1,1], chance: 0.3 }, { itemName: "Piedras Espirituales", quantity: [100, 200], chance: 0.8 } ], fixedLocation: { x: 17, y: 12 } },
        cristal_qi: { symbol: 'üíé', name: 'Cristal de Qi', reward: 'Cristales de Qi', interaction: 'collect_resource' },
        master: { symbol: 'üë¥', name: 'Maestro Anciano', teaching: 't√©cnica', expGain: 50, interaction: 'learn_from_master' },
        cultivation: { symbol: 'üå∏', name: 'Lugar de Cultivo', benefit: 'mana', manaGain: 20, interaction: 'meditate_spot' },
        "boss_demon_general": { symbol: 'üëø', name: 'General Demonio de la Sombra', typeOverride: 'monster', hp: 500, attack: 45, defense: 20, exp: 300, maxHp: 500, isBoss: true, specialChance: 0.35, specialAttackMultiplier: 1.8, healChance: 0.15, lootTable: [ { itemName: "Piedras Espirituales", quantity: [150, 300], chance: 1.0 }, { itemName: "N√∫cleo Demon√≠aco Mayor", quantity: [1, 1], chance: 0.8 }, { itemName: "Rollo: Palma Destructora de Monta√±as", quantity: [1, 1], chance: 0.25 }, { itemName: "Fragmento de Arma Celestial", quantity: [1, 1], chance: 0.1 }, { itemName: "Rollo: Cambio Temporal", quantity: [1,1], chance: 0.25 }, { itemName: "Rollo: Ritual de Sangre", quantity: [1,1], chance: 0.20 }, { itemName: "Rollo: Aura de Pureza", quantity: [1,1], chance: 0.22 }, { itemName: "Rollo: Invocar Elemental", quantity: [1,1], chance: 0.18 }, { itemName: "Rollo: Barrera M√≠stica", quantity: [1,1], chance: 0.25 } ], nextBossId: "boss_ancient_golem", fixedLocation: { x: 18, y: 25 } },
        "boss_ancient_golem": { 
            symbol: 'üóø', 
            name: 'Golem Ancestral de Jade', 
            typeOverride: 'monster', 
            hp: 800, 
            attack: 35, 
            defense: 50, 
            exp: 500, 
            maxHp: 800, 
            isBoss: true, 
            abilities: [ { name: "Golpe S√≠smico", damageMultiplier: 2.0, chance: 0.2, type: "area_attack_simulated" }, { name: "Restauraci√≥n P√©trea", healPercentage: 0.2, chance: 0.1 } ], 
            lootTable: [ { itemName: "Piedras Espirituales", quantity: [300, 500], chance: 1.0 }, { itemName: "Coraz√≥n de Golem de Jade", quantity: [1, 1], chance: 0.9 }, { itemName: "Rollo: Armadura de Tierra Impenetrable", quantity: [1, 1], chance: 0.3 }, { itemName: "Fragmento de Arma Celestial", quantity: [1, 1], chance: 0.15 }, { itemName: "Mineral de Hierro Espiritual", quantity: [5,10], chance: 0.6 }, { itemName: "Fragmentos de Jade", quantity: [3,6], chance: 0.7 }, { itemName: "N√∫cleo Elemental", quantity: [1,2], chance: 0.3, extraData: {elementalType: "earth"} }, { itemName: "Rollo: Piel de Piedra", quantity: [1,1], chance: 0.25 }, ], nextBossId: null, 
            fixedLocation: { x: 20, y: 13 } },
        "npc_secta_guia": { symbol: 'üë®‚Äçüè´', name: 'Gu√≠a Lin', interaction: 'talk_secta_npc', npcId: "guia_lin", fixedLocation: { x: 13, y: 15 } },
        "npc_secta_admin": { symbol: ' üë¥', name: 'Administrador Yao', interaction: 'talk_secta_npc', npcId: "admin_yao", fixedLocation: { x: 13, y: 16 } },
        "rival_interno_1": { 
            symbol: 'üò†', 
            name: 'Han Li (Guardi√°n Interno)',
            typeOverride: 'monster', 
            hp: 250, 
            attack: 60, 
            defense: 15, 
            exp: 150, 
            maxHp: 250, 
            isSectChallengeRival: true,
            npcId: "rival_interno_1", 
            fixedLocation: { x: 5, y: 12 } },
        "rival_principal_1": { 
            symbol: 'üò°', 
            name: 'Anciana Shui (Prueba Principal)', 
            typeOverride: 'monster', 
            hp: 600, 
            attack: 90, 
            defense: 25, 
            exp: 400, 
            maxHp: 600, 
            isSectChallengeRival: true, 
            npcId: "rival_principal_1", 
            fixedLocation: { x: 4, y: 12 }, 
            specialChance: 0.2, 
            specialAttackMultiplier: 1.6, },
    };
    
    const itemData = {
        "Hierbas Medicinales": { description: "Restaura un 30% de tu HP M√°ximo.", effect: (ps) => { if (ps.hp >= ps.maxHp) return "Vida al m√°ximo."; const h = Math.floor(ps.maxHp * 0.30); const o=ps.hp; ps.hp=Math.min(ps.maxHp, ps.hp+h); return `Recuperado ${ps.hp-o} HP.`; }, canUse: (ps) => ps.hp < ps.maxHp },
        "Cristales de Qi": { description: "Restaura un 30% de tu Man√° M√°ximo.", effect: (ps) => { if (ps.mana >= ps.maxMana) return "Man√° al m√°ximo."; const h = Math.floor(ps.maxMana * 0.30); const o=ps.mana; ps.mana=Math.min(ps.maxMana, ps.mana+h); return `Recuperado ${ps.mana-o} Man√°.`; }, canUse: (ps) => ps.mana < ps.maxMana },
        "Piedras Espirituales": { description: "Imbuida de energ√≠a. Otorga 50 EXP.", effect: (ps, gex) => { gex(50); return `Absorbido Piedra Espiritual y ganado 50 EXP.`; }, canUse: () => true },
        "Flor de Luna Escarchada": { description: "Flor brillante usada en alquimia.", canUse: () => false },
        "Ra√≠z de Fuego Terrenal": { description: "Ra√≠z que irradia calor, ingrediente alqu√≠mico.", canUse: () => false },
        "P√≠ldora de Recuperaci√≥n Menor": { description: "P√≠ldora alqu√≠mica que restaura 50 HP.", effect: (ps) => { if (ps.hp >= ps.maxHp) return "Vida al m√°ximo."; const h=50; const o=ps.hp; ps.hp=Math.min(ps.maxHp, ps.hp+h); return `Usada P√≠ldora, recuperado ${ps.hp-o} HP.`; }, canUse: (ps) => ps.hp < ps.maxHp },
        "Talism√°n de Percepci√≥n": { description: "Agudiza sentidos. Otorga EXP.", effect: (ps, gex) => { gex(100); return `Estudiado Talism√°n, ganado 100 EXP.`; }, canUse: () => true },
        "Colmillo de Jabal√≠ Alfa": { description: "Colmillo intacto de Jabal√≠ Alfa. Prueba de caza.", canUse: () => false },
        "Carne de Bestia Ex√≥tica": { description: "Nutritiva. Restaura 25% HP y 10% Man√°.", effect: (ps) => { let m = ""; const hA=Math.floor(ps.maxHp*0.25); if(ps.hp<ps.maxHp){const o=ps.hp;ps.hp=Math.min(ps.maxHp,ps.hp+hA);m+=`Recuperado ${ps.hp-o} HP. `;} const mA=Math.floor(ps.maxMana*0.10); if(ps.mana<ps.maxMana){const o=ps.mana;ps.mana=Math.min(ps.maxMana,ps.mana+mA);m+=`Recuperado ${ps.mana-o} Man√°.`;} return m||"HP y Man√° al m√°ximo."; }, canUse: (ps) => ps.hp < ps.maxHp || ps.mana < ps.maxMana },
        "Mapa del Tesoro Fragmentado": { description: "Fragmento de mapa antiguo. ¬øOtras partes?", effect: (ps, gex) => { gex(50); return `Examinado fragmento, ganado 50 EXP. Indica zona monta√±osa...`; }, canUse: () => true },
        "Comp√°s Espiritual Antiguo": { description: "Artefacto de secta que resuena con energ√≠as.", canUse: () => false },
        "Manual de Formaci√≥n B√°sica": { description: "Ense√±a principios de formaciones defensivas.", effect: (ps) => { ps.baseDefense += 2; recalculatePlayerStats(); return `Estudiado Manual. Defensa base +2.`; }, canUse: () => true },
        "N√∫cleo de Bestia Menor": { description: "N√∫cleo de bestia demon√≠aca. Otorga 20 EXP.", effect: (ps, gex) => { gex(20); return `Absorbido N√∫cleo, ganado 20 EXP.`; }, canUse: () => true },
        "Rollo: Absorci√≥n de Qi Menor": { description: "Ense√±a 'T√©cnica de Absorci√≥n de Qi Menor'.", effect: (ps) => learnTechniqueFromRoll(ps, "qi_absorption_boost_1"), canUse: () => true },
        "Rollo: Fortificaci√≥n Corporal B√°sica": { description: "Ense√±a 'Fortificaci√≥n Corporal B√°sica'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_fortification_1"), canUse: () => true },
        "Rollo: Corte de Espada B√°sico": { description: "Ense√±a 'Corte de Espada B√°sico'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_slash_1"), canUse: () => true },
        "Rollo: Conversi√≥n de Qi": { description: "Ense√±a 'T√©cnica de Conversi√≥n de Qi'.", effect: (ps) => learnTechniqueFromRoll(ps, "qi_to_hp_conversion_1"), canUse: () => true },
        "Rollo: Prisi√≥n de Hielo": { description: "Ense√±a 'Prisi√≥n de Hielo'.", effect: (ps) => learnTechniqueFromRoll(ps, "ice_prison_1"), canUse: () => true },
        "Rollo: Golpe de Llamas": { description: "Ense√±a 'Golpe de Llamas'.", effect: (ps) => learnTechniqueFromRoll(ps, "flame_strike_1"), canUse: () => true },
        "Rollo: Furia del Trueno": { description: "Ense√±a 'Furia del Trueno'.", effect: (ps) => learnTechniqueFromRoll(ps, "thunder_fury_1"), canUse: () => true },
        "Rollo: Dardo Venenoso": { description: "Ense√±a 'Dardo Venenoso'.", effect: (ps) => learnTechniqueFromRoll(ps, "poison_dart_1"), canUse: () => true },
        "Rollo: Piel de Piedra": { description: "Ense√±a 'Piel de Piedra'.", effect: (ps) => learnTechniqueFromRoll(ps, "stone_skin_1"), canUse: () => true },
        "Rollo: Paso de las Sombras": { description: "Ense√±a 'Paso de las Sombras'.", effect: (ps) => learnTechniqueFromRoll(ps, "shadow_step_1"), canUse: () => true },
        "Rollo: Drenaje de Alma": { description: "Ense√±a 'Drenaje de Alma'.", effect: (ps) => learnTechniqueFromRoll(ps, "soul_drain_1"), canUse: () => true },
        "Rollo: Golpe Cicl√≥n": { description: "Ense√±a 'Golpe Cicl√≥n'.", effect: (ps) => learnTechniqueFromRoll(ps, "cyclone_strike_1"), canUse: () => true },
        "Rollo: Lluvia Curativa": { description: "Ense√±a 'Lluvia Curativa'.", effect: (ps) => learnTechniqueFromRoll(ps, "healing_rain_1"), canUse: () => true },
        "Rollo: Explosi√≥n Mental": { description: "Ense√±a 'Explosi√≥n Mental'.", effect: (ps) => learnTechniqueFromRoll(ps, "mind_blast_1"), canUse: () => true },
        "Rollo: Voluntad de Hierro": { description: "Ense√±a 'Voluntad de Hierro'.", effect: (ps) => learnTechniqueFromRoll(ps, "iron_will_1"), canUse: () => true },
        "Rollo: Flecha Celestial": { description: "Ense√±a 'Flecha Celestial'.", effect: (ps) => learnTechniqueFromRoll(ps, "celestial_arrow_1"), canUse: () => true },
        "Rollo: Abrazo de la Naturaleza": { description: "Ense√±a 'Abrazo de la Naturaleza'.", effect: (ps) => learnTechniqueFromRoll(ps, "nature_grasp_1"), canUse: () => true },
        "Rollo: Rugido de Drag√≥n": { description: "Ense√±a 'Rugido de Drag√≥n'.", effect: (ps) => learnTechniqueFromRoll(ps, "dragon_roar_1"), canUse: () => true },
        "Rollo: Clon Fantasma": { description: "Ense√±a 'Clon Fantasma'.", effect: (ps) => learnTechniqueFromRoll(ps, "phantom_clone_1"), canUse: () => true },
        "Rollo: Cambio Temporal": { description: "Ense√±a 'Cambio Temporal'.", effect: (ps) => learnTechniqueFromRoll(ps, "temporal_shift_1"), canUse: () => true },
        "Rollo: Ritual de Sangre": { description: "Ense√±a 'Ritual de Sangre'.", effect: (ps) => learnTechniqueFromRoll(ps, "blood_ritual_1"), canUse: () => true },
        "Rollo: Aura de Pureza": { description: "Ense√±a 'Aura de Pureza'.", effect: (ps) => learnTechniqueFromRoll(ps, "aura_of_purity_1"), canUse: () => true },
        "Rollo: Invocar Elemental": { description: "Ense√±a 'Invocar Elemental'.", effect: (ps) => learnTechniqueFromRoll(ps, "summon_elemental_1"), canUse: () => true },
        "Rollo: Barrera M√≠stica": { description: "Ense√±a 'Barrera M√≠stica'.", effect: (ps) => learnTechniqueFromRoll(ps, "mystic_barrier_1"), canUse: () => true },
        "Cristal de Hielo": { description: "Cristal g√©lido. Otorga 25 EXP.", effect: (ps, gex) => { gex(25); return `Absorbido Cristal de Hielo, ganado 25 EXP.`; }, canUse: () => true },
        "Esencia de Fuego": { description: "Energ√≠a √≠gnea concentrada. Otorga 25 EXP.", effect: (ps, gex) => { gex(25); return `Absorbido Esencia de Fuego, ganado 25 EXP.`; }, canUse: () => true },
        "N√∫cleo de Tormenta": { description: "Coraz√≥n de tormenta. Otorga 50 EXP.", effect: (ps, gex) => { gex(50); return `Absorbido N√∫cleo de Tormenta, ganado 50 EXP.`; }, canUse: () => true },
        "Venenos Mortales": { description: "Venenos potentes. Otorga 15 EXP.", effect: (ps, gex) => { gex(15); return `Estudiado Venenos Mortales, ganado 15 EXP.`; }, canUse: () => true },
        "Fragmentos de Jade": { description: "Jade imbuido de energ√≠a. Otorga 20 EXP.", effect: (ps, gex) => { gex(20); return `Absorbido Fragmentos de Jade, ganado 20 EXP.`; }, canUse: () => true },
        "Esencia Oscura": { description: "Energ√≠a de sombras. Otorga 30 EXP.", effect: (ps, gex) => { gex(30); return `Absorbido Esencia Oscura, ganado 30 EXP.`; }, canUse: () => true },
        "Almas Condenadas": { description: "Ecos de almas. Otorga 40 EXP.", effect: (ps, gex) => { gex(40); return `Liberado Almas Condenadas, ganado 40 EXP.`; }, canUse: () => true },
        "N√∫cleo de V√≥rtice": { description: "Energ√≠a ca√≥tica. Otorga 50 EXP.", effect: (ps, gex) => { gex(50); return `Absorbido N√∫cleo de V√≥rtice, ganado 50 EXP.`; }, canUse: () => true },
        "Roc√≠o Celestial": { description: "Gotas de energ√≠a celestial. Otorga 35 EXP.", effect: (ps, gex) => { gex(35); return `Bebido Roc√≠o Celestial, ganado 35 EXP.`; }, canUse: () => true },
        "Cristales Ps√≠quicos": { description: "Resuenan con poder mental. Otorga 45 EXP.", effect: (ps, gex) => { gex(45); return `Meditado con Cristales Ps√≠quicos, ganado 45 EXP.`; }, canUse: () => true },
        "Mineral de Hierro Espiritual": { description: "Hierro imbuido con Qi. Otorga 25 EXP.", effect: (ps, gex) => { gex(25); return `Refinado Mineral, ganado 25 EXP.`; }, canUse: () => true },
        "Plumas de F√©nix": { description: "Imbuidas con esencia de renovaci√≥n. Otorga 60 EXP.", effect: (ps, gex) => { gex(60); return `Meditado con Plumas de F√©nix, ganado 60 EXP.`; }, canUse: () => true },
        "Semillas Ancestrales": { description: "Llenas de vitalidad. Otorga 30 EXP.", effect: (ps, gex) => { gex(30); return `Plantado Semillas en dantian, ganado 30 EXP.`; }, canUse: () => true },
        "Escamas de Drag√≥n": { description: "Imbuidas con poder drac√≥nico. Otorga 70 EXP.", effect: (ps, gex) => { gex(70); return `Estudiado Escamas de Drag√≥n, ganado 70 EXP.`; }, canUse: () => true },
        "Espejos Astrales": { description: "Reflejan otros planos. Otorga 40 EXP.", effect: (ps, gex) => { gex(40); return `Meditado con Espejos Astrales, ganado 40 EXP.`; }, canUse: () => true },
        "Relojes de Arena": { description: "Manipulan flujo del tiempo. Otorga 50 EXP.", effect: (ps, gex) => { gex(50); return `Estudiado Relojes de Arena, ganado 50 EXP.`; }, canUse: () => true },
        "Sangre de Demonio": { description: "Sangre corrupta pero potente. Otorga 35 EXP.", effect: (ps, gex) => { gex(35); return `Analizado Sangre de Demonio, ganado 35 EXP.`; }, canUse: () => true },
        "L√°grimas de Unicornio": { description: "Purificadoras con propiedades curativas. Otorga 45 EXP.", effect: (ps, gex) => { gex(45); return `Usado L√°grimas para purificar Qi, ganado 45 EXP.`; }, canUse: () => true },
        "N√∫cleo Elemental": { description: "Esencia de poder elemental. Otorga 65 EXP.", effect: (ps, gex) => { gex(65); return `Absorbido N√∫cleo Elemental, ganado 65 EXP.`; }, canUse: () => true },
        "Polvo de Arcano": { description: "Brillante con propiedades m√°gicas. Otorga 40 EXP.", effect: (ps, gex) => { gex(40); return `Utilizado Polvo de Arcano en ritual, ganado 40 EXP.`; }, canUse: () => true },
    };


   // --- FUNCIONES HELPER PARA UI M√ìVIL ---
   function isMobileView() {
        return window.matchMedia("(max-width: 768px)").matches || window.matchMedia("(hover: none) and (pointer: coarse)").matches;
    }

    /// <!-- CAMBIO TAMA√ëO MAPA M√ìVIL -->
    function calculateAndSetTileSize() {
        const mapContainerElement = document.querySelector('.map-container');
        if (!mapContainerElement) {
            console.warn("calculateAndSetTileSize: mapContainerElement no encontrado, usando G_TILE_SIZE por defecto.");
            currentTileSize = G_TILE_SIZE;
            return G_TILE_SIZE;
        }

        if (isMobileView()) {
            const availableWidth = mapContainerElement.clientWidth;
            const availableHeight = mapContainerElement.clientHeight;

            // Decidir cu√°ntos tiles queremos ver en pantalla en m√≥vil (aproximado)
            // Ajusta estos valores seg√∫n tus preferencias visuales.
            const TILES_VISIBLE_X_MOBILE = 10; // Por ejemplo, queremos ver unos 15 tiles de ancho
            const TILES_VISIBLE_Y_MOBILE = 5; // Y unos 10 de alto

            const tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_MOBILE;
            const tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_MOBILE;
            
            currentTileSize = Math.floor(Math.min(tileSizeBasedOnWidth, tileSizeBasedOnHeight));
            currentTileSize = Math.max(20, currentTileSize); // Asegurar un tama√±o m√≠nimo razonable (ej. 20px)

            console.log(`Mobile View: Container W: ${availableWidth}, H: ${availableHeight}. Calculated Tile Size: ${currentTileSize}`);
        } else {
            currentTileSize = G_TILE_SIZE; // Usar el tama√±o fijo para escritorio
            console.log(`Desktop View: Using G_TILE_SIZE: ${currentTileSize}`);
        }
        return currentTileSize;
    }
    // <!-- FIN CAMBIO TAMA√ëO MAPA M√ìVIL -->

    function isAnyModalOpen() {
        const modals = ['interactionModal', 'activeCultivationModal', 'shopModal', 'sectHallModal', 'skillTreeModal', 'cultivationChoiceModal', 'techniqueModal'];
        for (const modalId of modals) {
            const modalElement = document.getElementById(modalId);
            if (modalElement && modalElement.style.display === 'flex') {
                return true;
            }
        }
        return false;
    }
    
    function showTouchControls() {
        const joystick = document.getElementById('joystick-container');
        const actionBtn = document.getElementById('action-button-touch');

        if (isMobileView() && !mapControlsManuallyHidden && !gameState.battle.active && !isAnyModalOpen()) {
            if (joystick) joystick.style.display = 'block';
            if (actionBtn) actionBtn.style.display = 'block';
        } else {
            if (joystick) joystick.style.display = 'none';
            if (actionBtn) actionBtn.style.display = 'none';
        }
    }

    function hideTouchControls() {
        const joystick = document.getElementById('joystick-container');
        const actionBtn = document.getElementById('action-button-touch');
        if (joystick) joystick.style.display = 'none';
        if (actionBtn) actionBtn.style.display = 'none';
    }

    function toggleMapControlsVisibility() {
        mapControlsManuallyHidden = !mapControlsManuallyHidden;
        const btn = document.getElementById('toggleMapControlsBtn');
        if (mapControlsManuallyHidden) {
            hideTouchControls(); 
            btn.textContent = 'Mostrar Controles';
        } else {
            showTouchControls();
            btn.textContent = 'Ocultar Controles';
        }
    }


    // --- FUNCIONES DEL JUEGO (MODIFICADAS Y EXISTENTES) ---

    function learnTechniqueFromRoll(playerState, techId) {
        if (!techniqueData[techId]) return "Error: T√©cnica desconocida.";
        if (playerState.learnedTechniques[techId]) {
            return `Ya conoces esta t√©cnica: ${techniqueData[techId].name}.`;
        }
        const techCultivationSettings = techniqueData[techId].cultivationSettings;
        playerState.learnedTechniques[techId] = { 
            level: 0, 
            currentCultivationProgress: 0,
            cultivationTimeToNextLevel: techCultivationSettings ? techCultivationSettings.baseTimeToLevelUp : 60 
        };
        if (techId === "qi_to_hp_conversion_1") {
            playerState.canUseQiConversion = true; 
            updateToggleQiConversionButtonVisibility(); 
        }
        return `Has aprendido '${techniqueData[techId].name}'. Puedes cultivarla para mejorarla.`;
    }

    function showModal(title, text, nonInteractive = false) {
        const modalElement = document.getElementById('interactionModal');
        const modalTitleEl = document.getElementById('modalTitle'); 
        const modalTextEl = document.getElementById('modalText');
        
        if (!modalElement || !modalTitleEl || !modalTextEl) {
            console.error("CRITICAL: Modal o sus elementos internos no encontrados.");
            alert(`Error UI: Modal no encontrado.\nMensaje: ${title} - ${text}`); 
            return;
        }

        modalTitleEl.textContent = title;
        modalTextEl.innerHTML = text.replace(/\n/g, '<br>');

        const closeButton = modalElement.querySelector('button.close-modal-btn'); // Busca por clase
        
        if (closeButton) {
            if (nonInteractive) {
                closeButton.style.display = 'none'; // Ocultar si es no interactivo
            } else {
                closeButton.style.display = 'block'; // Asegurar que sea visible si es interactivo
                // El onclick="closeModal()" ya est√° en el HTML, por lo que no necesitamos reasignarlo.
            }
        } else if (!nonInteractive) {
            console.warn("#interactionModal no tiene un bot√≥n de cierre con clase .close-modal-btn y no es nonInteractive.");
        }
        
        modalElement.style.display = 'flex';
        hideTouchControls(); 
    }

    function closeModal() {
        const modalElement = document.getElementById('interactionModal');
        if (modalElement) {
            modalElement.style.display = 'none';
        }
        showTouchControls(); // Restaurar controles t√°ctiles (si aplica)
    }

    function ensureFixedEntities() {
        const player = gameState.player;
        let entities = gameState.map.entities; // Usar let para poder reasignar si filtramos

        let idsParaProcesar = [
            "shop", "secta_entrada_principal", "npc_secta_guia", "npc_secta_admin",
        ];

        if (player.worldState.currentBossToSpawn && entityTypes[player.worldState.currentBossToSpawn]) {
            const bossDef = entityTypes[player.worldState.currentBossToSpawn];
            if (bossDef.fixedLocation && !player.worldState.defeatedBosses[player.worldState.currentBossToSpawn]) {
                if (!idsParaProcesar.includes(player.worldState.currentBossToSpawn)) {
                    idsParaProcesar.push(player.worldState.currentBossToSpawn);
                }
            }
        }
        
        player.secta.misionesActivas.forEach(misionActiva => {
            const misionData = MISIONES_DATA[misionActiva.id];
            if (misionData?.objetivo?.tipo === "derrotar_npc_especifico" && misionData.objetivo.npcId) {
                const rivalId = misionData.objetivo.npcId;
                if (entityTypes[rivalId]?.fixedLocation && !player.secta.misionesCompletadas[misionActiva.id]) {
                    if (!idsParaProcesar.includes(rivalId)) {
                        idsParaProcesar.push(rivalId);
                    }
                }
            }
        });

        // console.log("[EnsureFixed] IDs a procesar:", JSON.stringify(idsParaProcesar));

        idsParaProcesar.forEach(entityTypeId => {
            // ----------- LOGS ESPEC√çFICOS PARA SECTA_ENTRADA_PRINCIPAL -----------
            if (entityTypeId === "secta_entrada_principal") {
                console.log(`[EnsureFixed - SECTA] Procesando: ${entityTypeId}`);
            }
            // --------------------------------------------------------------------

            const definition = entityTypes[entityTypeId];
            if (!definition) {
                if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] ERROR: Definici√≥n no encontrada para ${entityTypeId}`);
                return;
            }

            let fixedX, fixedY;
            if (definition.fixedLocation) {
                fixedX = definition.fixedLocation.x;
                fixedY = definition.fixedLocation.y;
                if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] Coordenadas fijas: X=${fixedX}, Y=${fixedY}`);
            } else {
                if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] ERROR: ${entityTypeId} no tiene fixedLocation.`);
                return;
            }

            const existingEntityInstance = entities.find(e =>
                (e.x === fixedX && e.y === fixedY && (e.type === (definition.typeOverride || entityTypeId) || e.originalEntityTypeId === entityTypeId)) ||
                (definition.npcId && e.npcId === definition.npcId)
            );
            if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] Instancia existente?: ${!!existingEntityInstance}`, existingEntityInstance || '');


            let debeExistir = true; 
            if (definition.isSectChallengeRival && definition.npcId) {
                // ... (l√≥gica de rivales sin cambios) ...
                const desafioMision = Object.values(MISIONES_DATA).find(m => m.objetivo?.tipo === "derrotar_npc_especifico" && m.objetivo?.npcId === definition.npcId);
                const misionId = desafioMision ? Object.keys(MISIONES_DATA).find(key => MISIONES_DATA[key] === desafioMision) : null;
                if (misionId) {
                    if (player.secta.misionesCompletadas[misionId]) debeExistir = false;
                    else if (!player.secta.misionesActivas.some(m => m.id === misionId)) debeExistir = false;
                } else debeExistir = false; 
            } else if (definition.isBoss) {
                if (player.worldState.defeatedBosses[entityTypeId]) debeExistir = false;
            }
            if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] debeExistir: ${debeExistir}`);


            if (debeExistir) {
                if (!existingEntityInstance) {
                    if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] CREANDO nueva instancia.`);
                    const newEntityData = { /* ... tu objeto newEntityData ... */ 
                        x: fixedX, y: fixedY,
                        type: definition.typeOverride || entityTypeId,
                        symbol: definition.symbol, name: definition.name,
                        interaction: definition.interaction, npcId: definition.npcId,
                        discovered: (["secta_entrada_principal", "shop"].includes(entityTypeId) || definition.isSectChallengeRival || definition.isBoss || definition.discovered === true),
                        isFixed: true,
                        id: `${entityTypeId}_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                        originalEntityTypeId: entityTypeId,
                        ...(definition.hp && { hp: definition.hp }),
                        ...(definition.maxHp && { maxHp: definition.maxHp }),
                        ...(definition.attack && { attack: definition.attack }),
                        ...(definition.defense && { defense: definition.defense }),
                        ...(definition.exp && { exp: definition.exp }),
                        ...(definition.lootTable && { lootTable: definition.lootTable }),
                        ...(definition.isBoss && { isBoss: true }),
                        ...(definition.isSectChallengeRival && { isSectChallengeRival: true }),
                        ...(definition.specialChance && { specialChance: definition.specialChance }),
                        ...(definition.specialAttackMultiplier && { specialAttackMultiplier: definition.specialAttackMultiplier }),
                        ...(definition.healChance && { healChance: definition.healChance }),
                        ...(definition.abilities && { abilities: definition.abilities }),
                    };
                    if (newEntityData.hp && !newEntityData.maxHp) newEntityData.maxHp = newEntityData.hp;
                    
                    const finalEntity = { ...definition, ...newEntityData }; 
                    delete finalEntity.fixedLocation; 
                    
                    if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] Entidad a a√±adir:`, JSON.parse(JSON.stringify(finalEntity)));
                    entities.push(finalEntity);
                } else {
                    if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] Actualizando propiedades de instancia existente.`);
                    existingEntityInstance.isFixed = true;
                    if (["secta_entrada_principal", "shop"].includes(entityTypeId) || definition.isSectChallengeRival || definition.isBoss || definition.discovered === true) {
                        existingEntityInstance.discovered = true;
                    }
                    if (!existingEntityInstance.id) {
                        existingEntityInstance.id = `${entityTypeId}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
                    }
                    if (!existingEntityInstance.originalEntityTypeId) {
                        existingEntityInstance.originalEntityTypeId = entityTypeId;
                    }
                }
            } else { 
                if (existingEntityInstance) {
                    if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] ELIMINANDO instancia existente porque debeExistir es false.`);
                    // Esta reasignaci√≥n es importante
                    entities = entities.filter(e => e.id !== existingEntityInstance.id);
                } else {
                    if (entityTypeId === "secta_entrada_principal") console.log(`[EnsureFixed - SECTA] No debe existir y no existe. Nada que hacer.`);
                }
            }
        });
        // IMPORTANTE: Reasignar la variable global si `entities` fue modificada por `filter`
        gameState.map.entities = entities;
    }
//GENERAR MAPA!
    function generateMap(isFullReset = true) {
        calculateAndSetTileSize();

        if (isFullReset) {
            console.log("generateMap: Full reset. Entities BEFORE filtering for isFixed:");
            gameState.map.entities.forEach(e => {
                if (e.type === 'secta_entrada_principal' || e.type === 'npc_secta_guia' || e.type === 'npc_secta_admin') {
                    console.log(`  - ${e.name || e.type} at (${e.x},${e.y}), isFixed: ${e.isFixed}, ID: ${e.id}`);
                }
            });
    
            // Limpiar entidades que no son fijas si es un reseteo completo
            // Esto es importante para que populateZoneWithObjects no cuente entidades viejas
            gameState.map.entities = gameState.map.entities.filter(e => e.isFixed);
            console.log("generateMap: Full reset. Entities AFTER filtering for isFixed:");
            gameState.map.entities.forEach(e => {
                if (e.type === 'secta_entrada_principal' || e.type === 'npc_secta_guia' || e.type === 'npc_secta_admin') {
                    console.log(`  - KEPT: ${e.name || e.type} at (${e.x},${e.y}), isFixed: ${e.isFixed}, ID: ${e.id}`);
                }
            });
             // Resetear currentCount en las spawnSettings de las zonas
            gameState.map.terrainZones.forEach(zone => {
                if (zone.spawnSettings && zone.spawnSettings.targetEntities) {
                    zone.spawnSettings.targetEntities.forEach(target => {
                        target.currentCount = 0;
                    });
                     zone.spawnSettings.respawnTimer = 0; // Asegurar que el timer est√© a 0 para el llenado inicial
                     zone.spawnSettings.lastSpawnCheck = 0; // Resetear lastSpawnCheck tambi√©n
                }
            });

            gameState.map.terrainZones.forEach(zone => {
                if (zone.spawnSettings) {
                    console.log(`generateMap: Processing zone "${zone.name}" for initial population.`);
                    populateZoneWithObjects(zone, true); // true para forzar el llenado inicial completo
                    console.log("generateMap: Full reset. Populating decorative elements.");
                    populateDecorativeElements(50); // A√±ade, por ejemplo, 50 elementos decorativos
                }
            });
            
        } else {
            // Para una "reaparici√≥n" m√°s ligera (si a√∫n necesitas este concepto fuera de las zonas)
            // Filtra solo las entidades que NO son gestionadas por zonas y NO son fijas
          
            gameState.map.entities = gameState.map.entities.filter(e => e.isFixed || e.isDecorative || (!e.zoneOrigin && !e.isFixed));
        }
        updatePlayerPosition(); // Esto llamar√° a renderMap()
        showTouchControls();
        // Siempre asegurar que las entidades fijas est√©n presentes y correctas
        ensureFixedEntities();
        console.log("generateMap: Entities AFTER ensureFixedEntities has run:");
        gameState.map.entities.forEach(e => {
            if (e.type === 'secta_entrada_principal' || e.type === 'npc_secta_guia' || e.type === 'npc_secta_admin') {
                console.log(`  - FINAL: ${e.name || e.type} at (${e.x},${e.y}), isFixed: ${e.isFixed}, ID: ${e.id}`);
            }
        });
        
    }
    
    function populateDecorativeElements(numberOfElements = 3000) {
        const decorativeKeys = Object.keys(entityTypes).filter(key => entityTypes[key].isDecorative);
        if (decorativeKeys.length === 0) {
            console.log("[Decor] No decorative entity types found."); // LOG
            return;
        }
        // MODIFICACI√ìN: A√±adir las claves encontradas al log
        console.log(`[Decor] Attempting to populate ${numberOfElements} decorative elements. Found ${decorativeKeys.length} types:`, decorativeKeys.join(', ')); 

        let addedCount = 0; 
        for (let i = 0; i < numberOfElements; i++) {
            let spawnX, spawnY, attempts = 0;
            let positionFound = false;
            const randomDecoKey = decorativeKeys[Math.floor(Math.random() * decorativeKeys.length)];

            while (attempts < 20 && !positionFound) { // Intentos para encontrar posici√≥n
                spawnX = Math.floor(Math.random() * gameState.map.width);
                spawnY = Math.floor(Math.random() * gameState.map.height);

                // Para decorativos, la condici√≥n de "caminable" puede ser menos estricta
                // Lo importante es que la celda no est√© ya ocupada.
                const isOccupied = gameState.map.entities.some(e => e.x === spawnX && e.y === spawnY);
                const isPlayerPos = (spawnX === gameState.player.x && spawnY === gameState.player.y);

                if (!isOccupied && !isPlayerPos) { 
                    positionFound = true;
                }
                attempts++;
            }

            if (positionFound) {
                const decoDefinition = entityTypes[randomDecoKey];
                if (!decoDefinition || !decoDefinition.symbol) { 
                    console.warn(`[Decor] Definition or symbol missing for deco key: ${randomDecoKey}`);
                    continue;
                }
                const newDeco = {
                    ...decoDefinition, // Copia todas las propiedades de la definici√≥n
                    x: spawnX,
                    y: spawnY,
                    type: randomDecoKey, // El tipo ES la clave original de entityTypes
                    id: `${randomDecoKey}_${Date.now()}_${i}_${Math.random().toString(16).slice(2)}`,
                    discovered: true, // Importante: los decorativos suelen estar descubiertos
                    isFixed: true,    // Importante: para que no se limpien f√°cilmente
                    isDecorative: true, // Asegura que sea true, incluso si la definici√≥n lo omite
                };
                
                gameState.map.entities.push(newDeco);
                addedCount++; 
                // MODIFICACI√ìN: Log m√°s detallado, incluyendo si isDecorative es true en la instancia
                console.log(`[Decor] Added: ${newDeco.name} (Symbol: ${newDeco.symbol}, Type: ${newDeco.type}, IsDecorative: ${newDeco.isDecorative}) at ${spawnX},${spawnY}. ID: ${newDeco.id}`); 
            } else {
                // console.log(`[Decor] Could not find position for a decorative element of type ${randomDecoKey} after 20 attempts.`); 
            }
        }
        console.log(`[Decor] Finished populating. Added ${addedCount} decorative elements out of ${numberOfElements} attempts.`); 
    }


    function populateZoneWithObjects(zone, initialPopulation = false) {
    if (!zone.spawnSettings) {
        console.log(`populateZoneWithObjects: Zone "${zone.name}" has no spawnSettings. Skipping.`);
        return;
    }

    console.log(`populateZoneWithObjects: Called for zone "${zone.name}". InitialPopulation: ${initialPopulation}`);

    zone.spawnSettings.targetEntities.forEach(targetSpawnInfo => {
        console.log(`  Zone "${zone.name}": Processing target spawn info for entityTypeId "${targetSpawnInfo.entityTypeId}", count: ${targetSpawnInfo.count}, currentCount: ${targetSpawnInfo.currentCount}`);

        const entityTypeDefinition = entityTypes[targetSpawnInfo.entityTypeId];
        if (!entityTypeDefinition) {
            console.warn(`  Zone "${zone.name}": Definition for entityTypeId "${targetSpawnInfo.entityTypeId}" NOT FOUND in entityTypes.`);
            return;
        }

        let attemptSpawns = targetSpawnInfo.count - targetSpawnInfo.currentCount;
        console.log(`  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Need to spawn ${attemptSpawns} (target: ${targetSpawnInfo.count}, current: ${targetSpawnInfo.currentCount})`);


        if (!initialPopulation && zone.spawnSettings.respawnTimer > 0) {
            console.log(`  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Zone in cooldown (timer: ${zone.spawnSettings.respawnTimer}). Skipping spawn.`);
            return;
        }


        if (attemptSpawns <= 0 && !initialPopulation) {
            console.log(`  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": No spawns needed and not initial population. Skipping.`);
            return;
        }
        if (attemptSpawns <= 0 && initialPopulation && targetSpawnInfo.currentCount >= targetSpawnInfo.count) {
            console.log(`  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Initial population, but already at target count. Skipping.`);
            return;
        }


        let spawnedThisCycle = 0;
        for (let i = 0; i < attemptSpawns; i++) {
            if (targetSpawnInfo.currentCount >= targetSpawnInfo.count) {
                console.log(`    Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Reached target count (${targetSpawnInfo.currentCount}/${targetSpawnInfo.count}). Stopping spawns for this type.`);
                break;
            }

            let spawnX, spawnY, attempts = 0;
            let positionFound = false;
            while (attempts < 20 && !positionFound) {
                spawnX = zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1 + 1));
                spawnY = zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1 + 1));

                const targetTerrainId = getTerrainTypeAt(spawnX, spawnY);
                const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
                const terrainWalkable = !targetTerrainData || targetTerrainData.walkable !== false;

                const isOccupied = gameState.map.entities.some(e => e.x === spawnX && e.y === spawnY);
                const isPlayerPos = (spawnX === gameState.player.x && spawnY === gameState.player.y);

                if (terrainWalkable && !isOccupied && !isPlayerPos) {
                    positionFound = true;
                }
                attempts++;
            }

            if (positionFound) {
                let newEntity;
                newEntity = {
                        ...entityTypeDefinition,// <--- COPIAR TODAS LAS PROPIEDADES DE LA DEFINICI√ìN PRIMERO
                        x: spawnX,
                        y: spawnY,
                        type: entityTypeDefinition.typeOverride || targetSpawnInfo.entityTypeId,
                        id: `${targetSpawnInfo.entityTypeId}_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                        zoneOrigin: zone.name,
                        originalEntityTypeId: targetSpawnInfo.entityTypeId,
                        discovered: false,
                        //name: entityTypeDefinition.name,
                        //symbol: entityTypeDefinition.symbol,
                        //interaction: entityTypeDefinition.interaction,
                        //reward: entityTypeDefinition.reward,
                    };
                    // Asegurar HP/MaxHP para entidades de combate y limpiar para no combatientes
                    if (G_COMBAT_ENTITY_TYPES.includes(newEntity.type) || newEntity.isBoss || newEntity.isSectChallengeRival) {
                        // Si entityTypeDefinition ya tiene hp/maxHp, el spread ya los copi√≥.
                        // Este bloque es m√°s para asegurar que existan o para poner valores por defecto.
                        newEntity.hp = newEntity.hp ?? entityTypeDefinition.hp ?? 50;
                        newEntity.maxHp = newEntity.maxHp ?? newEntity.hp;
                        // Aqu√≠ 'attack', 'defense', 'exp', 'lootTable' ya deber√≠an estar copiados por el spread de entityTypeDefinition
                    } else { // Para recursos u otras entidades no combativas
                        delete newEntity.hp;
                        delete newEntity.maxHp;
                        delete newEntity.attack; // Asegurarse de que no tengan stats de combate
                        delete newEntity.defense;
                        delete newEntity.exp;
                        // lootTable podr√≠a ser relevante para recursos si lo usaras para definir m√∫ltiples items de un nodo.
                    }
                    
                    // Correcci√≥n espec√≠fica si es un recurso, para que su 'type' en el mapa sea solo 'resource' si as√≠ lo deseas
                    // para la l√≥gica de interacci√≥n, o mantener el tipo espec√≠fico si prefieres.
                    // La l√≥gica actual en handleEntityInteraction ya maneja bien `targetSpawnInfo.entityTypeId` como type.
                    // if (entityTypeDefinition.type === "resource") newEntity.type = "resource";

                    gameState.map.entities.push(newEntity);
                    targetSpawnInfo.currentCount++;
                    spawnedThisCycle++;
                    console.log(`    SUCCESS: Spawned "${newEntity.name}" (Attack: ${newEntity.attack}, Final Type: ${newEntity.type}, OrigTypeID: ${newEntity.originalEntityTypeId}) in zone "${zone.name}" at (${spawnX},${spawnY}).`);
                } else {
                    // console.log(`    FAILED: Could not find position for "${targetSpawnInfo.entityTypeId}" ...`);
                    break;
                }
            }
            if (spawnedThisCycle > 0 && !initialPopulation) { 
                zone.spawnSettings.respawnTimer = zone.spawnSettings.respawnCooldown;
                console.log(`  Zone "${zone.name}": Spawned ${spawnedThisCycle} of "${targetSpawnInfo.entityTypeId}". Setting respawn timer to ${zone.spawnSettings.respawnCooldown}s.`);
            }
        });
    }

    // Funci√≥n para llamar en el bucle principal del juego o con setInterval
    function gameTickUpdater() {
        const now = Date.now();
        const deltaTime = (now - gameState.lastGameTimeUpdate) / 1000;
        gameState.gameTime += deltaTime;
        gameState.lastGameTimeUpdate = now;

        gameState.map.terrainZones.forEach(zone => {
            if (zone.spawnSettings) {
                if (zone.spawnSettings.respawnTimer > 0) {
                    zone.spawnSettings.respawnTimer -= deltaTime;
                    if (zone.spawnSettings.respawnTimer < 0) zone.spawnSettings.respawnTimer = 0;
                }

                // Comprobar si CUALQUIER tipo de entidad en la zona necesita reaparecer
                let needsRespawn = false;
                for (const target of zone.spawnSettings.targetEntities) {
                    if (target.currentCount < target.count) {
                        needsRespawn = true;
                        break;
                    }
                }
                // Ajustado el cooldown del chequeo de respawn para ser m√°s frecuente (e.g. 5-10s)
                const SPAWN_CHECK_COOLDOWN = 10; // Segundos
                if (needsRespawn && zone.spawnSettings.respawnTimer <= 0 && (gameState.gameTime - (zone.spawnSettings.lastSpawnCheck || 0) > SPAWN_CHECK_COOLDOWN)) { 
                    console.log(`gameTickUpdater: Zone "${zone.name}" needs respawn and timer is 0. Calling populateZoneWithObjects.`); // LOG
                    zone.spawnSettings.lastSpawnCheck = gameState.gameTime; // Actualizar ANTES de llamar para evitar bucles r√°pidos
                    populateZoneWithObjects(zone, false); // false porque no es poblaci√≥n inicial
                }
            }
        });
        // ...
    }
    // movePlayer() no necesita grandes cambios, ya que updatePlayerPosition()
    // se encarga ahora del scroll.
    let animationFrameIndex = 0; // Para ciclar a trav√©s de PLAYER_WALK_CYCLE
    let lastPlayerMoveTime = 0;   // Para controlar el tiempo de la animaci√≥n

    function movePlayer(dx, dy) {
        movePlayerCallCount++;
        const callId = movePlayerCallCount;
        // console.log(`[MovePlayer CALL #${callId}] dx:${dx}, dy:${dy}. Current Player: (${gameState.player.x}, ${gameState.player.y})`);

        if (gameState.player.isCultivating || gameState.battle.active) return;

        const newX = gameState.player.x + dx;
        const newY = gameState.player.y + dy;
        // console.log(`[MovePlayer CALL #${callId}] Calculated New Pos: (${newX},${newY})`);

        // 1. Comprobar l√≠mites del MUNDO
        if (newX < 0 || newX >= gameState.map.width || newY < 0 || newY >= gameState.map.height) {
            console.log(`[MovePlayer CALL #${callId}] Movimiento bloqueado: Fuera de l√≠mites.`);
            return;
        }

        // 2. Comprobar si el TERRENO en newX, newY es transitable
        const targetTerrainId = getTerrainTypeAt(newX, newY);
        const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
        if (targetTerrainData && targetTerrainData.walkable === false) {
            console.log(`[MovePlayer CALL #${callId}] Movimiento bloqueado: Terreno no transitable (${targetTerrainData.name}).`);
            showModal("Camino Bloqueado", `No puedes moverte sobre ${targetTerrainData.name}.`);
            return;
        }

        // 3. Comprobar ENTIDADES en newX, newY
        const entityAtNewPosition = gameState.map.entities.find(e => e.x === newX && e.y === newY);

        if (entityAtNewPosition) {
            console.log(`[MovePlayer CALL #${callId}] Entidad encontrada en (${newX},${newY}):`, JSON.parse(JSON.stringify(entityAtNewPosition))); // Log profundo de la entidad
            
            const entityTypeToCheck = entityAtNewPosition.originalEntityTypeId || entityAtNewPosition.type;
            console.log(`[MovePlayer CALL #${callId}] Tipo de entidad a verificar para bloqueo: '${entityTypeToCheck}'`);

            const entityDef = entityTypes[entityTypeToCheck]; // Usar el tipo correcto para buscar la definici√≥n
            if (entityDef) {
                console.log(`[MovePlayer CALL #${callId}] Definici√≥n de entidad encontrada:`, JSON.parse(JSON.stringify(entityDef)));
            } else {
                console.log(`[MovePlayer CALL #${callId}] ADVERTENCIA: No se encontr√≥ definici√≥n para el tipo '${entityTypeToCheck}'.`);
            }


            // 3.1. Si es una entidad de combate, iniciar batalla
            if (G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) || entityAtNewPosition.isBoss || entityAtNewPosition.isSectChallengeRival) {
                console.log(`[MovePlayer CALL #${callId}] Movimiento resulta en batalla con: ${entityAtNewPosition.name}`);
                startBattle(entityAtNewPosition);
                return; 
            }
            
            // 3.2. NUEVA L√ìGICA: Comprobar si es una entidad que bloquea el paso
            let isBlockingByType = G_BLOCKING_ENTITY_TYPES.includes(entityTypeToCheck);
            let isBlockingByNpcId = (entityDef && entityDef.npcId);

            console.log(`[MovePlayer CALL #${callId}] Verificando bloqueo: isBlockingByType (${entityTypeToCheck} en G_BLOCKING_ENTITY_TYPES) -> ${isBlockingByType}`);
            console.log(`[MovePlayer CALL #${callId}] Verificando bloqueo: isBlockingByNpcId (entidadDef tiene npcId) -> ${isBlockingByNpcId}`);

            if (isBlockingByType || isBlockingByNpcId) {
                console.log(`[MovePlayer CALL #${callId}] MOVIMIENTO BLOQUEADO por entidad: ${entityAtNewPosition.name}`);
                // showModal("Camino Bloqueado", `No puedes caminar sobre ${entityAtNewPosition.name}.`); // Opcional
                return; 
            }
            
            console.log(`[MovePlayer CALL #${callId}] Entidad ${entityAtNewPosition.name} no es de combate ni bloqueante por tipo/npcId. Se permite pasar (interacci√≥n con Espacio).`);

        } else {
            console.log(`[MovePlayer CALL #${callId}] No hay entidad en (${newX},${newY}).`);
        }

        // Si llegamos aqu√≠, la celda es transitable
        console.log(`[MovePlayer CALL #${callId}] Movimiento permitido a (${newX},${newY}).`);
        gameState.player.x = newX;
        gameState.player.y = newY;
        updatePlayerPosition(`movePlayer_call_${callId}`);
        // L√≥gica de emboscada (sin cambios)
        const adjacentOffsets = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
        for (const offset of adjacentOffsets) {
            const adjX = newX + offset.dx;
            const adjY = newY + offset.dy;
            if (adjX >= 0 && adjX < gameState.map.width && adjY >= 0 && adjY < gameState.map.height) {
                const adjEntity = gameState.map.entities.find(e => e.x === adjX && e.y === adjY);
                if (adjEntity && (G_COMBAT_ENTITY_TYPES.includes(adjEntity.type) || adjEntity.isBoss || adjEntity.isSectChallengeRival)) {
                    if (!adjEntity.discovered) {
                        adjEntity.discovered = true;
                        renderMap();
                    }
                    showModal("¬°Emboscada!", `¬°Un ${adjEntity.name} te ha visto y ataca!`, true);
                    setTimeout(() => {
                        closeModal();
                        startBattle(adjEntity);
                    }, 1500);
                    return;
                }
            }
        }
        updateUI();
    }



    // Ajuste menor en window.addEventListener('resize')
    window.addEventListener('resize', () => {
        calculateAndSetTileSize();
        // renderMap(); // updatePlayerPosition se encarga de esto
        updatePlayerPosition(); 
    });

    function getTerrainTypeAt(x, y) {
        if (x < 0 || x >= gameState.map.width || y < 0 || y >= gameState.map.height) {
            return null; // Fuera de los l√≠mites del mapa
        }

        // Opci√≥n A: Si usas terrainGrid directamente
        if (gameState.map.terrainGrid && gameState.map.terrainGrid[y] && gameState.map.terrainGrid[y][x]) {
            return gameState.map.terrainGrid[y][x];
        }

        // Opci√≥n B: Usando terrainZones
        for (const zone of gameState.map.terrainZones) {
            if (x >= zone.x1 && x <= zone.x2 && y >= zone.y1 && y <= zone.y2) {
                return zone.type;
            }
        }
        return gameState.map.defaultTerrain; // Devuelve el terreno por defecto
    }
    
    function renderMap(callerId = 'unknown') { // A√±adido callerId para depuraci√≥n
        const mapElement = document.getElementById('gameMap');
        const mapContainerElement = document.querySelector('.map-container');

        if (!mapElement || !mapContainerElement) {
            return;
        }
        
        const currentContainerWidth = mapContainerElement.clientWidth;
        const currentContainerHeight = mapContainerElement.clientHeight;

        const playerScreenX = (currentContainerWidth / 2) - (currentTileSize / 2);
        const playerScreenY = (currentContainerHeight / 2) - (currentTileSize / 2);
        const mapExpectedScrollX = - (gameState.player.x * currentTileSize) + playerScreenX;
        const mapExpectedScrollY = - (gameState.player.y * currentTileSize) + playerScreenY;
        
        const viewWorldXStart = Math.floor(-mapExpectedScrollX / currentTileSize);
        const viewWorldYStart = Math.floor(-mapExpectedScrollY / currentTileSize);
        const tilesInViewX = Math.ceil(currentContainerWidth / currentTileSize) + 2; // +2 para margen
        const tilesInViewY = Math.ceil(currentContainerHeight / currentTileSize) + 2; // +2 para margen
        const viewWorldXEnd = viewWorldXStart + tilesInViewX;
        const viewWorldYEnd = viewWorldYStart + tilesInViewY;

        mapElement.innerHTML = ''; 

        // 1. Renderizar TERRENO BASE
        for (let y = viewWorldYStart; y < viewWorldYEnd; y++) {
            for (let x = viewWorldXStart; x < viewWorldXEnd; x++) {
                if (x < 0 || x >= gameState.map.width || y < 0 || y >= gameState.map.height) {
                    continue; // No dibujar fuera de los l√≠mites del mundo
                }
                const terrainId = getTerrainTypeAt(x, y);
                const terrainData = G_TERRAIN_TYPES[terrainId];
                if (terrainData) {
                    const terrainTile = document.createElement('div');
                    terrainTile.className = 'tile terrain-tile'; 
                    terrainTile.style.left = `${x * currentTileSize}px`;
                    terrainTile.style.top = `${y * currentTileSize}px`;
                    terrainTile.style.width = `${currentTileSize}px`;
                    terrainTile.style.height = `${currentTileSize}px`;
                    
                    // --- INICIO VARIEDAD VISUAL TERRENO ---
                    let tileColor = terrainData.color;
                    let detailSymbol = '';
                    let detailOpacity = 0.15; // Opacidad para s√≠mbolos de detalle

                    // Generar un valor pseudoaleatorio basado en coordenadas para consistencia
                    const noiseVal = ((x * 31 + y * 13) % 100) / 100.0; // Simple hash

                    if (terrainId === 'GRASSLAND') {
                        if (noiseVal < 0.1) { // 10% de tiles un poco m√°s oscuros
                            tileColor = '#2A8C4A'; // Un verde ligeramente m√°s oscuro
                        } else if (noiseVal < 0.15) { // 5% con un "matojo"
                            detailSymbol = 'Ÿ¨'; // Coma o ap√≥strofe como peque√±o detalle
                        } else if (noiseVal < 0.2) {
                             detailSymbol = '¬∑';
                        }
                    } else if (terrainId === 'FOREST') {
                        if (noiseVal < 0.15) {
                            tileColor = '#166F3C'; // M√°s oscuro
                        } else if (noiseVal < 0.25) {
                            detailSymbol = '‚àó'; // Un peque√±o asterisco
                        }
                    } else if (terrainId === 'DESERT') {
                         if (noiseVal < 0.08) {
                            tileColor = '#FAD7A0'; // Ligeramente diferente
                        } else if (noiseVal < 0.15) {
                            detailSymbol = '¬∑';
                        }
                    }
                    // A√±adir m√°s reglas para otros tipos de terreno
                    
                    terrainTile.style.backgroundColor = tileColor;
                    // --- FIN VARIEDAD VISUAL TERRENO ---

                    terrainTile.style.fontSize = `${currentTileSize * 0.6}px`;
                    terrainTile.style.display = 'flex';
                    terrainTile.style.alignItems = 'center';
                    terrainTile.style.justifyContent = 'center';
                    terrainTile.style.zIndex = '1'; 

                    // S√≠mbolo principal del terreno (m√°s opaco)
                    const mainSymbolSpan = document.createElement('span');
                    mainSymbolSpan.textContent = terrainData.symbol;
                    mainSymbolSpan.style.opacity = '0.3'; 
                    terrainTile.appendChild(mainSymbolSpan);

                    // S√≠mbolo de detalle (si existe, m√°s transparente)
                    if (detailSymbol) {
                        const detailSymbolSpan = document.createElement('span');
                        detailSymbolSpan.textContent = detailSymbol;
                        detailSymbolSpan.style.position = 'absolute'; // Para superponerlo
                        // Posicionarlo aleatoriamente dentro del tile de forma sutil
                        detailSymbolSpan.style.left = `${(noiseVal * 50 + 25)}%`; // entre 25% y 75%
                        detailSymbolSpan.style.top = `${(((y*7 + x*3) % 50) + 25)}%`; // diferente variaci√≥n aleatoria
                        detailSymbolSpan.style.opacity = `${detailOpacity}`;
                        detailSymbolSpan.style.fontSize = `${currentTileSize * 0.4}px`; // M√°s peque√±o
                        detailSymbolSpan.style.transform = 'translate(-50%, -50%)'; // Centrar el s√≠mbolo de detalle
                        terrainTile.appendChild(detailSymbolSpan);
                    }
                    mapElement.appendChild(terrainTile);
                }
            }
        }

        // 2. Renderizar ENTIDADES (Monstruos, NPCs, Recursos, Decorativos)
        gameState.map.entities.forEach(entity => {
            // LOG para ver todas las entidades que se intentan renderizar y sus propiedades
            // console.log(`[RenderMap] Checking entity: ${entity.name || entity.type}, X:${entity.x}, Y:${entity.y}, Discovered: ${entity.discovered}, Decorative: ${entity.isDecorative}, Fixed: ${entity.isFixed}, Symbol: ${entity.symbol}`);

            if (entity.discovered) { 
                if (entity.x >= viewWorldXStart && entity.x < viewWorldXEnd &&
                    entity.y >= viewWorldYStart && entity.y < viewWorldYEnd) {
                    
                    const tile = document.createElement('div'); 

                    const displayTypeKey = entity.type; 
                    tile.className = `tile entity-on-map ${displayTypeKey.replace(/\s/g, '_')}`; 

                    tile.style.left = `${entity.x * currentTileSize}px`;
                    tile.style.top = `${entity.y * currentTileSize}px`;
                    tile.style.width = `${currentTileSize}px`;
                    tile.style.height = `${currentTileSize}px`;
                    tile.style.fontSize = `${currentTileSize * (entity.isDecorative ? 0.5 : 0.6)}px`; 
                    
                    // Esta l√≥gica para obtener el s√≠mbolo ya es robusta en tu c√≥digo:
                    const definitionForSymbol = entityTypes[entity.originalEntityTypeId] || entityTypes[entity.type];
                    tile.textContent = entity.symbol || (definitionForSymbol ? definitionForSymbol.symbol : '?');
                    
                    if (!tile.textContent || tile.textContent === '?') { 
                        console.warn(`[RenderMap] Entity ${entity.name || entity.type} at (${entity.x},${entity.y}) has NO SYMBOL or symbol is '?'! Definition key for fallback: ${entity.originalEntityTypeId || entity.type}. Entity instance:`, JSON.parse(JSON.stringify(entity)));
                    }

                    tile.style.zIndex = entity.isDecorative ? '3' : '5'; 
                    tile.style.backgroundColor = 'transparent'; 
                     if (entity.isDecorative) {
                        tile.style.opacity = '0.7'; 
                        // MODIFICACI√ìN: Log espec√≠fico cuando se va a dibujar un decorativo
                        // console.log(`[RenderMap] Drawing DECORATIVE entity: ${entity.name || entity.type} (Symbol: ${tile.textContent}) at ${entity.x},${entity.y} with zIndex ${tile.style.zIndex} and opacity ${tile.style.opacity}`);
                    }
                    
                    mapElement.appendChild(tile);
                }
            }
        });
        updatePlayerVisualSize(); // Asegura que el tama√±o del jugador tambi√©n se actualice
    }

    

    function updatePlayerSpriteVisual() { // Aseg√∫rate que el nombre sea este
        const player = gameState.player;
        const playerElement = document.getElementById('player');
        if (!playerElement) return;

        // Verificaci√≥n para depurar el error de la l√≠nea 2263
        if (!player.directionRowMap || typeof player.currentDirection === 'undefined') {
            console.error("CRITICAL: player.directionRowMap o player.currentDirection no est√°n definidos en updatePlayerSpriteVisual.", player);
            // Podr√≠as establecer valores por defecto aqu√≠ como un parche temporal,
            // pero lo ideal es que est√©n bien inicializados en gameState.
            // player.currentDirection = player.currentDirection || 'down';
            // player.directionRowMap = player.directionRowMap || { 'down': 0, 'left': 1, 'right': 2, 'up': 3 };
            // player.currentFrame = player.currentFrame || 0;
            // player.frameWidth = player.frameWidth || 64;
            // player.frameHeight = player.frameHeight || 64;
            return; // Salir si faltan datos cruciales para evitar m√°s errores
        }

        const row = player.directionRowMap[player.currentDirection];
        const col = player.currentFrame;

        // Otra verificaci√≥n
        if (typeof row === 'undefined' || typeof col === 'undefined') {
            console.error("CRITICAL: 'row' o 'col' son undefined en updatePlayerSpriteVisual.", { playerDir: player.currentDirection, playerFrame: player.currentFrame, map: player.directionRowMap });
            return;
        }

        const offsetX = col * player.frameWidth;
        const offsetY = row * player.frameHeight;

        playerElement.style.backgroundPosition = `-${offsetX}px -${offsetY}px`;

        if (gameState.battle.active) {
            const battlePlayerSprite = document.querySelector('.battle-area .character-sprite');
            if (battlePlayerSprite) {
                const battleRow = player.directionRowMap['down'];
                const battleFrame = 0; 
                const battleOffsetX = battleFrame * player.frameWidth;
                const battleOffsetY = battleRow * player.frameHeight;
                battlePlayerSprite.style.backgroundPosition = `-${battleOffsetX}px -${battleOffsetY}px`;
            }
        }
    }

    // Aseg√∫rate que G_TILE_SIZE sea igual a las dimensiones de tu frame de sprite
    // Si no, tendr√°s que ajustar c√≥mo se define el tama√±o del jugador.
    // En calculateAndSetTileSize, si currentTileSize se calcula din√°micamente,
    // y quieres que el jugador SIEMPRE tenga el tama√±o del sprite:
    function updatePlayerVisualSize() {
        const playerElement = document.getElementById('player');
        if (playerElement) {
          // ESTO ES CRUCIAL: El tama√±o del div del jugador DEBE ser el tama√±o de UN FRAME
          // Si currentTileSize representa el tama√±o deseado del jugador en pantalla,
          // y tus frames en la hoja de sprites son de un tama√±o fijo (ej. 64x64),
          // entonces el div del jugador tambi√©n debe ser de ese tama√±o fijo para que background-position funcione.
          // O, si quieres que el jugador se reescale con currentTileSize, entonces frameWidth/Height
          // deben ser iguales a currentTileSize, y background-size debe escalar la hoja completa.

          // Opci√≥n A: El jugador mantiene el tama√±o del frame original, y currentTileSize es solo para el mapa.
           playerElement.style.width = `${gameState.player.frameWidth}px`;
           playerElement.style.height = `${gameState.player.frameHeight}px`;
          // En este caso, .player y .character-sprite NO deber√≠an cambiar su width/height en @media queries
          // basados en currentTileSize, sino mantener el tama√±o del frame.

          // Opci√≥n B: El jugador se reescala con los tiles del mapa (m√°s complejo con spritesheets).
          // Si eliges esto, frameWidth y frameHeight en gameState.player deber√≠an ser actualizados
          // por calculateAndSetTileSize() para ser igual a currentTileSize.
          // Y el background-size del spritesheet necesitar√≠a ajustarse para que un "frame virtual"
          // dentro de la hoja escalada coincida con currentTileSize.
          // Ejemplo para Opci√≥n B:
          //playerElement.style.width = `${currentTileSize}px`;
          //playerElement.style.height = `${currentTileSize}px`;
          // Y en updatePlayerSpriteVisual, los c√°lculos de offsetX/Y necesitar√≠an
          // usar este currentTileSize en lugar de player.frameWidth/Height si la hoja
          // tambi√©n se est√° escalando.
          // Por ahora, mantengamos la Opci√≥n A (tama√±o de frame fijo) que es m√°s simple
          // si tu CSS para .player no est√° siendo sobrescrito por las @media queries.
      }
    }

    

    function updatePlayerPosition(callerId = 'unknown') {
        // ... (c√°lculos de scroll y movimiento del mapa) ...
        const playerElement = document.getElementById('player');
        const mapElement = document.getElementById('gameMap');
        const mapContainerElement = document.querySelector('.map-container');

        if (!playerElement || !mapElement || !mapContainerElement) {
            console.error("UpdatePlayerPosition: Elemento(s) clave no encontrado(s).");
            return;
        }
        // El div del jugador (.player) se centra en la pantalla con CSS o JS
        // Si el .game-container es flex y .map-container es flex-grow,
        // el .player (que est√° DENTRO de .map-container pero posicionado absoluto respecto a √©l o a .map)
        // se mover√° CON el .map si su 'left' y 'top' son relativos al .map.
        // Pero t√∫ quieres que el JUGADOR est√© CENTRADO en el .map-container, y el MAPA se mueva DETR√ÅS.

        // Centrar el JUGADOR en el MAP_CONTAINER
        // Aseg√∫rate que G_TILE_SIZE coincida con PLAYER_SPRITE_FRAME_WIDTH/HEIGHT para que el centrado sea preciso
        // o usa PLAYER_SPRITE_FRAME_WIDTH/HEIGHT para el c√°lculo del jugador.
        const playerVisualWidth = PLAYER_SPRITE_FRAME_WIDTH;  // Usar el tama√±o real del sprite
        const playerVisualHeight = PLAYER_SPRITE_FRAME_HEIGHT;

        const playerScreenX = (mapContainerElement.clientWidth / 2) - (playerVisualWidth / 2);
        const playerScreenY = (mapContainerElement.clientHeight / 2) - (playerVisualHeight / 2);

        playerElement.style.left = `${playerScreenX}px`;
        playerElement.style.top = `${playerScreenY}px`;

        // Mover el MAPA para que el jugador APARENTE estar en gameState.player.x, gameState.player.y
        // Aqu√≠ currentTileSize es el tama√±o de cada celda del mapa.
        const mapScrollX = - (gameState.player.x * currentTileSize) + playerScreenX;
        const mapScrollY = - (gameState.player.y * currentTileSize) + playerScreenY;
        
        mapElement.style.transform = `translate(${mapScrollX}px, ${mapScrollY}px)`;
        
        // Descubrir entidades
        gameState.map.entities.forEach(entity => {
            const distance = Math.abs(entity.x - gameState.player.x) + Math.abs(entity.y - gameState.player.y);
            if (distance <= G_PLAYER_DISCOVERY_RANGE) {
                if (!entity.discovered) entity.discovered = true;
            }
        });
        
        renderMap(callerId);    // Renderiza el mapa y las entidades
        updatePlayerSpriteVisual();   // Actualiza el frame del sprite del jugador
        updatePlayerVisualSize(); // Asegura el tama√±o correcto del div del jugador
    }
    
    // ... (el resto de tus funciones JS, como updateUI, movePlayer, interact, etc. SIN CAMBIOS IMPORTANTES aqu√≠,
    //      ya que los cambios principales son en el renderizado y tama√±o de tiles)
    function updateUI() {
        const player = gameState.player;
        document.getElementById('playerLevel').textContent = player.level;
        document.getElementById('playerRealm').textContent = player.realm;
        document.getElementById('hpText').textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
        document.getElementById('manaText').textContent = `${Math.floor(player.mana)}/${player.maxMana}`;
        document.getElementById('expText').textContent = `${Math.floor(player.exp)}/${player.expToNext}`;

        document.getElementById('hpBar').style.width = `${(player.hp / player.maxHp) * 100}%`;
        document.getElementById('manaBar').style.width = `${(player.mana / player.maxMana) * 100}%`;
        document.getElementById('expBar').style.width = `${(player.exp / player.expToNext) * 100}%`;
        document.getElementById('playerCoords').textContent = `X: ${player.x}, Y: ${player.y}`;
        updateToggleQiConversionButtonVisibility();
        updateInventoryUI();
        updateSectUI(); 
    }

    function updateInventoryUI() {
        const inventoryDisplay = document.getElementById('inventory');
        inventoryDisplay.innerHTML = '';
        Object.entries(gameState.inventory).forEach(([itemName, count]) => {
            if (count <= 0 && itemName !== "Piedras Espirituales") return; 

            const itemDiv = document.createElement('div');
            itemDiv.className = 'inventory-item';
            
            const itemInfo = itemData[itemName];
            const description = itemInfo ? itemInfo.description : "Un objeto misterioso.";
            itemDiv.innerHTML = `<strong>${itemName}: ${count}</strong><br><small><em>${description}</em></small>`;

            if (count > 0 && itemInfo && itemInfo.effect) { 
                const canBeUsedNow = itemInfo.canUse ? itemInfo.canUse(gameState.player) : true;
                itemDiv.style.cursor = canBeUsedNow ? 'pointer' : 'not-allowed';
                itemDiv.style.opacity = canBeUsedNow ? 1 : 0.6;
                itemDiv.title = canBeUsedNow ? `Usar ${itemName}` : `No puedes usar ${itemName} ahora.`;
                if (canBeUsedNow) {
                    itemDiv.onclick = () => useItem(itemName);
                }
            } else {
                itemDiv.style.opacity = 0.8; 
                itemDiv.style.cursor = 'default';
            }
            inventoryDisplay.appendChild(itemDiv);
        });
    }

    function updateToggleQiConversionButtonVisibility() {
        const button = document.getElementById('toggleQiConversionButton');
        if (gameState.player.canUseQiConversion) {
            button.style.display = 'inline-block';
            button.textContent = gameState.player.isQiConversionActive ? 
                '‚òØÔ∏è Detener Conversi√≥n Qi' : 
                '‚òØÔ∏è Activar Conversi√≥n Qi';
        } else {
            button.style.display = 'none';
        }
    }

    function updateRefinementUI() { }

    let movePlayerCallCount = 0;
    
    let lastPlayerAnimationUpdateTime = 0; // Renombrado para claridad
    
    function movePlayer(dx, dy) {
        const playerState = gameState.player; // Acceso m√°s corto

        if (playerState.isCultivating || gameState.battle.active) {
            if (playerState.isMoving) { // Si se estaba moviendo y se interrumpe
                playerState.isMoving = false;
                updatePlayerSpriteVisual();
            }
            return;
        }

        const prevDirection = playerState.spriteFacingDirection;
        let newDirection = prevDirection;

        if (dx > 0) newDirection = 'right';
        else if (dx < 0) newDirection = 'left';
        else if (dy > 0) newDirection = 'down';
        else if (dy < 0) newDirection = 'up';
        
        // console.log(`[MovePlayer] Attempt move. dx:${dx}, dy:${dy}. NewDir: ${newDirection}`);

        playerState.isMoving = true; // Intenci√≥n de moverse

        if (prevDirection !== newDirection) {
            playerState.spriteFacingDirection = newDirection;
            animationFrameIndex = 0; // Reiniciar animaci√≥n al cambiar de direcci√≥n
            playerState.spriteWalkFrame = PLAYER_WALK_CYCLE[animationFrameIndex];
            // console.log(`[MovePlayer] Direction changed to ${newDirection}. Reset animFrameIdx to 0.`);
        }

        const now = Date.now();
        if (now - lastPlayerAnimationUpdateTime > PLAYER_ANIMATION_SPEED) {
            animationFrameIndex = (animationFrameIndex + 1) % PLAYER_WALK_CYCLE.length;
            playerState.spriteWalkFrame = PLAYER_WALK_CYCLE[animationFrameIndex];
            lastPlayerAnimationUpdateTime = now;
            // console.log(`[MovePlayer] Animation tick. animFrameIdx: ${animationFrameIndex}, spriteWalkFrame set to col: ${playerState.spriteWalkFrame}`);
        }
        
        const newX = playerState.x + dx;
        const newY = playerState.y + dy;
        let canMove = true;

        if (newX < 0 || newX >= gameState.map.width || newY < 0 || newY >= gameState.map.height) {
            canMove = false; 
        } else {
            const targetTerrainId = getTerrainTypeAt(newX, newY);
            const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
            if (targetTerrainData && targetTerrainData.walkable === false) {
                // showModal("Camino Bloqueado", `No puedes moverte sobre ${targetTerrainData.name}.`); // Puede ser muy verboso
                canMove = false; 
            } else {
                const entityAtNewPosition = gameState.map.entities.find(e => e.x === newX && e.y === newY && e.type !== 'shop' && e.type !== 'secta_entrada_principal' && !(entityTypes[e.type] && entityTypes[e.type].npcId));
                if (entityAtNewPosition) {
                    if (G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) || entityAtNewPosition.isBoss || entityAtNewPosition.isSectChallengeRival) {
                        playerState.isMoving = false; // Detener animaci√≥n antes de la batalla
                        updatePlayerSpriteVisual(); 
                        startBattle(entityAtNewPosition); 
                        return; 
                    }
                }
            }
        }

        if (canMove) {
            playerState.x = newX;
            playerState.y = newY;
            updatePlayerPosition(`movePlayer_success`); 
            updateUI();
        } else {
            playerState.isMoving = false; // No se pudo mover, no est√° "movi√©ndose"
            // console.log("[MovePlayer] Movement blocked.");
        }
        
        updatePlayerSpriteVisual(); // Actualizar el sprite con la direcci√≥n y estado de movimiento actuales

        clearTimeout(playerState.stopMoveAnimTimer);
        playerState.stopMoveAnimTimer = setTimeout(() => {
            // console.log("[MovePlayer] Stop animation timer fired.");
            playerState.isMoving = false;
            // playerState.spriteWalkFrame = PLAYER_WALK_CYCLE[0]; // Volver al frame definido como "quieto"
            updatePlayerSpriteVisual(); // Asegurar que se muestre el frame de quieto
        }, PLAYER_ANIMATION_SPEED + 50); // Un poco m√°s que la velocidad de animaci√≥n del frame
    }

    let playerMovementKeysDown = { // Para rastrear qu√© teclas de movimiento est√°n presionadas
        'up': false, 'down': false, 'left': false, 'right': false
    };
    function handlePlayerMovementInput(direction, isKeyDown) {
        const player = gameState.player;

        if (isKeyDown) {
            playerMovementKeysDown[direction] = true;
            player.currentDirection = direction;
            player.isMoving = true;

            if (player.idleTimeout) {
                clearTimeout(player.idleTimeout);
                player.idleTimeout = null;
            }

            if (!player.animationTimer) {
                player.currentFrame = 1; 
                updatePlayerSpriteVisual(); // <--- CORREGIR AQU√ç
                player.animationTimer = setInterval(() => {
                    if (player.isMoving) {
                        player.currentFrame = (player.currentFrame + 1) % player.animationFrames;
                        if (player.currentFrame === 0) player.currentFrame = 1; 
                        updatePlayerSpriteVisual(); // <--- CORREGIR AQU√ç
                    }
                }, player.animationSpeed);
            }
        } else {
            playerMovementKeysDown[direction] = false;
            const stillMoving = Object.values(playerMovementKeysDown).some(status => status === true);

            if (!stillMoving) {
                player.isMoving = false;
                if (player.animationTimer) {
                    clearInterval(player.animationTimer);
                    player.animationTimer = null;
                }
                player.idleTimeout = setTimeout(() => {
                    if (!player.isMoving) { 
                        player.currentFrame = 0; 
                        updatePlayerSpriteVisual(); // <--- CORREGIR AQU√ç
                    }
                }, player.animationSpeed); 
            } else {
                if (playerMovementKeysDown['up']) player.currentDirection = 'up';
                else if (playerMovementKeysDown['down']) player.currentDirection = 'down';
                else if (playerMovementKeysDown['left']) player.currentDirection = 'left';
                else if (playerMovementKeysDown['right']) player.currentDirection = 'right';
                updatePlayerSpriteVisual(); // <--- CORREGIR AQU√ç
            }
        }
    }

    function interact() {
        if (gameState.player.isCultivating) {
            showModal("Acci√≥n no permitida", "Det√©n tu cultivo antes de interactuar.");
            return;
        }
        if (gameState.battle.active) {
            showModal("Acci√≥n no permitida", "No puedes interactuar durante el combate.");
            return;
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        const offsets = [ { dx: 0, dy: 0 }, { dx: 0, dy: -1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 } ];

        for (const offset of offsets) {
            const targetX = playerX + offset.dx;
            const targetY = playerY + offset.dy;
            const entity = gameState.map.entities.find(e => e.x === targetX && e.y === targetY);

            if (entity) {
                if (G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss || entity.isSectChallengeRival) {
                    const desafioMision = gameState.player.secta.misionesActivas.find(m =>
                        MISIONES_DATA[m.id]?.objetivo?.tipo === "derrotar_npc_especifico" &&
                        MISIONES_DATA[m.id]?.objetivo?.npcId === entity.npcId
                    );
                    if (entity.isSectChallengeRival) {
                        if (desafioMision) {
                            showModal("¬°Desaf√≠o Aceptado!", `Te preparas para enfrentar a ${entity.name}.`, true);
                            setTimeout(() => { closeModal(); startBattle(entity); }, 1500);
                        } else {
                            showModal("Paz, por ahora...", `${entity.name} te observa, pero no hay raz√≥n para luchar.`);
                        }
                    } else { 
                        showModal("¬°A la Batalla!", `Decides enfrentar a ${entity.name}.`, true);
                        setTimeout(() => { closeModal(); startBattle(entity); }, 1000);
                    }
                    return; 
                }
                else if (entity.interaction || entityTypes[entity.type]?.interaction || ['resource', 'master', 'cultivation', 'shop', 'secta_entrada_principal'].includes(entity.type)) {
                    handleEntityInteraction(entity);
                    return;
                }
            }
        }
    }

    function handleEntityInteraction(entity) {
        if (!entity) return;

        let interactionType = entity.interaction; // Priorizar la interacci√≥n de la instancia

        // Si no hay interacci√≥n en la instancia, buscar en la definici√≥n de entityTypes
        // usando entity.originalEntityTypeId si est√° disponible, sino entity.type
        const definitionKey = entity.originalEntityTypeId || entity.type;
        if (!interactionType && entityTypes[definitionKey]) {
            interactionType = entityTypes[definitionKey].interaction;
        }

        if (interactionType) {
            switch (interactionType) {
                case 'browse': 
                    if (entity.type === 'shop') { openShop(); return; } 
                    break;
                case 'talk_secta_npc': 
                    if (entity.npcId) { interactWithSectNPC(entity.npcId); return; } 
                    break;
                case 'access_sect_hall': 
                    if (entity.type === 'secta_entrada_principal') { openSectHallInterface(); return; } 
                    break;
                case 'collect_resource':
                    const rewardItem = entity.reward ||
                                        (entityTypes[entity.originalEntityTypeId] ? entityTypes[entity.originalEntityTypeId].reward : null) ||
                                        "Piedras Espirituales"; // √öltimo fallback

                    const itemNameDisplay = entity.name || (entityTypes[entity.originalEntityTypeId] ? entityTypes[entity.originalEntityTypeId].name : entity.type);

                    gameState.inventory[rewardItem] = (gameState.inventory[rewardItem] || 0) + 1;
                    showModal('Recurso Encontrado', `Has obtenido: 1 ${rewardItem}! (de ${itemNameDisplay})`);
                    removeEntity(entity); 
                    updateInventoryUI(); 
                    return;
                case 'learn_from_master':
                    const expGain = entity.expGain || entityTypes[entity.type]?.expGain || 50;
                    gainExperience(expGain);
                    showModal('Encuentro con Maestro', `El ${entity.name} te ha ense√±ado sabidur√≠a. Ganas ${expGain} EXP!`);
                    removeEntity(entity); 
                    return;
                case 'meditate_spot':
                    const manaGain = entity.manaGain || entityTypes[entity.type]?.manaGain || 20;
                    gameState.player.mana = Math.min(gameState.player.maxMana, gameState.player.mana + manaGain);
                    showModal('Lugar de Cultivo', `Has meditado en '${entity.name}'. Recuperas ${manaGain} Man√°.`);
                    removeEntity(entity); 
                    updateUI(); 
                    return;
                default: 
                    console.warn(`Interacci√≥n '${interactionType}' desconocida para ${entity.name} (Tipo: ${entity.type}, ID: ${entity.id}).`); 
                    break; 
            }
        } else {
             console.log(`No hay acci√≥n definida para tipo '${entity.type}' (Entidad: ${entity.name}, ID: ${entity.id}, OrigTypeID: ${entity.originalEntityTypeId}).`);
        }
    }
            
    function interactWithSectNPC(npcId) {
        const npcData = SECTA_DATA.npcs[npcId];
        const player = gameState.player;
        if (!npcData) return;

        let modalContentHTML = `<h3>${npcData.nombre} (${npcData.rol})</h3>`;
        modalContentHTML += `<p><em>"${npcData.dialogoInicial}"</em></p><hr>`;

        const elementsToProcess = []; // Para botones que necesitan listeners

        // --- SECCI√ìN: MISIONES PARA COMPLETAR ---
        modalContentHTML += `<h4>Misiones para Completar:</h4>`;
        let algunaMisionParaCompletar = false;
        player.secta.misionesActivas.forEach(misionActiva => {
            const misionDef = MISIONES_DATA[misionActiva.id];
            if (misionDef && misionDef.objetivo && misionDef.objetivo.npcEntrega === npcId) {
                // Verificar si los objetivos est√°n listos para este tipo de misi√≥n
                let listaParaEntregar = false;
                let objetivoStatus = "";
                const objetivo = misionActiva.objetivoOriginal;

                if (objetivo.tipo === "entregar_item") {
                    if ((gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad) {
                        listaParaEntregar = true;
                        objetivoStatus = `(Tienes ${gameState.inventory[objetivo.item]}/${objetivo.cantidad} ${objetivo.item})`;
                    } else {
                        objetivoStatus = `(Necesitas ${objetivo.cantidad - (gameState.inventory[objetivo.item] || 0)} m√°s ${objetivo.item})`;
                    }
                } else if (objetivo.tipo === "eliminar_enemigo") {
                    if (misionActiva.progreso >= objetivo.cantidad) {
                        listaParaEntregar = true;
                        objetivoStatus = `(${misionActiva.progreso}/${objetivo.cantidad} ${objetivo.nombreDisplay} eliminados)`;
                    } else {
                         objetivoStatus = `(Elimina ${objetivo.cantidad - misionActiva.progreso} m√°s ${objetivo.nombreDisplay})`;
                    }
                } else if (objetivo.tipo === "recolectar_multiples_items") {
                    let todosRecolectados = true;
                    let itemsStatusArray = [];
                    for (const itemReq of objetivo.items) {
                        const tiene = gameState.inventory[itemReq.nombre] || 0;
                        if (tiene < itemReq.cantidad) todosRecolectados = false;
                        itemsStatusArray.push(`${tiene}/${itemReq.cantidad} ${itemReq.nombre}`);
                    }
                    if (todosRecolectados) listaParaEntregar = true;
                    objetivoStatus = `(${itemsStatusArray.join(', ')})`;

                } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot"){
                    if (misionActiva.progreso === 1 && (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba){
                        listaParaEntregar = true;
                        objetivoStatus = `(Tienes ${objetivo.itemPrueba})`;
                    } else {
                         objetivoStatus = `(Consigue ${objetivo.itemPrueba})`;
                    }
                }
                // A√±adir m√°s casos si es necesario

                if (listaParaEntregar) {
                    const buttonId = `complete-mission-btn-${misionActiva.id.replace(/\s/g, '-')}`;
                    modalContentHTML += `<div style="padding: 5px; border: 1px solid #55cc55; margin-bottom: 5px;">
                                            <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                            <button id="${buttonId}">Completar Misi√≥n</button>
                                        </div>`;
                    elementsToProcess.push({ buttonId: buttonId, action: () => {
                        if (completeMission(misionActiva.id, npcId)) {
                            // Si la misi√≥n se complet√≥ con √©xito, refrescar el modal del NPC
                            // closeModal(); // Cierra el modal actual
                            interactWithSectNPC(npcId); // Vuelve a abrir con el estado actualizado
                        }
                    }});
                    algunaMisionParaCompletar = true;
                }
            }
        });
        if (!algunaMisionParaCompletar) modalContentHTML += "<p>No tienes misiones listas para entregarme.</p>";
        modalContentHTML += "<hr>";


        // --- SECCI√ìN: MISIONES DISPONIBLES (CON FILTRO DE NIVEL) ---
        if (npcData.misionesOfrecidas && npcData.misionesOfrecidas.length > 0) {
            modalContentHTML += "<h4>Misiones Disponibles:</h4>";
            modalContentHTML += `<div id="npc-dynamic-content-missions" style="max-height: 200px; overflow-y: auto; border: 1px solid #444; padding: 10px; margin-bottom:10px;">`;
            let algunaMisionMostrada = false;
            npcData.misionesOfrecidas.forEach((misionId, index) => {
                const mision = MISIONES_DATA[misionId];
                if (mision && 
                    !player.secta.misionesActivas.some(m => m.id === misionId) && 
                    !player.secta.misionesCompletadas[misionId] &&
                    (!mision.requisitoNivel || player.level >= mision.requisitoNivel) && // <<< FILTRO DE NIVEL
                    (!mision.requisitoRango || SECTA_DATA.rangos.findIndex(r=>r.nombre===player.secta.rango) >= SECTA_DATA.rangos.findIndex(r=>r.nombre===mision.requisitoRango)) // <<< FILTRO DE RANGO (opcional)
                   ) {
                    // ... (resto de la l√≥gica para mostrar el bot√≥n de aceptar misi√≥n)
                    let recompensaTextoResumido = `Recompensa: ${mision.recompensa.pcs || 0} PCS, ${mision.recompensa.exp || 0} EXP`;
                    if (mision.recompensa.items) recompensaTextoResumido += ", Objetos";
                    if (mision.recompensa.nuevoRango) recompensaTextoResumido += `, Ascenso a ${mision.recompensa.nuevoRango}`;
                    
                    const buttonId = `accept-mission-btn-${misionId.replace(/\s/g, '-')}-${index}`;
                    const botonHTML = `<button id="${buttonId}">Aceptar Misi√≥n</button>`; 
                    
                    modalContentHTML += `<div style="padding: 5px; border: 1px solid #555; margin-bottom: 5px;">
                                        <strong>${mision.titulo}</strong> (Req. Nv: ${mision.requisitoNivel || 1})<br><small>${mision.descripcion}</small><br>
                                        <small style="color: #aaa;"><em>${recompensaTextoResumido}</em></small><br>
                                        ${botonHTML} 
                                    </div>`;
                    elementsToProcess.push({ buttonId: buttonId, missionIdToAccept: misionId });
                    algunaMisionMostrada = true;
                }
            });
            if (!algunaMisionMostrada) modalContentHTML += "<p>No hay nuevas misiones para ti en este momento que cumplan tus requisitos.</p>";
            modalContentHTML += `</div>`;
            modalContentHTML += "<hr>";
        } else {
            modalContentHTML += "<p>No tengo misiones para ti en este momento.</p><hr>";
        }

        // --- SECCI√ìN: ENTREGA DE RECURSOS (sin cambios importantes) ---
        if (npcData.aceptaRecursos && npcData.aceptaRecursos.length > 0) {
            modalContentHTML += `<h4>Entregar Recursos:</h4>`;
            modalContentHTML += `<div id="npc-dynamic-content-resources">`;
            let puedeEntregarAlgo = false;
            npcData.aceptaRecursos.forEach(itemName => {
                const cantidadPlayer = gameState.inventory[itemName] || 0;
                if (cantidadPlayer > 0) {
                    const pcsPorItem = (itemName === "Hierbas Medicinales" ? 2 : (itemName === "Cristales de Qi" ? 5 : 10)); // Ajusta PCS como necesites
                    const buttonIdEntregar1 = `entregar-1-${itemName.replace(/\s/g, '-')}`;
                    const buttonIdEntregar5 = `entregar-5-${itemName.replace(/\s/g, '-')}`;
                    modalContentHTML += `<p>${itemName} (Tienes: ${cantidadPlayer}): 
                                    <button id="${buttonIdEntregar1}">Entregar 1 (${pcsPorItem} PCS)</button>
                                    ${cantidadPlayer >= 5 ? `<button id="${buttonIdEntregar5}">Entregar 5 (${pcsPorItem*5} PCS)</button>` : ''}
                                </p>`;
                    elementsToProcess.push({ buttonId: buttonIdEntregar1, action: () => { entregarRecursoSecta(itemName, 1, pcsPorItem); interactWithSectNPC(npcId); } });
                    if (cantidadPlayer >= 5) {
                        elementsToProcess.push({ buttonId: buttonIdEntregar5, action: () => { entregarRecursoSecta(itemName, 5, pcsPorItem * 5); interactWithSectNPC(npcId); } });
                    }
                    puedeEntregarAlgo = true;
                }
            });
            if (!puedeEntregarAlgo) modalContentHTML += "<p>No tienes recursos que pueda necesitar en este momento.</p>";
            modalContentHTML += `</div><hr>`;
        }

        showModal("Interacci√≥n con " + npcData.nombre, modalContentHTML);

        const modalTextEl = document.getElementById('modalText'); 
        if (modalTextEl) {
            elementsToProcess.forEach(item => {
                const buttonElement = modalTextEl.querySelector('#' + item.buttonId); 
                if (buttonElement) {
                    if (item.missionIdToAccept) { 
                        buttonElement.addEventListener('click', () => {
                            acceptMission(item.missionIdToAccept);
                            interactWithSectNPC(npcId); // Re-abre el modal del NPC para actualizarlo
                        });
                    } else if (item.action) { 
                        buttonElement.addEventListener('click', item.action);
                        // No refrescar aqu√≠, la acci√≥n de entregar ya refresca.
                    }
                } else {
                    console.warn("No se encontr√≥ el bot√≥n con ID:", item.buttonId, "dentro de #modalText para a√±adir listener.");
                }
            });
        } else {
            console.error("El elemento #modalText no fue encontrado para adjuntar listeners a los botones din√°micos.");
        }
    }

    function entregarRecursoSecta(itemName, cantidad, pcsGanados) {
        if ((gameState.inventory[itemName] || 0) < cantidad) {
            showModal("Error", "No tienes suficientes objetos.");
            return;
        }
        gameState.inventory[itemName] -= cantidad;
        gameState.player.secta.puntosContribucion += pcsGanados;
        showModal("Recurso Entregado", `Entregaste ${cantidad} ${itemName} y ganaste ${pcsGanados} PCS.`);
        updateSectUI(); updateInventoryUI(); checkAndActivateRankChallengeMissions();
        closeModal(); 
    }

    function acceptMission(misionId) {
        const misionData = MISIONES_DATA[misionId];
        const player = gameState.player;
        if (!misionData) { showModal("Error de Misi√≥n", "Datos no encontrados."); return; }
        if (player.secta.misionesActivas.some(m => m.id === misionId) || player.secta.misionesCompletadas[misionId]) {
            showModal("Error de Misi√≥n", "Ya activa/completada."); return;
        }
        if (!misionData.objetivo) { showModal("Error de Misi√≥n", "Objetivo no definido."); return; }

        let nuevaMisionActiva;
        try {
            nuevaMisionActiva = { id: misionId, progreso: 0, objetivoOriginal: JSON.parse(JSON.stringify(misionData.objetivo)) };
        } catch (error) { showModal("Error de Misi√≥n", "Problema al procesar objetivo."); return; }

        player.secta.misionesActivas.push(nuevaMisionActiva);
        showModal("Misi√≥n Aceptada", `Has aceptado: ${misionData.titulo}`);
        updateSectUI();

        const npcInteractionModal = document.getElementById('interactionModal');
        const modalTitleElement = document.getElementById('modalTitle');
        if (npcInteractionModal.style.display === 'flex' && modalTitleElement && modalTitleElement.textContent.includes("Interacci√≥n con Secta")) {
            closeModal();
        }
    }

    function removeEntity(entityToRemove) {
        const index = gameState.map.entities.findIndex(e => e.id === entityToRemove.id); // Usar ID √∫nico
        
        if (index > -1) {
            const removedEntity = gameState.map.entities.splice(index, 1)[0];

            // Si la entidad proven√≠a de una zona de spawn, actualizar el contador de esa zona
            if (removedEntity.zoneOrigin) {
                const originZone = gameState.map.terrainZones.find(z => z.name === removedEntity.zoneOrigin && z.spawnSettings);
                if (originZone) {
                    
                    const targetSpawnInfo = originZone.spawnSettings.targetEntities.find(
                        t => t.entityTypeId === removedEntity.originalEntityTypeId // <-- USAR ESTO
                    );
                    if (targetSpawnInfo && targetSpawnInfo.currentCount > 0) {
                        targetSpawnInfo.currentCount--;
                        // console.log(`Entidad ${removedEntity.name} eliminada de zona ${originZone.name}. Restantes de tipo ${targetSpawnInfo.entityTypeId}: ${targetSpawnInfo.currentCount}`);

                        // Si el contador baja y el timer estaba en cooldown, podemos resetear el timer
                        // para que intente reaparecer antes si la zona est√° por debajo del objetivo.
                        // Opcional: Podr√≠as querer que el cooldown siempre se cumpla.
                        // if (originZone.spawnSettings.respawnTimer > 10) { // Si estaba en cooldown largo
                        //    originZone.spawnSettings.respawnTimer = 10; // Poner un cooldown corto para el pr√≥ximo chequeo
                        // }
                    }
                }
            }
            renderMap(); // Actualizar visualizaci√≥n
        }
    }

    function isRespawnNeeded() {
        const player = gameState.player;
        const activeBoss = gameState.map.entities.find(e => e.isBoss && 
                                                            !player.worldState.defeatedBosses[e.id || e.type] &&
                                                            (Math.abs(e.x - player.x) <= 5 && Math.abs(e.y - player.y) <= 5)); 
        return !activeBoss;
    }

    function toggleCultivation() {
        if (gameState.battle.active) {
            showModal("Acci√≥n no permitida", "No puedes cultivar en combate."); return;
        }
        if (gameState.player.isCultivating) {
            showActiveCultivationModal(); 
        } else {
            openCultivationChoiceModal();
        }
    }

    function openCultivationChoiceModal() {
        const player = gameState.player;
        const techniquesListDiv = document.getElementById('cultivableTechniquesList');
        techniquesListDiv.innerHTML = ''; 
        let hasCultivableTechniques = false;
        for (const techId in player.learnedTechniques) {
            const playerTech = player.learnedTechniques[techId];
            const techData = techniqueData[techId];
            if (techData && techData.cultivationSettings && playerTech.level < techData.maxLevel) {
                hasCultivableTechniques = true;
                const techButton = document.createElement('button');
                techButton.className = 'cultivation-option-btn';
                techButton.textContent = `${techData.name} (Nv. ${playerTech.level})`;
                techButton.onclick = () => { startCultivationMode('technique', techId); closeCultivationChoiceModal(); };
                techniquesListDiv.appendChild(techButton);
            }
        }
        if (!hasCultivableTechniques) {
            techniquesListDiv.innerHTML = '<p>No tienes t√©cnicas que requieran m√°s cultivo.</p>';
        }
        document.getElementById('cultivationChoiceModal').style.display = 'flex';
        hideTouchControls(); 
    }

    function closeCultivationChoiceModal() {
        document.getElementById('cultivationChoiceModal').style.display = 'none';
        showTouchControls(); 
    }
      
    function startCultivationMode(type, targetId = null) {
        const player = gameState.player;
        if (player.isCultivating) { 
            stopCultivation(); 
        }

        player.isCultivating = true;
        player.cultivationMode.type = type;
        player.cultivationMode.targetId = targetId;
        player.cultivationMode.startTime = Date.now();
        
        // Si se inicia el modo de recuperaci√≥n, reseteamos el progreso de su barra visual
        if (type === 'recovery') {
            recoveryProgress = 0;
            recoveryDirection = 1;
        }
            
        const cultivateBtnSidebar = document.getElementById('cultivateButton'); 
        if (cultivateBtnSidebar) {
            cultivateBtnSidebar.textContent = 'üö´ Detener Cultivo';
        } else {
            console.error("Error en startCultivationMode: No se encontr√≥ 'cultivateButton'.");
        }
        
        if (gameState.cultivationInterval) clearInterval(gameState.cultivationInterval);
        gameState.cultivationInterval = setInterval(processCultivationTick, 1000);

        showActiveCultivationModal(); 
    }

    function stopCultivation() {
        const player = gameState.player;
        if (!player.isCultivating) return;
        player.isCultivating = false;

        if (gameState.cultivationInterval) { clearInterval(gameState.cultivationInterval); gameState.cultivationInterval = null; }
        
        closeActiveCultivationModal(); 

        const cultivateBtn = document.getElementById('cultivateButton');
        if (cultivateBtn) cultivateBtn.textContent = 'üßò‚Äç‚ôÄÔ∏è Cultivar';
        
        const durationSeconds = Math.floor((Date.now() - player.cultivationMode.startTime) / 1000);
        showModal("Cultivo Terminado", `Has terminado de meditar/cultivar por ${durationSeconds} segundos.`);
        updateUI(); 
        if (document.getElementById('techniqueModal').style.display === 'flex') { showTechniquePanel(); }
    }

    function showActiveCultivationModal() {
        const player = gameState.player;
        const mode = player.cultivationMode;
        const modal = document.getElementById('activeCultivationModal');
        const title = document.getElementById('activeCultivationTitle');
        const description = document.getElementById('activeCultivationDescription');
        
        const techniqueProgressUIDiv = document.getElementById('activeCultivationProgressUI');
        const recoveryProgressUIDiv = document.getElementById('recoveryCultivationProgressUI');
        const cultivationBoostSection = document.getElementById('cultivationBoostSection'); // Nueva referencia

        if (!player.isCultivating) {
            closeActiveCultivationModal();
            return;
        }

        // Ocultar todas las UIs de progreso y la secci√≥n de boost primero
        if (techniqueProgressUIDiv) techniqueProgressUIDiv.style.display = 'none';
        if (recoveryProgressUIDiv) recoveryProgressUIDiv.style.display = 'none';
        if (cultivationBoostSection) cultivationBoostSection.style.display = 'none'; // Ocultar por defecto

        if (mode.type === 'recovery') {
            title.textContent = "Meditaci√≥n Restauradora";
            description.textContent = "Recuperando energ√≠a vital, Qi y absorbiendo experiencia del entorno.";
            
            if (recoveryProgressUIDiv) {
                recoveryProgressUIDiv.style.display = 'block'; 
                const recoveryProgressBar = document.getElementById('recoveryProgressBar'); 
                const recoveryCycleText = document.getElementById('recoveryCycleText'); 
                const modalHpText = document.getElementById('modalHpText');
                const modalHpBar = document.getElementById('modalHpBar');
                const modalManaText = document.getElementById('modalManaText');
                const modalManaBar = document.getElementById('modalManaBar');

                if (recoveryProgressBar) recoveryProgressBar.style.width = `${recoveryProgress}%`;
                if (recoveryCycleText) recoveryCycleText.textContent = recoveryDirection === 1 ? "Inhalando Qi..." : "Exhalando impurezas...";
                if (modalHpText) modalHpText.textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
                if (modalHpBar) modalHpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
                if (modalManaText) modalManaText.textContent = `${Math.floor(player.mana)}/${player.maxMana}`;
                if (modalManaBar) modalManaBar.style.width = `${(player.mana / player.maxMana) * 100}%`;
            }

        } else if (mode.type === 'technique' && mode.targetId) {
            const techData = techniqueData[mode.targetId];
            const playerTech = player.learnedTechniques[mode.targetId];

            if (techData && playerTech) {
                title.textContent = `Cultivando: ${techData.name}`;
                description.textContent = techData.description;
                
                if (techniqueProgressUIDiv) {
                    techniqueProgressUIDiv.style.display = 'block';
                    const targetNameSpan = document.getElementById('activeCultivationTargetName');
                    const targetLevelSpan = document.getElementById('activeCultivationTargetLevel');
                    const techniqueProgressBar = document.getElementById('activeCultivationProgressBar');
                    const techniqueProgressText = document.getElementById('activeCultivationProgressText');

                    if (targetNameSpan) targetNameSpan.textContent = techData.name;
                    if (targetLevelSpan) targetLevelSpan.textContent = playerTech.level;

                    const timeToNext = playerTech.cultivationTimeToNextLevel || (techData.cultivationSettings ? techData.cultivationSettings.baseTimeToLevelUp : Infinity);
                    const progressPercent = playerTech.currentCultivationProgress && timeToNext !== Infinity
                                            ? (playerTech.currentCultivationProgress / timeToNext) * 100 
                                            : (playerTech.level >= techData.maxLevel ? 100 : 0);
                    if (techniqueProgressBar) techniqueProgressBar.style.width = `${Math.min(100, progressPercent)}%`;
                    if (techniqueProgressText) techniqueProgressText.textContent = timeToNext === Infinity ? "Nivel M√°ximo" : `${Math.floor(playerTech.currentCultivationProgress || 0)}s / ${timeToNext}s`;
                }

                // Mostrar y configurar la secci√≥n de aceleraci√≥n
                if (cultivationBoostSection) {
                    cultivationBoostSection.style.display = 'block';
                    document.getElementById('cultivationModalPlayerStones').textContent = gameState.inventory["Piedras Espirituales"] || 0;
                    const boostButton = document.getElementById('boostCultivationButton');
                    if (boostButton) {
                        boostButton.disabled = (gameState.inventory["Piedras Espirituales"] || 0) < 1 || playerTech.level >= techData.maxLevel;
                        if (playerTech.level >= techData.maxLevel) {
                            boostButton.title = "T√©cnica al m√°ximo nivel";
                        } else if ((gameState.inventory["Piedras Espirituales"] || 0) < 1) {
                            boostButton.title = "Piedras Espirituales insuficientes";
                        } else {
                            boostButton.title = "Acelerar Cultivo (1 Piedra = 10s)";
                        }
                    }
                }

            } else {
                // Fallback a recuperaci√≥n si hay un error
                title.textContent = "Meditaci√≥n Restauradora";
                description.textContent = "Error al cargar datos de t√©cnica/habilidad. Cultivo de recuperaci√≥n activado.";
                if (recoveryProgressUIDiv) {
                    recoveryProgressUIDiv.style.display = 'block';
                    const modalHpText = document.getElementById('modalHpText');
                    const modalHpBar = document.getElementById('modalHpBar');
                    const modalManaText = document.getElementById('modalManaText');
                    const modalManaBar = document.getElementById('modalManaBar');
                    if (modalHpText) modalHpText.textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
                    if (modalHpBar) modalHpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
                    if (modalManaText) modalManaText.textContent = `${Math.floor(player.mana)}/${player.maxMana}`;
                    if (modalManaBar) modalManaBar.style.width = `${(player.mana / player.maxMana) * 100}%`;
                }
            }
        } // No a√±adas llaves extra aqu√≠, aseg√∫rate de que la funci√≥n cierra correctamente.


        if (modal) modal.style.display = 'flex';
        hideTouchControls();
    }


    function closeActiveCultivationModal() {
        document.getElementById('activeCultivationModal').style.display = 'none';
        showTouchControls(); 
    }

    function processCultivationTick() {
        const player = gameState.player;
        if (!player.isCultivating) {
            clearInterval(gameState.cultivationInterval);
            gameState.cultivationInterval = null;
            return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        if (mode === 'recovery') {
            // --- Recuperaci√≥n General ---
            if (player.hp < player.maxHp) player.hp = Math.min(player.maxHp, player.hp + player.hpPerSecondBase);
            
            let manaGainThisTick = player.qiPerSecondBase;
            if (player.canUseQiConversion && player.isQiConversionActive && player.learnedTechniques["qi_to_hp_conversion_1"]) {
                // ... (l√≥gica de conversi√≥n Qi a HP sin cambios) ...
                const conversionTechInfo = techniqueData["qi_to_hp_conversion_1"];
                const playerConversionTech = player.learnedTechniques["qi_to_hp_conversion_1"];
                if (conversionTechInfo?.effect && playerConversionTech.level > 0) {
                    const effectDef = conversionTechInfo.effect;
                    const techLevel = playerConversionTech.level;
                    let currentManaCost = effectDef.baseManaCostPerSecond - ((effectDef.manaCostReductionPerLevel || 0) * (techLevel - 1));
                    currentManaCost = Math.max(0.1, currentManaCost);
                    let currentHpGain = effectDef.baseHpGainPerSecond + ((effectDef.hpGainIncreasePerLevel || 0) * (techLevel - 1));
                    if (player.mana >= currentManaCost && player.hp < player.maxHp) {
                        player.mana -= currentManaCost;
                        manaGainThisTick = 0; 
                        player.hp = Math.min(player.maxHp, player.hp + currentHpGain);
                    }
                }
            }
            if (player.mana < player.maxMana && manaGainThisTick > 0) {
                player.mana = Math.min(player.maxMana, player.mana + manaGainThisTick);
            }
            gainExperience(player.expPerSecondBase);

            // --- L√≥gica para la barra de progreso de recuperaci√≥n ---
            const increment = 100 / RECOVERY_CYCLE_DURATION; // % a cambiar por segundo
            recoveryProgress += recoveryDirection * increment;

            if (recoveryProgress >= 100) {
                recoveryProgress = 100;
                recoveryDirection = -1; // Cambiar a vaciar
                 document.getElementById('recoveryCycleText').textContent = "Exhalando impurezas...";
            } else if (recoveryProgress <= 0) {
                recoveryProgress = 0;
                recoveryDirection = 1; // Cambiar a llenar
                 document.getElementById('recoveryCycleText').textContent = "Inhalando Qi...";
            }
            document.getElementById('recoveryProgressBar').style.width = `${recoveryProgress}%`;

        } else if (mode === 'technique' && targetId) {
            // ... (l√≥gica de cultivo de t√©cnica sin cambios) ...
            const playerTech = player.learnedTechniques[targetId];
            const techData = techniqueData[targetId];
            if (playerTech && techData && techData.cultivationSettings && playerTech.level < techData.maxLevel) {
                playerTech.currentCultivationProgress = (playerTech.currentCultivationProgress || 0) + 1;
                gainExperience(player.expPerSecondBase * 0.2); 
                if (playerTech.currentCultivationProgress >= playerTech.cultivationTimeToNextLevel) {
                    playerTech.level++;
                    playerTech.currentCultivationProgress = 0;
                    if (playerTech.level < techData.maxLevel) {
                        playerTech.cultivationTimeToNextLevel = Math.floor(
                            techData.cultivationSettings.baseTimeToLevelUp * (techData.cultivationSettings.levelTimeMultiplier * playerTech.level) 
                        );
                        playerTech.cultivationTimeToNextLevel = Math.max(techData.cultivationSettings.baseTimeToLevelUp, playerTech.cultivationTimeToNextLevel);
                    } else {
                        playerTech.cultivationTimeToNextLevel = Infinity; 
                    }
                    applyTechniqueEffect(targetId, playerTech.level); 
                    recalculatePlayerStats(); 
                    let message = `¬°Has cultivado '${techData.name}' al Nivel ${playerTech.level}!`;
                    if (playerTech.level >= techData.maxLevel) {
                        message += " (¬°Nivel M√°ximo alcanzado!)";
                    }
                    
                    // Detener el cultivo DESPU√âS de aplicar efectos y mostrar el mensaje.
                    stopCultivation(); // <--- ¬°AQU√ç SE DETIENE EL CULTIVO!
                    showModal("¬°T√©cnica Mejorada!", message + "\n\nEl cultivo se ha detenido. Puedes reiniciarlo si lo deseas."); // Mensaje modificado
                    
                    if (document.getElementById('techniqueModal').style.display === 'flex') { showTechniquePanel(); }
                    // No necesitamos cambiar a 'recovery' aqu√≠ a menos que se alcance el nivel m√°ximo Y se quiera automatizar.
                    // Pero la petici√≥n es detenerlo siempre que suba de nivel.
                }
            } else if (playerTech && techData && playerTech.level >= techData.maxLevel) {
                // Si ya estaba en nivel m√°ximo y se intenta cultivar (no deber√≠a pasar si se detiene antes)
                stopCultivation(); 
                // Opcionalmente, iniciar modo recuperaci√≥n si ya estaba al m√°ximo
                // startCultivationMode('recovery'); 
            }
        } else if (mode === 'skill' && targetId) {
            // ...
        }

        updateUI(); 
        if (document.getElementById('activeCultivationModal').style.display === 'flex') {
            showActiveCultivationModal(); // Refresca el modal, incluyendo la nueva barra de recuperaci√≥n
        }
    }
   
    function boostCultivationProgress() {
        const player = gameState.player;
        const mode = player.cultivationMode;

        if (!player.isCultivating || mode.type !== 'technique' || !mode.targetId) {
            showModal("Error de Aceleraci√≥n", "Solo puedes acelerar el cultivo activo de una t√©cnica espec√≠fica.");
            return;
        }

        if ((gameState.inventory["Piedras Espirituales"] || 0) < 1) {
            showModal("Piedras Insuficientes", "No tienes suficientes Piedras Espirituales para acelerar.");
            return;
        }

        const techId = mode.targetId;
        const playerTech = player.learnedTechniques[techId];
        const techData = techniqueData[techId];

        if (!playerTech || !techData || !techData.cultivationSettings || playerTech.level >= techData.maxLevel) { // A√±adida comprobaci√≥n de techData.cultivationSettings
            showModal("L√≠mite Alcanzado", "Esta t√©cnica ya est√° en su nivel m√°ximo, no se puede cultivar m√°s, o faltan datos de cultivo.");
            const boostButton = document.getElementById('boostCultivationButton');
            if (boostButton) boostButton.disabled = true;
            return;
        }

        // Consumir piedra
        gameState.inventory["Piedras Espirituales"]--;

        // A√±adir progreso (10 segundos)
        playerTech.currentCultivationProgress = (playerTech.currentCultivationProgress || 0) + 10;
        gainExperience(player.expPerSecondBase * 0.2 * 2); 

        let leveledUpThisBoost = false;
        let firstLevelUpMessage = ""; 

        // Asegurarse de que cultivationTimeToNextLevel est√° inicializado si el nivel es 0
        if (playerTech.level === 0 && (!playerTech.cultivationTimeToNextLevel || playerTech.cultivationTimeToNextLevel === Infinity)) {
            playerTech.cultivationTimeToNextLevel = techData.cultivationSettings.baseTimeToLevelUp;
        }


        while (playerTech.currentCultivationProgress >= playerTech.cultivationTimeToNextLevel && playerTech.level < techData.maxLevel) {
            playerTech.level++;
            playerTech.currentCultivationProgress -= playerTech.cultivationTimeToNextLevel; 
            
            if (playerTech.level < techData.maxLevel) {
                playerTech.cultivationTimeToNextLevel = Math.floor(
                    techData.cultivationSettings.baseTimeToLevelUp * (techData.cultivationSettings.levelTimeMultiplier * playerTech.level)
                );
                // La siguiente l√≠nea es crucial: Asegura que el tiempo calculado no sea MENOR que el baseTimeToLevelUp.
                // Y aqu√≠ estaba el error: se usaba baseTimeToNextLevel en lugar de baseTimeToLevelUp
                playerTech.cultivationTimeToNextLevel = Math.max(techData.cultivationSettings.baseTimeToLevelUp, playerTech.cultivationTimeToNextLevel); // <-- CORRECCI√ìN IMPORTANTE AQU√ç
            } else {
                playerTech.currentCultivationProgress = 0; 
                playerTech.cultivationTimeToNextLevel = Infinity;
            }
            
            applyTechniqueEffect(techId, playerTech.level);
            recalculatePlayerStats();

            if (!leveledUpThisBoost) { 
                firstLevelUpMessage = `¬°Aceleraste '${techData.name}' al Nivel ${playerTech.level}!`;
                if (playerTech.level >= techData.maxLevel) {
                    firstLevelUpMessage += " (¬°Nivel M√°ximo alcanzado!)";
                }
            }
            leveledUpThisBoost = true;
        }
        
        if (leveledUpThisBoost) {
            stopCultivation(); 
            showModal("¬°T√©cnica Mejorada con Aceleraci√≥n!", firstLevelUpMessage + "\n\nEl cultivo se ha detenido. Puedes reiniciarlo.");
        } else if (playerTech.level >= techData.maxLevel) {
            stopCultivation();
            showModal("Nivel M√°ximo Alcanzado", `La t√©cnica ${techData.name} ya est√° en su m√°ximo potencial. El cultivo se ha detenido.`);
        }

        updateUI(); 
        // Es importante llamar a showActiveCultivationModal() DESPU√âS de stopCultivation() si el cultivo se detuvo,
        // o si no se detuvo, para que refleje el estado actual.
        // Si se detuvo, el modal se cerrar√° por stopCultivation(). Si el modal no est√° abierto, esta llamada no har√° nada.
        if (document.getElementById('activeCultivationModal').style.display === 'flex') {
            showActiveCultivationModal(); 
        }
        
        if (document.getElementById('techniqueModal').style.display === 'flex') {
            showTechniquePanel(); 
        }
    }

    function toggleQiConversionMode() {
        if (!gameState.player.canUseQiConversion) {
            showModal("Habilidad Bloqueada", "Debes dominar la T√©cnica de Conversi√≥n de Qi."); return;
        }
        if (gameState.player.isCultivating) {
            showModal("Acci√≥n no Permitida", "Det√©n tu cultivo antes de cambiar conversi√≥n."); return;
        }
        gameState.player.isQiConversionActive = !gameState.player.isQiConversionActive;
        updateToggleQiConversionButtonVisibility();
        showModal("Modo de Cultivo", `Conversi√≥n de Qi ${gameState.player.isQiConversionActive ? "Activada" : "Desactivada"}.`);
    }

    function useItem(itemName) {
        if (gameState.battle.active) {
            showModal("Acci√≥n no permitida", "No puedes usar objetos del inventario en combate desde aqu√≠."); return;
        }
        if (!gameState.inventory[itemName] || gameState.inventory[itemName] <= 0) {
            showModal("Inventario Vac√≠o", `No tienes ${itemName}.`); return;
        }
        const itemInfo = itemData[itemName];
        if (!itemInfo || !itemInfo.effect) {
            showModal("Error", `${itemName} no tiene efecto o no se puede usar as√≠.`); return;
        }
        if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
            let reason = "No puedes usar esto ahora."; 
            if (itemName === "Hierbas Medicinales" && gameState.player.hp >= gameState.player.maxHp) reason = "Vida al m√°ximo.";
            if (itemName === "Cristales de Qi" && gameState.player.mana >= gameState.player.maxMana) reason = "Man√° al m√°ximo.";
            showModal("No se puede usar", reason); return;
        }
        const message = (itemName === "Piedras Espirituales" || itemName === "N√∫cleo de Bestia Menor" || (itemInfo.description && (itemInfo.description.includes("Otorga") || itemInfo.description.includes("otorga")))) ?
                        itemInfo.effect(gameState.player, gainExperience) :
                        itemInfo.effect(gameState.player);
        
        // Solo decrementar si el mensaje no indica un error (por si el efecto mismo retorna un error)
        if (message && !message.toLowerCase().includes("error") && !message.toLowerCase().includes("al m√°ximo")) {
            gameState.inventory[itemName]--;
        }
        showModal("Objeto Usado", message);
        updateUI();
    }

    function gainExperience(amount) {
        if (amount <= 0) return;
        gameState.player.exp += amount;
        while (gameState.player.exp >= gameState.player.expToNext) {
            levelUp();
        }
    }

    function levelUp() {
        const player = gameState.player;
        player.exp -= player.expToNext;
        player.level++;
        

        const hpIncrease = 20 + Math.floor(player.level / 2); 
        const manaIncrease = 10 + Math.floor(player.level / 3);
        const attackIncrease = 2 + Math.floor(player.level / 4);
        const defenseIncrease = 1 + Math.floor(player.level / 5);

        player.baseMaxHp += hpIncrease;
        player.baseMaxMana += manaIncrease;
        player.baseAttack += attackIncrease;
        player.baseDefense += defenseIncrease;
        
        player.hp = player.baseMaxHp; // Rellenar HP y Mana al subir de nivel
        player.mana = player.baseMaxMana;
        player.expToNext = Math.floor(player.expToNext * (1.3 + player.level * 0.02)); 

        const oldRealm = player.realm;
        const realms = ["Mortal", "Forjado del Cuerpo", "Condensaci√≥n de Qi", "Fundaci√≥n", "N√∫cleo Dorado", "Alma Naciente", "Esp√≠ritu Primordial"];
        const realmIndex = Math.min(Math.floor((player.level - 1) / 5), realms.length - 1);
        player.realm = realms[realmIndex];
        let realmChangeMessage = "";
        if (player.realm !== oldRealm) {
            realmChangeMessage = `\n\n¬°Has avanzado al Reino de ${player.realm}! Sientes una profunda transformaci√≥n...`;
            generateMap(true); 
        }
        recalculatePlayerStats(); 
        
        showModal('¬°Nivel Aumentado!', `Nivel ${player.level}!\nReino: ${player.realm}\n+${hpIncrease} HP, +${manaIncrease} Man√°\n+${attackIncrease} Atk, +${defenseIncrease} Def${realmChangeMessage}`);
    }

    function recalculatePlayerStats() {
        const player = gameState.player;
        // Reiniciar stats a base
        player.maxHp = player.baseMaxHp; 
        player.maxMana = player.baseMaxMana;
        player.attack = player.baseAttack; 
        player.defense = player.baseDefense;
        
        // Asegurar que HP y Mana actuales no excedan los m√°ximos recalculados
        player.hp = Math.min(player.hp, player.maxHp);
        player.mana = Math.min(player.mana, player.maxMana);

        gameState.activeCombatAbilities = []; // Reiniciar lista de habilidades de combate activas

        // Procesar t√©cnicas aprendidas para habilidades de combate activas y efectos pasivos directos
        for (const techId in player.learnedTechniques) {
            const playerTech = player.learnedTechniques[techId];
            if (playerTech.level > 0) { // Solo si la t√©cnica ha sido cultivada al menos al nivel 1 (o 0 si as√≠ lo defines)
                const techInfo = techniqueData[techId];
                if (techInfo?.type === "active_ability" && !gameState.activeCombatAbilities.find(ab => ab.id === techInfo.abilityId)) {
                    gameState.activeCombatAbilities.push({ 
                        id: techInfo.abilityId, 
                        name: techInfo.name, 
                        source: "technique", 
                        sourceTechniqueId: techId // Guardar el ID de la t√©cnica fuente es √∫til
                    });
                }
                // Si tienes t√©cnicas pasivas que modifican stats como "Fortificaci√≥n Corporal B√°sica",
                // sus efectos ya se aplicaron al player.baseStat cuando se aprendieron/subieron de nivel en applyTechniqueEffect.
                // recalculatePlayerStats se encarga de que maxHp, attack, etc., se actualicen desde baseMaxHp, baseAttack.
            }
        }
        updateUI(); // Actualizar la UI con los stats recalculados
    }

    function startBattle(mapEntity) {
        const player = gameState.player;
        if (player.isCultivating) stopCultivation();
        hideTouchControls();

        // Detener animaci√≥n de caminar al entrar en batalla
        player.isMoving = false;
        if (player.animationTimer) {
            clearInterval(player.animationTimer);
            player.animationTimer = null;
        }
        if (player.idleTimeout) {
            clearTimeout(player.idleTimeout);
            player.idleTimeout = null;
        }
        player.currentDirection = 'down'; // O la direcci√≥n que quieras en batalla
        player.currentFrame = 0;         // Frame idle
        updatePlayerSpriteVisual();      // Actualizar para mostrar el sprite de batalla

        gameState.battle.active = true;
        gameState.battle.enemy = {
            ...mapEntity,
            hp: mapEntity.hp,
            maxHp: mapEntity.maxHp || mapEntity.hp,
            entityRef: mapEntity,
            frozenTurns: 0, stunnedTurns: 0, burningTurns: 0, burnDamage: 0,
            poisonedTurns: 0, poisonDamage: 0, defenseReductionTurns: 0,
            defenseReductionAmount: 0, rootedTurns: 0, rootDamage: 0,
            attackReductionTurns: 0, attackReductionAmount: 0,
        };
        gameState.battle.playerTurn = true;

        document.getElementById('battleScreen').style.display = 'flex';
        populateBattleActionButtons();
        updateBattleUI();
        logBattle(`¬°Un ${gameState.battle.enemy.name} te enfrenta!`);
    }

    function populateBattleActionButtons() {
        const battleActionButtons = document.getElementById('battleActionButtons');
        battleActionButtons.innerHTML = `
            <button onclick="battleAction('attack')">‚öîÔ∏è Atacar</button>
            <button onclick="battleAction('defend')">üõ°Ô∏è Defender</button>
            <button onclick="battleAction('qi_fist')">üßò Pu√±o de Qi</button> 
            <button onclick="battleAction('escape')">üèÉ Huir</button>
        `;
        gameState.activeCombatAbilities.forEach(ability => {
            const abilityButton = document.createElement('button');
            let buttonText = `‚ú® ${ability.name}`;
            let canAfford = true; 
            if (ability.source === "technique" && ability.sourceTechniqueId) {
                const techLevel = gameState.player.learnedTechniques[ability.sourceTechniqueId]?.level;
                if (techLevel > 0) buttonText += ` (Nv.${techLevel})`;
                else { abilityButton.disabled = true; abilityButton.title = "Requiere refinamiento"; }
            }
                const techDetails = ability.source === "technique" && ability.sourceTechniqueId ? techniqueData[ability.sourceTechniqueId] : null;
                let manaCost = 0;
                if (techDetails && techDetails.effect && techDetails.effect.manaCost) {
                    manaCost = techDetails.effect.manaCost;
                } else if (ability.id === 'qi_blast_minor') { 
                    manaCost = 15; 
                } else if (techDetails && techDetails.manaCost) { 
                     manaCost = techDetails.manaCost;
                }
                if (manaCost > 0 && gameState.player.mana < manaCost) {
                    canAfford = false;
                }

            abilityButton.textContent = buttonText;
            abilityButton.onclick = () => battleAction(ability.id, ability);
            abilityButton.disabled = abilityButton.disabled || !canAfford;
            if (!canAfford && !abilityButton.disabled) abilityButton.title = "Man√° insuficiente";
            
            battleActionButtons.appendChild(abilityButton);
        });
    }

    function updateBattleUI() {
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        document.getElementById('playerBattleName').textContent = `Cultivador (Nv.${player.level})`;
        document.getElementById('playerBattleHp').textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
        document.getElementById('playerBattleHpBar').style.width = `${(player.hp / player.maxHp) * 100}%`;
        if (enemy) {
            document.getElementById('enemySprite').textContent = enemy.symbol || '?';
            document.getElementById('enemyName').textContent = enemy.name;
            document.getElementById('enemyHp').textContent = `${Math.floor(enemy.hp)}/${enemy.maxHp}`;
            document.getElementById('enemyHpBar').style.width = `${(enemy.hp / enemy.maxHp) * 100}%`;
        }
    }

    function battleAction(action, abilityDetails = null) {
        if (!gameState.battle.playerTurn || !gameState.battle.active) return;
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        let actionTaken = true; 
        let playerTechLevel = 0; 
        if (abilityDetails && abilityDetails.source === "technique" && abilityDetails.sourceTechniqueId) {
            playerTechLevel = player.learnedTechniques[abilityDetails.sourceTechniqueId]?.level || 0;
        }

        // --- Aplicar DoTs y HoTs al JUGADOR ---
        if (player.burningTurns > 0) { player.hp -= player.burnDamage; logBattle(`Sufres ${player.burnDamage} da√±o por quemadura.`); player.burningTurns--; if(player.burningTurns === 0) logBattle("Quemadura se extingue."); }
        if (player.poisonedTurns > 0) { player.hp -= player.poisonDamage; logBattle(`Sufres ${player.poisonDamage} da√±o por veneno.`); player.poisonedTurns--; if(player.poisonedTurns === 0) logBattle("Veneno desaparece."); }
        if (player.healingRainTurns > 0) { const heal = player.healingRainAmount; player.hp = Math.min(player.maxHp, player.hp + heal); logBattle(`Lluvia Curativa te sana ${heal} HP.`); player.healingRainTurns--; if(player.healingRainTurns === 0) logBattle("Lluvia Curativa cesa."); }
        
        // --- Revertir buffs/debuffs temporales del JUGADOR ---
        if (player.defenseBoostTurns > 0) { player.defenseBoostTurns--; if (player.defenseBoostTurns === 0) { player.defense -= player.defenseBoostAmount; logBattle(`Piel de Piedra termina. Defensa: ${player.defense}.`); player.defenseBoostAmount = 0; } }
        if (player.bloodRitualTurns > 0 && action !== 'blood_ritual') { player.bloodRitualTurns--; if(player.bloodRitualTurns === 0) { player.attack -= player.bloodRitualAttackBoost; logBattle(`Ritual de Sangre termina. Ataque: ${player.attack}.`); player.bloodRitualAttackBoost = 0;} }
        if (player.immuneTurns > 0 && action !== 'aura_of_purity') { player.immuneTurns--; if(player.immuneTurns === 0) { logBattle(`Inmunidad termina.`);} }
        if (player.cloneActive && player.cloneTurns > 0 && action !== 'phantom_clone') { player.cloneTurns--; if (player.cloneTurns === 0) { player.cloneActive = false; logBattle("Clon Fantasma desaparece."); } }
        if (player.elementalTurns > 0 && action !== 'summon_elemental') { player.elementalTurns--; if (player.elementalTurns === 0) { player.attack -= player.tempAttackBonus; player.defense -= player.tempDefenseBonus; logBattle("Elemental invocado desaparece."); player.tempAttackBonus = 0; player.tempDefenseBonus = 0; } }
        if (player.magicShieldTurns > 0 && action !== 'mystic_barrier') { player.magicShieldTurns--; if(player.magicShieldTurns === 0 && player.magicShieldValue > 0) { logBattle("Barrera M√≠stica se disipa."); player.magicShieldValue = 0;} }


        if (player.hp <= 0) { 
            logBattle('Has sucumbido antes de actuar.');
                player.hp = 0;
                setTimeout(() => {
                    player.hp = Math.floor(player.maxHp * 0.1); player.mana = Math.floor(player.maxMana * 0.1);
                    const expLossPercentage = 0.1; const expToLose = Math.floor(player.exp * expLossPercentage);
                    player.exp = Math.max(0, player.exp - expToLose); logBattle(`Pierdes ${expToLose} EXP.`);
                    const safeRespawnCoords = findSafeRespawnLocation(G_SAFE_RESPAWN_X, G_SAFE_RESPAWN_Y);
                    player.x = safeRespawnCoords.x; player.y = safeRespawnCoords.y;
                    updatePlayerPosition(); endBattle(false); showModal('Derrota', 'Has sido derrotado...');
                }, 2000);
            return;
        }

            switch (action) {
                case 'attack':
                    const damage = Math.max(1, player.attack - (enemy.defense || 0) + Math.floor(Math.random() * 5 - 2));
                    enemy.hp -= damage;
                    logBattle(`Atacas causando ${damage} da√±o.`);
                    break;
                case 'defend':
                    let healAmount = Math.floor(player.maxHp * 0.1);
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    logBattle(`Te defiendes y recuperas ${healAmount} HP.`);
                    const meditationSkillInfo = getSkillById("se_mana_regen_1");
                    if (meditationSkillInfo && player.learnedSkills["se_mana_regen_1"]) {
                        const manaRegenEffect = meditationSkillInfo.effects.find(e => e.effectId === "mana_regen_on_defend");
                        if (manaRegenEffect) {
                            player.mana = Math.min(player.maxMana, player.mana + manaRegenEffect.value);
                            logBattle(`Meditaci√≥n profunda restaura ${manaRegenEffect.value} man√°.`);
                        }
                    }
                    break;
                case 'qi_fist':
                    const qiFistCost = 10;
                    if (player.mana >= qiFistCost) {
                        player.mana -= qiFistCost;
                        const magicDamage = Math.max(1, Math.floor(player.attack * 0.8 + player.maxMana * 0.2) - (enemy.defense || 0));
                        enemy.hp -= magicDamage;
                        logBattle(`Pu√±o de Qi causa ${magicDamage} da√±o m√°gico.`);
                    } else { logBattle('Man√° insuficiente para Pu√±o de Qi.'); actionTaken = false; }
                    break;
                case 'escape':
                    if (enemy.isBoss) { logBattle(`¬°No puedes huir de un ${enemy.name}!`); }
                    else if (Math.random() < 0.7) { logBattle('¬°Escapaste!'); endBattle(false); return; }
                    else { logBattle('¬°No pudiste escapar!'); }
                    break;
                 case 'sword_slash': 
                    const swordTechDetails = techniqueData["sword_slash_1"];
                    const swordManaCost = swordTechDetails.manaCost || 10; 
                    if (player.mana >= swordManaCost) {
                        player.mana -= swordManaCost;
                        const damageMultiplier = swordTechDetails.effect.baseDamageMultiplier + ((playerTechLevel - 1) * 0.2);
                        const swordDamage = Math.max(1, Math.floor(player.attack * damageMultiplier) - (enemy.defense || 0));
                        enemy.hp -= swordDamage;
                        logBattle(`¬°${swordTechDetails.name} (Nv.${playerTechLevel}) causa ${swordDamage} da√±o!`);
                    } else { logBattle(`Man√° insuficiente para ${swordTechDetails.name}.`); actionTaken = false; }
                    break;
                case 'qi_blast_minor': 
                    const qiBlastCostSkill = 15; 
                    if (player.mana >= qiBlastCostSkill) {
                        player.mana -= qiBlastCostSkill;
                        const qiDamage = Math.max(1, Math.floor(player.attack * 0.6 + player.maxMana * 0.4) - (enemy.defense || 0));
                        enemy.hp -= qiDamage;
                        logBattle(`¬°Lanzas ${abilityDetails.name} causando ${qiDamage} da√±o Qi!`);
                    } else { logBattle(`Man√° insuficiente para ${abilityDetails.name}.`); actionTaken = false; }
                    break;
                case 'ice_prison':
                    const icePrisonDetails = techniqueData["ice_prison_1"];
                    const iceManaCost = icePrisonDetails.effect.manaCost;
                    if (player.mana >= iceManaCost) {
                        player.mana -= iceManaCost;
                        const freezeChance = icePrisonDetails.effect.freezeChance + ((playerTechLevel -1) * 0.05); 
                        if (Math.random() < freezeChance) {
                            const freezeDuration = icePrisonDetails.effect.freezeDuration + Math.floor((playerTechLevel -1) / 2); 
                            enemy.frozenTurns = Math.max(enemy.frozenTurns, freezeDuration); 
                            logBattle(`¬°${icePrisonDetails.name} (Nv.${playerTechLevel}) congela a ${enemy.name} por ${freezeDuration} turnos!`);
                        } else { logBattle(`¬°${icePrisonDetails.name} (Nv.${playerTechLevel}) fall√≥!`); }
                    } else { logBattle(`Man√° insuficiente para ${icePrisonDetails.name}.`); actionTaken = false; }
                    break;
                case 'flame_strike':
                    const flameStrikeDetails = techniqueData["flame_strike_1"];
                    const flameManaCost = flameStrikeDetails.effect.manaCost;
                    if (player.mana >= flameManaCost) {
                        player.mana -= flameManaCost;
                        const baseDam = Math.floor(player.attack * (flameStrikeDetails.effect.baseDamageMultiplier + ((playerTechLevel -1) * 0.1)));
                        const burnDam = flameStrikeDetails.effect.burnDamagePerTurn + ((playerTechLevel -1) * 2);
                        const burnDur = flameStrikeDetails.effect.burnDuration;
                        enemy.hp -= baseDam;
                        enemy.burningTurns = Math.max(enemy.burningTurns, burnDur);
                        enemy.burnDamage = Math.max(enemy.burnDamage, burnDam); 
                        logBattle(`¬°${flameStrikeDetails.name} (Nv.${playerTechLevel}) causa ${baseDam} da√±o e inflige quemadura de ${burnDam} por ${burnDur} turnos!`);
                    } else { logBattle(`Man√° insuficiente para ${flameStrikeDetails.name}.`); actionTaken = false; }
                    break;
                case 'thunder_fury':
                    const thunderDetails = techniqueData["thunder_fury_1"];
                    const thunderManaCost = thunderDetails.effect.manaCost;
                    if (player.mana >= thunderManaCost) {
                        player.mana -= thunderManaCost;
                        const damage = Math.floor(player.attack * (thunderDetails.effect.baseDamageMultiplier + ((playerTechLevel -1) * 0.15)));
                        enemy.hp -= damage;
                        logBattle(`${thunderDetails.name} (Nv.${playerTechLevel}) golpea con ${damage} da√±o.`);
                        const stunChance = thunderDetails.effect.stunChance + ((playerTechLevel-1) * 0.08);
                        if (Math.random() < stunChance) {
                            enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1 + Math.floor((playerTechLevel-1)/3)); 
                            logBattle(`¬°${enemy.name} queda aturdido!`);
                        }
                    } else { logBattle(`Man√° insuficiente para ${thunderDetails.name}.`); actionTaken = false; }
                    break;
                case 'poison_dart':
                    const poisonDetails = techniqueData["poison_dart_1"];
                    const poisonManaCost = poisonDetails.effect.manaCost;
                    if (player.mana >= poisonManaCost) {
                        player.mana -= poisonManaCost;
                        const baseDam = Math.floor(player.attack * (poisonDetails.effect.baseDamageMultiplier + ((playerTechLevel-1)*0.05)));
                        const poisonDam = poisonDetails.effect.poisonDamagePerTurn + Math.floor((playerTechLevel-1)*1.5);
                        const poisonDur = poisonDetails.effect.poisonDuration;
                        enemy.hp -= baseDam;
                        enemy.poisonedTurns = Math.max(enemy.poisonedTurns, poisonDur);
                        enemy.poisonDamage = Math.max(enemy.poisonDamage, poisonDam);
                        logBattle(`¬°${poisonDetails.name} (Nv.${playerTechLevel}) causa ${baseDam} da√±o e inflige veneno de ${poisonDam} por ${poisonDur} turnos!`);
                    } else { logBattle(`Man√° insuficiente para ${poisonDetails.name}.`); actionTaken = false; }
                    break;
                case 'stone_skin':
                    const stoneSkinDetails = techniqueData["stone_skin_1"];
                    const stoneManaCost = stoneSkinDetails.effect.manaCost;
                    if (player.mana >= stoneManaCost) {
                        player.mana -= stoneManaCost;
                        if (player.defenseBoostTurns > 0) { 
                            logBattle(`Refrescas ${stoneSkinDetails.name}.`);
                        } else {
                            player.defenseBoostAmount = stoneSkinDetails.effect.defenseBoost + ((playerTechLevel-1)*3);
                            player.defense += player.defenseBoostAmount;
                            logBattle(`${stoneSkinDetails.name} (Nv.${playerTechLevel}) aumenta tu defensa en ${player.defenseBoostAmount}. Defensa: ${player.defense}.`);
                        }
                        player.defenseBoostTurns = stoneSkinDetails.effect.duration;
                    } else { logBattle(`Man√° insuficiente para ${stoneSkinDetails.name}.`); actionTaken = false; }
                    break;
                case 'shadow_step':
                    const shadowDetails = techniqueData["shadow_step_1"];
                    const shadowManaCost = shadowDetails.effect.manaCost;
                    if (player.mana >= shadowManaCost) {
                        player.mana -= shadowManaCost;
                        player.dodgeNextAttack = true; 
                        logBattle(`¬°${shadowDetails.name} (Nv.${playerTechLevel})! Te preparas para esquivar.`);
                    } else { logBattle(`Man√° insuficiente para ${shadowDetails.name}.`); actionTaken = false; }
                    break;
                case 'soul_drain':
                    const soulDrainDetails = techniqueData["soul_drain_1"];
                    const soulManaCost = soulDrainDetails.effect.manaCost;
                    if(player.mana >= soulManaCost) {
                        player.mana -= soulManaCost;
                        const damageDealt = Math.max(1, Math.floor(player.attack * (soulDrainDetails.effect.baseDamageMultiplier + ((playerTechLevel-1)*0.1))) - (enemy.defense || 0) );
                        enemy.hp -= damageDealt;
                        const lifeStolen = Math.floor(damageDealt * (soulDrainDetails.effect.lifeStealPercent + ((playerTechLevel-1)*0.05)));
                        player.hp = Math.min(player.maxHp, player.hp + lifeStolen);
                        logBattle(`${soulDrainDetails.name} (Nv.${playerTechLevel}) drena ${damageDealt} HP y te cura ${lifeStolen} HP.`);
                    } else { logBattle(`Man√° insuficiente para ${soulDrainDetails.name}.`); actionTaken = false; }
                    break;
                case 'cyclone_strike': 
                    const cycloneDetails = techniqueData["cyclone_strike_1"];
                    const cycloneManaCost = cycloneDetails.effect.manaCost;
                    if(player.mana >= cycloneManaCost){
                        player.mana -= cycloneManaCost;
                        const damageDealt = Math.max(1, Math.floor(player.attack * (cycloneDetails.effect.baseDamageMultiplier + ((playerTechLevel-1)*0.1))) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;
                        logBattle(`${cycloneDetails.name} (Nv.${playerTechLevel}) golpea a ${enemy.name} con ${damageDealt} da√±o.`);
                    } else { logBattle(`Man√° insuficiente para ${cycloneDetails.name}.`); actionTaken = false; }
                    break;
                case 'healing_rain':
                    const healingRainDetails = techniqueData["healing_rain_1"];
                    const healingManaCost = healingRainDetails.effect.manaCost;
                    if(player.mana >= healingManaCost){
                        player.mana -= healingManaCost;
                        player.healingRainTurns = healingRainDetails.effect.duration;
                        player.healingRainAmount = healingRainDetails.effect.healPerTurn + ((playerTechLevel-1)*5);
                        logBattle(`${healingRainDetails.name} (Nv.${playerTechLevel}) invoca lluvia curativa por ${player.healingRainTurns} turnos.`);
                    } else { logBattle(`Man√° insuficiente para ${healingRainDetails.name}.`); actionTaken = false; }
                    break;
                case 'mind_blast':
                    const mindBlastDetails = techniqueData["mind_blast_1"];
                    const mindManaCost = mindBlastDetails.effect.manaCost;
                    if(player.mana >= mindManaCost){
                        player.mana -= mindManaCost;
                        const damageDealt = Math.max(1, 
                            Math.floor(player.attack * (mindBlastDetails.effect.baseDamageMultiplier + ((playerTechLevel-1)*0.05)) + 
                                    player.maxMana * (mindBlastDetails.effect.manaDamageMultiplier + ((playerTechLevel-1)*0.02))) 
                            - (enemy.defense || 0));
                        enemy.hp -= damageDealt;
                        const defReduction = mindBlastDetails.effect.defenseReduction + ((playerTechLevel-1)*1);
                        enemy.defense = Math.max(0, (enemy.defense || 0) - defReduction);
                        logBattle(`${mindBlastDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} da√±o y reduce defensa enemiga en ${defReduction}.`);
                    } else { logBattle(`Man√° insuficiente para ${mindBlastDetails.name}.`); actionTaken = false; }
                    break;
                case 'celestial_arrow':
                    const arrowDetails = techniqueData["celestial_arrow_1"];
                    if (player.mana >= arrowDetails.effect.manaCost) {
                        player.mana -= arrowDetails.effect.manaCost;
                        const damage = Math.floor(player.attack * (arrowDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.1));
                        enemy.hp -= damage; 
                        logBattle(`${arrowDetails.name} (Nv.${playerTechLevel}) ignora defensas y causa ${damage} da√±o.`);
                    } else { logBattle(`Man√° insuficiente para ${arrowDetails.name}.`); actionTaken = false; }
                    break;
                case 'nature_grasp':
                    const natureDetails = techniqueData["nature_grasp_1"];
                    if (player.mana >= natureDetails.effect.manaCost) {
                        player.mana -= natureDetails.effect.manaCost;
                        const initialDamage = Math.floor(player.attack * (natureDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.05));
                        enemy.hp -= initialDamage;
                        enemy.rootedTurns = Math.max(enemy.rootedTurns, natureDetails.effect.rootDuration);
                        enemy.rootDamage = Math.max(enemy.rootDamage, natureDetails.effect.damagePerTurn + (playerTechLevel - 1) * 1);
                        logBattle(`${natureDetails.name} (Nv.${playerTechLevel}) causa ${initialDamage} da√±o y enreda, causando ${enemy.rootDamage} da√±o por ${enemy.rootedTurns} turnos.`);
                    } else { logBattle(`Man√° insuficiente para ${natureDetails.name}.`); actionTaken = false; }
                    break;
                case 'dragon_roar':
                    const roarDetails = techniqueData["dragon_roar_1"];
                    if (player.mana >= roarDetails.effect.manaCost) {
                        player.mana -= roarDetails.effect.manaCost;
                        const stunChance = roarDetails.effect.aoeStunChance + (playerTechLevel-1)*0.03;
                        if(Math.random() < stunChance) {
                            enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1); 
                            logBattle(`${roarDetails.name} (Nv.${playerTechLevel}) aturde a ${enemy.name}!`);
                        }
                        const attackRed = roarDetails.effect.attackReduction + (playerTechLevel - 1) * 2;
                        enemy.attack = Math.max(5, (enemy.attack || 0) - attackRed); 
                        enemy.attackReductionTurns = roarDetails.effect.duration; 
                        enemy.attackReductionAmount = attackRed;
                        logBattle(`${roarDetails.name} reduce ataque enemigo en ${attackRed} por ${roarDetails.effect.duration} turnos.`);
                    } else { logBattle(`Man√° insuficiente para ${roarDetails.name}.`); actionTaken = false; }
                    break;
                case 'phantom_clone':
                    const cloneDetails = techniqueData["phantom_clone_1"];
                    if (player.mana >= cloneDetails.effect.manaCost) {
                        player.mana -= cloneDetails.effect.manaCost;
                        player.cloneActive = true;
                        player.cloneHealth = cloneDetails.effect.cloneHealth + (playerTechLevel - 1) * 10;
                        player.cloneTurns = cloneDetails.effect.duration + Math.floor((playerTechLevel-1)/2);
                        logBattle(`${cloneDetails.name} (Nv.${playerTechLevel}) crea clon con ${player.cloneHealth} HP por ${player.cloneTurns} turnos.`);
                    } else { logBattle(`Man√° insuficiente para ${cloneDetails.name}.`); actionTaken = false; }
                    break;
                case 'temporal_shift': 
                    const temporalDetails = techniqueData["temporal_shift_1"];
                    if(player.mana >= temporalDetails.effect.manaCost) {
                        player.mana -= temporalDetails.effect.manaCost;
                        player.temporalShiftTurns = temporalDetails.effect.duration;
                        logBattle(`${temporalDetails.name} (Nv.${playerTechLevel}) distorsiona tiempo por ${player.temporalShiftTurns} turnos.`);
                    } else { logBattle(`Man√° insuficiente para ${temporalDetails.name}.`); actionTaken = false; }
                    break;
                case 'blood_ritual':
                    const bloodDetails = techniqueData["blood_ritual_1"];
                    const hpCost = bloodDetails.effect.hpCost - (playerTechLevel-1)*2; 
                    if (player.hp > hpCost && player.mana >= bloodDetails.effect.manaCost) {
                        player.hp -= hpCost;
                        player.mana -= bloodDetails.effect.manaCost;
                        if (player.bloodRitualTurns === 0) { 
                            player.bloodRitualAttackBoost = bloodDetails.effect.attackBoost + (playerTechLevel - 1) * 5;
                            player.attack += player.bloodRitualAttackBoost;
                        } else { logBattle(`Refrescas Ritual de Sangre.`); }
                        player.bloodRitualTurns = bloodDetails.effect.duration;
                        logBattle(`${bloodDetails.name} (Nv.${playerTechLevel}) sacrifica ${hpCost} HP, aumenta ataque en ${player.bloodRitualAttackBoost} por ${player.bloodRitualTurns} turnos. Ataque: ${player.attack}.`);
                    } else { logBattle(`HP o Man√° insuficiente para ${bloodDetails.name}.`); actionTaken = false; }
                    break;
                case 'aura_of_purity':
                    const auraDetails = techniqueData["aura_of_purity_1"];
                    if(player.mana >= auraDetails.effect.manaCost){
                        player.mana -= auraDetails.effect.manaCost;
                        let cleansed = false;
                        if(player.poisonedTurns > 0) { player.poisonedTurns = 0; player.poisonDamage = 0; cleansed = true; }
                        if(player.burningTurns > 0) { player.burningTurns = 0; player.burnDamage = 0; cleansed = true; }
                        if(cleansed) logBattle(`${auraDetails.name} (Nv.${playerTechLevel}) purifica efectos negativos.`);
                        player.immuneTurns = auraDetails.effect.immunityDuration + Math.floor((playerTechLevel-1)/2);
                        logBattle(`Ganas inmunidad por ${player.immuneTurns} turnos.`);
                    } else { logBattle(`Man√° insuficiente para ${auraDetails.name}.`); actionTaken = false; }
                    break;
                case 'summon_elemental': 
                    const summonDetails = techniqueData["summon_elemental_1"];
                    if(player.mana >= summonDetails.effect.manaCost){
                        player.mana -= summonDetails.effect.manaCost;
                        player.tempAttackBonus = (summonDetails.effect.elementalAttack || 20) + (playerTechLevel-1)*3;
                        player.tempDefenseBonus = Math.floor((summonDetails.effect.elementalAttack || 20)/2) + (playerTechLevel-1)*2;
                        player.attack += player.tempAttackBonus;
                        player.defense += player.tempDefenseBonus;
                        player.elementalTurns = summonDetails.effect.duration;
                        logBattle(`${summonDetails.name} (Nv.${playerTechLevel}) invoca elemental, +${player.tempAttackBonus} Atk, +${player.tempDefenseBonus} Def por ${player.elementalTurns} turnos.`);
                    } else { logBattle(`Man√° insuficiente para ${summonDetails.name}.`); actionTaken = false; }
                    break;
                case 'mystic_barrier':
                    const barrierDetails = techniqueData["mystic_barrier_1"];
                    if(player.mana >= barrierDetails.effect.manaCost){
                        player.mana -= barrierDetails.effect.manaCost;
                        player.magicShieldValue = (barrierDetails.effect.magicShield || 40) + (playerTechLevel-1)*10;
                        player.magicShieldTurns = barrierDetails.effect.duration;
                        logBattle(`${barrierDetails.name} (Nv.${playerTechLevel}) crea barrera que absorber√° ${player.magicShieldValue} da√±o m√°gico por ${player.magicShieldTurns} turnos.`);
                    } else { logBattle(`Man√° insuficiente para ${barrierDetails.name}.`); actionTaken = false; }
                    break;

                default: logBattle("Acci√≥n desconocida."); actionTaken = false; break;
            }

        if (!actionTaken) { updateBattleUI(); return; }
        gameState.battle.playerTurn = false;
        updateBattleUI();

        if (enemy.hp <= 0) { handleEnemyDefeat(); } 
        else {
            let enemyDiedToDot = false;
                if (enemy.burningTurns > 0) { enemy.hp -= enemy.burnDamage; logBattle(`${enemy.name} sufre ${enemy.burnDamage} por quemadura. HP: ${Math.floor(enemy.hp)}`); if (enemy.hp <= 0) enemyDiedToDot = true; }
                if (!enemyDiedToDot && enemy.poisonedTurns > 0) { enemy.hp -= enemy.poisonDamage; logBattle(`${enemy.name} sufre ${enemy.poisonDamage} por veneno. HP: ${Math.floor(enemy.hp)}`); if (enemy.hp <= 0) enemyDiedToDot = true; }
                if (!enemyDiedToDot && enemy.rootedTurns > 0) { enemy.hp -= enemy.rootDamage; logBattle(`${enemy.name} sufre ${enemy.rootDamage} por enredo. HP: ${Math.floor(enemy.hp)}`); if (enemy.hp <= 0) enemyDiedToDot = true; }

            if (enemyDiedToDot) { handleEnemyDefeat(); } 
            else { setTimeout(enemyTurn, 1000); }
        }
    }

    function handleEnemyDefeat() {
        const enemy = gameState.battle.enemy;
        logBattle(`¬°Has derrotado al ${enemy.name}!`);
        gainExperience(enemy.exp);

        const misionesActivasDelJugador = [...gameState.player.secta.misionesActivas]; 
        misionesActivasDelJugador.forEach(misionActiva => { 
            const misionDataOriginal = MISIONES_DATA[misionActiva.id]; 
            if (!misionDataOriginal || !misionActiva.objetivoOriginal) return;

            if (misionActiva.objetivoOriginal.tipo === "eliminar_enemigo") {
                const enemyJustDefeated = gameState.battle.enemy; // Usar la referencia correcta
                if (enemyJustDefeated.type === misionActiva.objetivoOriginal.enemigoTipo || 
                    (entityTypes[enemyJustDefeated.originalEntityTypeId]?.name === misionActiva.objetivoOriginal.nombreDisplay) || // Comparar con nombre si est√° definido
                     enemyJustDefeated.name === misionActiva.objetivoOriginal.nombreDisplay
                    ) {
                    misionActiva.progreso = (misionActiva.progreso || 0) + 1; 
                    logBattle(`Progreso '${misionDataOriginal.titulo}': ${misionActiva.progreso}/${misionActiva.objetivoOriginal.cantidad}`);
                    // Ya no se completa aqu√≠, se completa al hablar con el NPC.
                    // if (misionActiva.progreso >= misionActiva.objetivoOriginal.cantidad) { 
                    //     logBattle(`¬°Objetivo de ${misionDataOriginal.titulo} cumplido! Reporta al NPC.`);
                    // }
                }
            } else if (misionActiva.objetivoOriginal.tipo === "derrotar_npc_especifico") {
                 // Este tipo de misi√≥n (desaf√≠os de secta) S√ç se autocompleta.
                 if (enemy.isSectChallengeRival && enemy.npcId === misionActiva.objetivoOriginal.npcId) {
                    completeMission(misionActiva.id); 
                }
            }
            else if (misionActiva.objetivoOriginal.tipo === "cazar_y_recuperar_item_de_loot") {
                if (enemy.type === misionActiva.objetivoOriginal.enemigoTipo || enemy.originalEntityTypeId === misionActiva.objetivoOriginal.enemigoTipo) { 
                    // El loot se a√±ade despu√©s, aqu√≠ solo marcamos que se mat√≥ al tipo correcto.
                    // La comprobaci√≥n del √≠tem en inventario se hace al ENTREGAR al NPC.
                    // Sin embargo, podemos marcar un progreso intermedio si se quiere.
                    // Por ahora, asumimos que el loot table se encarga de dar el itemPrueba.
                    // Si el itemPrueba est√° en el lootTable y se obtiene:
                    const itemPruebaDef = misionActiva.objetivoOriginal.itemPrueba;
                    if (enemy.lootTable && enemy.lootTable.some(l => l.itemName === itemPruebaDef && Math.random() < l.chance)) {
                        misionActiva.progreso = 1; // Marcar que el tipo de enemigo que suelta el item fue derrotado Y el item drope√≥.
                        logBattle(`Parece que ${enemy.name} solt√≥ ${itemPruebaDef} para '${misionDataOriginal.titulo}'. ¬°Rev√≠salo en tu inventario y entr√©galo!`);
                    }
                }
            }
        });
        updateSectUI(); 

        // ... (resto de la l√≥gica de loot y jefes sin cambios) ...
        if (enemy.lootTable && enemy.lootTable.length > 0) {
            enemy.lootTable.forEach(loot => {
                if (Math.random() < loot.chance) {
                    const quantity = (loot.quantity && loot.quantity.length === 2) ? Math.floor(Math.random() * (loot.quantity[1] - loot.quantity[0] + 1)) + loot.quantity[0] : 1;
                    gameState.inventory[loot.itemName] = (gameState.inventory[loot.itemName] || 0) + quantity;
                    logBattle(`¬°${enemy.name} solt√≥ ${quantity} ${loot.itemName}!`);
                    if (!itemData[loot.itemName] && loot.itemName.startsWith("Rollo: ")) {
                        const techNameFromRoll = loot.itemName.substring(7);
                        const techId = Object.keys(techniqueData).find(id => techniqueData[id].name.toLowerCase() === techNameFromRoll.toLowerCase());
                        itemData[loot.itemName] = { description: `Rollo que ense√±a '${techNameFromRoll}'.`, effect: (ps) => { if (techId) return learnTechniqueFromRoll(ps, techId); return `Conocimiento de '${techNameFromRoll}' requiere m√°s estudio.`; }, canUse: () => true };
                    } else if (!itemData[loot.itemName] && gameState.inventory[loot.itemName] > 0) {
                        itemData[loot.itemName] = { description: `Material de refinamiento: ${loot.itemName}.` };
                    }
                }
            });
        }
        // ...
        if (enemy.isBoss) { 
            gameState.player.worldState.defeatedBosses[enemy.id || enemy.type /*o enemy.originalEntityTypeId*/] = true;
            if (enemy.nextBossId) { gameState.player.worldState.currentBossToSpawn = enemy.nextBossId; } 
            else { gameState.player.worldState.currentBossToSpawn = null; }
            generateMap(true); // Regenerar mapa despu√©s de derrotar un jefe
        }

        updateUI();
        setTimeout(() => endBattle(true), 2000);
    }

    function completeMission(misionId, npcIdEntregaManual = null) { // npcIdEntregaManual es para cuando se completa desde el di√°logo del NPC
        const player = gameState.player;
        const misionActiva = player.secta.misionesActivas.find(m => m.id === misionId);
        const misionDataOriginal = MISIONES_DATA[misionId]; 

        if (!misionActiva || !misionDataOriginal) {
            console.error(`Error al intentar completar misi√≥n: ${misionId}. Datos no encontrados.`);
            showModal("Error de Misi√≥n", "Datos de la misi√≥n no encontrados.");
            return false; // Indicar fallo
        }
        
        // No filtrar m√°s por !player.secta.misionesActivas.some(m => m.id === misionId) aqu√≠,
        // ya que la estamos buscando DENTRO de las activas.

        console.log(`Intentando completar misi√≥n: ${misionDataOriginal.titulo}`);

        // Verificar si los objetivos est√°n realmente cumplidos ANTES de dar recompensas
        let objetivosCumplidos = false;
        const objetivo = misionActiva.objetivoOriginal;

        switch (objetivo.tipo) {
            case "entregar_item":
                if ((gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad) {
                    // Solo restar si es una entrega manual a un NPC o si es una misi√≥n que se autocompleta con entrega
                    // (por ahora, asumimos que todas las de entrega requieren NPC)
                    if (npcIdEntregaManual && npcIdEntregaManual === objetivo.npcEntrega) {
                        gameState.inventory[objetivo.item] -= objetivo.cantidad;
                        updateInventoryUI();
                        objetivosCumplidos = true;
                    } else if (!objetivo.npcEntrega) { // Caso raro: misi√≥n de entrega sin NPC espec√≠fico (se autocompleta)
                        gameState.inventory[objetivo.item] -= objetivo.cantidad;
                        updateInventoryUI();
                        objetivosCumplidos = true;
                    } else {
                        // No se cumple aqu√≠, se debe completar hablando con el NPC
                        // showModal("Entrega Pendiente", `Debes entregar ${objetivo.item} a ${SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre || 'un NPC'}.`);
                        return false; 
                    }
                } else {
                    showModal("Objetivo Incompleto", `A√∫n necesitas ${objetivo.cantidad - (gameState.inventory[objetivo.item] || 0)} ${objetivo.item}.`);
                    return false;
                }
                break;
            case "eliminar_enemigo":
                if (misionActiva.progreso >= objetivo.cantidad) {
                    objetivosCumplidos = true;
                    // No hay √≠tems que restar aqu√≠. La finalizaci√≥n ser√° al hablar con el NPC.
                } else {
                    // showModal("Objetivo Incompleto", `A√∫n necesitas eliminar m√°s enemigos.`);
                    return false;
                }
                break;
            case "recolectar_multiples_items":
                let todosItemsRecolectados = true;
                for (const itemReq of objetivo.items) {
                    if ((gameState.inventory[itemReq.nombre] || 0) < itemReq.cantidad) {
                        todosItemsRecolectados = false;
                        showModal("Objetivo Incompleto", `A√∫n necesitas recolectar m√°s ${itemReq.nombre}.`);
                        break;
                    }
                }
                if (todosItemsRecolectados) {
                    if (npcIdEntregaManual && npcIdEntregaManual === objetivo.npcEntrega) {
                        for (const itemReq of objetivo.items) {
                            gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                        }
                        updateInventoryUI();
                        objetivosCumplidos = true;
                    } else if (!objetivo.npcEntrega) {
                         for (const itemReq of objetivo.items) {
                            gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                        }
                        updateInventoryUI();
                        objetivosCumplidos = true;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
                break;
            case "cazar_y_recuperar_item_de_loot":
                // El progreso a 1 indica que el √≠tem FUE looteado. Ahora se comprueba si A√öN lo tiene.
                if (misionActiva.progreso === 1 && (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba) {
                    if (npcIdEntregaManual && npcIdEntregaManual === objetivo.npcEntrega) {
                        gameState.inventory[objetivo.itemPrueba] -= objetivo.cantidadItemPrueba;
                        updateInventoryUI();
                        objetivosCumplidos = true;
                    } else if (!objetivo.npcEntrega) {
                        gameState.inventory[objetivo.itemPrueba] -= objetivo.cantidadItemPrueba;
                        updateInventoryUI();
                        objetivosCumplidos = true;
                    } else {
                        return false;
                    }
                } else {
                    showModal("Objeto Faltante", `Parece que ya no tienes ${objetivo.itemPrueba} o no lo has obtenido a√∫n.`);
                    return false;
                }
                break;
            case "derrotar_npc_especifico": // Estas se autocompletan al derrotar al NPC
                // El progreso ya se verific√≥ al llamar a completeMission desde handleEnemyDefeat
                objetivosCumplidos = true;
                break;
            // A√±adir m√°s casos seg√∫n tipos de misi√≥n
            default:
                console.warn(`Tipo de objetivo desconocido '${objetivo.tipo}' para misi√≥n ${misionId}`);
                showModal("Error de Misi√≥n", "Tipo de objetivo no reconocido.");
                return false;
        }

        if (!objetivosCumplidos) {
            console.log(`Objetivos no cumplidos para ${misionDataOriginal.titulo} al intentar completar.`);
            return false; // No completar si los objetivos no est√°n verificados
        }

        // --- Dar Recompensas ---
        player.secta.puntosContribucion += misionDataOriginal.recompensa.pcs || 0;
        gainExperience(misionDataOriginal.recompensa.exp || 0);
        let recompensaItemsTexto = "";
        if (misionDataOriginal.recompensa.items) {
            for (const itemName in misionDataOriginal.recompensa.items) {
                gameState.inventory[itemName] = (gameState.inventory[itemName] || 0) + misionDataOriginal.recompensa.items[itemName];
                recompensaItemsTexto += `${misionDataOriginal.recompensa.items[itemName]} ${itemName}, `;
            }
            updateInventoryUI(); 
            if (recompensaItemsTexto) recompensaItemsTexto = recompensaItemsTexto.slice(0, -2); // quitar √∫ltima coma y espacio
        }
        
        let recompensaTextoGlobal = `Recompensas: ${misionDataOriginal.recompensa.pcs || 0} PCS, ${misionDataOriginal.recompensa.exp || 0} EXP`;
        if (recompensaItemsTexto) recompensaTextoGlobal += `, ${recompensaItemsTexto}`;

        player.secta.misionesActivas = player.secta.misionesActivas.filter(m => m.id !== misionId); 
        player.secta.misionesCompletadas[misionId] = true;
        
        showModal("¬°Misi√≥n Completada!", `Completaste: ${misionDataOriginal.titulo}.\n${recompensaTextoGlobal}`);

        if (misionDataOriginal.recompensa.nuevoRango) {
            player.secta.rango = misionDataOriginal.recompensa.nuevoRango;
            showModal("¬°Ascenso en la Secta!", `¬°Felicidades! Ascendiste a ${player.secta.rango}.`);
            applyRankBenefits(player.secta.rango);
        }
        updateSectUI(); 
        checkAndActivateRankChallengeMissions(); // Verificar si se desbloquean desaf√≠os de rango
        return true; // Indicar √©xito
    }
        
    function updateSectUI() {
        const player = gameState.player;
        document.getElementById('sectaNombreDisplay').textContent = player.secta.nombre;
        document.getElementById('playerSectRank').textContent = player.secta.rango;
        document.getElementById('playerPCS').textContent = player.secta.puntosContribucion;
        
        const missionsListDiv = document.getElementById('activeMissionsList');
        missionsListDiv.innerHTML = '';
        
        if (player.secta.misionesActivas.length === 0) {
            missionsListDiv.innerHTML = '<p>Ninguna misi√≥n activa.</p>';
        } else {
            player.secta.misionesActivas.forEach(misionActiva => { 
                const misionDataOriginal = MISIONES_DATA[misionActiva.id]; 
                if (misionDataOriginal && misionActiva.objetivoOriginal) { // Asegurar que objetivoOriginal exista
                    let progresoTexto = ""; 
                    const objetivo = misionActiva.objetivoOriginal;
                    const npcEntregaNombre = SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre || "NPC correspondiente";

                    if (objetivo.tipo === "eliminar_enemigo") {
                        progresoTexto = ` (${misionActiva.progreso || 0}/${objetivo.cantidad} ${objetivo.nombreDisplay || 'objetivos'})`;
                        if ((misionActiva.progreso || 0) >= objetivo.cantidad) {
                            progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                        }
                    } else if (objetivo.tipo === "entregar_item") {
                        const tiene = gameState.inventory[objetivo.item] || 0;
                        const necesita = objetivo.cantidad;
                        progresoTexto = ` (Tienes ${tiene}/${necesita} ${objetivo.item})`;
                        if (tiene >= necesita) {
                            progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                        }
                    } else if (objetivo.tipo === "recolectar_multiples_items") {
                        let todosListos = true;
                        let itemsStatusArray = objetivo.items.map(itemReq => {
                            const tiene = gameState.inventory[itemReq.nombre] || 0;
                            const necesita = itemReq.cantidad;
                            if (tiene < necesita) todosListos = false;
                            return `${tiene}/${necesita} ${itemReq.nombre}`;
                        });
                        progresoTexto = ` (${itemsStatusArray.join(', ')})`;
                        if (todosListos) {
                             progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                        }
                    } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot") {
                        const tieneItem = (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba;
                        progresoTexto = (misionActiva.progreso === 1 && tieneItem) ? ` (Prueba '${objetivo.itemPrueba}' obtenida)` : ` (Cazar ${objetivo.enemigoTipo} y obtener ${objetivo.itemPrueba})`;
                        if (misionActiva.progreso === 1 && tieneItem) {
                            progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                        }
                    } else if (objetivo.tipo === "derrotar_npc_especifico") {
                        // Estas se autocompletan, as√≠ que no aparecer√°n mucho aqu√≠ si se completan r√°pido
                        progresoTexto = ` (Derrotar a ${entityTypes[objetivo.npcId]?.name || 'objetivo'})`;
                    }
                    const p = document.createElement('p');
                    p.innerHTML = `<strong>${misionDataOriginal.titulo}</strong><small>${progresoTexto}</small>`;
                    missionsListDiv.appendChild(p);
                }
            });
        }
    }

    function checkAndActivateRankChallengeMissions() {
        const player = gameState.player;
        const currentRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === player.secta.rango);

        if (currentRankIndex === -1) {
            console.error("Error: Rango actual del jugador no encontrado en SECTA_DATA.rangos");
            return;
        }

        // Si ya est√° en el rango m√°ximo, no hay m√°s desaf√≠os
        if (currentRankIndex + 1 >= SECTA_DATA.rangos.length) {
            // console.log("Jugador en el rango m√°ximo o no hay m√°s rangos definidos.");
            return; 
        }

        const nextRankData = SECTA_DATA.rangos[currentRankIndex + 1];

        // Verificar si el jugador cumple los PCS para el siguiente rango
        if (player.secta.puntosContribucion >= nextRankData.pcsRequeridos) {
            // Verificar si hay un ID de rival para el desaf√≠o de este pr√≥ximo rango
            if (nextRankData.desafioRivalId) {
                const desafioMisionId = Object.keys(MISIONES_DATA).find(mId => {
                    const mision = MISIONES_DATA[mId];
                    return mision.objetivo?.tipo === "derrotar_npc_especifico" &&
                           mision.objetivo?.npcId === nextRankData.desafioRivalId &&
                           (mision.autoActivarAlCumplirRequisitos === true || mision.recompensa?.nuevoRango === nextRankData.nombre); // Condici√≥n para identificar la misi√≥n de desaf√≠o
                });

                if (desafioMisionId) {
                    // Verificar si la misi√≥n de desaf√≠o NO est√° ya activa o completada
                    const isMissionActive = player.secta.misionesActivas.some(m => m.id === desafioMisionId);
                    const isMissionCompleted = player.secta.misionesCompletadas[desafioMisionId];

                    if (!isMissionActive && !isMissionCompleted) {
                        acceptMission(desafioMisionId); 
                        const misionData = MISIONES_DATA[desafioMisionId];
                        showModal("¬°Nuevo Desaf√≠o de Rango!", 
                                  `Has alcanzado los requisitos de PCS para el rango de ${nextRankData.nombre}.\n` +
                                  `Se ha activado la misi√≥n de desaf√≠o: "${misionData.titulo}".\n` +
                                  `¬°Prep√°rate y busca a tu oponente en la arena de la secta!`);
                        
                        // Asegurar que el NPC del desaf√≠o (el rival) aparezca en el mapa si tiene fixedLocation
                        // ensureFixedEntities() deber√≠a encargarse de esto si el rival est√° en la lista de entidades fijas
                        // y no ha sido derrotado (lo cual es el caso si la misi√≥n se acaba de activar).
                        // Si el rival no es una entidad fija por defecto, podr√≠as a√±adirlo aqu√≠ din√°micamente,
                        // pero es m√°s limpio manejarlo con ensureFixedEntities.
                        ensureFixedEntities(); 
                        renderMap(); // Para asegurar que el rival (si es nuevo) se muestre
                    } else {
                        // console.log(`Misi√≥n de desaf√≠o ${desafioMisionId} para ${nextRankData.nombre} ya est√° activa o completada.`);
                    }
                } else {
                    console.warn(`No se encontr√≥ una misi√≥n de desaf√≠o auto-activable para el rival ${nextRankData.desafioRivalId} del rango ${nextRankData.nombre}.`);
                }
            } else {
                // console.log(`El siguiente rango ${nextRankData.nombre} no tiene un desafioRivalId definido. Podr√≠a ser un rango sin desaf√≠o.`);
            }
        } else {
            // console.log(`Jugador no tiene suficientes PCS para el siguiente rango ${nextRankData.nombre}. Necesita: ${nextRankData.pcsRequeridos}, Tiene: ${player.secta.puntosContribucion}`);
        }
        updateSectUI(); // Actualizar la UI de la secta por si algo cambi√≥
    }

    function applyRankBenefits(newRankName) {
        const rankData = SECTA_DATA.rangos.find(r => r.nombre === newRankName);
        if (rankData) {
            showModal("Beneficios de Rango", `Has obtenido beneficios de ${newRankName}: ${rankData.beneficios}`);
        }
        updateUI(); 
    }
 
    function enemyTurn() {
        if (!gameState.battle.active || gameState.battle.playerTurn) return;
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        let enemyDamage = enemy.attack; // Inicializar con el ataque base del enemigo
        let actionMessage = `${enemy.name} te ataca`;
        let enemySkippedTurn = false;

        // --- LOGS INICIALES DEL TURNO DEL ENEMIGO ---
        console.log(`--- Enemy Turn Start: ${enemy.name} ---`);
        console.log(`Enemy Base Attack: ${enemy.attack}, Initial enemyDamage: ${enemyDamage}`);
        console.log(`Player Defense: ${player.defense}, Player HP: ${player.hp}`);
        console.log(`Enemy Status - Frozen: ${enemy.frozenTurns}, Stunned: ${enemy.stunnedTurns}, Burning: ${enemy.burningTurns} (Dmg: ${enemy.burnDamage}), Poisoned: ${enemy.poisonedTurns} (Dmg: ${enemy.poisonDamage}), Rooted: ${enemy.rootedTurns}`);
        console.log(`Player Status - Dodge: ${player.dodgeNextAttack}, Clone: ${player.cloneActive} (HP: ${player.cloneHealth}), MagicShield: ${player.magicShieldValue}`);
        // --- FIN LOGS INICIALES ---

        // ... (l√≥gica de DoTs y HoTs del enemigo sin cambios) ...
        if (enemy.burningTurns > 0) { enemy.hp -= enemy.burnDamage; logBattle(`${enemy.name} sufre ${enemy.burnDamage} por quemadura (inicio turno). HP: ${Math.floor(enemy.hp)}`); enemy.burningTurns--; if (enemy.burningTurns === 0) logBattle(`Quemadura en ${enemy.name} se extingue.`); if (enemy.hp <= 0) { handleEnemyDefeat(); return; } }
        if (enemy.poisonedTurns > 0) { enemy.hp -= enemy.poisonDamage; logBattle(`${enemy.name} sufre ${enemy.poisonDamage} por veneno (inicio turno). HP: ${Math.floor(enemy.hp)}`); enemy.poisonedTurns--; if (enemy.poisonedTurns === 0) logBattle(`Veneno en ${enemy.name} desaparece.`); if (enemy.hp <= 0) { handleEnemyDefeat(); return; } }
        if (enemy.rootedTurns > 0) { enemy.rootedTurns--; logBattle(`${enemy.name} sigue enredado.`); if (enemy.rootedTurns === 0) logBattle(`Enredo en ${enemy.name} se deshace.`); }


        if (enemy.frozenTurns > 0) { logBattle(`¬°${enemy.name} est√° congelado!`); enemy.frozenTurns--; enemySkippedTurn = true; } 
        else if (enemy.stunnedTurns > 0) { logBattle(`¬°${enemy.name} est√° aturdido!`); enemy.stunnedTurns--; enemySkippedTurn = true; }
        
        if (enemy.attackReductionTurns > 0) { 
            enemy.attackReductionTurns--; 
            if(enemy.attackReductionTurns === 0){ 
                // enemy.attack += enemy.attackReductionAmount; // CUIDADO: Esto modifica el ataque base permanentemente si no se gestiona bien
                                                            // Es mejor aplicar la reducci√≥n al 'enemyDamage' del turno actual
                logBattle(`Reducci√≥n de ataque en ${enemy.name} termina.`); 
                // enemy.attackReductionAmount = 0; // Ya no es necesario si se aplica al damage del turno
            } else {
                // Aplicar la reducci√≥n al da√±o de este turno si el debuff est√° activo
                enemyDamage = Math.max(1, enemy.attack - (enemy.attackReductionAmount || 0));
                console.log(`Enemy attack reduced. Current turn damage: ${enemyDamage}`);
            }
        }


        if (enemySkippedTurn) { 
            console.log("Enemy skipped turn due to status effect.");
            gameState.battle.playerTurn = true; updateBattleUI(); updateUI(); return; 
        }

        // L√≥gica de ataque especial o curaci√≥n del enemigo
        if (enemy.specialChance && Math.random() < enemy.specialChance) { 
            enemyDamage = Math.floor(enemy.attack * (enemy.specialAttackMultiplier || 1.5)); 
            actionMessage = `${enemy.name} usa golpe de Qi y`; 
            console.log(`Enemy uses Special Attack! Damage before defense: ${enemyDamage}`);
        }
        else if (enemy.healChance && Math.random() < enemy.healChance) { 
            const heal = Math.floor(enemy.maxHp * 0.15); 
            enemy.hp=Math.min(enemy.maxHp,enemy.hp+heal); 
            logBattle(`${enemy.name} recupera ${heal} vida.`); 
            console.log("Enemy healed.");
            gameState.battle.playerTurn = true; updateBattleUI(); updateUI(); return;
        }
        // L√≥gica de habilidades de jefe
        if (enemy.isBoss && enemy.abilities) { 
            for (const ability of enemy.abilities) {
                if (Math.random() < (ability.chance || 0.1)) { 
                    if (ability.type === "area_attack_simulated") { 
                        enemyDamage = Math.floor(enemy.attack * (ability.damageMultiplier || 1.0));
                        actionMessage = `${enemy.name} usa ${ability.name}! Aura opresiva te envuelve, y`;
                        console.log(`Boss uses Ability '${ability.name}'! Damage before defense: ${enemyDamage}`);
                    } else if (ability.type === "healPercentage" && ability.healPercentage) {
                        const bossHeal = Math.floor(enemy.maxHp * ability.healPercentage);
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + bossHeal);
                        logBattle(`${enemy.name} usa ${ability.name} y recupera ${bossHeal} vida!`);
                        console.log("Boss healed with ability.");
                        gameState.battle.playerTurn = true; updateBattleUI(); updateUI(); return; 
                    }
                    break; 
                }
            }
        }
        
        console.log(`After enemy special/ability checks, enemyDamage is: ${enemyDamage}`);

        // L√≥gica de esquivar del jugador
        if (player.dodgeNextAttack) { 
            const shadowDetails = techniqueData["shadow_step_1"];
            const dodgeTechLevel = player.learnedTechniques["shadow_step_1"]?.level || 1;
            const dodgeChance = (shadowDetails?.effect?.dodgeChance || 0.8) + ((dodgeTechLevel-1)*0.03); 
            if (Math.random() < dodgeChance) {
                logBattle(`¬°Esquivas el ataque de ${enemy.name}!`);
                player.dodgeNextAttack = false; 
                console.log("Player dodged attack.");
                gameState.battle.playerTurn = true; updateBattleUI(); updateUI(); return;
            } else { 
                logBattle(`Intentaste esquivar, ¬°pero ${enemy.name} te alcanz√≥!`); 
                player.dodgeNextAttack = false; 
                console.log("Player failed to dodge.");
            }
        }

        // L√≥gica del clon del jugador
        if (player.cloneActive && player.cloneHealth > 0) { 
            const cloneDetails = techniqueData["phantom_clone_1"];
            const aggroCloneChance = (cloneDetails?.effect?.aggroChance || 0.8) + ((player.learnedTechniques["phantom_clone_1"]?.level || 1 -1)*0.02);
            if(Math.random() < aggroCloneChance) {
                let damageToClone = Math.max(1, enemyDamage - 0 + Math.floor(Math.random() * 5 - 2)); // Clon no tiene defensa
                player.cloneHealth -= damageToClone;
                logBattle(`Clon intercepta ataque, recibe ${damageToClone} da√±o. HP clon: ${player.cloneHealth}.`);
                if (player.cloneHealth <= 0) { player.cloneActive = false; logBattle("¬°Clon destruido!"); }
                console.log("Clone took damage.");
                gameState.battle.playerTurn = true; updateBattleUI(); updateUI(); return; 
            } else { 
                logBattle(`Clon distrae, pero ${enemy.name} te enfoca!`); 
                console.log("Clone did not take aggro.");
            }
        }
        
        // L√≥gica de Barrera M√≠stica del jugador
        let isEnemyAttackMagic = (actionMessage.includes("golpe de Qi")); // Simplificaci√≥n, podr√≠as tener una propiedad en el ataque del enemigo
        if (player.magicShieldValue > 0 && isEnemyAttackMagic) {
            let absorbedDamage = Math.min(player.magicShieldValue, enemyDamage);
            enemyDamage -= absorbedDamage;
            player.magicShieldValue -= absorbedDamage;
            logBattle(`Barrera M√≠stica absorbe ${absorbedDamage} da√±o m√°gico. Barrera: ${player.magicShieldValue}.`);
            if (player.magicShieldValue <= 0) { logBattle("Barrera M√≠stica rota."); }
            console.log(`Magic shield absorbed ${absorbedDamage}. Remaining shield: ${player.magicShieldValue}. Enemy damage now: ${enemyDamage}`);
        }

        // --- C√ÅLCULO FINAL DE DA√ëO ---
        // A√±adir un aleatorizador al da√±o base del enemigo ANTES de restar la defensa del jugador
        const randomFactor = Math.floor(Math.random() * 5 - 2); // Entre -2 y +2
        const damageBeforeDefense = Math.max(1, enemyDamage + randomFactor); 
        const damageDealt = Math.max(0, damageBeforeDefense - player.defense);

        console.log(`Final Calculation - EnemyDamage (after buffs/specials): ${enemyDamage}, RandomFactor: ${randomFactor}, DamageBeforePlayerDefense: ${damageBeforeDefense}, PlayerDefense: ${player.defense}, FinalDamageDealt: ${damageDealt}`);
        // --- FIN C√ÅLCULO FINAL DE DA√ëO ---
        
        if (damageDealt > 0) { 
            player.hp -= damageDealt; 
            logBattle(`${actionMessage} causando ${damageDealt} da√±o.`); 
        } else { 
            logBattle(`${actionMessage} pero tu defensa bloquea el ataque o el da√±o es insignificante.`); 
        }
            
        // ... (resto de la l√≥gica de derrota del jugador y fin de turno sin cambios) ...
        if (player.hp <= 0) {
            player.hp = 0; logBattle('¬°Has sido derrotado!');
            setTimeout(() => {  
                player.hp = Math.floor(player.maxHp * 0.1); player.mana = Math.floor(player.maxMana * 0.1); 
                const expLoss = Math.floor(player.exp * 0.1); player.exp = Math.max(0, player.exp - expLoss); 
                logBattle(`Pierdes ${expLoss} EXP.`);
                const safeCoords = findSafeRespawnLocation(G_SAFE_RESPAWN_X, G_SAFE_RESPAWN_Y);
                player.x = safeCoords.x; player.y = safeCoords.y;
                updatePlayerPosition();   
                endBattle(false); 
                showModal('Derrota', 'Has sido derrotado. Regresas a un lugar seguro, mermado.');
            }, 2000);
            return;
        }
        
        if (player.elementalTurns > 0) { player.elementalTurns--; if (player.elementalTurns === 0) { player.attack -= player.tempAttackBonus; player.defense -= player.tempDefenseBonus; logBattle("Elemental invocado desaparece."); player.tempAttackBonus = 0; player.tempDefenseBonus = 0; }}
        gameState.battle.playerTurn = true;
        updateBattleUI(); 
        updateUI();
    }

    function endBattle(victory) {
        const player = gameState.player;
        gameState.battle.active = false;
        document.getElementById('battleScreen').style.display = 'none';
        document.getElementById('battleLog').innerHTML = '';
        if (victory && gameState.battle.enemy?.entityRef) {
            removeEntity(gameState.battle.enemy.entityRef);
        }
        gameState.battle.enemy = null;

        // Restaurar sprite a idle despu√©s de la batalla
        player.currentDirection = 'down'; // O la √∫ltima direcci√≥n antes de la batalla
        player.currentFrame = 0;
        player.isMoving = false; // Asegurarse de que no est√© en estado de movimiento
        updatePlayerSpriteVisual();

        recalculatePlayerStats();
        updateUI();
        showTouchControls();
    }


    function findSafeRespawnLocation(preferredX, preferredY) {
        const isHostile = (entity) => G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss;
        let preferredSpotOccupiedByHostile = gameState.map.entities.some(e => e.x === preferredX && e.y === preferredY && isHostile(e));
        if (!preferredSpotOccupiedByHostile) return { x: preferredX, y: preferredY };
            for (let r = 1; r <= G_SAFE_RESPAWN_SEARCH_RADIUS; r++) {
                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
                        const cx = preferredX + dx; const cy = preferredY + dy;
                        if (cx < 0 || cx >= gameState.map.width || cy < 0 || cy >= gameState.map.height) continue;
                        const isCompletelyEmpty = !gameState.map.entities.some(e => e.x === cx && e.y === cy);
                        if (isCompletelyEmpty) return { x: cx, y: cy };
                    }
                }
            }
        return { x: preferredX, y: preferredY }; 
    }

    function logBattle(message) {
        const log = document.getElementById('battleLog');
        const p = document.createElement('p');
        p.textContent = message;
        log.appendChild(p);
        log.scrollTop = log.scrollHeight;
    }

    function showTechniquePanel() {
        const container = document.getElementById('learnedTechniquesContainer');
        container.innerHTML = '';
        const player = gameState.player;
        if (Object.keys(player.learnedTechniques).length === 0) {
            container.innerHTML = "<p>A√∫n no has aprendido ninguna t√©cnica.</p>";
        }
        for (const techId in player.learnedTechniques) {
            const techInfo = techniqueData[techId];
            const playerTech = player.learnedTechniques[techId];
            if (!techInfo) continue;
            const div = document.createElement('div');
            div.className = 'technique-item'; 
            let levelText = playerTech.level >= techInfo.maxLevel ? `Nivel: ${playerTech.level} (MAX)` : `Nivel: ${playerTech.level} / ${techInfo.maxLevel}`;
            let description = techInfo.description;
            // Podr√≠as a√±adir l√≥gica aqu√≠ para mostrar el efecto actual basado en el nivel
            // Ejemplo: if (techInfo.effect.baseDamageMultiplier) description += ` (Da√±o actual: ${...})`;
            div.innerHTML = `<strong>${techInfo.name} ${techInfo.icon || ''}</strong> (${levelText})<br><small>${description}</small><br>`;
            if (techInfo.cultivationSettings && playerTech.level < techInfo.maxLevel) {
                const progress = playerTech.currentCultivationProgress || 0;
                const timeToNext = playerTech.cultivationTimeToNextLevel || (techInfo.cultivationSettings ? techInfo.cultivationSettings.baseTimeToLevelUp : Infinity);
                div.innerHTML += `<small>Progreso Cultivo: ${Math.floor(progress)}s / ${timeToNext}s para Nv. ${playerTech.level + 1}</small><br>`;
            }
            container.appendChild(div);
        }
        document.getElementById('techniqueModal').style.display = 'flex';
        hideTouchControls(); 
    }

  
    function startTechniqueRefinement(techId) { }
   
    function stopTechniqueRefinement() { }

    function applyTechniqueEffect(techId, newLevel) {
        const techInfo = techniqueData[techId];
        const player = gameState.player;
        if (!techInfo) return;
        const effect = techInfo.effect;
        switch (techInfo.type) {
            case "passive_cultivation": if (player.hasOwnProperty(effect.statToBoost)) { player[effect.statToBoost] += effect.value; } break;
            case "passive_stat": if (player.hasOwnProperty(effect.statToBoost)) { player[effect.statToBoost] += effect.value; } recalculatePlayerStats(); break;
            case "active_ability": recalculatePlayerStats(); break; 
            case "active_refinement_effect": // O el tipo que uses para Conversi√≥n de Qi
                if (techId === "qi_to_hp_conversion_1") {
                    if (newLevel >= 1) {
                        player.canUseQiConversion = true;
                        updateToggleQiConversionButtonVisibility();
                    }
                    // Aqu√≠ no se modifican los stats base del jugador directamente,
                    // sino que se asume que la l√≥gica que USA esta t√©cnica (en processCultivationTick)
                    // leer√° el nivel actual de la t√©cnica desde player.learnedTechniques[techId].level
                    // y aplicar√° los efectos escalados (como hpGainIncreasePerLevel) basados en ese nivel.
                    // Lo importante es que el nivel de la t√©cnica S√ç se ha incrementado.
                    console.log(`T√©cnica ${techInfo.name} mejorada a Nv.${newLevel}. Sus efectos de conversi√≥n ser√°n m√°s potentes.`);
                }
                break;
        }
        updateUI();
    }


    function closeTechniqueModal() {
        document.getElementById('techniqueModal').style.display = 'none';
        showTouchControls(); 
    }

   

    let currentShopPage = 1;
    const shopItemsPerPage = 6; 

    function openShop() {
        document.getElementById('playerSpiritualStones').textContent = `Piedras Espirituales: ${gameState.inventory["Piedras Espirituales"] || 0}`;
        document.getElementById('shopModal').style.display = 'flex';
        renderShopProducts();
        hideTouchControls(); 
    }
    
    function renderShopProducts() {
        const shopProductsEl = document.getElementById('shopProducts');
        shopProductsEl.innerHTML = '';
        const activeCategory = document.querySelector('#shopCategories .active')?.dataset.category || 'all';
        const searchTerm = document.getElementById('shopSearch').value.toLowerCase();
        const priceVal = parseInt(document.getElementById('priceRange').value);
        document.getElementById('priceRangeValue').textContent = `${priceVal} PS`;


        let filteredItems = shopData.inventory.filter(item => {
            const itemNameLower = item.itemName.toLowerCase();
            const itemCategory = item.category || 'other'; 
            const itemTypeForFilter = item.type || (itemNameLower.includes("rollo:") ? "scroll" : "other");


            if (searchTerm && !itemNameLower.includes(searchTerm) && !(item.description && item.description.toLowerCase().includes(searchTerm))) return false;
            if (item.price > priceVal) return false;
            
            if (activeCategory !== 'all') {
                if (activeCategory === 'combat' && !techIsCombat(item.itemName)) return false;
                if (activeCategory === 'cultivation' && !techIsCultivation(item.itemName)) return false;
                if (activeCategory === 'scroll' && !itemNameLower.startsWith('rollo: ')) return false;
                if (activeCategory === 'consumable' && itemTypeForFilter !== 'consumable' && !['Hierbas Medicinales', 'Cristales de Qi', 'P√≠ldora de Recuperaci√≥n Menor'].includes(item.itemName)) return false;
                if (activeCategory === 'weapon' && itemCategory !== 'weapon') return false;
                if (activeCategory === 'armor' && itemCategory !== 'armor') return false;
                 if (activeCategory === 'material' && !isMaterial(item.itemName)) return false;
            }
            return true;
        });
        
        const totalPages = Math.ceil(filteredItems.length / shopItemsPerPage);
        const startIndex = (currentShopPage - 1) * shopItemsPerPage;
        const pageItems = filteredItems.slice(startIndex, startIndex + shopItemsPerPage);
            
        pageItems.forEach(item => {
            const itemInfo = itemData[item.itemName] || {};
            const productCard = document.createElement('div');
            productCard.className = 'product-card';
            let itemIcon = getItemIcon(item.itemName, item.category);
            let itemType = getItemShopType(item.itemName, item.category, item.type);
            
            productCard.innerHTML = `
                <div class="product-header">
                    <div>
                        <div class="product-name">${itemIcon} ${item.itemName}</div>
                        <span class="product-type">${itemType}</span>
                    </div>
                    <div class="product-price">${item.price} PS</div>
                </div>
                <div class="product-description">${itemInfo.description || item.description || 'Un objeto misterioso.'}</div>
                ${item.levelRequirement ? `<div><strong>Req:</strong> Nv ${item.levelRequirement}</div>` : ''}
                ${typeof item.stock === 'number' ? `<div><strong>Disp:</strong> ${item.stock}</div>` : ''}
                <div class="product-actions">
                    <button class="buy-btn" data-item="${item.itemName}" data-price="${item.price}">Comprar</button>
                </div>`;
            const buyBtn = productCard.querySelector('.buy-btn');
            if ((gameState.inventory["Piedras Espirituales"] || 0) < item.price || item.stock === 0) {
                buyBtn.disabled = true;
                buyBtn.title = item.stock === 0 ? "Agotado" : "Piedras insuficientes";
            }
            buyBtn.addEventListener('click', () => buyFromShop(item.itemName));
            shopProductsEl.appendChild(productCard);
        });
        renderShopPagination(totalPages);
    }

    function techIsCombat(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(id => techniqueData[id].name === techName);
        return techId && (techniqueData[techId].type === 'active_ability' || techniqueData[techId].abilityId);
    }
    function techIsCultivation(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(id => techniqueData[id].name === techName);
        return techId && (techniqueData[techId].type === 'passive_cultivation' || techniqueData[techId].type === 'passive_stat' || techniqueData[techId].type === 'active_refinement_effect');
    }
    function isMaterial(itemName) {
        const knownMaterials = ["Cristal de Hielo", "Esencia de Fuego", "N√∫cleo de Tormenta", "Venenos Mortales", "Fragmentos de Jade", "Esencia Oscura", "Almas Condenadas", "N√∫cleo de V√≥rtice", "Roc√≠o Celestial", "Cristales Ps√≠quicos", "Mineral de Hierro Espiritual", "Plumas de F√©nix", "Semillas Ancestrales", "Escamas de Drag√≥n", "Espejos Astrales", "Relojes de Arena", "Sangre de Demonio", "L√°grimas de Unicornio", "N√∫cleo Elemental", "Polvo de Arcano", "Piedras Espirituales", "Cristales de Qi", "Hierbas Medicinales"];
        return knownMaterials.includes(itemName);
    }

    function getItemIcon(itemName, category) {
        if (itemName.includes('Espada') || category === 'weapon') return '‚öîÔ∏è';
        if (itemName.includes('Armadura') || category === 'armor') return 'üõ°Ô∏è';
        if (itemName.includes('Hierba')) return 'üåø';
        if (itemName.includes('Cristal')) return 'üíé';
        if (itemName.includes('Piedra')) return 'üíé';
        if (itemName.startsWith('Rollo:')) return 'üìú';
        return 'üì¶'; 
    }

    function getItemShopType(itemName, category, type) {
        if (itemName.startsWith('Rollo: ')) return 'T√©cnica';
        if (category === 'weapon') return 'Arma';
        if (category === 'armor') return 'Armadura';
        if (type === 'consumable' || ['Hierbas Medicinales', 'Cristales de Qi', 'P√≠ldora de Recuperaci√≥n Menor'].includes(itemName)) return 'Consumible';
        if (isMaterial(itemName)) return 'Material';
        return 'Objeto';
    }

    function renderShopPagination(totalPages) {
        const pagination = document.getElementById('shopPagination');
        pagination.innerHTML = '';
        if (totalPages <= 1) return;
            const prevBtn = document.createElement('button'); prevBtn.className = 'page-btn'; prevBtn.textContent = '¬´';
            prevBtn.addEventListener('click', () => { if (currentShopPage > 1) { currentShopPage--; renderShopProducts(); } });
            pagination.appendChild(prevBtn);
            const startPage = Math.max(1, currentShopPage - 1); 
            const endPage = Math.min(totalPages, currentShopPage + 1);
            for (let i = startPage; i <= endPage; i++) {
                const pageBtn = document.createElement('button'); pageBtn.className = `page-btn ${i === currentShopPage ? 'active' : ''}`; pageBtn.textContent = i;
                pageBtn.addEventListener('click', () => { currentShopPage = i; renderShopProducts(); });
                pagination.appendChild(pageBtn);
            }
            const nextBtn = document.createElement('button'); nextBtn.className = 'page-btn'; nextBtn.textContent = '¬ª';
            nextBtn.addEventListener('click', () => { if (currentShopPage < totalPages) { currentShopPage++; renderShopProducts(); } });
            pagination.appendChild(nextBtn);
    }

    function closeShopModal() {
        document.getElementById('shopModal').style.display = 'none';
        showTouchControls(); 
    }

    function buyFromShop(itemName) {
        const itemToBuy = shopData.inventory.find(i => i.itemName === itemName);
        const playerStones = gameState.inventory["Piedras Espirituales"] || 0;
        if (!itemToBuy || itemToBuy.stock === 0 || playerStones < itemToBuy.price) {
            showModal("Error Compra", "No se puede comprar (fondos insuficientes, agotado o no existe)."); return;
        }
        gameState.inventory["Piedras Espirituales"] -= itemToBuy.price;
        if (itemToBuy.type === "equipment" && itemToBuy.attackBonus) {
            gameState.player.baseAttack += itemToBuy.attackBonus;
            recalculatePlayerStats();
            showModal("¬°Equipo Comprado!", `Compraste ${itemName}. Ataque base +${itemToBuy.attackBonus}.`);
        } else {
            gameState.inventory[itemName] = (gameState.inventory[itemName] || 0) + 1;
            if (itemData[itemName] && itemData[itemName].effect && itemName.startsWith("Rollo: ")) {
                showModal("¬°Rollo Comprado!", `Has comprado ${itemName}. √ösalo desde tu inventario para aprender la t√©cnica.`);
            } else {
                showModal("¬°Objeto Comprado!", `Has comprado ${itemName}.`);
            }
        }
        if (typeof itemToBuy.stock === 'number' && itemToBuy.stock > 0) itemToBuy.stock--; 
        openShop(); updateUI();
    }

    function sellToShop(itemName, quantityToSell, totalStonesEarned) { }

    function saveGame() {  
        try {
            const gameStateToSave = JSON.parse(JSON.stringify(gameState));
            const gameDataJson = JSON.stringify(gameStateToSave, null, 2);
            const blob = new Blob([gameDataJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'camino_del_cultivador_save.json';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showModal('Partida Guardada', 'Progreso guardado como archivo JSON.');
        } catch (error) { showModal('Error al Guardar', `Hubo un problema: ${error.message}`); }
    }
    function triggerFileUpload() { document.getElementById('fileInput').click(); }

    function loadGameFromFile(event) {
        const file = event.target.files[0];
        if (!file) { showModal('Carga Cancelada', 'No se seleccion√≥ archivo.'); return; }
        if (file.type !== "application/json") { showModal('Error de Archivo', 'Selecciona un JSON v√°lido.'); event.target.value = null; return; }
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const loadedGameState = JSON.parse(e.target.result);
                if (typeof loadedGameState !== 'object' || !loadedGameState.player || !loadedGameState.map) {
                    throw new Error("Formato de guardado incorrecto.");
                }

                // Sobrescribir el estado actual con el cargado
                Object.assign(gameState.player, loadedGameState.player);
                // ... (tu l√≥gica de carga existente para otras partes de gameState) ...
                // Asegurar que las nuevas propiedades del sprite est√©n o se inicialicen
                gameState.player.spriteSheetUrl = loadedGameState.player.spriteSheetUrl || 'img/personaje_cultivador_spritesheet.png';
                gameState.player.frameWidth = loadedGameState.player.frameWidth || 64;
                gameState.player.frameHeight = loadedGameState.player.frameHeight || 64;
                gameState.player.directionRowMap = loadedGameState.player.directionRowMap || { 'down': 0, 'left': 1, 'right': 2, 'up': 3 };
                gameState.player.animationFrames = loadedGameState.player.animationFrames || 4;
                gameState.player.currentFrame = loadedGameState.player.currentFrame || 0;
                gameState.player.currentDirection = loadedGameState.player.currentDirection || 'down';
                gameState.player.isMoving = false; // Siempre empezar sin moverse despu√©s de cargar
                gameState.player.animationTimer = null;
                gameState.player.idleTimeout = null;
                gameState.player.animationSpeed = loadedGameState.player.animationSpeed || 150;


                generateMap(true);
                calculateAndSetTileSize();
                recalculatePlayerStats();
                updatePlayerVisualSize(); // Asegura que el tama√±o del div sea correcto
                updatePlayerSpriteVisual(); // Establece el sprite inicial
                updatePlayerPosition("loadGameFromFile");


                if (gameState.battle.active && gameState.battle.enemy) {
                    document.getElementById('battleScreen').style.display = 'flex';
                    populateBattleActionButtons();
                    updateBattleUI();
                    updatePlayerSpriteVisual(); // Para el sprite de batalla
                } else {
                    document.getElementById('battleScreen').style.display = 'none';
                }

                event.target.value = null;
                showModal('Partida Cargada', '¬°Partida restaurada!');
            } catch (error) {
                showModal('Error al Cargar', `Problema al leer o procesar el archivo: ${error.message}`);
                console.error("Error loading game:", error);
                event.target.value = null;
            }
        };
        reader.onerror = () => { showModal('Error de Lectura', 'No se pudo leer archivo.'); event.target.value = null; };
        reader.readAsText(file);
    }

    function showHelp() {
        showModal('Ayuda - Camino del Cultivador', 
            'Explora y convi√©rtete en un cultivador poderoso.\n\n' +
            'üßò Cultiva (Bot√≥n "Cultivar") para mejorar HP/Man√°/EXP y tus T√©cnicas.\n' +
            'üìñ Aprende y Refina T√©cnicas para obtener nuevas habilidades y mejoras pasivas.\n' +
            '‚¨ÜÔ∏è Sube de Nivel para aumentar tus estad√≠sticas base.\n' + // Actualizado
            'üëπ Combate demonios y rivales.\n' +
            'üíé Recolecta recursos y tesoros.\n' +
            'üìú Busca o compra rollos de t√©cnicas para volverte m√°s fuerte\n\n' + // Eliminada menci√≥n al √°rbol de habilidades
            'Controles (Teclado):\n' +
            '  WASD/Flechas: Moverse\n' +
            '  ESPACIO: Interactuar\n\n' +
            'Controles (T√°ctil):\n' +
            '  Joystick: Moverse\n' +
            '  Bot√≥n "Acci√≥n": Interactuar');
    }

    const joystickContainer = document.getElementById('joystick-container');
    const joystickPad = document.getElementById('joystick-pad');
    const joystickHandle = document.getElementById('joystick-handle');
    const actionButtonTouch = document.getElementById('action-button-touch');
    let joystickActive = false; 
    let joystickCurrentDx = 0; // Guardar la direcci√≥n actual del joystick
    let joystickCurrentDy = 0;

    const JOYSTICK_THRESHOLD = 15; 
    const JOYSTICK_GAME_MOVE_INTERVAL = 250; 
    let joystickGameMoveTimerId = null;
    let lastJoystickMoveTime = 0; 
    let joystickLoopId = null;
    let joystickTouchIdentifier = null; // <!-- CAMBIO JOYSTICK: Para seguir el dedo correcto -->

    function initJoystick() {
        if (!joystickContainer || !joystickPad || !joystickHandle || !actionButtonTouch) {
            console.error("Error inicializando joystick: Elementos no encontrados.");
            return;
        }
        resetJoystickHandle();

        joystickPad.addEventListener('touchstart', (event) => {
            if (gameState.player.isCultivating || gameState.battle.active || joystickActive) return;
            const touch = event.changedTouches[0];
            if (!touch) return;
            const padRect = joystickPad.getBoundingClientRect();
            if (touch.clientX < padRect.left || touch.clientX > padRect.right || touch.clientY < padRect.top || touch.clientY > padRect.bottom) {
                return;
            }
            event.preventDefault();
            joystickActive = true;
            joystickTouchIdentifier = touch.identifier;
            document.addEventListener('touchmove', handleJoystickMove, { passive: false });
            document.addEventListener('touchend', handleJoystickEnd, { passive: false });
            document.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
            
            // No iniciar el gameMoveTimer aqu√≠, la animaci√≥n la maneja handlePlayerMovementInput
            // updateJoystickHandlePosition y determinar direcci√≥n inicial
            updateJoystickHandlePosition(touch, true); // true para indicar que es el inicio
        }, { passive: false });

        actionButtonTouch.addEventListener('click', () => {
            if (!gameState.player.isCultivating && !gameState.battle.active) {
                interact();
            }
        });
    }
    function resetJoystickHandle() {
        if (joystickHandle) joystickHandle.style.transform = 'translate(0px, 0px)';
        joystickCurrentDx = 0; 
        joystickCurrentDy = 0;
    }
    // <!-- CAMBIO JOYSTICK: Modificaciones en los manejadores -->
    function handleJoystickStart(event) {
        // event.preventDefault(); // Puede ser necesario, pero probar sin √©l primero si causa problemas
        if (gameState.player.isCultivating || gameState.battle.active || joystickActive) return;
        
        // Solo procesar el primer toque en el pad
        const touch = event.changedTouches[0]; 
        if (!touch) return;

        // Comprobar si el toque est√° realmente dentro del joystickPad (opcional, pero bueno para evitar activaciones accidentales)
        const padRect = joystickPad.getBoundingClientRect();
        if (touch.clientX < padRect.left || touch.clientX > padRect.right || touch.clientY < padRect.top || touch.clientY > padRect.bottom) {
            return; 
        }
        
        event.preventDefault(); // Prevenir scroll/zoom si el toque es para el joystick
        
        joystickActive = true;
        joystickTouchIdentifier = touch.identifier; // Guardar el ID del dedo

        // A√±adir listeners de movimiento y fin al documento para seguir el dedo fuera del pad
        document.addEventListener('touchmove', handleJoystickMove, { passive: false });
        document.addEventListener('touchend', handleJoystickEnd, { passive: false });
        document.addEventListener('touchcancel', handleJoystickEnd, { passive: false });


        if (!joystickGameMoveTimerId) {
            joystickGameMoveTimerId = setInterval(processJoystickGameMove, JOYSTICK_GAME_MOVE_INTERVAL);
        }
        updateJoystickHandlePosition(touch);
        // console.log("Joystick Start, ID:", joystickTouchIdentifier);
    }
    function handleJoystickMove(event) {
        if (!joystickActive) return;
        
        // Encontrar el toque correcto
        let touch = null;
        for (let i = 0; i < event.changedTouches.length; i++) {
            if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
                touch = event.changedTouches[i];
                break;
            }
        }

        if (touch) {
            event.preventDefault(); // Prevenir scroll si el movimiento es del dedo del joystick
            updateJoystickHandlePosition(touch);
            // console.log("Joystick Move");
        }
    }
    
    function updateJoystickHandlePosition(touch, isStart = false) {
        const padRect = joystickPad.getBoundingClientRect();
        if (padRect.width === 0 || padRect.height === 0) return;

        const joystickCenterX = padRect.left + padRect.width / 2;
        const joystickCenterY = padRect.top + padRect.height / 2;

        const currentX = touch.clientX - joystickCenterX;
        const currentY = touch.clientY - joystickCenterY;

        const angle = Math.atan2(currentY, currentX);
        const maxDistance = joystickPad.offsetWidth / 2 - joystickHandle.offsetWidth / 2;
        if (maxDistance <= 0) return;
        
        const distance = Math.min(maxDistance, Math.hypot(currentX, currentY));
        const limitedX = distance * Math.cos(angle);
        const limitedY = distance * Math.sin(angle);
        if (joystickHandle) joystickHandle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;

        let newJoystickDx = 0;
        let newJoystickDy = 0;
        let newDirection = null;

        const magnitude = Math.hypot(currentX, currentY);
        if (magnitude > JOYSTICK_THRESHOLD) {
            if (Math.abs(currentX) > Math.abs(currentY)) {
                newJoystickDx = currentX > 0 ? 1 : -1;
                newDirection = currentX > 0 ? 'right' : 'left';
            } else {
                newJoystickDy = currentY > 0 ? 1 : -1;
                newDirection = currentY > 0 ? 'down' : 'up';
            }
        }

        if (newDirection && (newDirection !== gameState.player.currentDirection || isStart || !gameState.player.isMoving )) {
            // Si la direcci√≥n cambia o si est√°bamos parados, actualizamos
            // Primero, "soltamos" la direcci√≥n anterior si la hay y est√°bamos movi√©ndonos
            if (gameState.player.isMoving && gameState.player.currentDirection && gameState.player.currentDirection !== newDirection) {
                handlePlayerMovementInput(gameState.player.currentDirection, false);
            }
            // Luego, "presionamos" la nueva direcci√≥n
            handlePlayerMovementInput(newDirection, true);
            // Y movemos l√≥gicamente
            movePlayer(newJoystickDx, newJoystickDy);

        } else if (!newDirection && gameState.player.isMoving) {
            // Si no hay nueva direcci√≥n (el dedo volvi√≥ al centro) y est√°bamos movi√©ndonos
            handlePlayerMovementInput(gameState.player.currentDirection, false);
        }
        // Guardar para referencia en processJoystickGameMove si lo vuelves a usar
        joystickCurrentDx = newJoystickDx;
        joystickCurrentDy = newJoystickDy;
    }

    function handleJoystickEnd(event) { // Simplificado
        if (!joystickActive) return;
        let touchEndedIsOurs = false;
        for (let i = 0; i < event.changedTouches.length; i++) {
            if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
                touchEndedIsOurs = true;
                break;
            }
        }
        if (touchEndedIsOurs) {
            joystickActive = false;
            joystickTouchIdentifier = null;
            resetJoystickHandle();
            document.removeEventListener('touchmove', handleJoystickMove);
            document.removeEventListener('touchend', handleJoystickEnd);
            document.removeEventListener('touchcancel', handleJoystickEnd);

            // "Soltar" la tecla de movimiento actual
            if (gameState.player.isMoving) {
                handlePlayerMovementInput(gameState.player.currentDirection, false);
            }
            joystickCurrentDx = 0;
            joystickCurrentDy = 0;
        }
    }
    // processJoystickGameMove se mantiene igual
    // <!-- FIN CAMBIO JOYSTICK -->
    function processJoystickGameMove() {
        // Esta funci√≥n se llama cada JOYSTICK_GAME_MOVE_INTERVAL
        if (joystickActive && (joystickCurrentDx !== 0 || joystickCurrentDy !== 0)) {
            // console.log(`[processJoystickGameMove] Effective move: dx=${joystickCurrentDx}, dy=${joystickCurrentDy}. Calling movePlayer.`);
            movePlayer(joystickCurrentDx, joystickCurrentDy);
        }
    }
    function joystickLoop() { 
        if (!joystickActive) { joystickLoopId = null; return; }
        const now = Date.now();
        if (now - lastJoystickMoveTime > JOYSTICK_MOVE_INTERVAL) {
            let dx = 0, dy = 0; const magnitude = Math.hypot(joystickCurrentX, joystickCurrentY);
            if (magnitude > JOYSTICK_THRESHOLD) {
                if (Math.abs(joystickCurrentX) > Math.abs(joystickCurrentY)) { dx = joystickCurrentX > 0 ? 1 : -1; } 
                else { dy = joystickCurrentY > 0 ? 1 : -1; }
            }
            if (dx !== 0 || dy !== 0) { movePlayer(dx, dy); lastJoystickMoveTime = now; }
        }
        joystickLoopId = requestAnimationFrame(joystickLoop);
    }
    
    function openSectHallInterface() {
        const player = gameState.player;
        const sectData = SECTA_DATA;
        console.log("[SectHall] Abrir interfaz. Rango actual:", player.secta.rango, "PCS:", player.secta.puntosContribucion); // LOG INICIAL

        document.getElementById('sectHallModalTitle').textContent = `Sal√≥n ${player.secta.nombre}`;
        document.getElementById('sectHallPlayerRank').textContent = player.secta.rango;
        document.getElementById('sectHallPlayerPCS').textContent = player.secta.puntosContribucion;

        const availableMissionsDiv = document.getElementById('sectHallAvailableMissions');
        availableMissionsDiv.innerHTML = '<p>Habla con Gu√≠a Lin o Admin Yao para asignaciones generales.</p>';

        const rankChallengesDiv = document.getElementById('sectHallRankChallenges');
        rankChallengesDiv.innerHTML = '';

        const currentRankIndex = sectData.rangos.findIndex(r => r.nombre === player.secta.rango);
        console.log("[SectHall] currentRankIndex:", currentRankIndex); // LOG currentRankIndex

        let challengeButtonAdded = false;

        // Condici√≥n principal para mostrar el bot√≥n de consulta
        if (currentRankIndex !== -1 && currentRankIndex + 1 < sectData.rangos.length) {
            console.log("[SectHall] Condici√≥n para mostrar bot√≥n CUMPLIDA. Hay un siguiente rango."); // LOG
            const nextRankData = sectData.rangos[currentRankIndex + 1];
            console.log("[SectHall] Siguiente rango:", nextRankData.nombre, "PCS Req:", nextRankData.pcsRequeridos); // LOG nextRankData

            const challengeButton = document.createElement('button');
            challengeButton.textContent = `Consultar Desaf√≠o para ${nextRankData.nombre}`;
            challengeButton.className = 'cultivation-option-btn';
            challengeButton.style.marginBottom = '10px';

            challengeButton.onclick = () => {
                // ... (l√≥gica del onclick que ya tienes, puedes a√±adir logs internos aqu√≠ tambi√©n si es necesario) ...
                console.log("[SectHall] Bot√≥n 'Consultar Desaf√≠o' CLICADO.");
                const pcsNecesarios = nextRankData.pcsRequeridos;
                const tieneSuficientesPCS = player.secta.puntosContribucion >= pcsNecesarios;
                const rivalIdParaDesafio = nextRankData.desafioRivalId;
                let mensajeDesafio = `<strong>Desaf√≠o para ascender a ${nextRankData.nombre}:</strong><br>`;
                let misionDesafioActiva = null;
                let misionDesafioDataObj = null; 
                let idDeLaMisionAsociada = null; 

                console.log(`[SectHall - OnClick] PCS Necesarios: ${pcsNecesarios}, Tiene PCS: ${tieneSuficientesPCS}, Rival ID: ${rivalIdParaDesafio}`);

                if (rivalIdParaDesafio) {
                    const misionEntry = Object.entries(MISIONES_DATA).find(([mKey, mVal]) =>
                        mVal.objetivo?.tipo === "derrotar_npc_especifico" &&
                        mVal.objetivo?.npcId === rivalIdParaDesafio &&
                        mVal.recompensa?.nuevoRango === nextRankData.nombre
                    );
                    console.log("[SectHall - OnClick] Mision Entry encontrada:", misionEntry);

                    if (misionEntry) {
                        idDeLaMisionAsociada = misionEntry[0]; 
                        misionDesafioDataObj = misionEntry[1];  
                        misionDesafioActiva = player.secta.misionesActivas.find(m => m.id === idDeLaMisionAsociada);
                        console.log("[SectHall - OnClick] ID Misi√≥n Asociada:", idDeLaMisionAsociada, "Misi√≥n Activa?:", !!misionDesafioActiva);

                        mensajeDesafio += `<em>"${misionDesafioDataObj.descripcion}"</em><br>`;
                        mensajeDesafio += `Oponente: <strong>${entityTypes[rivalIdParaDesafio]?.name || 'Guardi√°n Desconocido'}</strong>.<br>`;
                        mensajeDesafio += `Recompensas: ${misionDesafioDataObj.recompensa.pcs || 0} PCS, ${misionDesafioDataObj.recompensa.exp || 0} EXP, Rango ${nextRankData.nombre}.<br><hr>`;
                    } else {
                        mensajeDesafio += `Informaci√≥n del desaf√≠o espec√≠fico no encontrada (error de configuraci√≥n o la misi√≥n no est√° definida correctamente).<br><hr>`;
                    }
                } else {
                    mensajeDesafio += `Este rango no parece requerir un desaf√≠o de combate para ascender.<br><hr>`;
                }

                mensajeDesafio += `<strong>Requisitos Actuales:</strong><br>`;
                mensajeDesafio += `Puntos de Contribuci√≥n (PCS): ${player.secta.puntosContribucion} / ${pcsNecesarios} PCS. `;
                mensajeDesafio += tieneSuficientesPCS ? "<span style='color: #66ff66;'>(Cumplido)</span><br>" : `<span style='color: #ffcc66;'>(Faltan ${pcsNecesarios - player.secta.puntosContribucion} PCS)</span><br>`;

                
                if (misionDesafioActiva) {
                    mensajeDesafio += "<br><strong style='color: #66ff66;'>¬°El desaf√≠o est√° ACTIVO!</strong> Dir√≠gete a la arena.";
                } else if (idDeLaMisionAsociada && player.secta.misionesCompletadas[idDeLaMisionAsociada]) {
                    mensajeDesafio += "<br><strong style='color: #aaa;'>Ya has completado este desaf√≠o.</strong>";
                } else if (tieneSuficientesPCS && rivalIdParaDesafio && misionDesafioDataObj && idDeLaMisionAsociada) {
                    const activarDesafioBtnId = "activar-desafio-btn-specific";
                    mensajeDesafio += `<br><button id="${activarDesafioBtnId}">Activar Misi√≥n de Desaf√≠o Ahora</button>`;
                    
                    window.tempChallengeActivationInfo = {
                        misionId: idDeLaMisionAsociada, 
                        nextRankName: nextRankData.nombre
                    };
                } else if (!tieneSuficientesPCS) {
                    mensajeDesafio += "<br>A√∫n no cumples los requisitos de PCS para activar este desaf√≠o.";
                } else if (!rivalIdParaDesafio || !misionDesafioDataObj) {
                    mensajeDesafio += "<br>No hay un desaf√≠o de combate claramente definido para este rango o falta informaci√≥n de la misi√≥n.";
                }
                
                showModal("Informaci√≥n del Desaf√≠o de Rango", mensajeDesafio);

                if (window.tempChallengeActivationInfo && document.getElementById('activar-desafio-btn-specific')) {
                    document.getElementById('activar-desafio-btn-specific').onclick = () => {
                        console.log("[SectHall - OnClick] Bot√≥n 'Activar Misi√≥n Ahora' CLICADO.");
                        const info = window.tempChallengeActivationInfo;
                        const misionDataParaActivar = MISIONES_DATA[info.misionId]; 
                        const playerRef = gameState.player; 
                        const nextRankDataRef = SECTA_DATA.rangos.find(r => r.nombre === info.nextRankName);

                        if (misionDataParaActivar && nextRankDataRef && playerRef.secta.puntosContribucion >= nextRankDataRef.pcsRequeridos) {
                            if (!playerRef.secta.misionesActivas.some(m => m.id === info.misionId) && !playerRef.secta.misionesCompletadas[info.misionId]) {
                                acceptMission(info.misionId);
                                closeModal(); 
                                openSectHallInterface(); 
                                ensureFixedEntities(); 
                                renderMap();
                            } else {
                                showModal("Desaf√≠o ya Gestionado", "Este desaf√≠o ya est√° activo o ha sido completado.");
                            }
                        } else {
                            showModal("Requisitos No Cumplidos", "Ya no cumples los requisitos para activar este desaf√≠o.");
                        }
                        delete window.tempChallengeActivationInfo; 
                    };
                } else if (document.getElementById('activar-desafio-btn-specific')) {
                    console.warn("[SectHall - OnClick] Bot√≥n 'activar-desafio-btn-specific' existe, pero window.tempChallengeActivationInfo no est√° definido.");
                }
            };
            rankChallengesDiv.appendChild(challengeButton);
            challengeButtonAdded = true;
            console.log("[SectHall] Bot√≥n 'Consultar Desaf√≠o' A√ëADIDO al DOM."); // LOG si se a√±ade
        } else {
            // Este bloque se ejecuta si la condici√≥n if (currentRankIndex !== -1 && currentRankIndex + 1 < sectData.rangos.length) NO se cumple
            console.log("[SectHall] Condici√≥n para mostrar bot√≥n NO CUMPLIDA."); // LOG
            if (currentRankIndex === -1) {
                console.log("[SectHall] Raz√≥n: currentRankIndex es -1 (rango del jugador no encontrado)."); // LOG
            } else {
                console.log("[SectHall] Raz√≥n: Jugador en rango m√°ximo o no hay m√°s rangos (currentRankIndex + 1 >= sectData.rangos.length)."); // LOG
            }
        }

        // Mensajes de fallback si el bot√≥n no se a√±adi√≥
        if (!challengeButtonAdded) {
            console.log("[SectHall] challengeButtonAdded es FALSE. Mostrando mensaje de fallback."); // LOG
            if (currentRankIndex === -1) {
                rankChallengesDiv.innerHTML = "<p>Error al determinar tu rango actual.</p>";
            } else if (currentRankIndex + 1 >= sectData.rangos.length) {
                rankChallengesDiv.innerHTML = "<p>¬°Has alcanzado el rango m√°s alto o no hay m√°s desaf√≠os definidos!</p>";
            } else {
                // Esta situaci√≥n es menos com√∫n si la l√≥gica anterior es correcta,
                // pero podr√≠a ocurrir si hay un `nextRankData` pero por alguna raz√≥n no se crea el bot√≥n.
                rankChallengesDiv.innerHTML = "<p>No hay informaci√≥n de desaf√≠o disponible en este momento (situaci√≥n de fallback inesperada).</p>";
            }
        }

        document.getElementById('sectHallModal').style.display = 'flex';
        hideTouchControls();
    }
    function acceptMissionFromSectHall(misionId) { acceptMission(misionId); if (document.getElementById('sectHallModal').style.display === 'flex') { openSectHallInterface(); } }
    function closeSectHallModal() { document.getElementById('sectHallModal').style.display = 'none'; showTouchControls(); }
    function openSectShop() { showModal("Tienda de Secta", "El Dep√≥sito a√∫n est√° siendo abastecido."); }


    // --- INICIALIZACI√ìN ---
    document.addEventListener('DOMContentLoaded', () => {
    // MODIFICACI√ìN DEL LISTENER DE TECLADO
        document.addEventListener('keydown', (e) => {
            if (gameState.player.isCultivating || gameState.battle.active || isAnyModalOpen()) {
                if (e.code === 'Escape') { /* ... tu l√≥gica de modales ... */ }
                return;
            }
            let direction = null;
            switch (e.code) {
                case 'KeyW': case 'ArrowUp': direction = 'up'; break;
                case 'KeyS': case 'ArrowDown': direction = 'down'; break;
                case 'KeyA': case 'ArrowLeft': direction = 'left'; break;
                case 'KeyD': case 'ArrowRight': direction = 'right'; break;
                case 'Space': e.preventDefault(); interact(); return; // Interact no cambia
            }

            if (direction) {
                e.preventDefault();
                handlePlayerMovementInput(direction, true); // true para keyDown
                // El movePlayer original se llamar√° desde un intervalo o l√≥gica de juego si es necesario
                // para desacoplar la actualizaci√≥n visual de la l√≥gica de movimiento
                if (dxFromDirection(direction) !== 0 || dyFromDirection(direction) !== 0) {
                    movePlayer(dxFromDirection(direction), dyFromDirection(direction));
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            if (gameState.player.isCultivating || gameState.battle.active || isAnyModalOpen()) {
                return;
            }
            let direction = null;
            switch (e.code) {
                case 'KeyW': case 'ArrowUp': direction = 'up'; break;
                case 'KeyS': case 'ArrowDown': direction = 'down'; break;
                case 'KeyA': case 'ArrowLeft': direction = 'left'; break;
                case 'KeyD': case 'ArrowRight': direction = 'right'; break;
            }
            if (direction) {
                handlePlayerMovementInput(direction, false); // false para keyUp
            }
        });
        // Helper para convertir direcci√≥n a dx/dy para movePlayer
        function dxFromDirection(direction) {
            if (direction === 'left') return -1;
            if (direction === 'right') return 1;
            return 0;
        }
        function dyFromDirection(direction) {
            if (direction === 'up') return -1;
            if (direction === 'down') return 1;
            return 0;
        }
        const fileInput = document.getElementById('fileInput');
        if (fileInput) fileInput.addEventListener('change', loadGameFromFile);
        
        const toggleControlsBtn = document.getElementById('toggleMapControlsBtn');
        if (toggleControlsBtn) toggleControlsBtn.addEventListener('click', toggleMapControlsVisibility);

        // Listener para redimensionar y recalcular el tama√±o de los tiles
        window.addEventListener('resize', () => {
            calculateAndSetTileSize();
            renderMap(); // Vuelve a dibujar con el nuevo tama√±o
            updatePlayerPosition(); // Asegura que el jugador est√© bien posicionado
        });
        

        // Iniciar el bucle de actualizaci√≥n del juego
        setInterval(gameTickUpdater, 1000); // Llama cada segundo, ajusta seg√∫n necesidad
        initJoystick();
        calculateAndSetTileSize();
        // generateMap() ahora es m√°s simple, isRespawn = false para carga inicial completa
        gameState.lastGameTimeUpdate = Date.now(); // Inicializar antes del primer tick
        // ---------- CAMBIO IMPORTANTE AQU√ç ----------
        generateMap(true); // Usar true para la generaci√≥n inicial completa, incluyendo decorativos
        // ---------- FIN DEL CAMBIO IMPORTANTE ----------
        recalculatePlayerStats();
        updatePlayerVisualSize();   // Asegura el tama√±o correcto del div del jugador
        updatePlayerSpriteVisual(); // Establece el sprite inicial
        updatePlayerPosition("DOMContentLoaded_init"); // Llama despu√©s de sprite visual
       
        
        updatePlayerSpriteVisual(); // Llamar una vez para establecer el sprite inicial
        
        showTouchControls();

        showModal('Despertar del Cultivador', 
             'Has despertado en un mundo de cultivadores buscando poder supremo. ' +
            'Te encuentras cerca de la <strong>Secta del Viento Azure</strong>. Quiz√°s all√≠ encuentres tu camino.\n\n' +
            '<strong>Objetivo:</strong> Asciende en la secta, domina t√©cnicas, derrota enemigos y desvela secretos.\n\n' +
            'Busca al <strong>Gu√≠a Lin</strong> en la secta (‚õ©Ô∏è) para comenzar.\n\n' +
            'Usa Controles (Teclado/T√°ctil) para moverte e interactuar. Presiona "?" para ayuda.'
        );
        document.querySelectorAll('#shopCategories .category-item').forEach(item => {
            item.addEventListener('click', function() {
                document.querySelectorAll('#shopCategories .category-item').forEach(i => i.classList.remove('active'));
                this.classList.add('active'); currentShopPage = 1; renderShopProducts();
            });
        });
        document.getElementById('shopSearch').addEventListener('input', () => { currentShopPage = 1; renderShopProducts(); });
        document.getElementById('priceRange').addEventListener('input', (e) => { 
            document.getElementById('priceRangeValue').textContent = `${e.target.value} PS`;
            currentShopPage = 1; renderShopProducts(); 
        });
    });
    </script>
</body>
</html>