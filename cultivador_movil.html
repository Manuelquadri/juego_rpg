<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Camino del Cultivador</title>
    <style>
      /****************************************
       * 1. ESTILOS GENERALES Y LAYOUT
       ****************************************/
       
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", monospace;
        background: linear-gradient(135deg, #2c1810, #8b4513);
        color: #f4e4bc;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Evita el scroll indeseado */
      }

      .game-container {
        display: flex;
        flex-grow: 1;
        /* El padding-top crea el espacio para la barra de navegaci√≥n superior */
        padding-top: 55px; /* Ajusta este valor si cambia la altura de la barra */
        position: relative;
        z-index: 1;
      }

      .sidebar {
        display: none; /* La barra lateral ya no se usa, se oculta permanentemente */
      }

      button {
        background: linear-gradient(135deg, #d4af37, #b8941f);
        color: #2c1810;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      button:hover {
        background: linear-gradient(135deg, #f4d03f, #d4af37);
        transform: translateY(-2px);
      }

      button:disabled {
        background: #666;
        color: #999;
        cursor: not-allowed;
        transform: none;
      }
      /* Esta regla se aplicar√° a TODAS las barras de estad√≠sticas del juego */
      .stat-bar {
        width: 100%;
        height: 18px; /* Una altura est√°ndar y visible. Puedes ajustarla. */
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 9px;
        overflow: hidden; /* Asegura que el relleno no se salga */
        border: 1px solid rgba(212, 175, 55, 0.2);
        margin: 8px 0; /* Un poco de espacio vertical para que no se pegue a otros elementos */
      }

      /* El relleno de la barra */
      .stat-fill {
        height: 100%; /* Ahora esto funcionar√°, porque el padre (.stat-bar) tiene una altura fija */
        transition: width 0.3s linear;
      }
      #fullscreenIcon {
        margin-right: 8px;
        display: inline-block;
        /* Para el √≠cono de salir */
        font-family: 'Arial Unicode MS', 'Apple Symbols', 'sans-serif';
      }
      /****************************************
       * 2. INTERFAZ PRINCIPAL (HUD, BARRAS, BOTONES)
       ****************************************/

      /* --- Barra de Navegaci√≥n Superior --- */
      .top-nav-bar {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 55px; /* Altura fija para el c√°lculo de padding */
        background: linear-gradient(180deg, #2c1810, #1a1a1a);
        border-bottom: 2px solid #d4af37;
        display: flex;
        justify-content: space-around;
        align-items: center;
        z-index: 250;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease-in-out;
        transform: translateY(0);
      }

      .top-nav-bar.hidden {
        transform: translateY(-100%);
      }

      .nav-button {
        position: relative;
        background: transparent;
        border: none;
        color: #f4e4bc;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 8px 5px;
        cursor: pointer;
        font-family: "Courier New", monospace;
        font-size: 0.75rem;
        flex-grow: 1;
        max-width: 20%;
        transition: background-color 0.2s, color 0.2s;
      }

      .nav-button:hover,
      .nav-button.active {
        background-color: rgba(212, 175, 55, 0.15);
        color: #f4d03f;
      }

      .nav-icon {
        font-size: 1.5rem;
        margin-bottom: 3px;
      }

      /* --- HUD de Stats del Jugador (Esquina superior izquierda) --- */
      .stats-panel {
        position: fixed; /* FIJO en la ventana, no relativo al mapa */
        top: 70px; /* 55px de la barra + 15px de margen */
        left: 15px;
        z-index: 100;
        width: 180px;
        background: rgba(26, 26, 26, 0.75);
        backdrop-filter: blur(4px);
        border: 2px solid #d4af37;
        border-radius: 8px;
        padding: 10px;
        margin: 0;
      }

      .stats-panel .stat-bar {
        width: 100%;
        height: 12px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 7px;
        margin-top: 3px;
        margin-bottom: 8px;
        overflow: hidden;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      .stat-fill {
        height: 100%;
        transition: width 0.3s;
      }
      .stats-panel .stat-line,
      .stats-panel .stat-block {
        margin-bottom: 8px; /* Espaciado consistente */
      }

      .stats-panel .stat-stones {
        color: #f4d03f; /* Destacar las piedras espirituales */
        font-weight: bold;
        margin-top: 4px;
      }

      .stats-panel .stat-block span {
        display: block; /* Asegura que el texto est√© en su propia l√≠nea */
        font-size: 0.9em;
        margin-bottom: 2px;
      }
      .hp-fill {
        background: linear-gradient(90deg, #ff4444, #ff6666);
      }
      .mana-fill {
        background: linear-gradient(90deg, #4444ff, #6666ff);
      }
      .exp-fill {
        background: linear-gradient(90deg, #44ff44, #66ff66);
      }
      .stats-panel.hidden {
        opacity: 0;
        pointer-events: none; /* Evita que se pueda hacer clic en el panel cuando est√° oculto */
        transform: translateX(
          -100%
        ); /* Opcional: lo desliza fuera de la pantalla */
        transition: opacity 0.3s ease, transform 0.3s ease;
      }
      /* --- Barra de Acceso R√°pido Inferior --- */
      .quick-slot-bar {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        padding: 8px;
        background: rgba(26, 26, 26, 0.8);
        border: 2px solid #d4af37;
        border-radius: 12px;
        z-index: 150;
        box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
        backdrop-filter: blur(4px);
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      }
      .quick-slot-bar.hidden {
          opacity: 0;
          visibility: hidden;
          pointer-events: none; /* Importante para que no sea clickeable cuando est√° invisible */
      }

      .quick-slot {
        width: 55px;
        height: 55px;
        border: 2px solid rgba(212, 175, 55, 0.5);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        position: relative;
        transition: all 0.2s;
      }
      .quick-slot:hover {
        background-color: rgba(212, 175, 55, 0.2);
        border-color: #f4d03f;
      }
      .quick-slot.empty {
        border-style: dashed;
      }

      .slot-item-count {
        position: absolute;
        bottom: 2px;
        right: 4px;
        font-size: 14px;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px black;
      }

      .slot-key-hint {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 12px;
        color: #f4e4bc;
        opacity: 0.7;
      }
      .cultivate-slot {
        font-size: 28px; /* Hacemos el emoji un poco m√°s grande */
        border-style: solid; /* Para que no se vea punteado como un slot vac√≠o */
      }

      /* Estilo para cuando el cultivo est√° activo */
      .cultivate-slot.active-cultivation {
        background-color: rgba(
          139,
          69,
          19,
          0.5
        ); /* Un brillo sutil de color del tema */
        border-color: #f4d03f;
        box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
        animation: pulse-cultivation 2s infinite;
      }
      .conversion-slot {
        font-size: 28px;
        border-style: solid;
        color: #f4e4bc;
        opacity: 0.6; /* Un poco tenue cuando est√° inactivo */
        transition: all 0.3s;
      }

      .conversion-slot:hover {
        opacity: 1;
      }

      .conversion-slot.active-conversion {
        opacity: 1;
        background-color: rgba(68, 68, 255, 0.3); /* Brillo azulado */
        border-color: #6666ff;
        box-shadow: 0 0 10px rgba(102, 102, 255, 0.7);
        animation: pulse-conversion 2s infinite;
      }

      @keyframes pulse-conversion {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes pulse-cultivation {
        0% {
          transform: scale(1);
          box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 15px rgba(244, 208, 63, 0.8);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
        }
      }

      /* --- Botones de Control Superpuestos (M√≥vil) --- */
      #mobileMenuBtn {
        display: none;
        position: fixed;
        top: 10px;
        right: 10px; /* <--- CORREGIDO */
        z-index: 1000;
        width: 45px;
        height: 45px;
        font-size: 24px;
        padding: 0;
      }

      #toggleMapControlsBtn {
          display: none; /* Se controla por JS y media queries */
          position: fixed;
          top: 60px; /* Posici√≥n respecto a la ventana */
          right: 10px;
          z-index: 200; /* Aseguramos que est√© al mismo nivel que los otros controles */
          padding: 8px 12px;
          font-size: 14px;
      }

      #toggleMapControlsBtn.hidden-during-battle {
        display: none !important;
      }

      /****************************************
       * 3. MAPA Y ELEMENTOS DEL MAPA
       ****************************************/
      .map-container {
        flex: 1;
        position: relative;
        background: #1a3d2e;
        border: 3px solid #d4af37;
        overflow: hidden;
      }

      .map {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .tile {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .player {
        z-index: 10;
        color: transparent; /* Oculta el emoji de fallback */
        font-size: 0;
        background-image: url("img/tu_sprite_sheet.png"); /* Aseg√∫rate que la ruta sea correcta */
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: 256px 256px; /* Ajusta al tama√±o total de tu spritesheet */
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }

      /* Barras de stats sobre el jugador en el mapa */
      #playerOnMapBarsContainer {
        position: absolute;
        width: 48px;
        display: none; /* JS lo controla */
        flex-direction: column;
        gap: 1px;
        z-index: 15;
        pointer-events: none;
        transform: translateX(-50%);
      }

      .on-map-stat-bar {
        width: 100%;
        height: 6px;
        background-color: rgba(50, 50, 50, 0.7);
        border: 1px solid rgba(0, 0, 0, 0.5);
        border-radius: 2px;
        overflow: hidden;
      }

      .on-map-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerOnMapHpFill {
        background-color: #f44336;
      }
      #playerOnMapManaFill {
        background-color: #2196f3;
      }
      .entity-name-plate {
        position: absolute; /* Para posicionarlo relativo al mapa */
        bottom: 100%; /* Lo coloca justo encima del 'top' del sprite */
        left: 50%;
        transform: translateX(-50%); /* Lo centra horizontalmente */
        background-color: rgba(10, 10, 10, 0.7);
        color: #f4e4bc;
        padding: 2px 5px;
        border-radius: 4px;
        font-size: 10px; /* Un tama√±o de fuente peque√±o y legible */
        font-weight: bold;
        white-space: nowrap; /* Evita que el nombre se parta en dos l√≠neas */
        z-index: 6; /* Asegura que est√© por encima de la entidad */
        pointer-events: none; /* Evita que la etiqueta intercepte clics del rat√≥n */
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      /****************************************
       * 4. PANTALLA DE BATALLA
       ****************************************/

      .battle-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        display: none;
        flex-direction: column;
        z-index: 300;
        overflow: hidden;
        max-height: 100dvh; 
      }

      .battle-area {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: space-around;
        padding: 20px 10px;
        gap: 10px;
        overflow-y: auto;
      }

      .character,
      .enemy {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-basis: 45%;
        max-width: 280px;
        min-width: 120px;
        padding: 60px 0;
      }

      .character-sprite,
      .enemy-sprite {
        width: 80px;
        height: 80px;
        font-size: 60px;
        margin-bottom: 10px;
      }
      .enemy-sprite {
        background-size: contain; /* Asegura que la imagen quepa completa en el div */
        background-repeat: no-repeat;
        background-position: center; /* Centra la imagen del sprite */
        image-rendering: pixelated; /* Mantiene la est√©tica pixel-art si la tienes */
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }

      .character-sprite {
        background-image: url("img/tu_sprite_sheet.png");
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: auto;
        color: transparent;
      }

      .battle-actions {
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-top: 2px solid #d4af37;
        flex-shrink: 0;
      }

      .action-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 5px;
        margin-bottom: 10px;
      }

      .battle-actions button {
        padding: 8px 10px;
        font-size: 0.8em;
      }

      .log {
        display: none;
      }

      /* Barras sobre sprites en batalla */
      #playerInBattleSpriteBarsContainer,
      #enemyInBattleInfoContainer {
        position: absolute;
        display: none;
        flex-direction: column;
        gap: 2px;
        z-index: 5;
        pointer-events: none;
        transform: translateX(-50%);
      }

      #playerInBattleSpriteBarsContainer {
        width: 60px;
      }
      #enemyInBattleInfoContainer {
        min-width: 70px;
        max-width: 300px;
        align-items: center;
        padding: 2px 4px;
        background-color: rgba(10, 10, 10, 0.6);
        border-radius: 3px;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      .in-battle-sprite-stat-bar {
        width: 100%;
        height: 5px;
        background-color: rgba(50, 50, 50, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.6);
        border-radius: 2px;
        overflow: hidden;
      }
      .in-battle-sprite-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerInBattleSpriteHpFill {
        background-color: #e53935;
      }
      #playerInBattleSpriteManaFill {
        background-color: #1e88e5;
      }
      #enemyInBattleSpriteHpFill {
        background-color: #c62828;
      }

      .enemy-battle-name-level {
        font-size: 0.8em;
        color: #f4e4bc;
        font-weight: bold;
        white-space: nowrap;
      }

      /****************************************
       * 5. MODALES Y ELEMENTOS DE UI
       ****************************************/
      /* === NUEVO: ESTILOS PARA EL VELO OSCURECEDOR === */
      .game-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6); /* Color negro semitransparente */
        backdrop-filter: blur(
          3px
        ); /* Efecto de desenfoque para el fondo (opcional, muy vistoso) */
        z-index: 290; /* Clave: Por encima del juego (z-index < 290) pero por debajo de la batalla/modales (z-index >= 300) */
        opacity: 0;
        pointer-events: none; /* No debe ser clickeable cuando est√° invisible */
        transition: opacity 0.4s ease-in-out;
      }

      .game-overlay.active {
        opacity: 1;
        pointer-events: auto; /* Se vuelve "s√≥lido" para evitar clics en el juego de fondo */
      }
      /* === FIN DE ESTILOS PARA EL VELO === */

      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 500; /* M√°s alto que la batalla */
        padding: 10px;
      }

      .modal-content {
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        border: 3px solid #d4af37;
        border-radius: 15px;
        padding: 20px;
        max-width: 95%;
        width: 500px;
        text-align: center;
        max-height: 90vh;
        overflow-y: auto;
      }
      .inventory-modal-item .item-description {
          font-size: 0.9em;
          opacity: 0.8;
          margin-top: 4px;
          margin-bottom: 8px; /* <-- A√±ade este margen inferior */
      }

      .cultivation-option-btn {
        display: block;
        width: 100%;
        padding: 10px;
        margin-bottom: 8px;
        text-align: left;
      }

      /* Controles t√°ctiles del mapa (Joystick, Bot√≥n Acci√≥n) */
      #joystick-container {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
        z-index: 200;
        /* display: none;  SE MUESTRA/OCULTA CON EL OVERLAY PADRE */
        opacity: 0.7;
      }
      #joystick-pad {
        z-index: 1;
        width: 100%;
        height: 100%;
        background-color: rgba(128, 128, 128, 0.5);
        border-radius: 50%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid rgba(255, 255, 255, 0.7);
      }
      #joystick-handle {
        width: 50px;
        height: 50px;
        background-color: rgba(80, 80, 80, 0.8);
        border-radius: 50%;
        position: absolute;
        border: 2px solid rgba(200, 200, 200, 0.9);
      }
      #action-button-touch {
        position: fixed;
        bottom: 60px;
        right: 60px;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        z-index: 200;
        /* display: none; SE MUESTRA/OCULTA CON EL OVERLAY PADRE */
        font-size: 0.8em;
      }
      #touch-controls-overlay {
          /* Este contenedor no tiene tama√±o, solo sirve para agrupar 
            y asegurar que sus hijos 'fixed' se muestren correctamente */
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none; /* Clave: Permite que los clics "atraviesen" el overlay y lleguen al mapa */
          z-index: 199; /* Justo debajo de los controles individuales */
          display: none; /* Por defecto, oculto. JS lo controla. */
      }

      /* Cualquier elemento clickeable DENTRO del overlay debe reactivar los pointer-events */
      #touch-controls-overlay > * {
          pointer-events: auto;
      }
      /* --- Estilos para Modal de Inventario --- */
      .inventory-modal-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 15px;
        padding: 10px;
        margin-bottom: 8px;
        border: 1px solid rgba(212, 175, 55, 0.2);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.15);
      }

      .inventory-modal-item .item-details {
        flex-grow: 1;
      }

      .inventory-modal-item .item-name {
        font-weight: bold;
        color: #f4d03f;
        font-size: 1.1em;
      }

      .inventory-modal-item .item-description {
        font-size: 0.9em;
        opacity: 0.8;
        margin-top: 4px;
      }

      .inventory-modal-item .item-actions {
        display: flex;
        gap: 8px;
        flex-shrink: 0;
      }

      .inventory-modal-item .item-actions button {
        padding: 6px 10px;
        font-size: 0.8em;
      }
      .assignable-item {
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .assignable-item:hover {
        background-color: rgba(212, 175, 55, 0.1);
        border-color: rgba(212, 175, 55, 0.4);
      }
      /* --- Fin Estilos Modal Inventario --- */

      /* === ESTILOS PARA NOTIFICACI√ìN DE ZONA === */
      .zone-notification {
        position: absolute;
        top: 20%; /* Posici√≥n vertical */
        left: 50%;
        transform: translateX(-50%); /* Centrado horizontal */
        background-color: rgba(10, 10, 10, 0.8);
        color: #f4d03f;
        font-size: 1.5em; /* Tama√±o de fuente grande */
        font-weight: bold;
        padding: 15px 30px;
        border-radius: 10px;
        border: 2px solid #d4af37;
        z-index: 200; /* Por encima del mapa pero debajo de otros modales */
        pointer-events: none; /* Para que no intercepte clics */
        opacity: 0; /* Empieza invisible */
        transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out;
        text-shadow: 1px 1px 3px black;
        white-space: nowrap; /* Evita que el texto se rompa */
      }

      .zone-notification.show {
        opacity: 1;
        top: 25%; /* Se mueve un poco hacia abajo al aparecer */
      }

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
      @media (max-width: 768px),
        (max-height: 500px),
        (hover: none) and (pointer: coarse) {
        .game-container {
          padding-top: 0; /* En m√≥vil, no hay espacio arriba, el men√∫ es un overlay */
          /* --- CORRECCI√ìN CLAVE --- */
          /* Hacemos que el contenedor del juego pueda estar detr√°s de la barra */
        
        }

        .map-container {
          max-height: 100dvh; 
        }

        #mobileMenuBtn,
        #toggleMapControlsBtn {
          display: block;
        }

        .top-nav-bar {
        flex-direction: column;
        justify-content: flex-start;
        align-items: stretch;
        height: auto; /* <-- Correcto */
        padding-top: 60px; /* <-- Correcto */
        z-index: 200;
        transform: translateY(-100%);
        transition: transform 0.4s ease-in-out;

        /* 1. Establecemos una altura m√°xima. No puede ser m√°s alto que la pantalla. */
        max-height: 100dvh; 
        
        /* 2. LA CLAVE: Si el contenido se desborda, creamos un scroll vertical. */
        overflow-y: auto; 

        /* 3. (Opcional pero recomendado) Mejoramos la est√©tica de la barra de scroll en navegadores Webkit (Chrome, Safari) */
        scrollbar-width: thin;
        scrollbar-color: #d4af37 rgba(0, 0, 0, 0.3);
        }
        /* Para navegadores Webkit (Chrome, Safari, Edge) */
        .top-nav-bar::-webkit-scrollbar {
            width: 8px;
        }
        .top-nav-bar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        .top-nav-bar::-webkit-scrollbar-thumb {
            background-color: #b8941f;
            border-radius: 4px;
            border: 2px solid transparent;
            background-clip: content-box;
        }
        .top-nav-bar.open {
          transform: translateY(0);
        }

        .top-nav-bar .nav-button {
          justify-content: flex-start;
          padding: 15px 20px;
          max-width: 100%;
        }

        .stats-panel .desktop-only {
          display: none;
        }

        .stats-panel {
          /* Ajustes existentes para m√≥vil */
          width: 180px; /* Un poco m√°s ancho para la nueva info */
          padding: 8px;
          font-size: 0.8em; /* Un poco m√°s grande para legibilidad */
          top: 10px;
          left: 10px;
          backdrop-filter: blur(2px);
        }

        #toggleMapControlsBtn {
          top: 60px; /* Vuelve a su posici√≥n original en m√≥vil */
        }

        .character-sprite,
        .enemy-sprite {
          width: 60px;
          height: 60px;
          font-size: 55px;
        }
      }

      @media (max-width: 480px) {
        .nav-text {
          display: none;
        }
        .nav-icon {
          font-size: 1.8rem;
          margin-bottom: 0;
        }
        .nav-button {
          padding: 10px 5px;
        }

        .stats-panel {
          width: 160px;
          font-size: 0.8em;
        }
        .stats-panel h3 {
          font-size: 1.1em;
        }

        .character-sprite,
        .enemy-sprite {
          width: 50px;
          height: 50px;
          font-size: 50px;
        }
        .battle-actions button {
          padding: 6px 8px;
          font-size: 0.75em;
        }
      }
      @media (max-height: 500px) and (min-width: 600px), (orientation: landscape) {

        /* --- Acciones de Batalla m√°s Compactas (L√ìGICA MEJORADA) --- */
        .battle-actions {
            padding: 5px; 
        }

        .action-buttons {
            /* Clave: Forzamos la cuadr√≠cula a tener m√°s columnas para que se expanda horizontalmente */
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 5px; 
            margin-bottom: 5px;
            /* Opcional: Para centrar los botones si no llenan todo el espacio */
            justify-content: center; 
        }

        .battle-actions button {
            /* Hacemos los botones m√°s anchos pero menos altos */
            padding: 8px 12px;     /* M√°s padding horizontal, menos vertical */
            min-height: 36px;      /* Establecemos una altura m√≠nima/m√°xima para controlar su altura */
            max-height: 38px;
            font-size: 0.70rem;    /* Un tama√±o de fuente legible pero compacto */
            line-height: 1.2;      /* Ayuda a centrar el texto verticalmente en la nueva altura */
            
            /* Aseguramos que el contenido dentro del bot√≥n se centre */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        /* --- Ajustes al resto de la UI en modo horizontal --- */
        .stats-panel {
            top: 10px;
            left: 10px;
            padding: 6px;
            font-size: 0.75rem;
        }

        .stats-panel h3 {
            font-size: 1rem;
            margin-bottom: 2px;
        }

        .quick-slot-bar {
            bottom: 5px;
            padding: 6px;
            gap: 6px;
        }
        .quick-slot {
            width: 48px;
            height: 48px;
            font-size: 22px;
        }
        .slot-item-count {
            font-size: 12px;
        }
        .slot-key-hint {
            font-size: 10px;
        }
        
       

        /* 2. Ajustamos los sprites y nombres para que ocupen el espacio liberado */
        .character,
        .enemy {
            padding: 10px 0; /* Reducimos dr√°sticamente el padding vertical */
            justify-content: center; /* Centramos el contenido restante (sprite y nombre) */
        }

        .character-sprite,
        .enemy-sprite {
            margin-bottom: 8px; /* Un peque√±o margen entre el sprite y el nombre */
        }

        /* 3. Aseguramos que la informaci√≥n sobre el sprite del enemigo sea visible */
        #enemyInBattleInfoContainer {
            /* Es posible que necesitemos ajustar su posici√≥n si se descuadra */
            transform: translate(-50%, 5px); /* Empuja la barra un poco hacia abajo para que no se pegue al borde */
        }
        

        }
      /****************************************
       * NUEVO: 7. ESTILOS DE LA TIENDA
       ****************************************/

      #shopModal .modal-content {
        max-width: 90%;
        width: 1000px; /* Un ancho mayor para la tienda */
        height: 90vh;
        display: flex;
        flex-direction: column;
      }

      .shop-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        flex-shrink: 0;
      }

      .shop-stats {
        font-size: 1.1em;
        color: #f4d03f;
      }

      .shop-container {
        display: flex;
        gap: 20px;
        flex-grow: 1;
        overflow: hidden; /* Evita que el contenedor principal scrollee */
      }

      .shop-filters {
        flex: 0 0 220px; /* No crece, no se encoge, base de 220px */
        padding-right: 15px;
        border-right: 1px solid rgba(212, 175, 55, 0.2);
        overflow-y: auto;
      }

      .shop-products {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .products-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 15px;
        overflow-y: auto; /* El scroll ahora est√° aqu√≠ */
        padding: 5px;
        flex-grow: 1;
      }

      .section-title {
        color: #f4d03f;
        margin-bottom: 10px;
        border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        padding-bottom: 5px;
      }

      .search-box {
        width: 100%;
        padding: 8px;
        background-color: rgba(0, 0, 0, 0.3);
        border: 1px solid #555;
        border-radius: 5px;
        color: #f4e4bc;
        margin-bottom: 15px;
      }

      .filter-group {
        margin-bottom: 20px;
      }
      .filter-title {
        font-weight: bold;
        margin-bottom: 8px;
        font-size: 0.9em;
        opacity: 0.8;
      }

      .category-list {
        list-style: none;
      }
      .category-item {
        padding: 8px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .category-item:hover {
        background-color: rgba(212, 175, 55, 0.1);
      }
      .category-item.active {
        background-color: rgba(212, 175, 55, 0.2);
        color: #f4d03f;
        font-weight: bold;
      }

      .product-card {
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(212, 175, 55, 0.3);
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
      }

      .product-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 10px;
      }

      .product-name {
        font-weight: bold;
        color: #f4d03f;
      }
      .product-type {
        font-size: 0.8em;
        opacity: 0.7;
      }
      .product-price {
        font-weight: bold;
        white-space: nowrap;
      }

      .product-description {
        font-size: 0.9em;
        margin: 10px 0;
        opacity: 0.9;
        flex-grow: 1; /* Hace que la descripci√≥n empuje el bot√≥n hacia abajo */
      }

      .product-actions {
        margin-top: auto; /* Empuja el bot√≥n al final de la tarjeta */
      }
      .buy-btn {
        width: 100%;
      }

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
      @media (max-width: 768px) {
        /* ... (tus otras media queries) ... */

        /* A√ëADE ESTAS REGLAS DENTRO DE LA MEDIA QUERY DE 768px */
        #shopModal .modal-content {
          width: 95%; /* Ocupa m√°s ancho en m√≥vil */
          /* Quitamos la altura fija para que se adapte al contenido en m√≥vil */
          height: auto;
          max-height: 85vh; /* Ponemos una altura m√°xima para que no ocupe toda la pantalla */
        }

        .shop-container {
          flex-direction: column; /* Apila los filtros encima de los productos */
          /* Hacemos que el scroll sea manejado por el .modal-content general en m√≥vil */
          overflow: visible;
        }

        .shop-filters {
          flex: 0 0 auto; /* No debe crecer, su tama√±o ser√° determinado por su contenido */
          border-right: none;
          border-bottom: 1px solid rgba(212, 175, 55, 0.2);
          padding-bottom: 15px;
          margin-bottom: 15px;
          overflow-y: visible; /* Correcto, no queremos scroll aqu√≠ */
        }

        .shop-products {
          /* Quitamos el overflow: hidden que podr√≠a estar ocultando el contenido */
          overflow: visible;
        }

        .products-grid {
          grid-template-columns: 1fr; /* Una sola columna para los productos en m√≥vil */
          overflow-y: visible; /* El scroll lo maneja el padre */
          /* Quitamos el flex-grow para evitar conflictos */
        }
      }
      /****************************************
       * NUEVO: 8. ESTILOS DE COMBATE FLOTANTES
       ****************************************/
      .damage-popup {
        position: absolute;
        z-index: 310; /* Encima de todo en la batalla */
        font-family: "Courier New", monospace;
        font-weight: bold;
        pointer-events: none; /* Para que no intercepte clics */
        text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.7);
        animation: floatUpAndFade 1.5s ease-out forwards;
      }

      /* Estilos espec√≠ficos */
      .damage-popup.damage {
        color: #ff4d4d;
        font-size: 1.2em;
      }
      .damage-popup.heal {
        color: #66ff66;
        font-size: 1.8em;
      }
      .damage-popup.mana {
        color: #87cefa;
        font-size: 1.5em;
      }
      .damage-popup.ability {
        color: #f4d03f;
        font-size: 1.2em;
      }
      .damage-popup.debuff {
        color: #dda0dd;
        font-size: 1.2em;
      }

      @keyframes floatUpAndFade {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        100% {
          transform: translateY(-80px) scale(1.2);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <!-- ======================================================================= -->
    <!-- 1. CAPAS GLOBALES Y ELEMENTOS FIJOS (Velo, Stats, Botones) -->
    <!-- Estos elementos est√°n en la capa superior y no se mueven con el mapa. -->
    <!-- ======================================================================= -->
    <div id="game-overlay" class="game-overlay"></div>
    <button id="mobileMenuBtn">‚ò∞</button>

    <div class="stats-panel">
      <p class="stat-line stat-coords">
        Coords: <span id="playerCoords">X: 0, Y: 0</span>
      </p>
      <p class="stat-line stat-zone">
        Zona: <span id="playerZone">Desconocida</span>
      </p>
      <p class="stat-line stat-level desktop-only">
        Nivel: <span id="playerLevel">1</span>
      </p>
      <p class="stat-line stat-realm desktop-only">
        Reino: <span id="playerRealm">Mortal</span>
      </p>
      <div class="stat-block desktop-only">
        <span>Vida: <span id="hpText">100/100</span></span>
        <div class="stat-bar">
          <div class="stat-fill hp-fill" id="hpBar" style="width: 100%"></div>
        </div>
      </div>
      <div class="stat-block desktop-only">
        <span>Man√°: <span id="manaText">50/50</span></span>
        <div class="stat-bar">
          <div
            class="stat-fill mana-fill"
            id="manaBar"
            style="width: 100%"
          ></div>
        </div>
      </div>
      <div class="stat-block">
        <span>Experiencia: <span id="expText">0/100</span></span>
        <div class="stat-bar">
          <div class="stat-fill exp-fill" id="expBar" style="width: 0%"></div>
        </div>
      </div>
      <p class="stat-line stat-stones">
        P. Espirituales: <span id="playerStonesHud">0</span>
      </p>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display: none" />
   

    <!-- ======================================================================= -->
    <!-- 2. CONTENEDOR PRINCIPAL DEL JUEGO (El mundo que se mueve) -->
    <!-- Solo contiene el mapa, el jugador y los elementos que est√°n DENTRO del mundo del juego. -->
    <!-- ======================================================================= -->
    <div class="game-container">
      <div class="map-container">
        <div class="map" id="gameMap"></div>
        <div class="tile player" id="player">üßò</div>
        <div id="zone-notification" class="zone-notification"></div>

        <div id="playerOnMapBarsContainer">
          <div class="on-map-stat-bar">
            <div class="on-map-stat-fill" id="playerOnMapHpFill"></div>
          </div>
          <div class="on-map-stat-bar">
            <div class="on-map-stat-fill" id="playerOnMapManaFill"></div>
          </div>
        </div>

        

        <!-- El sidebar es parte del layout del juego, por lo que se queda aqu√≠. -->
        <div class="sidebar">
          <div class="inventory-panel">
            <h3>Inventario</h3>
            <div class="inventory-grid" id="inventory"></div>
          </div>
          <div class="controls-panel">
            <h3>Controles</h3>
            <p><strong>Escritorio:</strong></p>
            <p>WASD/Flechas: Moverse</p>
            <p>ESPACIO: Interactuar</p>
            <p style="margin-top: 5px"><strong>M√≥vil:</strong></p>
            <p>Joystick: Moverse</p>
            <p>Bot√≥n Acci√≥n: Interactuar</p>
            <p>
              "Ocultar/Mostrar Controles": Alterna visibilidad de controles
              t√°ctiles.
            </p>
            <button id="cultivateButton" onclick="toggleCultivation()">
              üßò‚Äç‚ôÄÔ∏è Cultivar
            </button>
            <button onclick="showTechniquePanel()">üìñ T√©cnicas</button>
            <button onclick="saveGame()">üíæ Guardar Partida</button>
            <button onclick="triggerFileUpload()">üìÅ Cargar Partida</button>
            <button onclick="showHelp()">‚ùì Ayuda</button>
          </div>
          <div class="secta-panel">
            <h3><span id="sectaNombreDisplay">Secta</span></h3>
            <p>Rango: <span id="playerSectRank">Disc√≠pulo Externo</span></p>
            <p>Puntos de Contribuci√≥n: <span id="playerPCS">0</span> PCS</p>
            <h4>Misiones Activas:</h4>
            <div
              id="activeMissionsList"
              style="font-size: 0.9em; max-height: 150px; overflow-y: auto"
            >
              <p>Ninguna misi√≥n activa.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- <<--- FIN DEL CONTENEDOR PRINCIPAL DEL JUEGO -->
      
    <!-- === INICIO DE LA NUEVA SECCI√ìN DE CONTROLES T√ÅCTILES === -->
    <!-- Este es el contenedor correcto que el JavaScript mostrar√° u ocultar√° -->
    <div id="touch-controls-overlay">
      <div id="joystick-container">
          <div id="joystick-pad">
              <div id="joystick-handle"></div>
          </div>
      </div>
      <button id="action-button-touch">Acci√≥n</button>
    </div>
    <button id="toggleMapControlsBtn">Ocultar Controles</button>

    <!-- ======================================================================= -->
    <!-- 3. TODAS LAS PANTALLAS Y MODALES SUPERPUESTOS -->
    <!-- Al estar fuera del game-container, no se ver√°n borrosos en m√≥vil. -->
    <!-- ======================================================================= -->

    <!-- Pantalla de Combate -->
    <div class="battle-screen" id="battleScreen">
      <div class="battle-area">
        <div class="character">
          <div id="playerInBattleSpriteBarsContainer">
            <div class="in-battle-sprite-stat-bar">
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteHpFill"
              ></div>
            </div>
            <div class="in-battle-sprite-stat-bar">
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteManaFill"
              ></div>
            </div>
          </div>
          <div class="character-sprite">üßò</div>
          <h3 id="playerBattleName">Cultivador</h3>
          <div>Vida: <span id="playerBattleHp">100/100</span></div>
          <div class="stat-bar"style="display: none;">
            <div
              class="stat-fill hp-fill"
              id="playerBattleHpBar"
              style="display:none"
            ></div>
          </div>
        </div>
        <div class="enemy">
          <div id="enemyInBattleInfoContainer">
            <div class="enemy-battle-name-level" id="enemyBattleNameLevel">
              Enemigo (Nv. X)
            </div>
            <div class="in-battle-sprite-stat-bar enemy-hp-bar">
              <div
                class="in-battle-sprite-stat-fill"
                id="enemyInBattleSpriteHpFill"
              ></div>
            </div>
          </div>
          <div class="enemy-sprite" id="enemySprite"></div>
          <h3 id="enemyName">Demonio</h3>
          <div>Vida: <span id="enemyHp">80/80</span></div>
          <div class="stat-bar"style="display: none;">
            <div
              class="stat-fill hp-fill"
              id="enemyHpBar"
              
            ></div>
          </div>
        </div>
      </div>
      <div class="battle-actions">
        <div class="action-buttons" id="battleActionButtons"></div>
        <div class="log" id="battleLog"></div>
      </div>
    </div>

    <!-- Modal para Cultivo Activo -->
    <div class="modal" id="activeCultivationModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="activeCultivationTitle">Cultivando...</h3>
        <p id="activeCultivationDescription">Concentrando tu energ√≠a...</p>
        <div id="activeCultivationProgressUI" style="display: none">
          <p>
            Progreso:
            <span id="activeCultivationTargetName">T√©cnica X</span> (Nv.
            <span id="activeCultivationTargetLevel">Y</span>)
          </p>
          <div class="stat-bar" style="background: #444; margin: 10px 0">
            <div
              class="stat-fill"
              id="activeCultivationProgressBar"
              style="
                width: 0%;
                background: linear-gradient(90deg, #ffd700, #ffae42);
              "
            ></div>
          </div>
          <p
            id="activeCultivationProgressText"
            style="text-align: center; font-size: 0.9em"
          >
            0s / 0s
          </p>
        </div>
        <div
          id="recoveryCultivationProgressUI"
          style="display: none; margin-top: 15px"
        >
          <p>Absorbiendo Qi del entorno...</p>
          <div style="margin-top: 15px; font-size: 0.9em">
            <div>Vida: <span id="modalHpText">100/100</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill hp-fill"
                id="modalHpBar"
                style="width: 100%"
              ></div>
            </div>
            <div>Man√°: <span id="modalManaText">50/50</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill mana-fill"
                id="modalManaBar"
                style="width: 100%"
              ></div>
            </div>
          </div>
        </div>
        <div id="cultivationBoostSection" style="display: none; margin-top: 15px; padding-top: 10px; border-top: 1px solid #555;">
          <p>Piedras Espirituales: <span id="cultivationModalPlayerStones">0</span></p>
          
          <!-- Contenedor para los botones de aceleraci√≥n -->
          <div style="display: flex; gap: 10px; margin-top: 8px;">
              
              <!-- Bot√≥n para usar 1 piedra -->
              <button id="boostCultivationButton1" onclick="boostCultivationProgress(1)" style="flex-grow: 1;">
                  ‚ö° Usar 1 PS (+10s)
              </button>
              
              <!-- NUEVO Bot√≥n para usar 10 piedras -->
              <button id="boostCultivationButton10" onclick="boostCultivationProgress(10)" style="flex-grow: 1; background: linear-gradient(135deg, #e8c34f, #c9a82e);">
                  ‚ö°‚ö° Usar 10 PS (+100s)
              </button>
      
          </div>
      </div>
        <button onclick="stopCultivation(true)" style="margin-top: 20px">
          üö´ Detener Cultivo
        </button>
      </div>
    </div>

    <!-- Modal para tienda -->
    <div class="modal" id="shopModal">
      <div class="modal-content">
        <div class="shop-header">
          <h2 id="shopName">Pabell√≥n de Tesoros del Drag√≥n Oculto</h2>
          <div class="shop-stats">
            <span id="playerSpiritualStones">Piedras Espirituales: 0</span>
          </div>
        </div>
        <div class="shop-container">
          <div class="shop-filters">
            <h3 class="section-title">Filtros</h3>
            <input
              type="text"
              class="search-box"
              id="shopSearch"
              placeholder="Buscar..."
            />
            <div class="filter-group">
              <div class="filter-title">Categor√≠as</div>
              <ul class="category-list" id="shopCategories">
                <li class="category-item active" data-category="all">Todas</li>
                <li class="category-item" data-category="combat">T. Combate</li>
                <li class="category-item" data-category="cultivation">
                  T. Cultivo
                </li>
                <li class="category-item" data-category="weapon">Armas</li>
                <li class="category-item" data-category="armor">Armaduras</li>
                <li class="category-item" data-category="consumable">
                  Consumibles
                </li>
                <li class="category-item" data-category="material">
                  Materiales
                </li>
                <li class="category-item" data-category="scroll">Rollos</li>
              </ul>
            </div>
            <div class="filter-group">
              <div class="filter-title">Rango de Precio</div>
              <div>
                <input
                  type="range"
                  id="priceRange"
                  min="0"
                  max="3000"
                  value="3000"
                  style="width: 100%"
                />
              </div>
              <div
                style="
                  display: flex;
                  justify-content: space-between;
                  font-size: 0.8em;
                "
              >
                <span>0 PS</span><span id="priceRangeValue">1000 PS</span>
              </div>
            </div>
          </div>
          <div class="shop-products">
            <h3 class="section-title">T√©cnicas y Objetos</h3>
            <div class="products-grid" id="shopProducts"></div>
            <div class="pagination" id="shopPagination"></div>
          </div>
        </div>
        <div>
          <button onclick="closeShopModal()" style="margin-top: 20px">
            Salir de la Tienda
          </button>
        </div>
      </div>
    </div>

    <!-- Modal para Secta -->
    <div class="modal" id="sectHallModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 id="sectHallModalTitle">Sal√≥n de la Secta del Viento Azure</h3>
        <div id="sectHallOptions">
          <p>
            Bienvenido, Disc√≠pulo <span id="sectHallPlayerRank">Externo</span>.
          </p>
          <p>Puntos de Contribuci√≥n: <span id="sectHallPlayerPCS">0</span></p>
          <hr />
          <h4>Tabl√≥n de Misiones</h4>
          <div
            id="sectHallAvailableMissions"
            style="
              max-height: 150px;
              overflow-y: auto;
              margin-bottom: 10px;
              border: 1px solid #444;
              padding: 5px;
            "
          >
            <p>Habla con el Gu√≠a Lin para nuevas asignaciones.</p>
          </div>
          <h4>Contribuciones a la Secta</h4>
          <div id="sectHallContributions" style="margin-bottom: 10px">
            <p>Visita al Administrador Yao para entregar recursos.</p>
          </div>
          <h4>Desaf√≠os de Rango</h4>
          <div id="sectHallRankChallenges" style="margin-bottom: 10px">
            <p id="sectHallChallengeStatus">
              Consulta con el Maestro de la Arena.
            </p>
          </div>
          <h4>Tienda de la Secta</h4>
          <button onclick="openSectShop()">Visitar Dep√≥sito de la Secta</button>
          <hr />
        </div>
        <button
          onclick="closeSectHallModal()"
          style="display: block; margin: 20px auto 0"
        >
          Salir del Sal√≥n
        </button>
      </div>
    </div>

    <!-- Modal gen√©rico para confirmaciones (S√≠/No) -->
    <div class="modal" id="confirmationModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="confirmationModalTitle">Confirmar Acci√≥n</h3>
        <p id="confirmationModalText" style="margin: 15px 0; line-height: 1.5">
          ¬øEst√°s seguro?
        </p>
        <div
          style="display: flex; justify-content: space-around; margin-top: 20px"
        >
          <button id="confirmBtn" style="background-color: #4caf50">
            Confirmar
          </button>
          <button
            id="cancelBtn"
            onclick="closeConfirmationModal()"
            style="background-color: #f44336"
          >
            Cancelar
          </button>
        </div>
      </div>
    </div>

    <!-- Modal para Misiones -->
    <div class="modal" id="missionsModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">Diario de Misiones</h3>
        <div
          id="missionsContainer"
          style="
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
          "
        ></div>
        <button
          onclick="closeMissionsModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Modal para Revisi√≥n de Batalla -->
    <div class="modal" id="battleReviewModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">Resumen del Combate</h3>
        <div
          id="battleReviewLog"
          style="
            margin-top: 15px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.5;
          "
        ></div>
        <button
          onclick="closeBattleReviewModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Modal para Selecci√≥n de Cultivo -->
    <div class="modal" id="cultivationChoiceModal">
      <div class="modal-content" style="max-width: 500px; text-align: left">
        <h3>¬øQu√© deseas cultivar?</h3>
        <div id="cultivationOptionsContainer">
          <button
            class="cultivation-option-btn"
            onclick="startCultivationMode('recovery')"
          >
            üßò Meditaci√≥n Restauradora
          </button>
          <hr />
          <h4>Cultivar T√©cnica:</h4>
          <div
            id="cultivableTechniquesList"
            style="max-height: 200px; overflow-y: auto"
          ></div>
        </div>
        <button
          onclick="closeCultivationChoiceModal()"
          style="margin-top: 20px"
        >
          Cancelar
        </button>
      </div>
    </div>

    <!-- Modal gen√©rico para interacciones y notificaciones -->
    <div class="modal" id="interactionModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="modalTitle">T√≠tulo del Modal</h3>
        <p
          id="modalText"
          style="margin-top: 15px; margin-bottom: 20px; line-height: 1.5"
        >
          Texto.
        </p>
        <button onclick="closeModal()" class="close-modal-btn">Cerrar</button>
      </div>
    </div>
    <!-- Modal para Gesti√≥n de T√©cnicas -->
    <div class="modal" id="manageTechniquesModal">
      <div class="modal-content" style="max-width: 800px; text-align: left;">
          <h3 style="text-align: center;">Gestionar T√©cnicas de Combate</h3>
          <div id="technique-management-container" style="display: flex; gap: 20px; margin-top: 20px;">
              
              <!-- Columna de T√©cnicas Equipadas -->
              <div id="equipped-techniques-panel" style="flex: 1; border-right: 1px solid #555; padding-right: 20px;">
                  <h4>Equipadas (3 m√°x.)</h4>
                  <div id="equipped-techniques-list">
                      <!-- Los slots equipados se generar√°n aqu√≠ -->
                  </div>
              </div>

              <!-- Columna de T√©cnicas Aprendidas (disponibles para equipar) -->
              <div id="available-techniques-panel" style="flex: 2;">
                  <h4>T√©cnicas Aprendidas</h4>
                  <div id="available-techniques-list" style="max-height: 400px; overflow-y: auto;">
                      <!-- La lista de t√©cnicas disponibles se generar√° aqu√≠ -->
                  </div>
              </div>

          </div>
          <button onclick="closeManageTechniquesModal()" style="display: block; margin: 20px auto 0;">Cerrar</button>
      </div>
  </div>
    <!-- Modal para T√©cnicas -->
    <div class="modal" id="techniqueModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">T√©cnicas Aprendidas</h3>
        <div
          id="learnedTechniquesContainer"
          style="
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
          "
        ></div>
        <button onclick="openManageTechniquesModal()" style="display: block; margin: 20px auto 10px; background-color: #3a7c6a;">
          ‚öîÔ∏è Gestionar T√©cnicas de Combate
      </button>
        <button
          onclick="closeTechniqueModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Modal para Recompensa de Ascenso de Rango -->
    <div class="modal" id="rankUpRewardModal">
      <div class="modal-content" style="max-width: 550px; text-align: left">
        <h3 id="rankUpRewardTitle">Recompensa por Ascenso</h3>
        <p>
          Como reconocimiento a tu progreso, la secta te otorga un manual de
          t√©cnica. Elige sabiamente, pues este conocimiento definir√° tu camino.
        </p>
        <div id="rankUpRewardOptionsContainer" style="margin-top: 15px"></div>
        <button onclick="closeRankUpRewardModal()" style="margin-top: 20px">
          Decidir√© m√°s tarde
        </button>
      </div>
    </div>

    <!-- Modal para Teletransporte -->
    <div class="modal" id="teleportModal">
      <div class="modal-content" style="max-width: 500px; text-align: left">
        <h3 id="teleportModalTitle">Red de Matrices Espirituales</h3>
        <p>Selecciona un destino sintonizado:</p>
        <div id="teleportOptionsContainer" style="margin-top: 15px"></div>
        <button onclick="closeTeleportModal()" style="margin-top: 20px">
          Cancelar
        </button>
      </div>
    </div>

    <!-- ======================================================================= -->
    <!-- 4. BARRAS DE NAVEGACI√ìN SUPERPUESTAS -->
    <!-- Tambi√©n van fuera para garantizar su posici√≥n fija y renderizado n√≠tido. -->
    <!-- ======================================================================= -->

    <nav class="top-nav-bar" id="topNavBar">
      <button id="navBtnCharacter" class="nav-button">
        <div class="nav-icon">üë§</div>
        <span class="nav-text">Personaje</span>
      </button>
      <button id="navBtnMissions" class="nav-button">
        <div class="nav-icon">üìñ</div>
        <span class="nav-text">Misiones</span>
      </button>
      <button id="navBtnInventory" class="nav-button">
        <div class="nav-icon">üéí</div>
        <span class="nav-text">Inventario</span>
      </button>
      <button id="navBtnCultivate" class="nav-button">
        <div class="nav-icon">üßò</div>
        <span class="nav-text">Cultivar</span>
      </button>
      <button id="navBtnTechniques" class="nav-button">
        <div class="nav-icon">üìú</div>
        <span class="nav-text">T√©cnicas</span>
      </button>
      <button id="navBtnMenu" class="nav-button">
        <div class="nav-icon">‚öôÔ∏è</div>
        <span class="nav-text">Men√∫</span>
      </button>
    </nav>
    <!-- ================================================================= -->
    <script>
      let lastSuccessfulMoveTime = 0;
      const PLAYER_MOVE_COOLDOWN = 250; // <-- ¬°ESTE ES EL N√öMERO QUE AJUSTAR√ÅS! (en milisegundos)
      let playerMovementKeysDown = {
        // Para rastrear qu√© teclas de movimiento est√°n presionadas
        up: false,
        down: false,
        left: false,
        right: false,
      };
      const topNavBar = document.getElementById("topNavBar");
      const navBtnInventory = document.getElementById("navBtnInventory");
      console.log("Bot√≥n de Inventario (navBtnInventory):", navBtnInventory);
      const navBtnCharacter = document.getElementById("navBtnCharacter");
      const navBtnCultivate = document.getElementById("navBtnCultivate");
      const navBtnTechniques = document.getElementById("navBtnTechniques");
      const navBtnMenu = document.getElementById("navBtnMenu");
      let movePlayerCallCount = 0;
      // --- ESTADO DEL JUEGO ---
      let gameState = {
        /* ... (tu gameState existente sin cambios) ... */
      };
      // Estado del juego y datos principales
      gameState = {
        player: {
          x: 11,
          y: 15,
          level: 1,
          baseMaxHp: 100,
          baseMaxMana: 50,
          baseAttack: 15,
          baseDefense: 5,
          hp: 100,
          maxHp: 100,
          mana: 50,
          maxMana: 50,
          attack: 15,
          defense: 5,
          exp: 0,
          expToNext: 100,
          realm: "Mortal",
          quickSlots: [null, null, null, null, null], // 5 slots, inicialmente vac√≠os
          equippedTechniques: [null, null, null],
          isCultivating: false,
          cultivationMode: {
            type: null,
            targetId: null,
            startTime: 0,
          },
          cultivationStartTime: 0,
          qiPerSecondBase: 1,
          expPerSecondBase: 0.5,
          hpPerSecondBase: 1,
          learnedTechniques: {},
          activeRefiningTechniqueId: null,
          canUseQiConversion: false,
          isQiConversionActive: false,
          worldState: {
            defeatedBosses: {},
            currentBossToSpawn: "boss_dem",
            defeatedFixedEntities: {},
            storyFlags: {
              metAncianaSu: false,
              knowsAboutCalamity: false,
              knowsAboutSoberano: false,
              knowsFullTruth: false,
            },
          },
          secta: {
            nombre: "Secta del Viento Azure",
            rango: "Disc√≠pulo Externo",
            puntosContribucion: 0,
            misionesActivas: [],
            misionesCompletadas: {},
            rivalesDerrotadosClave: {},
          },
          // ---- PROPIEDADES DE ANIMACI√ìN DEL SPRITE - ASEG√öRATE QUE EST√âN AQU√ç Y CORRECTAS ----
          spriteSheetUrl: "img/personaje_cultivador_spritesheet.png",
          frameWidth: 64, // Ancho de un solo frame del sprite
          frameHeight: 64, // Alto de un solo frame del sprite
          directionRowMap: {
            // Mapeo de direcci√≥n a la fila Y en la hoja de sprites (0-indexed)
            down: 0, // Fila 0 para mirar/caminar hacia abajo
            left: 1, // Fila 1 para mirar/caminar hacia la izquierda
            right: 2, // Fila 2 para mirar/caminar hacia la derecha
            up: 3, // Fila 3 para mirar/caminar hacia arriba
          },
          animationFrames: 4, // N√∫mero de frames por direcci√≥n en la hoja
          currentFrame: 0, // Frame actual de la animaci√≥n (0 a animationFrames - 1)
          currentDirection: "down", // Direcci√≥n inicial: 'up', 'down', 'left', 'right'
          currentZoneName: null,
          isMoving: false,
          unlockedTeleporters: {
            tp_sect_hub: true, // El teletransportador de la secta empieza activado
          },
          animationTimer: null, // Para el intervalo de la animaci√≥n de caminar
          idleTimeout: null, // Para volver al estado idle despu√©s de moverse
          animationSpeed: 150, // Milisegundos entre frames de animaci√≥n
          // ---- FIN PROPIEDADES DE ANIMACI√ìN ----
          // NUEVO: Para animaci√≥n de sprites
          sprites: {
            idle: "img/personaje_cultivador_idle.png", // O 'img/personaje_cultivador_down.png' si es tu frontal
            up: "img/personaje_cultivador_up.png",
            down: "img/personaje_cultivador_down.png",
            left: "img/personaje_cultivador_left.png",
            right: "img/personaje_cultivador_right.png",
          },
          currentSpriteKey: "idle", // 'idle', 'up', 'down', 'left', 'right'
          movementAnimationTimeout: null,
          //BUFF
          defenseBoostTurns: 0,
          defenseBoostAmount: 0,
          abilityCooldowns: {},
          // ===  DEBUFFS ===
          defenseReductionTurns: 0,
          defenseReductionAmount: 0,
          attackReductionTurns: 0,
          attackReductionAmount: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          burningTurns: 0,
          burnDamage: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          stunnedTurns: 0,
          manaDrainTurns: 0,
          manaDrainAmount: 0,
          // ===================================
          dodgeNextAttack: false,
          healingRainTurns: 0,

          defenseBoostTurns: 0,
          defenseBoostAmount: 0,
          dodgeNextAttack: false,
          healingRainTurns: 0,
          healingRainAmount: 0,
          // Para Ritual de Sangre
          bloodRitualTurns: 0,
          bloodRitualAttackBoost: 0,
          magicShieldValue: 0, // Valor actual del escudo de absorci√≥n
          magicShieldTurns: 0,

          activeChanneledAbility: {
            // Para habilidades con coste por turno
            id: null,
            hp: 0, // "Vida" de la habilidad (para los grilletes)
          },
          tempDefenseBoostTurns: 0,
          tempDefenseBoostAmount: 0,
          // Nuevos estados para t√©cnicas de alto nivel
          isImmuneToStatus: false, // Inmunidad a quemaduras, veneno, stun, etc.
          passiveHpRegen: 0, // Cantidad de HP a regenerar por segundo pasivamente
          reviveChance: 0, // Probabilidad de resucitar al morir
          deathSaveChance: 0, // Probabilidad de sobrevivir con 1 HP
          damageToHealingTurns: 0, // Turnos para convertir da√±o en curaci√≥n
          intangibleTurns: 0, // Turnos de ser intangible (inmune a da√±o directo)
          canRevive: false, // Flag activado por Llama del F√©nix
         
          immuneTurns: 0,
          silencedTurns: 0, // Turnos en que no puede usar habilidades especiales
          sealedTurns: 0,   // Turnos en que no puede realizar ninguna acci√≥n
        },
        cultivationInterval: null,
        inventory: {
          "Piedras Espirituales": 0,
          "Hierbas Medicinales": 0,
          "Cristales de Qi": 0,
        },
        map: {
          width: 600, // M√°s peque√±o para pruebas iniciales
          height: 600,
          defaultTerrain: "GRASSLAND",
          terrainZones: [
            //ZONAS
            //L√çMITES DE MAPA
            // ... otras zonas (monta√±as, ruinas, agua sin spawns de monstruos terrestres)

            {
              x1: 91,
              y1: 28,
              x2: 110,
              y2: 29,
              type: "SWAMP",
              name: "Camino a Tierra salvaje",
              decorations: [
          
              ],
           
            },
            {
              x1: 2,
              y1: 9,
              x2: 600,
              y2: 9,
              type: "MOUNTAIN_FRENTE",
              name: "l√≠mite norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 0,
              y1: 0,
              x2: 600,
              y2: 8,
              type: "MOUNTAIN_SUP",
              name: "Monta√±as Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: -20,
              y1: 0,
              x2: 0,
              y2: 600,
              type: "MOUNTAIN_SUP",
              name: "Monta√±as del Oeste",
            }, // Sin spawnSettings = no spawns
            {
              x1: 92,
              y1: 0,
              x2: 110,
              y2: 27,
              type: "MOUNTAIN_SUP",
              name: "Limite mapa este con desfiladero",
            }, 
            {//Limite con Valle del Drag√≥n
              x1: 145,
              y1: 0,
              x2: 145,
              y2: 600,
              type: "MOUNTAIN_SUP",
              name: "Limite mapa este con desfiladero",
            }, // Sin spawnSettings = no spawns
            {
              x1: 92,
              y1: 30,
              x2: 110,
              y2: 600,
              type: "MOUNTAIN_SUP",
              name: "Limite mapa este con desfiladero",
            }, // Sin spawnSettings = no spawns
            {
              x1: 91,
              y1: 9,
              x2: 91,
              y2: 9,
              type: "MOUNTAIN_SUP_DER",
              name: "Monta√±as del Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 9,
              x2: 1,
              y2: 9,
              type: "MOUNTAIN_SUP_IZQ",
              name: "Monta√±as del Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 40,
              x2: 1,
              y2: 40,
              type: "MOUNTAIN_INF_IZQ",
              name: "Monta√±as del Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 69,
              x2: 1,
              y2: 69,
              type: "MOUNTAIN_INF_IZQ",
              name: "borde desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 2,
              y1: 40,
              x2: 23,
              y2: 40,
              type: "MOUNTAIN_ABAJO_SUP",
              name: "frontera pradera-desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 26,
              y1: 40,
              x2: 89,
              y2: 40,
              type: "MOUNTAIN_ABAJO_SUP",
              name: "frontera pradera-desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 70,
              x2: 89,
              y2: 70,
              type: "MOUNTAIN_ABAJO_SUP_DES",
              name: "l√≠mite inferior desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 71,
              x2: 89,
              y2: 90,
              type: "MOUNTAIN_SUP",
              name: "l√≠mite inferior desierto",
            }, // Sin spawnSettings = no spawns

           

            {
              x1: 91,
              y1: 10,
              x2: 91,
              y2: 27,
              type: "MOUNTAIN_DER",
              name: "L√≠mite este con desfiladero",
            }, // Sin spawnSettings = no spawns
            {
              x1: 144,
              y1: 10,
              x2: 144,
              y2: 600,
              type: "MOUNTAIN_DER",
              name: "L√≠mite este con Valle del Drag√≥n",
            }, // Sin spawnSettings = no spawns
            {
              x1: 91,
              y1: 30,
              x2: 91,
              y2: 600,
              type: "MOUNTAIN_DER",
              name: "L√≠mite este",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 10,
              x2: 1,
              y2: 39,
              type: "MOUNTAIN_IZQ",
              name: "l√≠mite oeste pradera",
            }, // Sin spawnSettings = no spawns
            {
              x1: 146,
              y1: 10,
              x2: 146,
              y2: 600,
              type: "MOUNTAIN_IZQ",
              name: "l√≠mite este con Valle del Drag√≥n",
            }, // Sin spawnSettings = no spawns
            // ...FIN DE LOS LIMITES

            // ARENA DE LA SECTA
            {
              x1: 4,
              y1: 12,
              x2: 8,
              y2: 16, // Ejemplo de coordenadas (ajusta seg√∫n tu mapa)
              type: "ARENA", // Puedes usar 'DESERT' o crear un G_TERRAIN_TYPES.ARENA
              name: "Arena de la Secta",
              // No necesita spawnSettings por ahora, a menos que quieras peque√±os mobs decorativos all√≠.
            },

            ///ZONA SEGURA DE LA SECTA

            {
              x1: 2,
              y1: 10,
              x2: 29,
              y2: 24,

              type: "GRASSLAND",
              name: "Terreno de la Secta (Seguro)",
            },
            {
              x1: 2,
              y1: 25,
              x2: 29,
              y2: 39,

              type: "GRASSLAND",
              name: "Praderas de la Secta",
              spawnSettings: {
                targetEntities: [
                  // Lista de objetivos de spawn para esta zona
                  {
                    entityTypeId: "monster_secta_debil",
                    count: 10,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster", count: 10, currentCount: 0 },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "cristal_qi", count: 3, currentCount: 0 },
                  {
                    entityTypeId: "cultivator_rival_low",
                    count: 10,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0, // Cuando llegue a 0, puede reaparecer
                respawnCooldown: 300, // Segundos para reaparecer despu√©s de vaciarse o parcialmente
                lastSpawnCheck: 0, // Timestamp del √∫ltimo intento de spawn
              },
            },
            // Bosque Esmeralda Profundo
            {
              x1: 54,
              y1: 10,
              x2: 65,
              y2: 39,
              type: "GRASSLAND", //
              name: "Bosque Esmeralda Profundo",
              decorations: [
                { entityTypeId: "deco_arbol_grande", density: 0.1 }, // 10% de las celdas tendr√°n un √°rbol grande
                { entityTypeId: "deco_arbol_normal", density: 0.3 }, // 30% tendr√°n un √°rbol normal
                { entityTypeId: "deco_roca_musgosa", density: 0.05 }, // 5% tendr√°n una roca
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "osa_mayor_esmeralda",
                    count: 2,
                    currentCount: 0,
                  }, // Un enemigo m√°s raro y fuerte
                  { entityTypeId: "treant_anciano", count: 1, currentCount: 0 }, // Un mini-jefe de zon
                ],
                respawnTimer: 0,
                respawnCooldown: 450,
                lastSpawnCheck: 0,
              },
            },
            // Bosque Esmeralda
            {
              x1: 30,
              y1: 10,
              x2: 59,
              y2: 39,
              type: "GRASSLAND", // <-- El terreno base ahora es hierba
              name: "Bosque Esmeralda",
              decorations: [
                { entityTypeId: "deco_arbol_grande", density: 0.1 }, // 10% de las celdas tendr√°n un √°rbol grande
                { entityTypeId: "deco_arbol_normal", density: 0.3 }, // 30% tendr√°n un √°rbol normal
                { entityTypeId: "deco_roca_musgosa", density: 0.05 }, // 5% tendr√°n una roca
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_bosque_lobo",
                    count: 8,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_bosque_arana",
                    count: 5,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster_alpha", count: 5, currentCount: 0 },
                ],
                respawnTimer: 0,
                respawnCooldown: 450,
                lastSpawnCheck: 0,
              },
            },
            // Desierto Abrasador profundo
            {
              x1: 69,
              y1: 50,
              x2: 90,
              y2: 69,
              type: "DESERT",
              name: "Desierto Abrasador profundo",
              decorations: [
                { entityTypeId: "deco_desierto", density: 0.05 }, // 5% de las celdas tendr√°n un √°rbol grande
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "djinn_arenas",
                    count: 20,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "gusano_dunas_colosal",
                    count: 20,
                    currentCount: 0,
                    isElite: true,
                  }, // Golem como elite
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },
            // Desierto Abrasador
            {
              x1: 1,
              y1: 41,
              x2: 90,
              y2: 69,
              type: "DESERT",
              name: "Desierto Abrasador",
              decorations: [
                { entityTypeId: "deco_desierto", density: 0.05 }, // 5% de las celdas tendr√°n un √°rbol grande
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_desierto_escorpion",
                    count: 70,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_desierto_golem_arena",
                    count: 20,
                    currentCount: 0,
                    isElite: true,
                  }, // Golem como elite
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },
            // RUINAS
            {
              x1: 500,
              y1: 500,
              x2: 550,
              y2: 550,
              type: "RUINS",
              name: "Coraz√≥n de las Ruinas Olvidadas",
              decorations: [
                { entityTypeId: "deco_ruina_pilar", density: 0.02 },
              ],
              isIsolated: true, // Marca esta zona como un "mapa" separado
              ambientColor: "#1a1a1a", // Color del "vac√≠o" alrededor de la zona
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "esqueleto_podrido",
                    count: 25,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "boss_ancient_golem",
                    count: 25,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // Ci√©naga Sombr√≠a
            {
              x1: 66,
              y1: 10,
              x2: 90,
              y2: 39,
              type: "SWAMP",
              name: "Ci√©naga Sombr√≠a",
              decorations: [
                // <-- NUEVA PROPIEDAD
                { entityTypeId: "deco_arbol_pantano", density: 0.1 }, // 10% de las celdas tendr√°n un √°rbol grande
                { entityTypeId: "deco_agua_estancada", density: 0.05 },
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_cienaga_serpiente",
                    count: 10,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "espectro_pantano",
                    count: 4,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "cultivador_renegado",
                    count: 5,
                    currentCount: 0,
                  },
                  
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // ===============================================
            // === ZONAS DE ALTO NIVEL (NUEVAS) ===
            // ===============================================

            // Zona para Misiones de Di√°cono
            {
              x1: 111,
              y1: 10,
              x2: 143,
              y2: 50,
              type: "GRASSLAND", // Usaremos un terreno rocoso y hostil
              name: "Desfiladero de los Lamentos",
              isIsolated: false, // Es como un mapa separado
              ambientColor: "#3c2f2f", // Un tono rojizo oscuro
              decorations: [
               
             
                { entityTypeId: "deco_monta√±a", density: 0.3 }, // 30% tendr√°n un √°rbol normal
                { entityTypeId: "deco_monta√±a_large", density: 0.05 },
    
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "cultivador_secta_rival",
                    count: 15,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "murcielago_cristal_sangriento",
                    count: 10,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "bandido_desfiladero",
                    count: 20,
                    currentCount: 0,
                  },
                  
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },

            // Zona para Misiones de Anciano
            {
              x1: 147,
              y1: 10,
              x2: 225,
              y2: 70,
              type: "SWAMP", // Un terreno antiguo y corrupto
              name: "Valle del Drag√≥n Ca√≠do",
              isIsolated: true,
              ambientColor: "#2a3b2a", // Un verde enfermizo
              decorations: [
                { entityTypeId: "deco_arbol_pantano", density: 0.2 },
                { entityTypeId: "deco_huesos_gigantes", density: 0.05 }, // Necesitaremos definir esto
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "draco_hueso_antiguo",
                    count: 50,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "espectro_tifonico",
                    count: 80,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "draco_hueso_antiguo_boss",
                    count: 1,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 900,
                lastSpawnCheck: 0,
              },
            },

            // Zona para Misiones de Gran Anciano
            {
              x1: 400,
              y1: 10,
              x2: 450,
              y2: 60,
              type: "RUINS", // Terreno de otro mundo
              name: "La Fisura Demon√≠aca",
              isIsolated: true,
              ambientColor: "#4d194d", // Un p√∫rpura corrupto
              decorations: [
                { entityTypeId: "deco_cristal_corrupto", density: 0.15 }, // Necesitaremos definir esto
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "demonio_de_la_fisura",
                    count: 20,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "guardian_celestial_caido",
                    count: 5,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 1200,
                lastSpawnCheck: 0,
              },
            },

            ///=========  FIN ZONAS ==========
          ],
          terrainGrid: null,
          entities: [],
        },
        battle: {
          active: false,
          enemy: {
            frozenTurns: 0,
            stunnedTurns: 0,
            burningTurns: 0,
            burnDamage: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            defenseReductionTurns: 0,
            defenseReductionAmount: 0,
            attackReductionTurns: 0,
            attackReductionAmount: 0,

            // --- A√ëADE ESTAS L√çNEAS AQU√ç ---
            rootedTurns: 0, // Turnos que permanecer√° atrapado
            rootDamage: 0, // Da√±o que sufrir√° cada turno mientras est√© atrapado
            // --- FIN DE LAS L√çNEAS A A√ëADIR ---

            // Nuevos estados para efectos de alto nivel
            silencedTurns: 0,
            sealedTurns: 0,
            reflectDamageTurns: 0, // Para el aura de espinas
            reflectDamageMultiplier: 0,
            stunChance:0,
          },

          playerTurn: true,
        },
        gameTime: 0, // Un simple contador de segundos del juego para los temporizadores
        lastGameTimeUpdate: Date.now(),
        activeCombatAbilities: [],
      }; //FIN GAMESTATE

      let battleLogHistory = [];

      // --- CONSTANTES Y DATOS DEL JUEGO --- (sin cambios, deben estar aqu√≠)
      let G_TILE_SIZE = 100; // Valor por defecto para escritorio
      const G_PLAYER_DISCOVERY_RANGE = 3;
      // --- VARIABLES GLOBALES ADICIONALES PARA CONTROL UI M√ìVIL ---
      let mapControlsManuallyHidden = false;
      let currentTileSize = G_TILE_SIZE; // Usaremos este para los c√°lculos de renderizado
      let recoveryProgress = 0;
      let recoveryDirection = 1; // 1 para aumentar, -1 para disminuir
      const RECOVERY_CYCLE_DURATION = 2;

      const G_COMBAT_ENTITY_TYPES = [
        "monster",
        "esqueleto_podrido",
        "bandido_desfiladero",
        "monster_desierto_escorpion",
        "monster_secta_debil",
        "monster_alpha",
        "cultivator_rival_low",
        "cultivator_adept_hostile",
        "boss_dem",
        "boss_ancient_golem",
        "monster_cienaga_serpiente",
        "monster_bosque_lobo",
        "monster_bosque_arana",
        "monster_desierto_golem_arena",
        "jabali_colmilludo_alfa",
        "jabali_alfa_1",
        "jabali_alfa_2",
        "jabali_alfa_3",
        "jabali_alfa_4",
        "jabali_alfa_5",
        "jabali_alfa_6",
        "jabali_alfa_7",
        "jabali_alfa_8",
        "jabali_alfa_9",
        "jabali_alfa_10",
        "jabali_alfa_11",
        "jabali_alfa_12",
        "osa_mayor_esmeralda",
        "treant_anciano",
        "basilisco_cienaga",
        "espectro_pantano",
        "djinn_arenas",
        "gusano_dunas_colosal",
        "guardian_terracota",
        "murcielago_cristal_sangriento",
        "mercenario_acorazado",
        "bandido_desfiladero",
        "cultivador_secta_rival",
        "diacono_renegado_jin",
        "cultivador_renegado",
        "draco_hueso_antiguo",
        "espectro_tifonico",
        "demonio_de_la_fisura",
        "guardian_celestial_caido",
        "draco_hueso_antiguo_boss",
      ];
      const G_MAX_MAP_ENTITIES = 30;
      const G_RESPAWN_THRESHOLD = 15;
      const G_SAFE_RESPAWN_X = 10;
      const G_SAFE_RESPAWN_Y = 10;
      const G_SAFE_RESPAWN_SEARCH_RADIUS = 3;
      // TELETRANSPORTE
      const TELEPORTER_DATA = {
        tp_sect_hub: {
          name: "Matriz Central de la Secta",
          x: 15, // <-- Coordenadas al lado de la secta
          y: 11,
          isHub: true, // Marca este como el punto de partida principal
        },
        tp_forest_shrine: {
          name: "Santuario del Bosque Esmeralda",
          x: 45, // <-- Coordenadas en medio del bosque
          y: 25,
          isHub: false,
        },
        tp_desert_oasis: {
          name: "Oasis del Desierto Abrasador",
          x: 40, // <-- Coordenadas en una zona segura del desierto
          y: 60,
          isHub: false,
        },
        tp_swamp_ruin: {
          name: "Ruina Hundida de la Ci√©naga",
          x: 75, // <-- Coordenadas en la ci√©naga
          y: 30,
          isHub: false,
        },
        tp_desfiladero: {
          name: "Desfiladero",
          x: 135, // 
          y: 30,
          isHub: false,
        },
        tp_dragon_valley: {
        name: "Coraz√≥n del Valle del Drag√≥n",
        x: 150, // Coordenada segura DENTRO del valle
        y: 15,  // Puedes ajustar esto a donde quieras que aparezca el jugador
        isHub: false,
    },
        // Puedes a√±adir m√°s teletransportadores aqu√≠ en el futuro
      };
      const G_TERRAIN_TYPES = {
        VOID: {
          textureUrl: "img/mont_sup.png", // ¬°Aseg√∫rate de que esta imagen exista!
          name: "Vac√≠o",
        },
        ARENA: {
          symbol: "üèüÔ∏è",
          textureUrl: "img/b_arena.png",
          color: "#D2B48C",
          name: "Arena",
        },

        GRASSLAND: {
          symbol: "üü©",
          textureUrl: "img/grassland.png",
          color: "#34A853",
          name: "Pradera",
        }, // Verde para pastizales
        FOREST: {
          symbol: "üå≤",
          textureUrl: "img/grassland.png",
          color: "#1E824C",
          name: "Bosque",
        }, // Verde oscuro para bosques
        MOUNTAIN_FRENTE: {
          symbol: "‚õ∞Ô∏è",
          textureUrl: "img/mont_frente.png",
          color: "#A9A9A9",
          name: "Monta√±a",
        }, // Gris para monta√±as
        MOUNTAIN_SUP: {
          symbol: "‚õ∞Ô∏è",
          textureUrl: "img/mont_sup.png",
          color: "#A9A9A9",
          name: "Monta√±a",
        },
        MOUNTAIN_SUP_DER: {
          symbol: "‚õ∞Ô∏è",
          textureUrl: "img/mont_sup_der.png",
          color: "#A9A9A9",
          name: "Monta√±a",
        },
        MOUNTAIN_SUP_IZQ: {
          symbol: "‚õ∞Ô∏è",
          textureUrl: "img/mont_sup_izq.png",
          color: "#A9A9A9",
          name: "Monta√±a",
        },
        MOUNTAIN_DER: {
          symbol: "‚õ∞Ô∏è",
          textureUrl: "img/mont_der.png",
          color: "#A9A9A9",
          name: "Monta√±a",
        },
        MOUNTAIN_IZQ: {
          symbol: "‚õ∞Ô∏è",
          textureUrl: "img/mont_izq.png",
          color: "#A9A9A9",
          name: "Monta√±a",
        },
        MOUNTAIN_INF_IZQ: {
          symbol: "‚õ∞Ô∏è",
          textureUrl: "img/mont_int_inf_izq.png",
          color: "#A9A9A9",
          name: "Monta√±a",
        },
        MOUNTAIN_ABAJO_SUP: {
          symbol: "‚õ∞Ô∏è",
          textureUrl: "img/mont_abajo_sup.png",
          color: "#A9A9A9",
          name: "Monta√±a",
        },
        MOUNTAIN_ABAJO_SUP_DES: {
          symbol: "‚õ∞Ô∏è",
          textureUrl: "img/mont_abajo_sup_des.png",
          color: "#A9A9A9",
          name: "Monta√±a",
        },
        WATER: {
          symbol: "üü¶",
          color: "#4A86E8",
          name: "Agua",
        }, // Azul para agua (intransitable)
        RUINS: {
          symbol: "üèõÔ∏è",
          textureUrl: "img/suelo_ruinas.png",
          color: "#706050",
          name: "Ruinas",
        }, // Marr√≥n/Gris para ruinas
        TERRENO_MONT: {
          symbol: "üèõÔ∏è",
          textureUrl: "img/terreno_mont.png",
          color: "#706050",
          name: "Ruinas",
        },
        DESERT: {
          symbol: "üü®",
          textureUrl: "img/arena.png",
          color: "#F9E79F",
          name: "Desierto",
        }, // Amarillo claro para desierto
        SWAMP: {
          symbol: "üü™",
          textureUrl: "img/pantano.png",
          color: "#5D3A9A",
          name: "Pantano",
        }, // P√∫rpura/Verde oscuro para pantano

        // A√±ade m√°s seg√∫n necesites
      };

      const PLAYER_SPRITE_FRAME_WIDTH = 64; // <--- ¬°AJUSTA ESTO AL ANCHO DE UN FRAME DE TU SPRITE!
      const PLAYER_SPRITE_FRAME_HEIGHT = 64; // <--- ¬°AJUSTA ESTO AL ALTO DE UN FRAME DE TU SPRITE!
      const PLAYER_ANIMATION_SPEED = 150; // Milisegundos entre frames de caminata (ajusta a gusto)
      const PLAYER_WALK_CYCLE = [0, 1, 0, 2]; // Los frames de columna a ciclar para caminar.
      // Si tu animaci√≥n es 0-1-2-1, ser√≠a [0,1,2,1]
      // Si es 0-1-0-2 ser√≠a [0,1,0,2] (para un efecto de pie y luego paso)
      // Para tu sprite de 4 frames por direcci√≥n: [0, 1, 2, 3] y el frame 0 es el de "quieto"
      // o puedes usar [1,2,3,0] si el 0 es un frame de paso
      // Una animaci√≥n com√∫n es "quieto" -> paso1 -> "quieto" -> paso2
      // O para ciclo continuo: paso1 -> paso2 -> paso3 -> paso4 -> paso1 ...
      // Para el sprite que mostraste, parece ser:
      // Frame 0: Quieto
      // Frame 1: Paso A
      // Frame 2: Quieto (o un frame intermedio)
      // Frame 3: Paso B
      // Entonces un ciclo podr√≠a ser [0, 1, 0, 3] o [1,0,3,0] para animaci√≥n mientras se mueve
      // O si todos son frames de paso: [0,1,2,3]
      // VAMOS A USAR UN CICLO [1,0,3,0] (asumiendo frame 0 es el base/quieto y 1,3 son pasos)
      // Si el frame 0 es un paso y el personaje se "desliza" al estar quieto, cambia esto.
      // Definir las posiciones Y del sprite sheet para cada direcci√≥n
      const PLAYER_SPRITE_DIRECTIONS_Y = {
        down: 0 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 1 (√≠ndice 0) para caminar hacia abajo
        left: 1 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 2 (√≠ndice 1) para caminar hacia la izquierda
        right: 2 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 3 (√≠ndice 2) para caminar hacia la derecha
        up: 3 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 4 (√≠ndice 3) para caminar hacia arriba
      };
      // Podr√≠amos a√±adir una propiedad 'walkable' a cada tipo de terreno
      G_TERRAIN_TYPES.MOUNTAIN_FRENTE.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_SUP.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_SUP_DER.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_DER.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_IZQ.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP_DES.walkable = false;
      G_TERRAIN_TYPES.WATER.walkable = false;
      // Por defecto, asumimos que son transitables si no se especifica 'walkable: false'
      const G_BLOCKING_ENTITY_TYPES = [
        "shop",
        "secta_entrada_principal",
        "secta_entrada_principal_2",
        "secta_entrada_principal_3",
        "secta_entrada_principal_4",
        "npc_secta_guia",
        "npc_secta_admin",
        "npc_anciana_su",
        "npc_maestro_jian",
        "santuario_del_eco",
      ];
      //SECTA
      const SECTA_DATA = {
        nombre: "Secta del Viento Azure",
        rangos: [
          {
            nombre: "Disc√≠pulo Externo",
            pcsRequeridos: 0,
            beneficios: "Acceso b√°sico a la secta.",
          },
          {
            nombre: "Disc√≠pulo Interno", // GRADO 1
            pcsRequeridos: 50,
            desafioRivalId: "rival_interno_1",
            beneficios:
              "Acceso al Patio Interno, misiones de mayor nivel, +5% ganancia de Qi al cultivar en la secta.",
            techniqueChoice: [
              "sword_t1",
              "body_t1",
              "formation_t1",
              "fire_t1",
              "lightning_t1",
            ],
          },
          {
            nombre: "Disc√≠pulo Principal", // GRADO 2
            pcsRequeridos: 200,
            desafioRivalId: "rival_principal_1",
            beneficios:
              "Acceso a la Biblioteca de T√©cnicas (nuevas t√©cnicas), +10% ganancia de EXP en misiones de secta.",
            techniqueChoice: [
              "sword_t2",
              "body_t2",
              "formation_t2",
              "movement_t2",
              "fire_t2",
            ],
          },
          {
            nombre: "Di√°cono", // GRADO 3
            pcsRequeridos: 500,
            desafioRivalId: "guardian_diacono_1",
            beneficios:
              "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir peque√±os grupos de disc√≠pulos (mec√°nica futura).",
            techniqueChoice: [
              "sword_t3",
              "body_t3",
              "formation_t3",
              "lightning_t3",
              "movement_t3",
            ],
          },
          {
            nombre: "Anciano", // GRADO 4
            pcsRequeridos: 1500,
            desafioRivalId: "guardian_anciano_1",
            beneficios:
              "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir medianos grupos de disc√≠pulos (mec√°nica futura).",
            techniqueChoice: [
              "sword_t4",
              "body_t4",
              "fire_t4",
              "lightning_t4",
              "formation_t4",
              "movement_t4",
            ],
          },
          {
            nombre: "Gran Anciano", // GRADO 5
            pcsRequeridos: 2500,
            desafioRivalId: "guardian_gran_anciano_1",
            beneficios:
              "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir grandes grupos de disc√≠pulos (mec√°nica futura).",
            techniqueChoice: [
              "sword_t5",
              "body_t5",
              "fire_t5",
              "lightning_t5",
              "formation_t5",
              "movement_t5",
            ],
          },
          {
            nombre: "Maestro de Secta", // GRADO 6
            pcsRequeridos: 5000,
            desafioRivalId: "guardian_maestro_1",
            beneficios:
              "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir la secta completa (mec√°nica futura).",
            techniqueChoice: [
              "sword_t6",
              "body_t6",
              "fire_t6",
              "lightning_t6",
              "formation_t6",
              "movement_t6",
            ],
          },
          // === NUEVOS RANGOS A√ëADIDOS ===
          {
            nombre: "Patriarca", // GRADO 7
            pcsRequeridos: 10000,
            desafioRivalId: "guardian_patriarca_1", // Necesitar√≠as definir este rival
            beneficios:
              "Tu influencia trasciende la secta. Obtienes acceso a dominios secretos.",
            techniqueChoice: [
              "sword_t7",
              "body_t7",
              "fire_t7",
              "lightning_t7",
              "formation_t7",
              "movement_t7",
            ],
          },
          {
            nombre: "Soberano Inmortal", // GRADO 8
            pcsRequeridos: 25000,
            desafioRivalId: "guardian_soberano_1", // Necesitar√≠as definir este rival
            beneficios:
              "Tu nombre es leyenda. El mundo mortal ya no puede contenerte.",
            techniqueChoice: [
              "sword_t8",
              "body_t8",
              "fire_t8",
              "lightning_t8",
              "formation_t8",
              "movement_t8",
            ],
          },
          {
            nombre: "Soberano del Dao", // GRADO 9
            pcsRequeridos: 50000,
            desafioRivalId: "guardian_dao_1", // Necesitar√≠as definir este rival
            beneficios:
              "Te has fusionado con el Gran Dao. Eres uno con la creaci√≥n.",
            techniqueChoice: ["sword_t9"], // Ejemplo con una sola t√©cnica definitiva
          },
        ],
        npcs: {
          guia_lin: {
            nombre: "Gu√≠a Lin",
            rol: "Maestro de Reclutas",
            dialogoInicial:
              "Bienvenido, joven aspirante... ¬øEst√°s listo para empezar? Compra Items con Piedras espirituales,aprende t√©cnicas, completa misiones y sube de rango en la secta",

            misionesOfrecidas: [
              "mision_recolectar_hierbas_1", // Aunque la entrega sea a Yao, Lin puede ofrecerla
              "mision_eliminar_demonios_1",
              "mision_lobos_bosque_1", // Nueva misi√≥n ofrecida por Lin
              "mision_cultivador_hostil_1", // Nueva misi√≥n ofrecida por Lin
              "mision_componentes_alquimia_1",
              "mision_cazar_bestia_especifica_1",
              "mision_recuperar_artefacto_1",
              // --- NUEVAS MISIONES ASIGNADAS ---
              // Rango: Disc√≠pulo Externo
              "mision_ext_1",
              "mision_ext_3",
              "mision_ext_4",
              // Rango: Disc√≠pulo Interno
              "mision_int_1",
              "mision_int_2",
              "mision_int_4",
              // Rango: Disc√≠pulo Principal
              "mision_prin_4",
              // Misiones de Rango Di√°cono
              "mision_diac_1",
              "mision_diac_3",
              "mision_diac_4",

              // Misiones de Rango Anciano
              "mision_anc_1",
              "mision_anc_3",
              "mision_anc_4",

              // Misiones de Rango Gran Anciano
              "mision_gran_anc_1",
              "mision_gran_anc_2",
              "mision_gran_anc_3",

              // Misi√≥n Final de Maestro de Secta
              "mision_maestro_1",
            ],
          },
          admin_yao: {
            nombre: "Administrador Yao",
            rol: "Intendente de la Secta",
            dialogoInicial:
              "Entrega recursos valiosos o completa encargos para ganar Puntos de Contribuci√≥n. Tambi√©n puedes adquirir algunos suministros aqu√≠.",
            aceptaRecursos: [
              "Hierbas Medicinales",
              "Cristales de Qi",
              "N√∫cleo de Bestia Menor",
            ], // ...etc.
            tiendaSectaId: "tienda_secta_basica",
            misionesOfrecidas: [
              "mision_escorpiones_desierto_1", // Nueva misi√≥n ofrecida por Yao
              // --- NUEVAS MISIONES ASIGNADAS ---
              // Rango: Disc√≠pulo Externo
              "mision_ext_2",
              // Rango: Disc√≠pulo Interno
              "mision_int_3",
              // Rango: Disc√≠pulo Principal
              "mision_prin_1",
              "mision_prin_2",
              "mision_prin_3",
              // Misiones de Rango Di√°cono
              "mision_diac_2",

              // Misiones de Rango Anciano
              "mision_anc_2",

              // Misiones de Rango Gran Anciano
              "mision_gran_anc_4",
              // ... a√±ade m√°s ID de misiones que Yao ofrezca
            ],
          },
          npc_anciana_su: {
            symbol: "üëµ",
            name: "Anciana Su, la Archivista",
            spriteUrl: "img/anciana_su.png", // Necesitar√°s una imagen para ella
            interaction: "talk_story_npc",
            npcId: "anciana_su",
            fixedLocation: { x: 18, y: 14 }, // Por ejemplo, en un edificio tipo biblioteca de la secta
            discovered: true,
          },
          npc_maestro_jian: {
            symbol: "üëë",
            name: "Maestro de Secta Jian",
            spriteUrl: "img/maestro_jian.png", // Necesitar√°s una imagen para √©l
            interaction: "talk_story_npc",
            npcId: "maestro_jian",
            fixedLocation: { x: 15, y: 18 }, // En la parte m√°s profunda del sal√≥n principal
            discovered: true,
          },
          santuario_del_eco: {
            symbol: "‚õ©Ô∏è",
            name: "Santuario del Eco",
            spriteUrl: "img/santuario_eco.png", // Necesitar√°s una imagen (puede ser un altar brillante)
            interaction: "interact_shrine",
            type: "story_shrine",
            fixedLocation: { x: 330, y: 15 }, // Oculto en el Valle del Drag√≥n Ca√≠do
            discovered: false, // El jugador debe descubrirlo
          },
        },
      };

      const MISIONES_DATA = {
        // === MISIONES: DISC√çPULO EXTERNO ===

        mision_ext_1: {
          titulo: "Control de Plagas en la Pradera",
          descripcion:
            "Unas Bestias Menores de Pradera se est√°n acercando demasiado a los terrenos de la secta. Demuestra tu val√≠a eliminando 5 de ellas.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_secta_debil",
            cantidad: 5,
            nombreDisplay: "Bestia Menor",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 30,
            exp: 50,
            items: { "Piedras Espirituales": 5 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Externo",
        },
        mision_ext_2: {
          titulo: "Suministro de Energ√≠a",
          descripcion:
            "El Administrador Yao necesita reponer las reservas de energ√≠a de la secta. Recolecta 3 Cristales de Qi y entr√©gaselos.",
          objetivo: {
            tipo: "entregar_item",
            item: "Cristales de Qi",
            cantidad: 3,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 40,
            exp: 60,
            items: { "Piedras Espirituales": 10 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Disc√≠pulo Externo",
        },
        mision_ext_3: {
          titulo: "Una Lecci√≥n de Humildad",
          descripcion:
            "Algunos cultivadores novatos se han vuelto arrogantes y est√°n causando problemas. El Gu√≠a Lin quiere que derrotes a 3 de ellos para que recuerden su lugar.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivator_rival_low",
            cantidad: 3,
            nombreDisplay: "Cultivador Novato Hostil",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 50,
            exp: 120,
            items: { "P√≠ldora de Recuperaci√≥n Menor": 1 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Externo",
        },
        mision_ext_4: {
          titulo: "Primera Incursi√≥n al Bosque",
          descripcion:
            "Los lobos del Bosque Esmeralda est√°n mostrando una agresividad inusual. Ad√©ntrate con cuidado y elimina 2 Lobos del Bosque para investigar.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_bosque_lobo",
            cantidad: 2,
            nombreDisplay: "Lobo del Bosque",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 60, exp: 150, items: { "Colmillo de Lobo": 1 } },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Externo",
          requisitoNivel: 3, // Un peque√±o requisito de nivel para guiar al jugador.
        },

        mision_cultivador_hostil_1: {
          titulo: "Rivalidad Temprana",
          descripcion:
            "Un grupo de cultivadores est√°n causando alboroto en la secta. El Gu√≠a Lin quiere que les des una lecci√≥n. Derr√≥talos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivator_rival_low",
            cantidad: 10,
            nombreDisplay: "Cultivador Novato Hostil",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 200,
            exp: 400,
            items: {
              "P√≠ldora de Recuperaci√≥n Menor": 1,
              "Piedras Espirituales": 12,
            },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 8,
        },
        // Aseg√∫rate de que las misiones que quieres que se entreguen a un NPC tengan `npcEntrega` en su `objetivo`.
        mision_componentes_alquimia_1: {
          titulo: "Medicina Urgente",
          descripcion:
            "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Ra√≠ces de Fuego Terrenal' para una p√≠ldora vital. Se dice que crecen en zonas con fluctuaciones elementales. Entr√©galas al Administrador Yao.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "Flor de Luna Escarchada", cantidad: 3 },
              { nombre: "Ra√≠z de Fuego Terrenal", cantidad: 2 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 250,
            items: {
              "P√≠ldora de Recuperaci√≥n Menor": 2,
              "Piedras Espirituales": 10,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Externo",
        },

        // === MISIONES: DISC√çPULO INTERNO ===
        // (Se desbloquean al alcanzar este rango)

        mision_int_1: {
          titulo: "La Plaga Ar√°cnida",
          descripcion:
            "Las Ara√±as Tejesombras est√°n infestando el Bosque Esmeralda, haciendo peligrosa la recolecci√≥n de hierbas. Extermina a 8 de ellas.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_bosque_arana",
            cantidad: 8,
            nombreDisplay: "Ara√±a Tejesombras",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 80, exp: 250, items: { "Seda de Ara√±a": 3 } },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Interno",
        },
        mision_int_2: {
          titulo: "Limpieza en la Ci√©naga",
          descripcion:
            "La Ci√©naga Sombr√≠a es un lugar peligroso. Para mantener a raya a sus habitantes, elimina 4 Serpientes de Ci√©naga.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_cienaga_serpiente",
            cantidad: 4,
            nombreDisplay: "Serpiente de Ci√©naga",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 100,
            exp: 300,
            items: { "Piedras Espirituales": 25 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Interno",
        },
        mision_int_3: {
          titulo: "La Petici√≥n del Herrero",
          descripcion:
            "El herrero de la secta necesita Quitina Resistente para forjar armaduras ligeras. Caza Escorpiones de las Dunas hasta obtener 3 unidades de Quitina y entr√©gaselas a Yao.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "monster_desierto_escorpion",
            itemPrueba: "Quitina Resistente",
            cantidadItemPrueba: 3,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 400,
            items: { "Piedras Espirituales": 30 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Disc√≠pulo Interno",
        },
        mision_int_4: {
          titulo: "La Bestia Alfa",
          descripcion:
            "Un Lobo Alfa ha sido avistado en el coraz√≥n del bosque, liderando a las manadas. Cazarlo ser√° una prueba de tu creciente poder.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_alpha",
            cantidad: 1,
            nombreDisplay: "Lobo Alfa",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 500,
            items: { "N√∫cleo de Bestia Menor": 1, "Piedras Espirituales": 50 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Interno",
          requisitoNivel: 8,
        },
        mision_cazar_bestia_especifica_1: {
          titulo: "La Amenaza del Jabal√≠ Colmilludo",
          descripcion:
            "Un Jabal√≠ Colmilludo particularmente agresivo ha estado atacando a los recolectores de la secta en lo profundo del bosque. Caza a esta bestia y trae su 'Colmillo intacto' como prueba al Gu√≠a Lin.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "jabali_colmilludo_alfa",
            itemPrueba: "Colmillo de Jabal√≠ Alfa",
            cantidadItemPrueba: 1,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 300,
            items: { "Piedras Espirituales": 20, "Carne de Bestia Ex√≥tica": 3 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Interno",
          requisitoNivel: 10,
        },
        mision_cazar_bestia_especifica_1: {
          titulo: "Elimina el golem de piedra",
          descripcion:
            "Elimina al golem de piedra Geo al sur de la pradera de la secta.Regresa con el Gu√≠a Lin luego de eliminarlo.",
          objetivo: {
            objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "golem_de_piedra",
              cantidad: 1,
              nombreDisplay: "golem_de_piedra",
              npcEntrega: "guia_lin",
            },
          },
          recompensa: {
            pcs: 150,
            exp: 300,
            items: { "Piedras Espirituales": 20, "Carne de Bestia Ex√≥tica": 3 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Interno",
          requisitoNivel: 10,
        },

        // === MISIONES: DISC√çPULO PRINCIPAL ===
        // (Se desbloquean al alcanzar este rango)

        mision_prin_1: {
          titulo: "Arena y Aguij√≥n",
          descripcion:
            "Las caravanas que comercian con la secta reportan ataques de Escorpiones de las Dunas. Reduce su n√∫mero eliminando a 10 de ellos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_desierto_escorpion",
            cantidad: 10,
            nombreDisplay: "Escorpi√≥n de las Dunas",
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 180,
            exp: 600,
            items: { "Piedras Espirituales": 70 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Disc√≠pulo Principal",
        },
        mision_prin_2: {
          titulo: "Corazones de Arena",
          descripcion:
            "Los Golems de Tormenta de Arena son una amenaza mayor en el desierto. Destruye 5 y trae sus N√∫cleos de Arena como prueba.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "monster_desierto_golem_arena",
            itemPrueba: "N√∫cleo de Arena",
            cantidadItemPrueba: 5,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 250,
            exp: 800,
            items: { "Fragmento Des√©rtico": 2, "Piedras Espirituales": 100 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Disc√≠pulo Principal",
          requisitoNivel: 12,
        },
        mision_prin_3: {
          titulo: "Ecos Espectrales",
          descripcion:
            "Los alquimistas de la secta pagan bien por Esencias Espectrales. Se dice que los Espectros del Pantano las dejan al ser derrotados. Consigue 2 esencias.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "espectro_pantano",
            itemPrueba: "Esencia Espectral",
            cantidadItemPrueba: 2,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 300,
            exp: 900,
            items: { "Talism√°n de Percepci√≥n": 1 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Disc√≠pulo Principal",
        },
        mision_prin_4: {
          titulo: "Renegados Peligrosos",
          descripcion:
            "Un grupo de Cultivadores Renegados ha establecido un campamento en el bosque profundo, desafiando la autoridad de la secta. Disu√©lvelos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivador_renegado",
            cantidad: 4,
            nombreDisplay: "Cultivador Renegado",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 280,
            exp: 1000,
            items: {
              "Rollo: T√©cnica Aleatoria Menor": 1,
              "Piedras Espirituales": 80,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Principal",
          requisitoNivel: 15,
        },
        // === MISIONES: DI√ÅCONO ===
        mision_diac_1: {
          titulo: "Contenci√≥n de Rivales",
          descripcion:
            "La Secta de la Llama Negra se est√° expandiendo a nuestro territorio. Ve al Desfiladero de los Lamentos y derrota a 10 de sus cultivadores para enviar un mensaje.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivador_secta_rival",
            cantidad: 10,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 400,
            exp: 2500,
            items: { "Piedras Espirituales": 200 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Di√°cono",
        },
        mision_diac_2: {
          titulo: "Recolecci√≥n Peligrosa",
          descripcion:
            "Nuestros alquimistas necesitan Cristales de Sangre Puros, que solo se encuentran en la Caverna de Cristal de Sangre, dentro del Desfiladero. Ten cuidado con sus guardianes. Necesitamos 3 cristales.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "murcielago_cristal_sangriento",
            itemPrueba: "Cristal de Sangre Puro",
            cantidadItemPrueba: 3,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 500,
            exp: 3000,
            items: { "P√≠ldora de Recuperaci√≥n Mayor": 2 },
          }, // Necesitar√≠as definir este item
          npcInicio: "admin_yao",
          requisitoRango: "Di√°cono",
        },
        mision_diac_3: {
          titulo: "Investigar al Renegado",
          descripcion:
            "Hemos recibido informes de que el di√°cono renegado, Jin, se esconde al final del Desfiladero. Investiga la zona (alrededores de x:85 y:15  prep√°rate para lo peor.",
          objetivo: {
            tipo: "llegar_a_punto",
            x: 85,
            y: 15,
            nombreArea: "Guarida de Jin",
            npcEntrega: "guia_lin",
          }, // Objetivo de exploraci√≥n
          recompensa: { pcs: 200, exp: 1000 },
          npcInicio: "guia_lin",
          requisitoRango: "Di√°cono",
        },
        mision_diac_4: {
            titulo: "La Traici√≥n de Jin",
            descripcion: "Es hora de acabar con la amenaza del Di√°cono Renegado Jin. Derr√≥talo y restaura el honor de la secta.",
            objetivo: {
                tipo: "derrotar_npc_especifico", // <-- TIPO CORRECTO
                npcId: "diacono_renegado_jin",   // <-- PROPIEDAD CORRECTA
                npcEntrega: "guia_lin"
            },
            recompensa: {
                pcs: 1000,
                exp: 5000,
                items: { "Rollo: T√©cnica de Absorci√≥n de Qi Celestial": 1 }
            },
            npcInicio: "guia_lin",
            requisitoRango: "Di√°cono", 
        },

        // === MISIONES: ANCIANO ===
        mision_anc_1: {
          titulo: "El Resentimiento del Drag√≥n",
          descripcion:
            "La energ√≠a Yin en el Valle del Drag√≥n Ca√≠do ha reanimado a los antiguos dracos. Pacifica a 8 de estas criaturas esquel√©ticas.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "draco_hueso_antiguo",
            cantidad: 8,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 1200,
            exp: 8000,
            items: { "Piedras Espirituales": 500 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Anciano",
        },
        mision_anc_2: {
          titulo: "El Coraz√≥n de la Tormenta",
          descripcion:
            "Para forjar un artefacto celestial, necesitamos un Coraz√≥n de Tif√≥n. Caza a los Espectros Tif√≥nicos en el Valle hasta que obtengas uno.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "espectro_tifonico",
            itemPrueba: "Coraz√≥n de Tif√≥n",
            cantidadItemPrueba: 1,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 1500,
            exp: 10000,
            items: { "Piedras Espirituales": 700 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Anciano",
        },
        mision_anc_3: {
          titulo: "La Fuente de la Corrupci√≥n",
          descripcion:
            "Creemos que un poderoso no-muerto es la causa de la corrupci√≥n en el Valle. Encuentra su guarida y prep√°rate para enfrentarlo.",
          objetivo: {
            tipo: "llegar_a_punto",
            x: 350,
            y: 18,
            nombreArea: "Trono del Lich",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 500, exp: 3000 },
          npcInicio: "guia_lin",
          requisitoRango: "Anciano",
        },
        mision_anc_4: {
          titulo: "Sellar al Emperador Lich",
          descripcion:
            "El Emperador Lich amenaza con extender su plaga no-muerta. Destr√∫yelo y reclama su filacteria como prueba.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "emperador_lich_del_valle",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 2500,
            exp: 15000,
            items: {
              "Filacteria del Lich": 1,
              "Rollo: T√©cnica de Anciano Aleatoria": 1,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Anciano",
        },

        // === MISIONES: GRAN ANCIANO ===
        mision_gran_anc_1: {
          titulo: "Defensa de la Realidad",
          descripcion:
            "Una Fisura Demon√≠aca se ha abierto, y sus habitantes se derraman en nuestro mundo. Repele la primera oleada eliminando a 15 Demonios de la Fisura.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "demonio_de_la_fisura",
            cantidad: 15,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 3000,
            exp: 20000,
            items: { "Fragmento de la Fisura": 5 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Gran Anciano",
        },
        mision_gran_anc_2: {
          titulo: "Luz Ca√≠da",
          descripcion:
            "Los Guardianes Celestiales que proteg√≠an el sello de la fisura han sido corrompidos. Libera a 3 de ellos de su tormento.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "guardian_celestial_caido",
            cantidad: 3,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 4000,
            exp: 25000,
            items: { "L√°grima Celestial": 1 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Gran Anciano",
        },
        mision_gran_anc_3: {
          titulo: "El General del Abismo",
          descripcion:
            "El General Demon√≠aco Abismal comanda las fuerzas de la Fisura. Ad√©ntrate en su coraz√≥n y derr√≥talo para sellar la amenaza... por ahora.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "general_demoniaco_abismal",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 5000,
            exp: 40000,
            items: {
              "Coraz√≥n del Abismo": 1,
              "Rollo: T√©cnica de Gran Anciano Aleatoria": 1,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Gran Anciano",
        },
        mision_gran_anc_4: {
          titulo: "Preparativos para la Ascensi√≥n",
          descripcion:
            "Has llegado al pin√°culo. Para trascender, necesitas forjar un Sello del Dao. Re√∫ne 3 L√°grimas Celestiales, 5 Fragmentos de la Fisura y 10 Escamas de Drag√≥n Espectral.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "L√°grima Celestial", cantidad: 3 },
              { nombre: "Fragmento de la Fisura", cantidad: 5 },
              { nombre: "Escama de Drag√≥n Espectral", cantidad: 10 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: { pcs: 10000, exp: 50000 },
          npcInicio: "admin_yao",
          requisitoRango: "Gran Anciano",
        },

        // === MISI√ìN FINAL: MAESTRO DE SECTA ===
        mision_maestro_1: {
          titulo: "El Duelo del Destino",
          descripcion:
            "El equilibrio del mundo se ha roto. Un Avatar del Dao Corrupto ha despertado para consumir toda la existencia. Como Maestro de Secta, es tu deber enfrentarlo y proteger este mundo.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "avatar_del_dao_corrupto",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 0,
            exp: 100000,
            items: { "Semilla del Dao Verdadero": 1 },
            nuevoRango: "Soberano Inmortal",
          }, // Rango final honor√≠fico
          npcInicio: "guia_lin",
          requisitoRango: "Maestro de Secta",
        },

        //MISIONES DE DESAF√çO
        mision_desafio_interno_1: {
          titulo: "Prueba de Disc√≠pulo Interno",
          descripcion:
            "Para ser reconocido como Disc√≠pulo Interno, debes demostrar tu fuerza venciendo al Guardi√°n de la Prueba, Han Li. Encu√©ntralo en la arena de desaf√≠os de la secta.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_interno_1",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 200, exp: 300, nuevoRango: "Disc√≠pulo Interno" },
          autoActivarAlCumplirRequisitos: true,
        },
        mision_desafio_principal_1: {
          titulo: "Prueba de Disc√≠pulo Principal",
          descripcion:
            "La Anciana Shui espera en la arena. Demuestra que eres digno del rango de Disc√≠pulo Principal.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_principal_1",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 500, exp: 800, nuevoRango: "Disc√≠pulo Principal" },
          autoActivarAlCumplirRequisitos: true,
        },
        mision_desafio_diacono_1: {
          titulo: "Prueba de Di√°cono",
          descripcion:
            "Has demostrado tu val√≠a a trav√©s de tus contribuciones. Para ser reconocido como Di√°cono, debes derrotar al Guardi√°n de la Arena, Feng, en un duelo honorable.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_diacono_1",
            npcEntrega: "guia_lin", // El Gu√≠a Lin confirmar√° tu ascenso
          },
          recompensa: {
            pcs: 500,
            exp: 2000,
            nuevoRango: "Di√°cono",
            // La elecci√≥n de t√©cnica ya est√° manejada por tu l√≥gica de ascenso
          },
          autoActivarAlCumplirRequisitos: true, // Esto es clave para la automatizaci√≥n
        },

        mision_desafio_anciano_1: {
          titulo: "Prueba de Anciano",
          descripcion:
            "Solo los m√°s fuertes pueden guiar a la secta. El Anciano Guardi√°n Lei te espera en la arena para probar si eres digno del t√≠tulo de Anciano.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_anciano_1",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 1000,
            exp: 5000,
            nuevoRango: "Anciano",
          },
          autoActivarAlCumplirRequisitos: true,
        },

        mision_desafio_gran_anciano_1: {
          titulo: "Prueba de Gran Anciano",
          descripcion:
            "La Gran Anciana de la Hoja, Yue, pondr√° a prueba no solo tu fuerza, sino tu ingenio en combate. V√©ncela para obtener el respeto de todo el consejo de ancianos.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_gran_anciano_1",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 2000,
            exp: 10000,
            nuevoRango: "Gran Anciano",
          },
          autoActivarAlCumplirRequisitos: true,
        },

        mision_desafio_maestro_1: {
          titulo: "La Prueba Final: El Legado del Maestro",
          descripcion:
            "El camino hacia la cima llega a su fin. El Maestro de Secta anterior te espera para una √∫ltima prueba. Demuestra que est√°s listo para heredar su voluntad y liderar la secta hacia la gloria.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_maestro_1",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 5000,
            exp: 20000,
            nuevoRango: "Maestro de Secta",
          },
          autoActivarAlCumplirRequisitos: true,
        },
      };

      const shopData = {
        name: "Pabell√≥n de Tesoros del Drag√≥n Oculto",
        inventory: [
          { itemName: "Hierbas Medicinales", price: 1, stock: 100 },
          { itemName: "Cristales de Qi", price: 1, stock: 100 },
          {
            itemName: "Espada de Hierro",
            type: "equipment",
            category: "weapon",
            attackBonus: 5,
            price: 50,
            stock: 1,
            description: "Una espada b√°sica pero fiable. (+5 Ataque)",
          },
          //nivel 0
          { itemName: "Rollo: Absorci√≥n de Qi Menor", price: 15, stock: 10 },

          { itemName: "Rollo: Conversi√≥n de Qi", price: 25, stock: 10 },
          //nivel mortal
          { itemName: "Rollo: Tajo del Viento Veloz", price: 150, stock: 3 },
          { itemName: "Rollo: F√≠sico de Buey de Piedra", price: 200, stock: 2 },
          { itemName: "Rollo: Matriz de Escudo de Qi", price: 180, stock: 3 },
          { itemName: "Rollo: Chispa √çgnea", price: 170, stock: 3 },
          { itemName: "Rollo: Dedo de Rel√°mpago", price: 220, stock: 2 },
          //nivel terrenal

          {
            itemName: "Rollo: Estocada Perfora-Armadura",
            price: 300,
            stock: 3,
          },
          { itemName: "Rollo: Piel de Acero Fundido", price: 300, stock: 5 },
          {
            itemName: "Rollo: Matriz de Grilletes de Qi",
            price: 300,
            stock: 5,
          },
          { itemName: "Rollo: Paso Et√©reo", price: 300, stock: 5 },
          { itemName: "Rollo: Aliento de Drag√≥n Menor", price: 300, stock: 5 },
          //nivel celestial
          {
            itemName: "Rollo: Danza de Espada Cicl√≥nica",
            price: 600,
            stock: 3,
          },
          {
            itemName: "Rollo: Coraz√≥n de Voluntad Indomable",
            price: 600,
            stock: 3,
          },
          {
            itemName: "Rollo: Matriz de Supresi√≥n Espiritual",
            price: 600,
            stock: 3,
          },
          { itemName: "Rollo: Jaula de Rayos", price: 600, stock: 3 },
          { itemName: "Rollo: Parpadeo de Sombra", price: 600, stock: 3 },
          //Nivel soberano
          {
            itemName: "Rollo: Intenteci√≥n de Espada del Tirano",
            price: 1200,
            stock: 3,
          },
          { itemName: "Rollo: Cuerpo Dorado Inmortal", price: 1200, stock: 2 },
          { itemName: "Rollo: Sol Abrasador", price: 1200, stock: 3 },
          {
            itemName: "Rollo: Llamada del Juicio del Trueno",
            price: 1200,
            stock: 2,
          },
          {
            itemName: "Rollo: Santuario Dorado Protector",
            price: 1200,
            stock: 2,
          },
          //nivel trascendente
          {
            itemName: "Rollo: Corte que Divide Cielos y Tierra",
            price: 2400,
            stock: 2,
          },
          {
            itemName: "Rollo: Constituci√≥n de Drag√≥n Ancestral",
            price: 2400,
            stock: 3,
          },
          {
            itemName: "Rollo: Llama del F√©nix Renaciente",
            price: 2400,
            stock: 3,
          },
          {
            itemName: "Rollo: Tribulaci√≥n de los Nueve Cielos",
            price: 2400,
            stock: 3,
          },
          {
            itemName: "Rollo: Matriz de Reversi√≥n del Cosmos",
            price: 2400,
            stock: 3,
          },
          { itemName: "Rollo: Paso del Vac√≠o Infinito", price: 2400, stock: 3 },
        ],
      };

      //ROLLOS DE TECNICAS
      const techniqueData = {
        // =================================================================
        // == GRADO 1 (Rango: Disc√≠pulo Externo)
        // =================================================================
        qi_to_hp_conversion_1: {
          id: "qi_to_hp_conversion_1",
          name: "T√©cnica de Conversi√≥n de Qi",
          description:
            "Permite activar/desactivar la conversi√≥n de Man√° en HP al cultivar. Mejora la tasa de conversi√≥n y eficiencia con cada nivel de refinamiento.",
          type: "active_refinement_effect",
          effect: {
            baseManaCostPerSecond: 2.0, // Mantenemos un coste base razonable
            baseHpGainPerSecond: 3.0, // <-- ¬°VALOR CORREGIDO! Ahora es m√°s eficiente.
            hpGainIncreasePerLevel: 1, // Hacemos que la mejora por nivel sea m√°s gradual pero sostenida
            manaCostReductionPerLevel: 0.02, // Reducimos la mejora de eficiencia para balancear
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Cristales de Qi": 5, "Piedras Espirituales": 10 },
            levelRequirement: 1,
          },
          icon: "‚òØÔ∏è",
        },
        qi_absorption_boost_1: {
          id: "qi_absorption_boost_1",
          name: "T√©cnica de Absorci√≥n de Qi Menor",
          description:
            "Aumenta la cantidad de Qi ganado por segundo al cultivar en 0.5.",
          type: "passive_cultivation",
          effect: { statToBoost: "qiPerSecondBase", value: 0.5 },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 60,
            levelTimeMultiplier: 1.5,
          },
          refinementCost: {
            baseTime: 30,
            materials: { "Piedras Espirituales": 20 },
            levelRequirement: 1,
          },
          icon: "üìú",
        },

        qi_absorption_celestial_1: {
          id: "qi_absorption_celestial_1",
          name: "T√©cnica de Absorci√≥n de Qi Celestial",
          description: "Una t√©cnica de cultivo superior que alinea tu esp√≠ritu con los cielos, aumentando dr√°sticamente la cantidad de Qi ganado por segundo al cultivar (+2.0 Qi/s).",
          type: "passive_cultivation",
          effect: { statToBoost: "qiPerSecondBase", value: 2.0 },
          maxLevel: 10, // Se puede mejorar para aumentar a√∫n m√°s el beneficio
          cultivationSettings: {
            baseTimeToLevelUp: 300, // Requiere m√°s tiempo para subir de nivel que las b√°sicas
            levelTimeMultiplier: 1.8,
          },
          icon: "üåå",
        },

        // =================================================================
        // == GRADO 1 (Rango: Disc√≠pulo Interno) - Nivel Mortal
        // =================================================================
        sword_t1: {
          id: "sword_t1",
          requiredRank: "Disc√≠pulo Interno",
          name: "Tajo del Viento Veloz",
          icon: "üí®",
          description:
            "Un corte de espada r√°pido y eficiente. Un pilar del combate b√°sico.",
          type: "active_ability",
          abilityId: "sword_t1",
          // --- INICIO DE LA MODIFICACI√ìN ---
          effect: { 
            baseDamageMultiplier: 1.2,
            multiplierIncreasePerLevel: 0.2 // Aumenta el multiplicador en 0.2 por cada nivel.
          },
          // --- FIN DE LA MODIFICACI√ìN ---
          manaCost: 10,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          cooldown: 1,
        },
        body_t1: {
          requiredRank: "Disc√≠pulo Interno",
          id: "body_t1",
          name: "F√≠sico de Buey de Piedra",
          icon: "üêÇ",
          description:
            "Fortalece pasivamente tu cuerpo, aumentando tu Vida M√°xima base.",
          type: "passive_stat",
          effect: { 
            statToBoost: "baseMaxHp", 
            value: 25 },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 120,
            levelTimeMultiplier: 1.7,
          },
        },
        formation_t1: {
          requiredRank: "Disc√≠pulo Interno",
          id: "formation_t1",
          name: "Matriz de Escudo de Qi",
          icon: "üí†",
          description: "Crea un escudo temporal que absorbe da√±o. A niveles m√°s altos, el escudo es m√°s resistente e incluso restaura una peque√±a cantidad de vida al ser invocado.",
          type: "active_ability",
          abilityId: "formation_t1",
          effect: {
              // --- VALORES MEJORADOS ---
              shieldValue: 50,                // Aumentado desde 40. Un mejor punto de partida.
              shieldIncreasePerLevel: 15,     // Aumentado. +15 de escudo por nivel es muy notable.
              duration: 3,
              // --- NUEVO EFECTO SECUNDARIO ---
              healOnCastLevelReq: 5,          // Requiere nivel 5 de la t√©cnica para empezar a curar.
              healOnCastAmount: 20            // Cantidad base de la curaci√≥n.
          },
          manaCost: 20,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 100, levelTimeMultiplier: 1.8 },
      },
      fire_t1: {
        requiredRank: "Disc√≠pulo Interno",
          id: "fire_t1",
          name: "Chispa √çgnea",
          icon: "üî•",
          description:
            "Lanza una peque√±a bola de fuego que causa da√±o y puede aplicar una quemadura menor.",
          type: "active_ability",
          abilityId: "fire_t1",
          effect: {
            baseDamageMultiplier: 0.8,
            multiplierIncreasePerLevel: 0.1, // <-- MODIFICACI√ìN A√ëADIDA
            burnDamagePerTurn: 5,
            burnDamageIncreasePerLevel: 1, // <-- MODIFICACI√ìN A√ëADIDA
            burnDuration: 2,
          },
          manaCost: 15,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 110,
            levelTimeMultiplier: 1.7,
          },
        },
        lightning_t1: {
          requiredRank: "Disc√≠pulo Interno",
          id: "lightning_t1",
          name: "Dedo de Rel√°mpago",
          icon: "‚ö°",
          description:
            "Un r√°pido chispazo de rel√°mpago que puede aturdir brevemente al enemigo.",
          type: "active_ability",
          abilityId: "lightning_t1",
          effect: { 
            baseDamageMultiplier: 0.9,
            multiplierIncreasePerLevel: 0.1, // <-- MODIFICACI√ìN A√ëADIDA
            stunChance: 0.2,
            stunChanceIncreasePerLevel: 0.03, // <-- MODIFICACI√ìN A√ëADIDA
          },
          manaCost: 18,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 130,
            levelTimeMultiplier: 1.8,
          },
        },
        movement_t1: {
          requiredRank: "Disc√≠pulo Interno",
          id: "movement_t1",
          name: "Paso Veloz",
          icon: "üëü",
          description: "Un movimiento r√°pido que te reposiciona, aumentando temporalmente tu defensa para el siguiente turno.",
          type: "active_ability",
          abilityId: "movement_t1",
          effect: { 
              tempDefenseBuff: 10, // Un bono fijo y simple para una t√©cnica inicial
              buffDuration: 2,     // Dura tu turno actual y el siguiente del enemigo
              buffIncreasePerLevel: 2 // Aumenta el bono en 2 por cada nivel
          },
          manaCost: 15,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 100, levelTimeMultiplier: 1.7 }
      },

        // =================================================================
        // == GRADO 2 (Rango: Disc√≠pulo Principal) - Nivel Terrenal
        // =================================================================
        sword_t2: {
            id: "sword_t2",
            requiredRank: "Disc√≠pulo Principal", 
            name: "Estocada Perfora-Armadura",
            icon: "üó°Ô∏è",
            description: "Un ataque preciso que ignora una porci√≥n de la defensa enemiga y puede causar una herida sangrante.",
            type: "active_ability",
            abilityId: "sword_t2",
            effect: {
                // --- VALORES MEJORADOS ---
                baseDamageMultiplier: 1.8,      // Aumentado desde 1.1. Ahora es claramente m√°s fuerte.
                defensePenetration: 0.3,        // Aumentado desde 0.25. Ignora m√°s defensa.
                bleedChance: 0.3,               // NUEVO: 30% de probabilidad de causar hemorragia.
                bleedDamagePerTurn: 15,         // NUEVO: Da√±o de la hemorragia.
                bleedDuration: 2                // NUEVO: Duraci√≥n de la hemorragia.
            },
            manaCost: 25,
            cooldown: 2,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 180, levelTimeMultiplier: 1.6 },
        },
        body_t2: {
          
          id: "body_t2",
          requiredRank: "Disc√≠pulo Principal", 
          name: "Piel de Acero Fundido",
          icon: "ü¶æ",
          description:
            "Aumenta pasivamente tu Defensa base, haci√©ndote m√°s resistente.",
          type: "passive_stat",
          effect: { statToBoost: "baseDefense", value: 5 },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 200,
            levelTimeMultiplier: 1.7,
          },
        },
        formation_t2: {
          id: "formation_t2",
          requiredRank: "Disc√≠pulo Principal", 
          name: "Matriz de Grilletes de Qi",
          icon: "üîó",
          description:
            "Una formaci√≥n que intenta enraizar al enemigo. Consume man√° cada turno y puede romperse si el enemigo ataca con fuerza.",
          type: "active_ability",
          abilityId: "formation_t2",
          effect: {
            rootDuration: 2,
            damagePerTurn: 10,
            damagePerTurnIncreasePerLevel: 2, // <-- MODIFICACI√ìN A√ëADIDA
            rootChance: 0.7,
            shacklesHP: 100, 
            shacklesHPIncreasePerLevel: 20, // <-- MODIFICACI√ìN A√ëADIDA
            manaUpkeep: 5,
          },
          manaCost: 30,
          cooldown: 3,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 190,
            levelTimeMultiplier: 1.8,
          },
        },
        movement_t2: {
          id: "movement_t2",
          requiredRank: "Disc√≠pulo Principal", 
          name: "Paso Et√©reo",
          icon: "üëü",
          description: "Esquivas el pr√≥ximo ataque. El movimiento fluido tambi√©n aumenta tu defensa temporalmente. El bono de defensa aumenta con el nivel.",
          type: "active_ability",
          abilityId: "movement_t2",
          effect: {
              dodgeNextAttack: true,
              // --- NUEVAS PROPIEDADES ---
              tempDefenseBuff: 5,      // Defensa extra que otorga
              buffDuration: 2,         // Duraci√≥n del buff en turnos
              buffIncreasePerLevel: 2  // Cu√°nto aumenta el buff de defensa por nivel
          },
          manaCost: 40,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 220, levelTimeMultiplier: 1.9 },
      },
      fire_t2: {
          id: "fire_t2",
          requiredRank: "Disc√≠pulo Principal", 
          name: "Aliento de Drag√≥n Menor",
          icon: "üê≤",
          description:
            "Exhalas un cono de fuego que quema con mayor intensidad.",
          type: "active_ability",
          abilityId: "fire_t2",
          effect: {
            baseDamageMultiplier: 1.0,
            multiplierIncreasePerLevel: 0.2, // <-- MODIFICACI√ìN A√ëADIDA
            burnDamagePerTurn: 15,
            burnDamageIncreasePerLevel: 2, // <-- MODIFICACI√ìN A√ëADIDA
            burnDuration: 3,
          },
          manaCost: 35,
          cooldown: 3,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 200,
            levelTimeMultiplier: 1.7,
          },
        },
        lightning_t2: {
          id: "lightning_t2",
          requiredRank: "Disc√≠pulo Principal", 
          name: "L√°tigo de Trueno",
          icon: "‚ö°Ô∏è",
          description: "Un chasquido de energ√≠a el√©ctrica que golpea al enemigo, reduciendo su defensa temporalmente.",
          type: "active_ability",
          abilityId: "lightning_t2",
          effect: { 
              baseDamageMultiplier: 1.4,
              multiplierIncreasePerLevel: 0.15, // <-- MODIFICACI√ìN A√ëADIDA
              defenseReduction: 10,
              defenseReductionIncreasePerLevel: 1, // <-- MODIFICACI√ìN A√ëADIDA
              duration: 2
          },
          manaCost: 28,
          cooldown: 2,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 190, levelTimeMultiplier: 1.8 }
      },

        // =================================================================
        // == GRADO 3 (Rango: Di√°cono) - Nivel Celestial
        // =================================================================
        sword_t3: {
            id: "sword_t3",
            requiredRank: "Di√°cono",
            name: "Danza de Espada Cicl√≥nica",
            icon: "üå™Ô∏è",
            description: "Giras como un cicl√≥n, golpeando al enemigo m√∫ltiples veces. El n√∫mero de golpes aumenta con el nivel.",
            type: "active_ability",
            abilityId: "sword_t3",
            effect: {
                baseDamageMultiplier: 1.5,
                baseHits: 3, // <-- Nuevo: Golpes base
                hitsIncreasePerLevel: 0.5 // <-- Nuevo: Medio golpe por nivel (se redondear√°)
            },
            manaCost: 50,
            cooldown: 2,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 300, levelTimeMultiplier: 1.6 },
        },
        body_t3: {
          id: "body_t3",
          requiredRank: "Di√°cono",
          name: "Coraz√≥n de Voluntad Indomable",
          icon: "‚ù§Ô∏è‚Äçüî•",
          description:
            "Pasivamente, tu voluntad de hierro reduce una porci√≥n de todo el da√±o recibido.",
          type: "passive_stat",
          effect: { statToBoost: "damageReduction", value: 0.05 }, // Esto necesitar√° l√≥gica en el c√°lculo de da√±o
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 350,
            levelTimeMultiplier: 1.7,
          },
        },
        formation_t3: {
            id: "formation_t3",
            requiredRank: "Di√°cono",
            name: "Matriz de Supresi√≥n Espiritual",
            icon: "üï∏Ô∏è",
            description: "Crea un campo que debilita al enemigo, reduciendo su ataque y defensa. El efecto es m√°s potente con el nivel.",
            type: "active_ability",
            abilityId: "formation_t3",
            effect: { 
                baseReduction: 15, // <-- Nuevo
                reductionIncreasePerLevel: 3, // <-- Nuevo
                duration: 4 
            },
            manaCost: 45,
            cooldown: 5,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 320, levelTimeMultiplier: 1.8 },
        },
        lightning_t3: {
            id: "lightning_t3",
            requiredRank: "Di√°cono",
            name: "Jaula de Rayos",
            icon: "‚õìÔ∏è",
            description: "Encierra al enemigo en una jaula el√©ctrica, causando da√±o y con alta probabilidad de aturdir, ambos mejoran con el nivel.",
            type: "active_ability",
            abilityId: "lightning_t3",
            effect: {
                baseDamageMultiplier: 1.2,
                damageMultiplierIncreasePerLevel: 0.1, // <-- Nuevo
                baseStunChance: 0.5, // <-- Nuevo
                stunChanceIncreasePerLevel: 0.03, // <-- Nuevo
                duration: 2
            },
            manaCost: 60,
            cooldown: 4,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 380, levelTimeMultiplier: 1.8 },
        },
        movement_t3: {
          id: "movement_t3",
          requiredRank: "Di√°cono",
          name: "Parpadeo de Sombra",
          icon: "üëª",
          description: "Te teletransportas instant√°neamente detr√°s del enemigo para un golpe cr√≠tico garantizado. Su potencia aumenta con el nivel.", // Descripci√≥n mejorada
          type: "active_ability",
          abilityId: "movement_t3",
          effect: { 
              baseDamageMultiplier: 2.0, 
              multiplierIncreasePerLevel: 0.2, // <-- NUEVA PROPIEDAD DE ESCALADO
              isCritical: true 
          },
          manaCost: 55,
          cooldown: 3,
          maxLevel: 10,
          cultivationSettings: {
              baseTimeToLevelUp: 400,
              levelTimeMultiplier: 1.9,
          },
      },

        // =================================================================
        // == GRADO 4 (Rango: Anciano) - Nivel Soberano
        // =================================================================
        sword_t4: {
            id: "sword_t4",
            requiredRank: "Anciano",
            name: "Intenci√≥n de Espada del Tirano",
            icon: "üëë",
            description: "Canalizas tu Qi para una onda de energ√≠a que da√±a y puede aturdir. Su poder aumenta con el nivel.",
            type: "active_ability",
            abilityId: "sword_t4",
            effect: { 
                baseDamageMultiplier: 2.8,
                multiplierIncreasePerLevel: 0.25, // <-- Nuevo
                baseStunChance: 0.4, // <-- Nuevo
                stunChanceIncreasePerLevel: 0.02, // <-- Nuevo
            },
            manaCost: 70,
            cooldown: 1,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 500, levelTimeMultiplier: 1.5 },
        },
        body_t4: {
          id: "body_t4",
          requiredRank: "Anciano",
          name: "Cuerpo Dorado Inmortal",
          icon: "üåü",
          description:
            "Tu cuerpo se vuelve tan duro que regenera vida pasivamente incluso fuera del cultivo.",
          type: "passive_stat",
          effect: { statToBoost: "passiveHpRegen", value: 0.5 }, // Necesitar√° l√≥gica en el game tick
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 600,
            levelTimeMultiplier: 1.6,
          },
        },
        fire_t4: {
            id: "fire_t4",
            requiredRank: "Anciano",
            name: "Sol Abrasador",
            icon: "‚òÄÔ∏è",
            description: "Creas un sol en miniatura que explota, causando da√±o masivo y dejando una quemadura intensa que escala con el nivel.", // Descripci√≥n actualizada
            type: "active_ability",
            abilityId: "fire_t4",
            effect: { 
                baseDamageMultiplier: 2.5,
                multiplierIncreasePerLevel: 0.3, 
                aoe: true,
                // --- INICIO DE LA MODIFICACI√ìN ---
                burnDamagePerTurn: 30,       // Da√±o de quemadura base.
                burnDuration: 3,           // Duraci√≥n de la quemadura en turnos.
                burnIncreasePerLevel: 5    // El da√±o de la quemadura aumenta en 5 por cada nivel.
                // --- FIN DE LA MODIFICACI√ìN ---
            },
            manaCost: 80,
            cooldown: 4,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 550, levelTimeMultiplier: 1.6 },
        },
        lightning_t4: {
            id: "lightning_t4",
            requiredRank: "Anciano",
            name: "Llamada del Juicio del Trueno",
            icon: "üå©Ô∏è",
            description: "Invocas un rayo celestial que ignora la defensa. Su da√±o base aumenta con el nivel.",
            type: "active_ability",
            abilityId: "lightning_t4",
            effect: { 
                baseDamageMultiplier: 2.0,
                multiplierIncreasePerLevel: 0.25, // <-- Nuevo
                ignoreDefense: true 
            },
            manaCost: 75,
            cooldown: 4,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 580, levelTimeMultiplier: 1.7 },
        },
        formation_t4: {
            id: "formation_t4",
            requiredRank: "Anciano",
            name: "Santuario Dorado Protector",
            icon: "üè∞",
            description: "Una matriz defensiva definitiva que te hace inmune al da√±o. A niveles altos, dura un turno m√°s.",
            type: "active_ability",
            abilityId: "formation_t4",
            effect: { 
                baseDuration: 2, // <-- Nuevo
                levelForExtraTurn: 7 // <-- Nuevo: A nivel 7, dura un turno extra
            },
            manaCost: 100,
            cooldown: 8,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 620, levelTimeMultiplier: 1.8 },
        },
        movement_t4: {
          id: "movement_t4",
          requiredRank: "Anciano",
          name: "Danza del Viento Espectral",
          icon: "üíÉ",
          description: "Un ataque veloz que confunde al enemigo, permiti√©ndote esquivar con certeza el siguiente golpe recibido.",
          type: "active_ability",
          abilityId: "movement_t4",
          effect: { 
              baseDamageMultiplier: 1.8, 
              multiplierIncreasePerLevel: 0.2, // <-- MODIFICACI√ìN A√ëADIDA
              dodgeNextAttack: true
          },
          manaCost: 65,
          cooldown: 1,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 600, levelTimeMultiplier: 1.8 }
      },

        // =================================================================
        // == GRADO 5 (Rango: Gran Anciano) - Nivel Transcendente
        // =================================================================
        sword_t5: {
          id: "sword_t5",
          requiredRank: "Gran Anciano",
          name: "Corte que Divide Cielos y Tierra",
          icon: "‚öîÔ∏è",
          description:
            "Una t√©cnica legendaria que corta a trav√©s de cualquier defensa y causa da√±o verdadero.",
          type: "active_ability",
          abilityId: "sword_t5",
          effect: {
            baseDamageMultiplier: 4.0,
            multiplierIncreasePerLevel: 0.5, // <-- MODIFICACI√ìN A√ëADIDA
            trueDamage: true,
            criticalChance: 0.3,
            criticalChanceIncreasePerLevel: 0.02 // <-- MODIFICACI√ìN A√ëADIDA (2% m√°s por nivel)
          },
          manaCost: 120,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 800,
            levelTimeMultiplier: 1.4,
          },
        },
        body_t5: {
          id: "body_t5",
          requiredRank: "Gran Anciano",
          name: "Constituci√≥n de Drag√≥n Ancestral",
          icon: "üêâ",
          description:
            "Tu cuerpo alcanza la perfecci√≥n drac√≥nica, ganando inmunidad a efectos de estado y regeneraci√≥n poderosa.",
          type: "passive_stat",
          effect: {
            statToBoost: "statusImmunity",
            value: true,
            passiveHpRegen: 2.0,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 900,
            levelTimeMultiplier: 1.5,
          },
        },
        fire_t5: {
          id: "fire_t5",
          requiredRank: "Gran Anciano",
          name: "Llama del F√©nix Renaciente",
          icon: "üî•",
          description:
            "Invocas el fuego sagrado del f√©nix que causa da√±o masivo y puede resucitarte al morir.",
          type: "active_ability",
          abilityId: "fire_t5",
          effect: { 
            baseDamageMultiplier: 3.5, 
            aoe: true, 
            reviveChance: 0.25,
            reviveChanceIncreasePerLevel: 0.025 // <-- MODIFICACI√ìN A√ëADIDA (2.5% m√°s por nivel)
          },
          manaCost: 150,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 850,
            levelTimeMultiplier: 1.5,
          },
        },
        lightning_t5: {
          id: "lightning_t5",
          requiredRank: "Gran Anciano",
          name: "Tribulaci√≥n de los Nueve Cielos",
          icon: "üå©Ô∏è",
          description:
            "Canalizas el poder de la tribulaci√≥n celestial para devastar a todos los enemigos.",
          type: "active_ability",
          abilityId: "lightning_t5",
          effect: {
            baseDamageMultiplier: 3.0,
            multiplierIncreasePerLevel: 0.4, // <-- MODIFICACI√ìN A√ëADIDA
            aoe: true,
            paralyzeChance: 0.6,
            paralyzeChanceIncreasePerLevel: 0.04, // <-- MODIFICACI√ìN A√ëADIDA
            duration: 2,
          },
          manaCost: 140,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 880,
            levelTimeMultiplier: 1.6,
          },
        },
        formation_t5: {
          id: "formation_t5",
          requiredRank: "Gran Anciano",
          name: "Matriz de Reversi√≥n del Cosmos",
          icon: "üåå",
          description:
            "Una formaci√≥n que invierte el da√±o recibido, convirti√©ndolo en curaci√≥n.",
          type: "active_ability",
          abilityId: "formation_t5",
          effect: { damageToHealingDuration: 3, reflectDamage: 0.5 },
          manaCost: 180,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 950,
            levelTimeMultiplier: 1.7,
          },
        },
        movement_t5: {
          id: "movement_t5",
          requiredRank: "Gran Anciano",
          name: "Paso del Vac√≠o Infinito",
          icon: "üåÄ",
          description:
            "Te mueves entre dimensiones, volvi√©ndote intangible y atacando desde m√∫ltiples √°ngulos.",
          type: "active_ability",
          abilityId: "movement_t5",
          effect: {
            baseDamageMultiplier: 2.5,
            intangibleTurns: 2,
            multiHit: 3,
          },
          manaCost: 130,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 820,
            levelTimeMultiplier: 1.8,
          },
        },

        // =================================================================
        // == GRADO 6 (Rango: Patriarca) - Nivel M√≠tico
        // =================================================================
        sword_t6: {
          id: "sword_t6",
          requiredRank: "Maestro de Secta",
          name: "Espada del Emperador Celestial",
          icon: "üëë",
          description:
            "El arte supremo de la espada que puede cortar a trav√©s del destino mismo.",
          type: "active_ability",
          abilityId: "sword_t6",
          effect: {
            baseDamageMultiplier: 6.0,
            multiplierIncreasePerLevel: 0.5, // <-- MODIFICACI√ìN A√ëADIDA
            ignoreAllEffects: true,
            executeThreshold: 0.2,
            executeThresholdIncreasePerLevel: 0.01 // <-- MODIFICACI√ìN A√ëADIDA (1% m√°s de umbral por nivel)
          },
          manaCost: 200,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1200,
            levelTimeMultiplier: 1.3,
          },
        },
        body_t6: {
          id: "body_t6",
          requiredRank: "Maestro de Secta",
          name: "Cuerpo Inmortal de Jade",
          icon: "üíé",
          description:
            "Tu cuerpo trasciende la mortalidad, volvi√©ndose pr√°cticamente indestructible.",
          type: "passive_stat",
          effect: {
            statToBoost: "damageReduction",
            value: 0.25,
            deathSaveChance: 0.5,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1400,
            levelTimeMultiplier: 1.4,
          },
        },
        fire_t6: {
          id: "fire_t6",
          requiredRank: "Maestro de Secta",
          name: "Incineraci√≥n del Mundo Mortal",
          icon: "üåã",
          description:
            "Reduces todo a cenizas con el fuego que arde desde el n√∫cleo de la creaci√≥n.",
          type: "active_ability",
          abilityId: "fire_t6",
          effect: {
            baseDamageMultiplier: 5.0,
            aoe: true,
            burnDamagePerTurn: 100,
            burnDuration: 5,
          },
          manaCost: 250,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1300,
            levelTimeMultiplier: 1.4,
          },
        },
        lightning_t6: {
          id: "lightning_t6",
          requiredRank: "Maestro de Secta",
          name: "Decreto del Se√±or del Trueno",
          icon: "‚ö°",
          description:
            "Como se√±or de las tormentas, tu palabra se convierte en ley absoluta.",
          type: "active_ability",
          abilityId: "lightning_t6",
          effect: {
            baseDamageMultiplier: 4.5,
            aoe: true,
            silenceDuration: 3,
            stunChance: 0.8,
          },
          manaCost: 220,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1350,
            levelTimeMultiplier: 1.5,
          },
        },
        formation_t6: {
          id: "formation_t6",
          requiredRank: "Maestro de Secta",
          name: "Matriz del Sello del Demonio",
          icon: "üîí",
          description:
            "Sella completamente al enemigo, impidiendo todas sus acciones por varios turnos.",
          type: "active_ability",
          abilityId: "formation_t6",
          effect: { sealDuration: 4, damagePerTurn: 50 },
          manaCost: 300,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1500,
            levelTimeMultiplier: 1.6,
          },
        },
        movement_t6: {
          id: "movement_t6",
          requiredRank: "Maestro de Secta",
          name: "Omnipresencia Divina",
          icon: "üëÅÔ∏è",
          description:
            "Existes en m√∫ltiples lugares simult√°neamente, atacando desde todas partes.",
          type: "active_ability",
          abilityId: "movement_t6",
          effect: { baseDamageMultiplier: 3.0, unavoidable: true, multiHit: 5 },
          manaCost: 280,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1250,
            levelTimeMultiplier: 1.7,
          },
        },

        // =================================================================
        // == GRADO 7 (Rango: Soberano Supremo) - Nivel Legendario
        // =================================================================
        sword_t7: {
          id: "sword_t7",
          requiredRank: "Maestro de Secta",
          name: "Lamento del Fin del Mundo",
          icon: "üó°Ô∏è",
          description:
            "Una t√©cnica que lleva la esencia de la destrucci√≥n apocal√≠ptica.",
          type: "active_ability",
          abilityId: "sword_t7",
          effect: {
            baseDamageMultiplier: 8.0,
            aoe: true,
            ignoreAllDefenses: true,
            lifeSteal: 0.5,
          },
          manaCost: 350,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2000,
            levelTimeMultiplier: 1.2,
          },
        },
        body_t7: {
          id: "body_t7",
          requiredRank: "Maestro de Secta",
          name: "Forma del Ancestro Primordial",
          icon: "üåü",
          description:
            "Tu cuerpo alcanza la forma perfecta de los antiguos dioses creadores.",
          type: "passive_stat",
          effect: {
            statToBoost: "allStats",
            multiplier: 2.0,
            regenAllPerTurn: true,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2500,
            levelTimeMultiplier: 1.3,
          },
        },
        fire_t7: {
          id: "fire_t7",
          requiredRank: "Maestro de Secta",
          name: "G√©nesis √çgneo",
          icon: "üî•",
          description:
            "El fuego que cre√≥ el universo, capaz de destruir y recrear la realidad.",
          type: "active_ability",
          abilityId: "fire_t7",
          effect: {
            baseDamageMultiplier: 7.0,
            aoe: true,
            resetEnemyBuffs: true,
            burnDamagePerTurn: 200,
          },
          manaCost: 400,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2200,
            levelTimeMultiplier: 1.3,
          },
        },
        lightning_t7: {
          id: "lightning_t7",
          requiredRank: "Maestro de Secta",
          name: "C√≥lera del Emperador Celestial",
          icon: "‚ö°",
          description:
            "La ira divina se manifiesta como rayos que juzgan a todos los seres.",
          type: "active_ability",
          abilityId: "lightning_t7",
          effect: {
            baseDamageMultiplier: 6.5,
            aoe: true,
            judgmentEffect: true,
            chainLightning: 10,
          },
          manaCost: 380,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2300,
            levelTimeMultiplier: 1.4,
          },
        },
        formation_t7: {
          id: "formation_t7",
          requiredRank: "Maestro de Secta",
          name: "Matriz del Caos Primordial",
          icon: "üåÄ",
          description:
            "Invocas el caos que exist√≠a antes de la creaci√≥n para deshacer a tus enemigos.",
          type: "active_ability",
          abilityId: "formation_t7",
          effect: { randomCatastrophicEffects: true, reality_distortion: 5 },
          manaCost: 450,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2800,
            levelTimeMultiplier: 1.5,
          },
        },
        movement_t7: {
          id: "movement_t7",
          requiredRank: "Maestro de Secta",
          name: "Danza del Tejido Espacio-Tiempo",
          icon: "üåå",
          description:
            "Manipulas el espacio y el tiempo para existir en m√∫ltiples momentos simult√°neamente.",
          type: "active_ability",
          abilityId: "movement_t7",
          effect: {
            baseDamageMultiplier: 4.0,
            timeLoop: 3,
            spacialDistortion: true,
          },
          manaCost: 420,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2400,
            levelTimeMultiplier: 1.6,
          },
        },

        // =================================================================
        // == GRADO 8 (Rango: Emperador Inmortal) - Nivel √âpico
        // =================================================================
        sword_t8: {
          id: "sword_t8",
          requiredRank: "Maestro de Secta",
          name: "Decreto Imperial: Extinci√≥n",
          icon: "üëë",
          description:
            "Como emperador, tu palabra es ley absoluta. Decretas la extinci√≥n de tus enemigos.",
          type: "active_ability",
          abilityId: "sword_t8",
          effect: {
            baseDamageMultiplier: 12.0,
            instantKillChance: 0.3,
            ignoreAllProtections: true,
          },
          manaCost: 500,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 3500,
            levelTimeMultiplier: 1.1,
          },
        },
        body_t8: {
          id: "body_t8",
          requiredRank: "Maestro de Secta",
          name: "Avatar del Dao Eterno",
          icon: "‚òØÔ∏è",
          description:
            "Te conviertes en la manifestaci√≥n f√≠sica del Dao, trascendiendo todas las limitaciones.",
          type: "passive_stat",
          effect: {
            statToBoost: "transcendence",
            value: true,
            immuneToAll: true,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 4000,
            levelTimeMultiplier: 1.2,
          },
        },
        fire_t8: {
          id: "fire_t8",
          requiredRank: "Maestro de Secta",
          name: "Apocalipsis de Llamas Divinas",
          icon: "üî•",
          description:
            "El fuego que consume universos enteros, purificando la existencia misma.",
          type: "active_ability",
          abilityId: "fire_t8",
          effect: {
            baseDamageMultiplier: 10.0,
            aoe: true,
            purificationEffect: true,
            universeScaleDamage: true,
          },
          manaCost: 600,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 3800,
            levelTimeMultiplier: 1.2,
          },
        },
        lightning_t8: {
          id: "lightning_t8",
          requiredRank: "Maestro de Secta",
          name: "Tribulaci√≥n del Fin de los Tiempos",
          icon: "‚ö°",
          description:
            "Invocas la tribulaci√≥n final que marcar√° el fin de una era.",
          type: "active_ability",
          abilityId: "lightning_t8",
          effect: {
            baseDamageMultiplier: 9.0,
            aoe: true,
            eraEndingEffect: true,
            temporalDamage: true,
          },
          manaCost: 550,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 3600,
            levelTimeMultiplier: 1.3,
          },
        },
        formation_t8: {
          id: "formation_t8",
          requiredRank: "Maestro de Secta",
          name: "Matriz de Reescritura de la Realidad",
          icon: "üìú",
          description:
            "Reescribes las leyes fundamentales de la realidad a tu favor.",
          type: "active_ability",
          abilityId: "formation_t8",
          effect: {
            realityRewrite: true,
            lawManipulation: true,
            existenceControl: 7,
          },
          manaCost: 700,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 4500,
            levelTimeMultiplier: 1.4,
          },
        },
        movement_t8: {
          id: "movement_t8",
          requiredRank: "Maestro de Secta",
          name: "Trascendencia Dimensional",
          icon: "üåÄ",
          description:
            "Trasciendes las limitaciones dimensionales, existiendo en todas las dimensiones.",
          type: "active_ability",
          abilityId: "movement_t8",
          effect: {
            baseDamageMultiplier: 6.0,
            dimensionalTravel: true,
            omnipresence: true,
          },
          manaCost: 650,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 4200,
            levelTimeMultiplier: 1.5,
          },
        },

        // =================================================================
        // == GRADO 9 (Rango: Soberano del Dao) - Nivel M√≠tico Supremo
        // =================================================================
        sword_t9: {
          id: "sword_t9",
          requiredRank: "Maestro de Secta",
          name: "Corte del Origen Absoluto",
          icon: "‚öîÔ∏è",
          description:
            "Cortas a trav√©s del origen mismo de la existencia, negando la realidad de tus enemigos.",
          type: "active_ability",
          abilityId: "sword_t9",
          effect: {
            baseDamageMultiplier: 20.0,
            existenceNegation: true,
            conceptualDamage: true,
          },
          manaCost: 800,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 6000,
            levelTimeMultiplier: 1.0,
          },
        },
      };

      // ===  DICCIONARIO DE HABILIDADES DE ENEMIGOS ===
      const enemyAbilityData = {
        // --- BUFFS (Mejoras al enemigo) ---

        stone_skin_1: {
          name: "Piel de Piedra",
          type: "buff_stat",
          logMessage: (enemyName, defenseBoost, duration) =>
            `${enemyName} usa Piel de Piedra. ¬°Su defensa aumenta en ${defenseBoost} por ${duration} turnos!`,
          effect: {
            stat: "defense", // La estad√≠stica a mejorar
            amount: 15, // Cu√°nto aumenta
            duration: 3, // Cu√°ntos turnos dura
          },
        },
        // --- DEBUFFS (Perjuicios al jugador) ---
        armor_break: {
          name: "Golpe Rompe-Armadura",
          type: "debuff_stat",
          logMessage: (enemyName, damage, reduction, duration) =>
            `¬°${enemyName} usa un Golpe Rompe-Armadura! Recibes ${damage} de da√±o y tu defensa se reduce en ${reduction} por ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 1.2,
            debuff: {
              stat: "defense",
              amount: 10,
              duration: 3,
            },
          },
        },
        thorns_aura: {
          name: "Aura de Espinas",
          type: "buff_reflect",
          logMessage: (enemyName, reflectPercent, duration) =>
            `${enemyName} se rodea de un Aura de Espinas. ¬°Reflejar√° un ${reflectPercent}% del da√±o durante ${duration} turnos!`,
          effect: {
            reflectChance: 1.0, // 100% de probabilidad de reflejar
            reflectMultiplier: 0.25, // Refleja el 25% del da√±o
            duration: 2,
          },
        },
        armor_piercing_strike: {
          name: "Golpe Perforante",
          type: "piercing_damage",
          logMessage: (enemyName, damage) =>
            `${enemyName} utiliza un Golpe Perforante que ignora parte de tu armadura, ¬°causando ${damage} de da√±o!`,
          effect: {
            baseDamageMultiplier: 1.1,
            armorPenetration: 0.3, // 30% de la defensa del jugador ser√° ignorada
          },
        },
        intimidating_roar: {
          name: "Rugido Intimidante",
          type: "debuff_stat_no_damage", // Un debuff que no hace da√±o directo
          logMessage: (enemyName, reduction, duration) =>
            `¬°${enemyName} suelta un Rugido Intimidante! Tu ataque se reduce en ${reduction} por ${duration} turnos.`,
          effect: {
            debuff: {
              stat: "attack",
              amount: 8,
              duration: 3,
            },
          },
        },

        // --- ATAQUES CON DA√ëO EN EL TIEMPO (DoT) ---
        fire_breath: {
          name: "Aliento de Fuego",
          type: "dot_damage",
          logMessage: (enemyName, damage, burnDmg, duration) =>
            `¬°${enemyName} te envuelve en su Aliento de Fuego! Recibes ${damage} de da√±o y quedas quemado por ${burnDmg} de da√±o durante ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 0.8,
            dot: {
              type: "burn", // 'burn', 'poison', 'curse', etc.
              damagePerTurn: 8,
              duration: 3,
            },
          },
        },

        poison_sting: {
          name: "Picadura Venenosa",
          type: "dot_damage",
          logMessage: (enemyName, damage, poisonDmg, duration) =>
            `¬°${enemyName} te clava su Aguij√≥n Venenoso! Recibes ${damage} de da√±o y quedas envenenado por ${poisonDmg} de da√±o durante ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 0.5, // El golpe inicial no es tan fuerte
            poison: {
              damagePerTurn: 10, // Da√±o base del veneno
              duration: 3,
            },
          },
        },
        // Una maldici√≥n que drena el man√° del jugador cada turno
        mana_curse: {
          name: "Maldici√≥n de Man√°",
          type: "dot_resource", // <--- TIPO NUEVO (DoT que afecta un recurso)
          logMessage: (enemyName, manaDrain, duration) =>
            `${enemyName} te maldice, ¬°drenando ${manaDrain} de tu man√° cada turno durante ${duration} turnos!`,
          effect: {
            dot: {
              resource: "mana", // El recurso a drenar
              drainPerTurn: 15,
              duration: 3,
            },
          },
        },
        // --- HABILIDADES DE CURACI√ìN Y ROBO DE VIDA ---
        basic_heal: {
          name: "Recuperaci√≥n Menor",
          type: "heal",
          logMessage: (enemyName, healAmount) =>
            `${enemyName} se concentra y recupera ${healAmount} de vida.`,
          effect: {
            healAmount: 50,
          },
        },
        life_drain: {
          name: "Drenaje Vital",
          type: "heal_damage", // Hace da√±o Y se cura
          logMessage: (enemyName, damage, healAmount) =>
            `¬°${enemyName} usa Drenaje Vital! Te roba ${damage} de vida y se cura ${healAmount}.`,
          effect: {
            baseDamageMultiplier: 0.8,
            lifesteal: 0.5, // 50% del da√±o infligido se convierte en curaci√≥n para el enemigo
          },
        },

        //--- HABILIDADES DE ATURDIMIENTO
        concussive_blow: {
          name: "Golpe Conmocionador",
          type: "stun_chance", // <--- TIPO NUEVO
          logMessage: (enemyName, damage, didStun) => {
            let msg = `${enemyName} te asesta un Golpe Conmocionador, infligiendo ${damage} de da√±o.`;
            if (didStun) {
              msg += " ¬°Quedas aturdido y pierdes tu pr√≥ximo turno!";
            }
            return msg;
          },
          effect: {
            baseDamageMultiplier: 0.7, // Menos da√±o directo a cambio del potente efecto
            stunChance: 0.4, // 40% de probabilidad de aturdir
          },
        },

        //  HABILIDADES DE BLANCO ESPECIAL

        //  Un ataque que golpea a un clon si est√° activo, o al jugador si no.
        clone_hunter: {
          name: "Cazador de Ilusiones",
          type: "special_target_damage", // <--- TIPO NUEVO
          logMessage: (enemyName, damage, target) => {
            if (target === "clone") {
              return `${enemyName} usa Cazador de Ilusiones y destruye tu clon!`;
            } else {
              return `${enemyName} usa Cazador de Ilusiones, ¬°y te golpea directamente con ${damage} de da√±o!`;
            }
          },
          effect: {
            baseDamageMultiplier: 1.5, // Muy da√±ino si no hay clon
          },
        },
      };

      const entityTypes = {
        //FIJOS
        shop: {
          symbol: "üè™",
          name: "Tienda Misteriosa",
          spriteUrl: "img/shop.png",
          interaction: "browse",
          type: "shop", // 'type' es importante para la interacci√≥n
          // fixedX: 12, // Podr√≠as tener esto
          // fixedY: 13, // O esto
          fixedLocation: { x: 12, y: 13 }, // O esto (preferiblemente esto)
          discovered: true, // ¬°IMPORTANTE para que se muestre desde el inicio!
        },

        secta_entrada_principal: {
          symbol: "‚õ©Ô∏è",
          name: "Sal√≥n Principal de la Secta",
          spriteUrl: "img/secta.png",
          interaction: "access_sect_hall",
          // fixedX: 12, // Si ten√≠as esto antes
          // fixedY: 15, // Si ten√≠as esto antes
          // ASEG√öRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 15, y: 15 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },
        secta_entrada_principal_2: {
          symbol: "",
          name: "Sal√≥n Principal de la Secta",
          
          interaction: "access_sect_hall",
          // fixedX: 12, // Si ten√≠as esto antes
          // fixedY: 15, // Si ten√≠as esto antes
          // ASEG√öRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 16, y: 15 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },
        secta_entrada_principal_3: {
          symbol: "",
          name: "Sal√≥n Principal de la Secta",
          
          interaction: "access_sect_hall",
          // fixedX: 12, // Si ten√≠as esto antes
          // fixedY: 15, // Si ten√≠as esto antes
          // ASEG√öRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 15, y: 14 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },
        secta_entrada_principal_4: {
          symbol: "",
          name: "Sal√≥n Principal de la Secta",
          
          interaction: "access_sect_hall",
          // fixedX: 12, // Si ten√≠as esto antes
          // fixedY: 15, // Si ten√≠as esto antes
          // ASEG√öRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 16, y: 14 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },

        // --- ELEMENTOS DECORATIVOS ---
        deco_pino: {
          symbol: "üå≥",
          name: "Pino",
          spriteUrl: "img/pino.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_peque√±o: {
          symbol: "üå≥",
          name: "Pino",
          spriteUrl: "img/arbol.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_normal: {
          symbol: "",
          name: "Otro arbol",
          spriteUrl: "img/arbol.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_desierto: {
          symbol: "ü™®",
          name: "Roca Musgosa",
          spriteUrl: "img/deco_desierto.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_agua_estancada: {
          name: "Agua Estancada",
          spriteUrl: "img/agua_estancada.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_pantano: {
          symbol: "üå≥",
          name: "Arbol Pantano",
          spriteUrl: "img/arbol_pantano.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_ruina_pilar: {
          symbol: "üèõ",
          name: "Pilar Ca√≠do",
          spriteUrl: "img/columnas.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        }, // Usar un s√≠mbolo diferente si 'üèõÔ∏è' ya est√° en uso
        deco_flor_rara: {
          symbol: "üå∏",
          name: "Flor Luminiscente",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_monta√±a: {
          symbol: "üèõ",
          name: "Monta√±a",
          spriteUrl: "img/terreno_mont.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_monta√±a_large: {
          symbol: "üèõ",
          name: "Monta√±a",
          spriteUrl: "img/deco_monta√±a_large.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        // === NUEVAS DECORACIONES DE ALTO NIVEL ===
        deco_huesos_gigantes: {
          symbol: "ü¶¥",
          name: "Restos de Drag√≥n",
          spriteUrl: "img/deco_huesos.png", // Necesitar√°s una imagen para esto
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_cristal_corrupto: {
          symbol: "üîÆ",
          name: "Cristal Demon√≠aco",
          spriteUrl: "img/deco_cristal_corrupto.png", // Necesitar√°s una imagen para esto
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },

        ///----------------- FIN DECORACIONES------------
        /// ============================  NPCs  ========================================
        npc_secta_guia: {
          symbol: "üë®‚Äçüè´",
          name: "Gu√≠a Lin",
          spriteUrl: "img/guia_lin.png",
          interaction: "talk_secta_npc",
          npcId: "guia_lin",
          fixedLocation: { x: 13, y: 15 },
          discovered: true,
        },
        npc_secta_admin: {
          symbol: " üë¥",
          name: "Administrador Yao",
          spriteUrl: "img/adm_yao.png",
          interaction: "talk_secta_npc",
          npcId: "admin_yao",
          fixedLocation: { x: 17, y: 15 },
          discovered: true,
        },
        npc_anciana_su: {
          symbol: "üëµ",
          name: "Anciana Su, la Archivista",
          spriteUrl: "img/anciana_su.png",
          interaction: "talk_story_npc",
          npcId: "anciana_su",
          fixedLocation: { x: 18, y: 14 },
          discovered: true,
        },
        npc_maestro_jian: {
          symbol: "üëë",
          name: "Maestro de Secta Jian",
          spriteUrl: "img/maestro_jian.png",
          interaction: "talk_story_npc",
          npcId: "maestro_jian",
          fixedLocation: { x: 15, y: 18 },
          discovered: true,
        },
        santuario_del_eco: {
          symbol: "‚õ©Ô∏è",
          name: "Santuario del Eco",
          spriteUrl: "img/santuario_eco.png",
          interaction: "interact_shrine",
          type: "story_shrine",
          fixedLocation: { x: 330, y: 15 },
          discovered: false,
        },
        rival_interno_1: {
          symbol: "üò†",
          name: "Han Li (Guardi√°n Interno)",
          spriteUrl: "img/rival_1.png",
          typeOverride: "monster",
          hp: 250,
          attack: 60,
          defense: 15,
          exp: 150,
          maxHp: 250,
          isSectChallengeRival: true,
          npcId: "rival_interno_1",
          fixedLocation: { x: 5, y: 12 },
        },
        rival_principal_1: {
          symbol: "üò°",
          name: "Anciana Shui (Prueba Principal)",
          spriteUrl: "img/rival_2.png",
          typeOverride: "monster",
          hp: 600,
          attack: 90,
          defense: 25,
          exp: 400,
          maxHp: 600,
          isSectChallengeRival: true,
          npcId: "rival_principal_1",
          fixedLocation: { x: 4, y: 12 },
          specialChance: 0.2,
          specialAttackMultiplier: 1.6,
        },
        guardian_diacono_1: {
          symbol: "üë®‚Äç‚öñÔ∏è",
          name: "Guardi√°n de la Arena, Feng (Prueba de Di√°cono)",
          spriteUrl: "img/rival_3.png", // Necesitar√°s una imagen para √©l
          typeOverride: "monster",
          level: 28,
          hp: 2000,
          maxHp: 2000,
          attack: 150,
          defense: 80,
          exp: 1500,
          isSectChallengeRival: true,
          npcId: "guardian_diacono_1", // ID √∫nico para la misi√≥n
          abilities: [
            { abilityId: "armor_piercing_strike", chance: 0.3 },
            { abilityId: "stone_skin_1", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [300, 400],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 6, y: 14 }, // Posici√≥n en la Arena de la Secta
        },

        guardian_anciano_1: {
          symbol: "üë¥",
          name: "Anciano Guardi√°n, Yao (Prueba de Anciano)",
          spriteUrl: "img/adm_yao.png", // Necesitar√°s una imagen para √©l
          typeOverride: "monster",
          level: 45,
          hp: 4500,
          maxHp: 4500,
          attack: 300,
          defense: 150,
          exp: 4000,
          isSectChallengeRival: true,
          npcId: "guardian_anciano_1",
          abilities: [
            { abilityId: "thorns_aura", chance: 0.25 },
            { abilityId: "life_drain", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [800, 1000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 7, y: 14 }, // Posici√≥n en la Arena de la Secta
        },

        guardian_gran_anciano_1: {
          symbol: "üëµ",
          name: "Gran Anciano de la Hoja, Lin (Prueba de Gran Anciano)",
          spriteUrl: "img/guia_lin.png", // Necesitar√°s una imagen para ella
          typeOverride: "monster",
          level: 62,
          hp: 8000,
          maxHp: 8000,
          attack: 550,
          defense: 220,
          exp: 8000,
          isSectChallengeRival: true,
          npcId: "guardian_gran_anciano_1",
          abilities: [
            { abilityId: "clone_hunter", chance: 0.3 },
            { abilityId: "concussive_blow", chance: 0.25 },
            { abilityId: "basic_heal", chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [1500, 2000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 5, y: 15 }, // Posici√≥n en la Arena de la Secta
        },

        guardian_maestro_1: {
          symbol: "üëë",
          name: "Maestro de Secta Anterior (Prueba Final)",
          spriteUrl: "img/maestro_jian.png", // Necesitar√°s una imagen para √©l
          typeOverride: "monster",
          level: 75,
          hp: 15000,
          maxHp: 15000,
          attack: 700,
          defense: 300,
          exp: 15000,
          isSectChallengeRival: true,
          npcId: "guardian_maestro_1",
          abilities: [
            { abilityId: "mana_curse", chance: 0.4 },
            { abilityId: "intimidating_roar", chance: 0.3 },
            { abilityId: "fire_breath", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Sello del Maestro de Secta",
              quantity: [1, 1],
              chance: 1.0,
            },
          ], // Un item √∫nico como prueba
          fixedLocation: { x: 6, y: 15 }, // Posici√≥n en la Arena de la Secta
        },
        //== FIN NPC===
        //RECURSOS
        cristal_qi: {
          symbol: "üíé",
          name: "Cristal de Qi",
          spriteUrl: "img/cristal_de_qi.png",
          reward: "Cristales de Qi",
          interaction: "collect_resource",
        },
        piedras_espirituales: {
          symbol: "üíé",
          name: "Piedra espiritual",
          spriteUrl: "img/piedra_esp.png",
          reward: "Piedras Espirituales",
          interaction: "collect_resource",
        },
        cultivation: {
          symbol: "üå∏",
          name: "Lugar de Cultivo",
          benefit: "mana",
          manaGain: 20,
          interaction: "meditate_spot",
        },
        resource_hierbas_bosque: {
          symbol: "üåø", // <--- ¬°ASEG√öRATE DE QUE ESTO EST√â!
          name: "Hierbas del Bosque Profundo",
          spriteUrl: "img/hierbas.png",
          type: "resource",
          reward: "Hierbas Medicinales",
          interaction: "collect_resource",
        },
        // Tipo gen√©rico para la plataforma
        teleport_platform: {
          symbol: "üåÄ",
          name: "Matriz de Teletransporte",
          spriteUrl: "img/teleport_plat.png", // ¬°Necesitar√°s crear o encontrar esta imagen!
          interaction: "activate_teleporter", // Esta es la nueva interacci√≥n clave
          discovered: true, // Queremos que se vean en el mapa desde el principio
        },
        tp_sect_hub: {
          symbol: "üåÄ",
          name: "Matriz Central",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",
          teleporterId: "tp_sect_hub",
          fixedLocation: { x: 15, y: 10 },
          discovered: true,
        },
        tp_forest_shrine: {
          symbol: "üåÄ",
          name: "Matriz Bosque esmeralda",
          spriteUrl: "img/teleport_plat.png",

          teleporterId: "tp_forest_shrine",
          interaction: "activate_teleporter",
          fixedLocation: { x: 45, y: 25 },

          discovered: true,
        },
        tp_desert_oasis: {
          symbol: "üåÄ",
          name: "Matriz Desierto",
          spriteUrl: "img/teleport_plat.png",
          teleporterId: "tp_desert_oasis",
          interaction: "activate_teleporter",
          fixedLocation: { x: 40, y: 60 },
          discovered: false,
        },
        tp_swamp_ruin: {
          symbol: "üåÄ",
          name: "Matriz Ruinas 1",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",
          teleporterId: "tp_swamp_ruin",
          fixedLocation: { x: 75, y: 30 },
          discovered: false,
        },
        tp_desfiladero: {
          symbol: "üåÄ",
          name: "Matriz desfiladero",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",
          teleporterId: "tp_desfiladero",
          fixedLocation: { x: 125, y: 30 },
          discovered: false,
        },
        tp_dragon_valley: {
          symbol: "üåÄ",
          name: "Matriz del Valle del Drag√≥n",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",  // La interacci√≥n clave
          teleporterId: "tp_dragon_valley",    // ¬°DEBE coincidir con el ID de TELEPORTER_DATA!
          fixedLocation: { x: 150, y: 15 },    // La ubicaci√≥n f√≠sica DENTRO del valle
          discovered: true, // Para que sea visible en cuanto entres a la zona
      },

        // === NUEVAS ENTIDADES DE TRANSICI√ìN ===
        transition_ruins_entrance: {
          symbol: "üåÄ",
          name: "Entrada a las Ruinas",
          spriteUrl: "img/entrada_ruinas.png", // Crea o usa una imagen para el portal
          interaction: "transition",
          fixedLocation: { x: 45, y: 45 }, // Ubicaci√≥n en el mundo principal
          targetX: 501, // Coordenada X de destino (dentro de la zona de ruinas)
          targetY: 501, // Coordenada Y de destino
          discovered: true,
        },
        transition_ruins_exit: {
          symbol: "üåÄ",
          name: "Salida de las Ruinas",
          spriteUrl: "img/portal.png",
          interaction: "transition",
          fixedLocation: { x: 501, y: 500 }, // Ubicaci√≥n DENTRO de las ruinas
          targetX: 45, // Coordenada X de destino (de vuelta al mundo principal)
          targetY: 45, // Coordenada Y de destino (aparece al lado de la entrada)
          discovered: true,
        },
        transition_valley_entrance: {
          symbol: "üåÄ",
          name: "Entrada al valle del Drag√≥n",
          spriteUrl: "img/entrada_valle_dragon.png", // Crea o usa una imagen para el portal
          interaction: "transition",
          fixedLocation: { x: 143, y: 20 }, // Ubicaci√≥n en el mundo principal
          targetX: 147, // Coordenada X de destino (dentro de la zona de ruinas)
          targetY: 20, // Coordenada Y de destino
          discovered: true,
        },
        transition_valley_exit: {
          symbol: "üåÄ",
          name: "Salida del valle del Drag√≥n",
          spriteUrl: "img/entrada_valle_dragon.png",
          interaction: "transition",
          fixedLocation: { x: 147, y: 20 }, // Ubicaci√≥n DENTRO de las ruinas
          targetX: 143, // Coordenada X de destino (de vuelta al mundo principal)
          targetY: 20, // Coordenada Y de destino (aparece al lado de la entrada)
          discovered: true,
        },

        //ENEMIGOS
        monster: {
          symbol: "üëπ",
          name: "Demonio Menor",
          spriteUrl: "img/demonio_menor.png",
          level: 2,
          hp: 90,
          attack: 30,
          defense: 2,
          exp: 25,
          maxHp: 60,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_secta_debil: {
          symbol: "üêæ",
          name: "Bestia Menor de Pradera",
          spriteUrl: "img/monstruo_pradera.png",
          level: 1,
          hp: 40,
          attack: 30,
          defense: 1,
          exp: 12,
          maxHp: 40,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_bosque_lobo: {
          symbol: "üê∫",
          name: "Lobo del Bosque",
          spriteUrl: "img/lobo_bosque.png",
          hp: 170,
          level: 2,
          attack: 40,
          defense: 3,
          exp: 20,
          maxHp: 170,
          lootTable: [
            { itemName: "Colmillo de Lobo", quantity: [1, 1], chance: 0.4 },
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.6,
            },
            { itemName: "Carne Fresca", quantity: [1, 2], chance: 0.6 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
          ],
        },
        monster_bosque_arana: {
          symbol: "üï∑Ô∏è",
          name: "Ara√±a Tejesombras",
          hp: 250,
          level: 1,
          attack: 45,
          defense: 5,
          exp: 18,
          maxHp: 250,
          lootTable: [
            { itemName: "Seda de Ara√±a", quantity: [1, 3], chance: 0.7 },
            { itemName: "Veneno D√©bil", quantity: [1, 1], chance: 0.2 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            {
              itemName: "Ra√≠z de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.3,
            },
          ],
        },

        monster_desierto_escorpion: {
          symbol: "ü¶Ç",
          name: "Escorpi√≥n de las Dunas",
          spriteUrl: "img/escorpion.png",
          hp: 390,
          level: 9,
          attack: 30,
          defense: 10,
          exp: 35,
          maxHp: 390,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              abilityId: "poison_sting", // ID de la habilidad en enemyAbilityData
              chance: 0.4, // 40% de probabilidad de usar esta habilidad en su turno
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Aguij√≥n de Escorpi√≥n", quantity: [1, 1], chance: 0.5 },
            { itemName: "Quitina Resistente", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
          ],
        },
        monster_desierto_golem_arena: {
          symbol: "üß±",
          name: "Golem de Tormenta de Arena",
          spriteUrl: "img/golem_arena.png",
          hp: 400,
          level: 12,
          attack: 35,
          defense: 15,
          exp: 80,
          maxHp: 400,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              abilityId: " piel_de_piedra", // ID de la habilidad en enemyAbilityData
              chance: 0.4, // 40% de probabilidad de usar esta habilidad en su turno
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [2, 3], chance: 0.3 },
            { itemName: "N√∫cleo de Arena", quantity: [1, 1], chance: 0.6 },
            { itemName: "Fragmento Des√©rtico", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
          ],
        },
        monster_cienaga_serpiente: {
          symbol: "üêç",
          name: "Serpiente de Ci√©naga",
          spriteUrl: "img/serpiente.png",
          hp: 360,
          level: 15,
          attack: 50,
          defense: 6,
          exp: 100,
          maxHp: 360,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              abilityId: "poison_sting", // ID de la habilidad en enemyAbilityData
              chance: 0.3,
            },
          ],
          lootTable: [
            { itemName: "Escama de Serpiente", quantity: [1, 2], chance: 0.5 },
            
            { itemName: "Veneno de Ci√©naga", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [4, 7], chance: 1 },
          ],
        },
        cultivator_rival_low: {
          symbol: "üò†",
          name: "Cultivador Novato Hostil",
          spriteUrl: "img/cultivador_hostil.png",
          hp: 150,
          level: 5,
          attack: 50,
          defense: 5,
          exp: 80,
          maxHp: 150,
          specialChance: 0.2,
          specialAttackMultiplier: 1.5,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
          ],
        },
        monster_alpha: {
          symbol: "üê∫",
          name: "Lobo Alfa",
          spriteUrl: "img/lobo_alfa.png",
          hp: 200,
          level: 9,
          attack: 60,
          defense: 4,
          exp: 100,
          maxHp: 200,
          abilities: [
            { abilityId: "armor_break", chance: 0.3 },
            { abilityId: "intimidating_roar", chance: 0.2 },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            {
              itemName: "N√∫cleo de Bestia Menor",
              quantity: [1, 1],
              chance: 0.25,
            },
            { itemName: "Cristal de Hielo", quantity: [1, 2], chance: 0.1 },
            { itemName: "Esencia de Fuego", quantity: [1, 2], chance: 0.1 },
            { itemName: "Piedras Espirituales", quantity: [4, 10], chance: 1 },
          ],
        },
        cultivator_adept_hostile: {
          symbol: "üò°",
          name: "Cultivador Adepto Agresivo",
          spriteUrl: "img/cultivador_hostil.png",
          hp: 400,
          level: 15,
          attack: 80,
          defense: 20,
          exp: 250,
          maxHp: 400,
          specialChance: 0.25,
          specialAttackMultiplier: 1.7,
          healChance: 0.1,
          lootTable: [
            { itemName: "Piedras Espirituales", quantity: [5, 10], chance: 1 },
            { itemName: "Cristales de Qi", quantity: [3, 10], chance: 0.3 },
           
            { itemName: "Fragmentos de Jade", quantity: [1, 2], chance: 0.02 },
            { itemName: "Esencia Oscura", quantity: [1, 1], chance: 0.05 },
           
          
          ],
        },

        flor_luna_escarchada_guardian: {
          symbol: "‚ùÑÔ∏è",
          name: "Esp√≠ritu de Hielo Protector",
          typeOverride: "monster",
          hp: 120,
          level: 5,
          attack: 35,
          defense: 10,
          exp: 40,
          maxHp: 120,
          lootTable: [
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.8,
            },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
          ],
        },
        raiz_fuego_terrenal_elemental: {
          symbol: "üî•",
          name: "Elemental de Magma Menor",
          typeOverride: "monster",
          hp: 150,
          level: 17,
          attack: 40,
          defense: 5,
          exp: 45,
          maxHp: 150,
          lootTable: [
            {
              itemName: "Ra√≠z de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.7,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [5, 10],
              chance: 0.5,
            },
          ],
        },
        bandido_desfiladero: {
          symbol: "üò†",
          name: "Bandido del Desfiladero",
          spriteUrl: "img/mercenario.png",
          typeOverride: "monster",
          hp: 600,
          level: 19,
          attack: 100,
          defense: 80,
          exp: 600,
          maxHp: 600,
          healChance: 0.15,
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 30],
              chance: 0.5,
            },
           
          ],
          
        },

        esqueleto_podrido: {
          symbol: "üíÄ",
          name: "Esqueleto podrido",
          spriteUrl: "img/esqueleto_1.png",
          typeOverride: "monster",
          hp: 500,
          maxHp: 500,
          level: 20,
          attack: 80,
          defense: 30,
          exp: 120,
          abilities: [
            { abilityId: "mana_curse", chance: 0.35 }, // Dificulta a los jugadores que usan man√°
            { abilityId: "basic_heal", chance: 0.2 }, // Prolonga el combate cur√°ndose
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [8, 10],
              chance: 0.8,
            },
          ],
        },
        jabali_alfa_1: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 53, y: 26 },
        },
        jabali_alfa_2: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 55, y: 26 },
        },
        jabali_alfa_3: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 57, y: 26 },
        },
        jabali_alfa_4: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 59, y: 26 },
        },
        jabali_alfa_5: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 50, y: 28 },
        },
        jabali_alfa_6: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 28 },
        },
        jabali_alfa_7: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 54, y: 28 },
        },
        jabali_alfa_8: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 56, y: 30 },
        },
        jabali_alfa_9: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            /* (mismo loot) */
          ],
          fixedLocation: { x: 58, y: 30 },
        },
        jabali_alfa_10: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 55, y: 32 },
        },
        jabali_alfa_10: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 30 },
        },
        jabali_alfa_11: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 32 },
        },
        jabali_alfa_12: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 34 },
        },
        // ==========================================================
        // === NUEVOS ENEMIGOS DE NIVEL MEDIO (10-20) ===
        // ==========================================================

        // --- ENEMIGOS DEL BOSQUE PROFUNDO ---

        // 1. Osa Mayor Esmeralda (Tanque con Buff de Defensa)
        osa_mayor_esmeralda: {
          symbol: "üêª",
          name: "Osa Mayor Esmeralda",
          spriteUrl: "img/osa_mayor.png", // Necesitar√≠as un sprite para este
          level: 18,
          hp: 1450,
          maxHp: 1450,
          attack: 90,
          defense: 25,
          exp: 150,
          abilities: [
            { abilityId: "stone_skin_1", chance: 0.3 }, // Se vuelve muy dura
            { abilityId: "concussive_blow", chance: 0.15 }, // Un golpe poderoso pero poco frecuente
          ],
          lootTable: [
            {
              itemName: "Piel de Bestia Gruesa",
              quantity: [1, 2],
              chance: 0.7,
            },
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [2, 4],
              chance: 0.5,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 20],
              chance: 1.0,
            },
          ],
        },

        // 2. Treant Anciano (Drenaje de Recursos y Curaci√≥n)
        treant_anciano: {
          symbol: "üå≥",
          name: "Treant Anciano",
          spriteUrl: "img/treant.png", // Necesitar√≠as un sprite para este
          level: 18,
          hp: 600,
          maxHp: 600,
          attack: 80,
          defense: 30,
          exp: 220,
          abilities: [
            { abilityId: "mana_curse", chance: 0.35 }, // Dificulta a los jugadores que usan man√°
            { abilityId: "basic_heal", chance: 0.2 }, // Prolonga el combate cur√°ndose
          ],
          lootTable: [
            {
              itemName: "Coraz√≥n de Madera Viviente",
              quantity: [1, 1],
              chance: 0.4,
            },
            { itemName: "Semillas Ancestrales", quantity: [1, 3], chance: 0.2 },
            {
              itemName: "Piedras Espirituales",
              quantity: [15, 25],
              chance: 1.0,
            },
          ],
        },

        // --- ENEMIGOS DE LA CI√âNAGA SOMBR√çA ---

        // 3. Basilisco de Ci√©naga (Aturdimiento y Veneno)
        basilisco_cienaga: {
          symbol: "ü¶é",
          name: "Basilisco de Ci√©naga",
          spriteUrl: "img/basilisco.png", // Necesitar√≠as un sprite para este
          level: 19,
          hp: 1380,
          maxHp: 1380,
          attack: 65,
          defense: 80,
          exp: 300,
          abilities: [
            { abilityId: "concussive_blow", chance: 0.25 }, // Simula una mirada petrificante con el stun
            { abilityId: "poison_sting", chance: 0.4 }, // Su mordida es venenosa
          ],
          lootTable: [
            { itemName: "Ojo de Basilisco", quantity: [1, 1], chance: 0.3 },
            { itemName: "Escamas Iridiscentes", quantity: [2, 3], chance: 0.6 },
            {
              itemName: "Piedras Espirituales",
              quantity: [12, 22],
              chance: 1.0,
            },
          ],
        },

        // 4. Espectro del Pantano (Drena Vida y Debilita)
        espectro_pantano: {
          symbol: "üëª",
          name: "Espectro del Pantano",
          spriteUrl: "img/espectro.png", // Necesitar√≠as un sprite para este
          level: 17,
          hp: 550,
          maxHp: 550,
          attack: 180,
          defense: 15, // Baja defensa f√≠sica, pero peligroso
          exp: 250,
          abilities: [
            { abilityId: "life_drain", chance: 0.8 }, // Se cura a costa del jugador
            { abilityId: "intimidating_roar", chance: 0.25 }, // Su lamento debilita el ataque
          ],
          lootTable: [
            { itemName: "Esencia Espectral", quantity: [1, 2], chance: 0.5 },
            { itemName: "Almas Condenadas", quantity: [1, 1], chance: 0.25 },
            {
              itemName: "Piedras Espirituales",
              quantity: [20, 30],
              chance: 1.0,
            },
          ],
        },

        // --- ENEMIGOS DEL DESIERTO ABRASADOR ---

        // 5. Djinn de las Arenas (Ataque perforante)
        djinn_arenas: {
          symbol: "üßû",
          name: "Djinn de las Arenas",
          spriteUrl: "img/djinn.png", // Necesitar√≠as un sprite para este
          level: 19,
          hp: 650,
          maxHp: 650,
          attack: 100,
          defense: 20,
          exp: 300,
          abilities: [
            { abilityId: "armor_piercing_strike", chance: 0.4 }, // Su cimitarra de viento corta cualquier armadura
            { abilityId: "fire_breath", chance: 0.2 }, // Aliento abrasador del desierto
          ],
          lootTable: [
            {
              itemName: "Coraz√≥n de Tormenta de Arena",
              quantity: [1, 1],
              chance: 0.2,
            },
            { itemName: "Esencia de Fuego", quantity: [2, 4], chance: 0.5 },
            {
              itemName: "Piedras Espirituales",
              quantity: [25, 40],
              chance: 1.0,
            },
          ],
        },

        // 6. Gusano de las Dunas Colosal (Tanque con reflejo de da√±o)
        gusano_dunas_colosal: {
          symbol: "üêõ",
          name: "Gusano de las Dunas Colosal",
          spriteUrl: "img/gusano.png", // Necesitar√≠as un sprite para este
          level: 21,
          hp: 1000,
          maxHp: 1000,
          attack: 160,
          defense: 60,
          exp: 500,
          abilities: [
            { abilityId: "thorns_aura", chance: 0.3 }, // Su piel quitinosa da√±a a los atacantes
            { abilityId: "armor_break", chance: 0.2 }, // Su mordida aplastante rompe defensas
          ],
          lootTable: [
    
            {
              itemName: "Piedras Espirituales",
              quantity: [50, 75],
              chance: 1.0,
            },
          ],
        },

        // --- CULTIVADORES RIVALES Y BANDIDOS ---

        // 7. Cultivador Renegado (Equilibrado y peligroso)
        cultivador_renegado: {
          symbol: "üò°",
          name: "Cultivador Renegado",
          spriteUrl: "img/cultivador_hostil.png", // Un sprite de cultivador m√°s avanzado
          level: 25,
          hp: 500,
          maxHp: 500,
          attack: 75,
          defense: 50,
          exp: 1000,
          abilities: [
            { abilityId: "armor_piercing_strike", chance: 0.25 }, // Sabe d√≥nde golpear
            { abilityId: "basic_heal", chance: 0.15 }, // Usa p√≠ldoras para curarse
            { abilityId: "fire_breath", chance: 0.2 }, // Usa una t√©cnica de fuego
          ],
          lootTable: [
            {
              itemName: "P√≠ldora de Recuperaci√≥n Menor",
              quantity: [1, 2],
              chance: 0.3,
            },
           /*  {
              itemName: "Rollo: T√©cnica Aleatoria Menor",
              quantity: [1, 1],
              chance: 0.05,
            }, // Requerir√≠a una l√≥gica de loot especial */
            {
              itemName: "Piedras Espirituales",
              quantity: [30, 50],
              chance: 1.0,
            },
          ],
        },

        // 8. Mercenario Acorazado (Defensa y Stun)//valle del dragon
        mercenario_acorazado: {
          symbol: "üõ°Ô∏è",
          name: "Mercenario Acorazado",
          spriteUrl: "img/mercenario.png", // Necesitar√≠as un sprite para este
          level: 27,
          hp: 1500,
          maxHp: 1500,
          attack: 150,
          defense: 70,
          exp: 1600,
          abilities: [
            { abilityId: "stone_skin_1", chance: 0.4 }, // Siempre mantiene su defensa alta
            { abilityId: "concussive_blow", chance: 0.2 }, // Golpe de escudo
          ],
          lootTable: [
            {
              itemName: "Fragmento de Armadura Pesada",
              quantity: [1, 1],
              chance: 0.6,
            },
            {
              itemName: "Contrato de Mercenario",
              quantity: [1, 1],
              chance: 0.1,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [15, 25],
              chance: 1.0,
            },
          ],
        },

        // --- ENEMIGOS DE RUINAS ANTIGUAS ---

        // 9. Guardi√°n de Terracota (Defensivo y con Reflejo)
        guardian_terracota: {
          symbol: "üóø",
          name: "Guardi√°n de Terracota",
          spriteUrl: "img/guardian_terracota.png", // Necesitar√≠as un sprite para este
          level: 19,
          hp: 1000,
          maxHp: 1000,
          attack: 70,
          defense: 50,
          exp: 350,
          abilities: [
            { abilityId: "thorns_aura", chance: 0.25 }, // Su superficie encantada devuelve el da√±o
            { abilityId: "stone_skin_1", chance: 0.25 }, // Se endurece a√∫n m√°s
            { abilityId: "armor_break", chance: 0.15 }, // Un golpe para ablandar al objetivo
          ],
          lootTable: [
            { itemName: "Fragmentos de Jade", quantity: [2, 5], chance: 0.5 },
            {
              itemName: "N√∫cleo de Golem Antiguo",
              quantity: [1, 1],
              chance: 0.2,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [40, 60],
              chance: 1.0,
            },
          ],
        },

        // 10. Ilusionista Sombr√≠o (Cazador de Clones y Drenaje de Man√°)// valle del dragon
        ilusionista_sombrio: {
          symbol: "üë§",
          name: "Ilusionista Sombr√≠o",
          spriteUrl: "img/ilusionista.png", // Necesitar√≠as un sprite para este
          level: 28,
          hp: 800,
          maxHp: 800,
          attack: 85, // Golpea duro si te pilla sin defensas
          defense: 40,
          exp: 320,
          abilities: [
            { abilityId: "clone_hunter", chance: 0.5 }, // Su principal estrategia es eliminar clones
            { abilityId: "mana_curse", chance: 0.3 }, // Te deja sin recursos para contraatacar
          ],
          lootTable: [
    
            {
              itemName: "Piedras Espirituales",
              quantity: [35, 55],
              chance: 1.0,
            },
          ],
        },
        // === NUEVOS ENEMIGOS Y JEFES DE ALTO NIVEL ===

        // -- Nivel Di√°cono (Nivel 20-30) --
        cultivador_secta_rival: {
          symbol: "‚öîÔ∏è",
          name: "Cultivador de la Secta de la Llama Negra",
          spriteUrl: "img/rival_1.png",
          level: 22,
          hp: 800,
          maxHp: 800,
          attack: 170,
          defense: 80,
          exp: 450,
          abilities: [
            { abilityId: "fire_breath", chance: 0.3 },
            { abilityId: "armor_piercing_strike", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "P√≠ldora de Recuperaci√≥n Menor",
              quantity: [1, 2],
              chance: 0.2,
            },
            {
              itemName: "Insignia de Secta Rival",
              quantity: [1, 1],
              chance: 0.5,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [40, 60],
              chance: 1.0,
            },
          ],
        },
        murcielago_cristal_sangriento: {
          symbol: "ü¶á",
          name: "Murci√©lago de Cristal Sangriento",
          spriteUrl: "img/murcielago_sangre.png",
          level: 25,
          hp: 800,
          maxHp: 800,
          attack: 190,
          defense: 80,
          exp: 500,
          abilities: [{ abilityId: "life_drain", chance: 0.4 }],
          lootTable: [
            {
              itemName: "Cristal de Sangre Puro",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [50, 75],
              chance: 1.0,
            },
          ],
        },
        diacono_renegado_jin: {
          symbol: "üëø",
          name: "Di√°cono Renegado Jin (Jefe)",
          spriteUrl: "img/rival_3.png",
          typeOverride: "monster",
          level: 30,
          hp: 2500,
          maxHp: 2500,
          attack: 180,
          defense: 60,
          exp: 2000,
          isBoss: true,
          abilities: [
            { abilityId: "thorns_aura", chance: 0.3 },
            { abilityId: "armor_break", chance: 0.25 },
            { abilityId: "basic_heal", chance: 0.15 },
          ],
          lootTable: [
           
            {
              itemName: "Piedras Espirituales",
              quantity: [50, 100],
              chance: 1.0,
            },
            {
            itemName: "Rollo: T√©cnica de Absorci√≥n de Qi Celestial",
              quantity: [1, 1],
              chance: 1.0, // 
            },
          ],
          fixedLocation: { x: 90, y: 15 }, // Ubicaci√≥n en el Desfiladero
        },

        // -- Nivel Anciano (Nivel 35-45) --
        draco_hueso_antiguo: {
          symbol: "üêâ",
          name: "Draco de Hueso Antiguo",
          spriteUrl: "img/draco_hueso.png",
          level: 38,
          hp: 1500,
          maxHp: 1500,
          attack: 350,
          defense: 100,
          exp: 1200,
          abilities: [
            { abilityId: "intimidating_roar", chance: 0.3 },
            { abilityId: "mana_curse", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Escama de Drag√≥n Espectral",
              quantity: [1, 2],
              chance: 0.4,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [200, 250],
              chance: 1.0,
            },
          ],
        },
        draco_hueso_antiguo_boss: {
          symbol: "üêâ",
          name: "Draco de Hueso Antiguo (BOSS)",
          spriteUrl: "img/draco_hueso_boss.png",
          level: 38,
          hp: 2000,
          maxHp: 2000,
          attack: 380,
          defense: 120,
          exp: 12000,
          abilities: [
            { abilityId: "intimidating_roar", chance: 0.8 },
            { abilityId: "mana_curse", chance: 0.5 },
          ],
          lootTable: [
            {
              itemName: "Escama de Drag√≥n Espectral",
              quantity: [1, 2],
              chance: 0.4,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [1000, 1200],
              chance: 1.0,
            },
          ],
        },
        espectro_tifonico: {
          symbol: "üå™Ô∏è",
          name: "Espectro Tif√≥nico",
          spriteUrl: "img/espectro_tifon.png",
          level: 40,
          hp: 1200,
          maxHp: 1200,
          attack: 700,
          defense: 80,
          exp: 1500,
          abilities: [
            { abilityId: "mana_curse", chance: 0.4 },
            { abilityId: "concussive_blow", chance: 0.6 },
          ],
          lootTable: [
            { itemName: "Coraz√≥n de Tif√≥n", quantity: [1, 1], chance: 0.25 },
            {
              itemName: "Piedras Espirituales",
              quantity: [120, 250],
              chance: 1.0,
            },
          ],
        },
        emperador_lich_del_valle: {
          symbol: "üëë",
          name: "Emperador Lich del Valle (Jefe)",
          spriteUrl: "img/lich_emperador.png",
          typeOverride: "monster",
          level: 48,
          hp: 5000,
          maxHp: 5000,
          attack: 350,
          defense: 120,
          exp: 5000,
          isBoss: true,
          abilities: [
            { abilityId: "life_drain", chance: 0.3 },
            { abilityId: "mana_curse", chance: 0.3 },
            { abilityId: "clone_hunter", chance: 0.2 },
          ], // Asume que el jugador podr√≠a tener clones a este nivel
          lootTable: [
            { itemName: "Filacteria del Lich", quantity: [1, 1], chance: 1.0 },
            {
              itemName: "Rollo: T√©cnica de Anciano Aleatoria",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [200, 250],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 350, y: 20 }, // Ubicaci√≥n en el Valle del Drag√≥n Ca√≠do
        },

        // -- Nivel Gran Anciano (Nivel 50-60) --
        demonio_de_la_fisura: {
          symbol: "üëπ",
          name: "Demonio de la Fisura",
          spriteUrl: "img/demonio_fisura.png",
          level: 55,
          hp: 2500,
          maxHp: 2500,
          attack: 500,
          defense: 150,
          exp: 3000,
          abilities: [
            {
              abilityId: "fire_breath",
              chance: 0.5,
              effect: { burnDamagePerTurn: 100, duration: 3 },
            },
            { abilityId: "armor_break", chance: 0.3 },
          ],
          lootTable: [
            {
              itemName: "Fragmento de la Fisura",
              quantity: [1, 1],
              chance: 0.4,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [250, 400],
              chance: 1.0,
            },
          ],
        },
        guardian_celestial_caido: {
          symbol: "üëº",
          name: "Guardi√°n Celestial Ca√≠do",
          spriteUrl: "img/guardian_caido.png",
          level: 60,
          hp: 4000,
          maxHp: 4000,
          attack: 450,
          defense: 250,
          exp: 4000,
          abilities: [
            { abilityId: "stone_skin_1", chance: 0.3 },
            { abilityId: "basic_heal", chance: 0.2 },
          ],
          lootTable: [
            { itemName: "L√°grima Celestial", quantity: [1, 1], chance: 0.2 },
            {
              itemName: "Piedras Espirituales",
              quantity: [300, 500],
              chance: 1.0,
            },
          ],
        },
        general_demoniaco_abismal: {
          symbol: "üòà",
          name: "General Demon√≠aco Abismal (Jefe)",
          spriteUrl: "img/general_abismal.png",
          typeOverride: "monster",
          level: 65,
          hp: 10000,
          maxHp: 10000,
          attack: 600,
          defense: 200,
          exp: 10000,
          isBoss: true,
          abilities: [
            { abilityId: "intimidating_roar", chance: 0.4 },
            { abilityId: "thorns_aura", chance: 0.3 },
            { abilityId: "fire_breath", chance: 0.2 },
          ],
          lootTable: [
            { itemName: "Coraz√≥n del Abismo", quantity: [1, 1], chance: 1.0 },
            {
              itemName: "Rollo: T√©cnica de Gran Anciano Aleatoria",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [2000, 3000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 425, y: 35 }, // Ubicaci√≥n en la Fisura
        },

        // -- Nivel Maestro de Secta (Nivel 70+) --
        avatar_del_dao_corrupto: {
          symbol: "‚òØÔ∏è",
          name: "Avatar del Dao Corrupto (Jefe Final)",
          spriteUrl: "img/avatar_dao.png",
          typeOverride: "monster",
          level: 80,
          hp: 25000,
          maxHp: 25000,
          attack: 800,
          defense: 300,
          exp: 50000,
          isBoss: true,
          abilities: [
            { abilityId: "mana_curse", chance: 0.5 },
            { abilityId: "life_drain", chance: 0.4 },
            { abilityId: "thorns_aura", chance: 0.3 },
            { abilityId: "concussive_blow", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Semilla del Dao Verdadero",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [10000, 10000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 15, y: 12 }, // Aparece cerca de la secta para el enfrentamiento final
        },

        //BOSSES
        jabali_colmilludo_alfa: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo Alfa (BOSS)",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 400,
          level: 10,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,
          isBoss: true,
          healChance: 0.2,
          lootTable: [
            {
              itemName: "Colmillo de Jabal√≠ Alfa",
              quantity: [1, 1],
              chance: 0.9,
            },
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },
            { itemName: "Piel Resistente", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [6, 10], chance: 1 },
          ],
          fixedLocation: { x: 57, y: 28 },
        },

        golem_de_piedra: {
          symbol: "üóø",
          name: "Golem de piedra",
          spriteUrl: "img/golem_jade.png",
          typeOverride: "monster",
          hp: 800,
          level: 11,
          attack: 55,
          defense: 50,
          exp: 500,
          maxHp: 800,
          abilities: [
            {
              name: "Golpe S√≠smico",
              damageMultiplier: 2.0,
              chance: 0.1,
              type: "area_attack_simulated",
            },
            { name: "Restauraci√≥n P√©trea", healPercentage: 0.2, chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 15],
              chance: 1.0,
            },
            {
              itemName: "Coraz√≥n de Golem de Jade",
              quantity: [1, 1],
              chance: 0.9,
            },

            { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
            {
              itemName: "N√∫cleo Elemental",
              quantity: [1, 2],
              chance: 0.3,
              extraData: { elementalType: "earth" },
            },
          ],
        },

        lider_renegado_1: {
          symbol: "üë§",
          name: "L√≠der Cultor Renegado Kai",
          typeOverride: "monster",
          hp: 500,
          level: 15,
          attack: 70,
          defense: 25,
          exp: 250,
          maxHp: 500,
          isMiniBoss: true,
          specialChance: 0.25,
          specialAttackMultiplier: 1.6,
          lootTable: [
            {
              itemName: "Comp√°s Espiritual Antiguo",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "P√≠ldora de Qi Condensado",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 20],
              chance: 0.8,
            },
          ],
          fixedLocation: { x: 17, y: 12 },
        },

        //BOSSES

        boss_dem: {
          symbol: "üëø",
          name: "General Demonio",
          spriteUrl: "img/boss_dem.png",
          typeOverride: "monster",
          hp: 500,
          level: 10,
          attack: 45,
          defense: 20,
          exp: 1000,
          maxHp: 500,
          isBoss: true,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          healChance: 0.15,
          abilities: [{ abilityId: "fire_breath", chance: 0.3 }],

          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [20, 100],
              chance: 1.0,
            },
            {
              itemName: "N√∫cleo Demon√≠aco Mayor",
              quantity: [1, 1],
              chance: 0.8,
            },
       

        
          ],
          nextBossId: "boss_ancient_golem",
          fixedLocation: { x: 9, y: 36 },
        },

        boss_ancient_golem: {
          symbol: "üóø",
          name: "Golem Ancestral de Jade",
          spriteUrl: "img/golem_jade.png",
          typeOverride: "monster",
          hp: 800,
          level: 11,
          attack: 65,
          defense: 50,
          exp: 500,
          maxHp: 800,
          isBoss: true,
          abilities: [
            {
              name: "Golpe S√≠smico",
              damageMultiplier: 2.0,
              chance: 0.2,
              type: "area_attack_simulated",
            },
            { name: "Restauraci√≥n P√©trea", healPercentage: 0.2, chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 15],
              chance: 1.0,
            },
            {
              itemName: "Coraz√≥n de Golem de Jade",
              quantity: [1, 1],
              chance: 0.9,
            },

            { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
            {
              itemName: "N√∫cleo Elemental",
              quantity: [1, 2],
              chance: 0.3,
              extraData: { elementalType: "earth" },
            },
          ],
          nextBossId: null,
          fixedLocation: { x: 72, y: 51 },
        },
      };
      //------------------------   ITEMS ---------------------------------------------------
      const itemData = {
        "Hierbas Medicinales": {
          description: "Restaura un 30 de HP.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al m√°ximo.";
            const h = 30;
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Usada P√≠ldora, recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Cristales de Qi": {
          description: "Restaura un 30% de tu Man√° M√°ximo.",
          effect: (ps) => {
            if (ps.mana >= ps.maxMana) return "Man√° al m√°ximo.";
            const h = Math.floor(ps.maxMana * 0.3);
            const o = ps.mana;
            ps.mana = Math.min(ps.maxMana, ps.mana + h);
            return `Recuperado ${ps.mana - o} Man√°.`;
          },
          canUse: (ps) => ps.mana < ps.maxMana,
        },
        "Piedras Espirituales": {
          description: "Imbuida de energ√≠a. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Piedra Espiritual y ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Flor de Luna Escarchada": {
          description: "Flor brillante usada en alquimia.Item de misi√≥n",
          canUse: () => false,
        },
        "Ra√≠z de Fuego Terrenal": {
          description: "Ra√≠z que irradia calor, ingrediente alqu√≠mico.",
          canUse: () => false,
        },
        "P√≠ldora de Recuperaci√≥n Menor": {
          description: "P√≠ldora alqu√≠mica que restaura 50 HP.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al m√°ximo.";
            const h = 50;
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Usada P√≠ldora, recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Esencia Espectral": {
          description:
            "Un residuo et√©reo dejado por un espectro. Se usa en rituales y alquimia avanzada. Item de Misi√≥n.",
          canUse: () => false, // No es un consumible
        },
        "Talism√°n de Percepci√≥n": {
          description: "Agudiza sentidos. Otorga EXP.",
          effect: (ps, gex) => {
            gex(100);
            return `Estudiado Talism√°n, ganado 100 EXP.`;
          },
          canUse: () => true,
        },
        "Colmillo de Jabal√≠ Alfa": {
          description:
            "Colmillo intacto de Jabal√≠ Alfa. Item de misi√≥n de caza.",
          canUse: () => false,
        },
        "Carne de Bestia Ex√≥tica": {
          description: "Nutritiva. Restaura 25% HP y 10% Man√°.",
          effect: (ps) => {
            let m = "";
            const hA = Math.floor(ps.maxHp * 0.25);
            if (ps.hp < ps.maxHp) {
              const o = ps.hp;
              ps.hp = Math.min(ps.maxHp, ps.hp + hA);
              m += `Recuperado ${ps.hp - o} HP. `;
            }
            const mA = Math.floor(ps.maxMana * 0.1);
            if (ps.mana < ps.maxMana) {
              const o = ps.mana;
              ps.mana = Math.min(ps.maxMana, ps.mana + mA);
              m += `Recuperado ${ps.mana - o} Man√°.`;
            }
            return m || "HP y Man√° al m√°ximo.";
          },
          canUse: (ps) => ps.hp < ps.maxHp || ps.mana < ps.maxMana,
        },
        "Mapa del Tesoro Fragmentado": {
          description: "Fragmento de mapa antiguo. ¬øOtras partes?",
          effect: (ps, gex) => {
            gex(50);
            return `Examinado fragmento, ganado 50 EXP. Indica zona monta√±osa...`;
          },
          canUse: () => true,
        },
        "Comp√°s Espiritual Antiguo": {
          description: "Artefacto de secta que resuena con energ√≠as.",
          canUse: () => false,
        },
        "Manual de Formaci√≥n B√°sica": {
          description: "Ense√±a principios de formaciones defensivas.",
          effect: (ps) => {
            ps.baseDefense += 2;
            recalculatePlayerStats();
            return `Estudiado Manual. Defensa base +2.`;
          },
          canUse: () => true,
        },
        "N√∫cleo de Bestia Menor": {
          description: "N√∫cleo de bestia demon√≠aca. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido N√∫cleo, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Insignia de Secta Rival": {
          description:
            "Una insignia de la Secta de la Llama Negra. Prueba de tus victorias.",
          canUse: () => false,
        },
        "Cristal de Sangre Puro": {
          description:
            "Un cristal que pulsa con energ√≠a vital. Valioso para la alquimia de alto nivel.",
          canUse: () => false,
        },
        "Manual de T√©cnica de Di√°cono": {
          description:
            "Un manual que detalla una t√©cnica de nivel Di√°cono. Contiene profundos conocimientos.",
          effect: (ps, gex) => {
            gex(1000); // Da una buena cantidad de EXP
            return `Has estudiado el manual del di√°cono renegado. Ganas 1000 EXP y una nueva comprensi√≥n del combate.`;
          },
          canUse: () => true,
        },
        "Escama de Drag√≥n Espectral": {
          description:
            "Una escama et√©rea y resistente, imbuida con el resentimiento de un drag√≥n.",
          canUse: () => false,
        },
        "Coraz√≥n de Tif√≥n": {
          description:
            "El n√∫cleo arremolinado de un espectro elemental. Irradia un poder inmenso.",
          canUse: () => false,
        },
        "Filacteria del Lich": {
          description:
            "El recipiente del alma del Emperador Lich. Su destrucci√≥n asegura su final. Irradia poder oscuro.",
          effect: (ps, gex) => {
            gex(5000);
            return `Al destruir la filacteria, una oleada de energ√≠a pura te recorre. Ganas 5000 EXP.`;
          },
          canUse: () => true,
        },
        "Fragmento de la Fisura": {
          description:
            "Un trozo de realidad de un plano demon√≠aco. Es inestable y peligroso.",
          canUse: () => false,
        },
        "L√°grima Celestial": {
          description:
            "Una l√°grima cristalizada de un ser celestial. Contiene una pureza incre√≠ble.",
          canUse: () => false,
        },
        "Coraz√≥n del Abismo": {
          description:
            "El coraz√≥n de un general demon√≠aco. Es la fuente de su poder abismal.",
          effect: (ps, gex) => {
            gex(10000);
            player.baseMaxHp += 500;
            recalculatePlayerStats();
            return `Has purificado el Coraz√≥n del Abismo, fortaleciendo tu propia base vital. Ganas 10000 EXP y 500 HP M√°ximo base.`;
          },
          canUse: () => true,
        },
        "Semilla del Dao Verdadero": {
          description:
            "Un fragmento del origen de toda la cultivaci√≥n. Su estudio podr√≠a llevarte a la trascendencia.",
          effect: (ps) => {
            // Podr√≠a desbloquear una mec√°nica de post-juego o dar una mejora final masiva.
            ps.level += 5;
            levelUp(); // Simula varias subidas de nivel
            return `Has meditado sobre la Semilla del Dao, alcanzando una iluminaci√≥n sin precedentes. Tu nivel y poder se disparan.`;
          },
          canUse: () => true,
        },
        
      

        "Sello del Maestro de Secta": {
          description:
            "La prueba de que has superado al Maestro anterior. Irradia una autoridad inmensa. Item de Misi√≥n.",
          canUse: () => false,
        },
        "Rollo: T√©cnica de Absorci√≥n de Qi Celestial": {
          description: "Ense√±a 'T√©cnica de Absorci√≥n de Qi Celestial'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_absorption_celestial_1"),
          canUse: () => true,
        },
        /// ========================   ROLLOS DE T√âCNICAS    ============================

        // -- Rollos Grado 1 --
        "Rollo: Tajo del Viento Veloz": {
          description: "Ense√±a 'Tajo del Viento Veloz'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t1"),
          canUse: () => true,
        },
        "Rollo: F√≠sico de Buey de Piedra": {
          description: "Ense√±a 'F√≠sico de Buey de Piedra'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t1"),
          canUse: () => true,
        },
        "Rollo: Matriz de Escudo de Qi": {
          description: "Ense√±a 'Matriz de Escudo de Qi'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t1"),
          canUse: () => true,
        },
        "Rollo: Chispa √çgnea": {
          description: "Ense√±a 'Chispa √çgnea'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t1"),
          canUse: () => true,
        },
        "Rollo: Dedo de Rel√°mpago": {
          description: "Ense√±a 'Dedo de Rel√°mpago'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t1"),
          canUse: () => true,
        },
        "Rollo: Paso Veloz": {
          description: "Ense√±a 'Paso Veloz'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t1"),
          canUse: () => true,
        },

        // -- Rollos Grado 2 --
        "Rollo: Estocada Perfora-Armadura": {
          description: "Ense√±a 'Estocada Perfora-Armadura'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t2"),
          canUse: () => true,
        },
        "Rollo: Piel de Acero Fundido": {
          description: "Ense√±a 'Piel de Acero Fundido'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t2"),
          canUse: () => true,
        },
        "Rollo: Matriz de Grilletes de Qi": {
          description: "Ense√±a 'Matriz de Grilletes de Qi'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t2"),
          canUse: () => true,
        },
        "Rollo: Paso Et√©reo": {
          description: "Ense√±a 'Paso Et√©reo'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t2"),
          canUse: () => true,
        },
        "Rollo: Aliento de Drag√≥n Menor": {
          description: "Ense√±a 'Aliento de Drag√≥n Menor'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t2"),
          canUse: () => true,
        },

        // -- Rollos Grado 3 --
        "Rollo: Danza de Espada Cicl√≥nica": {
          description: "Ense√±a 'Danza de Espada Cicl√≥nica'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t3"),
          canUse: () => true,
        },
        "Rollo: Coraz√≥n de Voluntad Indomable": {
          description: "Ense√±a 'Coraz√≥n de Voluntad Indomable'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t3"),
          canUse: () => true,
        },
        "Rollo: Matriz de Supresi√≥n Espiritual": {
          description: "Ense√±a 'Matriz de Supresi√≥n Espiritual'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t3"),
          canUse: () => true,
        },
       "Rollo: Jaula de Rayos": {
          description: "Ense√±a 'Jaula de Rayos'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t3"),
          canUse: () => true,
        },
        "Rollo: Parpadeo de Sombra": {
          description: "Ense√±a 'Parpadeo de Sombra'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t3"),
          canUse: () => true,
        },

        // -- Rollos Grado 4 --
        "Rollo: Intento de Espada del Tirano": {
          description: "Ense√±a 'Intento de Espada del Tirano'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t4"),
          canUse: () => true,
        },
        "Rollo: Cuerpo Dorado Inmortal": {
          description: "Ense√±a 'Cuerpo Dorado Inmortal'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t4"),
          canUse: () => true,
        },
        "Rollo: Sol Abrasador": {
          description: "Ense√±a 'Sol Abrasador'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t4"),
          canUse: () => true,
        },
        "Rollo: Llamada del Juicio del Trueno": {
          description: "Ense√±a 'Llamada del Juicio del Trueno'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t4"),
          canUse: () => true,
        },
        "Rollo: Santuario Dorado Protector": {
          description: "Ense√±a 'Santuario Dorado Protector'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t4"),
          canUse: () => true,
        },
        // -- Rollos Grado 5 --
        "Rollo: Corte que Divide Cielos y Tierra": {
          description: "Ense√±a 'Corte que Divide Cielos y Tierra'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"),
          canUse: () => true,
        },
        "Rollo: Constituci√≥n de Drag√≥n Ancestral": {
          description: "Ense√±a 'Constituci√≥n de Drag√≥n Ancestral'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"),
          canUse: () => true,
        },
        "Rollo: Llama del F√©nix Renaciente": {
          description: "Ense√±a 'Llama del F√©nix Renaciente'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"),
          canUse: () => true,
        },
        "Rollo: Tribulaci√≥n de los Nueve Cielos": {
          description: "Ense√±a 'Tribulaci√≥n de los Nueve Cielos'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"),
          canUse: () => true,
        },
        "Rollo: Matriz de Reversi√≥n del Cosmos": {
          description: "Ense√±a 'Matriz de Reversi√≥n del Cosmos'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"),
          canUse: () => true,
        },
        "Rollo: Paso del Vac√≠o Infinito": {
          description: "Ense√±a 'Paso del Vac√≠o Infinito'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"),
          canUse: () => true,
        },

        // -- Rollos Grado 6 --
        "Rollo: Espada del Emperador Celestial": {
          description: "Ense√±a 'Espada del Emperador Celestial'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"),
          canUse: () => true,
        },
        "Rollo: Cuerpo Inmortal de Jade": {
          description: "Ense√±a 'Cuerpo Inmortal de Jade'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t6"),
          canUse: () => true,
        },
        "Rollo: Incineraci√≥n del Mundo Mortal": {
          description: "Ense√±a 'Incineraci√≥n del Mundo Mortal'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t6"),
          canUse: () => true,
        },
        "Rollo: Decreto del Se√±or del Trueno": {
          description: "Ense√±a 'Decreto del Se√±or del Trueno'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t6"),
          canUse: () => true,
        },
        "Rollo: Matriz del Sello del Demonio": {
          description: "Ense√±a 'Matriz del Sello del Demonio'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t6"),
          canUse: () => true,
        },
        "Rollo: Omnipresencia Divina": {
          description: "Ense√±a 'Omnipresencia Divina'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t6"),
          canUse: () => true,
        },
        // -- Rollos Grado 7 --
        "Rollo: Lamento del Fin del Mundo": {
          description: "Ense√±a 'Lamento del Fin del Mundo'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"),
          canUse: () => true,
        },
        "Rollo: Forma del Ancestro Primordial": {
          description: "Ense√±a 'Forma del Ancestro Primordial'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"),
          canUse: () => true,
        },
        "Rollo: G√©nesis √çgneo": {
          description: "Ense√±a 'G√©nesis √çgneo'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"),
          canUse: () => true,
        },
        "Rollo: C√≥lera del Emperador Celestial": {
          description: "Ense√±a 'C√≥lera del Emperador Celestia'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"),
          canUse: () => true,
        },
        "Rollo: Matriz del Caos Primordial": {
          description: "Ense√±a 'Matriz del Caos Primordial'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"),
          canUse: () => true,
        },
        "Rollo: Danza del Tejido Espacio-Tiempo": {
          description: "Ense√±a 'Danza del Tejido Espacio-Tiempo'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"),
          canUse: () => true,
        },

        // -- Rollos Grado 8 --
        "Rollo: Decreto Imperial: Extinci√≥n": {
          description: "Decreto Imperial: Extinci√≥n'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"),
          canUse: () => true,
        },
        "Rollo: Avatar del Dao Eterno": {
          description: "Ense√±a 'Avatar del Dao Eterno'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t6"),
          canUse: () => true,
        },
        "Rollo: Apocalipsis de Llamas Divinas": {
          description: "Ense√±a 'Apocalipsis de Llamas Divinas'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t6"),
          canUse: () => true,
        },
        "Rollo: Tribulaci√≥n del Fin de los Tiempos": {
          description: "Ense√±a 'Tribulaci√≥n del Fin de los Tiempos'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t6"),
          canUse: () => true,
        },
        "Rollo: Matriz de Reescritura de la Realidad": {
          description: "Ense√±a 'Matriz de Reescritura de la Realidad'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t6"),
          canUse: () => true,
        },
        "Rollo: Trascendencia Dimensional": {
          description: "Ense√±a 'Trascendencia Dimensional'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t6"),
          canUse: () => true,
        },
        // -- Rollos Grado 9 --
        "Rollo: Corte del Origen Absoluto": {
          description: "Ense√±a 'Corte del Origen Absoluto'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"),
          canUse: () => true,
        },
        "Rollo: Constituci√≥n de Drag√≥n Ancestral": {
          description: "Ense√±a 'Constituci√≥n de Drag√≥n Ancestral'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"),
          canUse: () => true,
        },
        "Rollo: Llama del F√©nix Renaciente": {
          description: "Ense√±a 'Llama del F√©nix Renaciente'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"),
          canUse: () => true,
        },
        "Rollo: Tribulaci√≥n de los Nueve Cielos": {
          description: "Ense√±a 'Tribulaci√≥n de los Nueve Cielos'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"),
          canUse: () => true,
        },
        "Rollo: Matriz de Reversi√≥n del Cosmos": {
          description: "Ense√±a 'Matriz de Reversi√≥n del Cosmos'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"),
          canUse: () => true,
        },
        "Rollo: Paso del Vac√≠o Infinito": {
          description: "Ense√±a 'Paso del Vac√≠o Infinito'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"),
          canUse: () => true,
        },

        // -- Rollos Grado 10 --
        "Rollo: Espada del Emperador Celestial": {
          description: "Ense√±a 'Espada del Emperador Celestial'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"),
          canUse: () => true,
        },
        "Rollo: Cuerpo Inmortal de Jade": {
          description: "Ense√±a 'Cuerpo Inmortal de Jade'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_t6"),
          canUse: () => true,
        },
        "Rollo: Incineraci√≥n del Mundo Mortal": {
          description: "Ense√±a 'Incineraci√≥n del Mundo Mortal'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "fire_t6"),
          canUse: () => true,
        },
        "Rollo: Decreto del Se√±or del Trueno": {
          description: "Ense√±a 'Decreto del Se√±or del Trueno'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t6"),
          canUse: () => true,
        },
        "Rollo: Matriz del Sello del Demonio": {
          description: "Ense√±a 'Matriz del Sello del Demonio'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "formation_t6"),
          canUse: () => true,
        },
        "Rollo: Omnipresencia Divina": {
          description: "Ense√±a 'Omnipresencia Divina'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "movement_t6"),
          canUse: () => true,
        },

        "Rollo: Absorci√≥n de Qi Menor": {
          description: "Ense√±a 'T√©cnica de Absorci√≥n de Qi Menor'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_absorption_boost_1"),
          canUse: () => true,
        },

        "Rollo: Fortificaci√≥n Corporal B√°sica": {
          description: "Ense√±a 'Fortificaci√≥n Corporal B√°sica'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_fortification_1"),
          canUse: () => true,
        },
     
        "Rollo: Conversi√≥n de Qi": {
          description: "Ense√±a 'T√©cnica de Conversi√≥n de Qi'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_to_hp_conversion_1"),
          canUse: () => true,
        },
    
    
    
    
        "Rollo: Paso de las Sombras": {
          description: "Ense√±a 'Paso de las Sombras'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "shadow_step_1"),
          canUse: () => true,
        },
 
   
   
  
        "Rollo: Voluntad de Hierro": {
          description: "Ense√±a 'Voluntad de Hierro'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "iron_will_1"),
          canUse: () => true,
        },
  

        "Rollo: Clon Fantasma": {
          description: "Ense√±a 'Clon Fantasma'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "phantom_clone_1"),
          canUse: () => true,
        },
        "Rollo: Cambio Temporal": {
          description: "Ense√±a 'Cambio Temporal'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "temporal_shift_1"),
          canUse: () => true,
        },
  
 
  
        "Cristal de Hielo": {
          description: "Cristal g√©lido. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Cristal de Hielo, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia de Fuego": {
          description: "Energ√≠a √≠gnea concentrada. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Esencia de Fuego, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "N√∫cleo de Tormenta": {
          description: "Coraz√≥n de tormenta. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido N√∫cleo de Tormenta, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Venenos Mortales": {
          description: "Venenos potentes. Otorga 15 EXP.",
          effect: (ps, gex) => {
            gex(15);
            return `Estudiado Venenos Mortales, ganado 15 EXP.`;
          },
          canUse: () => true,
        },
        "Fragmentos de Jade": {
          description: "Jade imbuido de energ√≠a. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido Fragmentos de Jade, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia Oscura": {
          description: "Energ√≠a de sombras. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Absorbido Esencia Oscura, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Almas Condenadas": {
          description: "Ecos de almas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Liberado Almas Condenadas, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "N√∫cleo de V√≥rtice": {
          description: "Energ√≠a ca√≥tica. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido N√∫cleo de V√≥rtice, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Roc√≠o Celestial": {
          description: "Gotas de energ√≠a celestial. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Bebido Roc√≠o Celestial, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "Cristales Ps√≠quicos": {
          description: "Resuenan con poder mental. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Meditado con Cristales Ps√≠quicos, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "Mineral de Hierro Espiritual": {
          description: "Hierro imbuido con Qi. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Refinado Mineral, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Plumas de F√©nix": {
          description: "Imbuidas con esencia de renovaci√≥n. Otorga 60 EXP.",
          effect: (ps, gex) => {
            gex(60);
            return `Meditado con Plumas de F√©nix, ganado 60 EXP.`;
          },
          canUse: () => true,
        },
        "Semillas Ancestrales": {
          description: "Llenas de vitalidad. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Plantado Semillas en dantian, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Escamas de Drag√≥n": {
          description: "Imbuidas con poder drac√≥nico. Otorga 70 EXP.",
          effect: (ps, gex) => {
            gex(70);
            return `Estudiado Escamas de Drag√≥n, ganado 70 EXP.`;
          },
          canUse: () => true,
        },
        "Espejos Astrales": {
          description: "Reflejan otros planos. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Meditado con Espejos Astrales, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "Relojes de Arena": {
          description: "Manipulan flujo del tiempo. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Estudiado Relojes de Arena, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Sangre de Demonio": {
          description: "Sangre corrupta pero potente. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Analizado Sangre de Demonio, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "L√°grimas de Unicornio": {
          description:
            "Purificadoras con propiedades curativas. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Usado L√°grimas para purificar Qi, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "N√∫cleo Elemental": {
          description: "Esencia de poder elemental. Otorga 65 EXP.",
          effect: (ps, gex) => {
            gex(65);
            return `Absorbido N√∫cleo Elemental, ganado 65 EXP.`;
          },
          canUse: () => true,
        },
        "Polvo de Arcano": {
          description: "Brillante con propiedades m√°gicas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Utilizado Polvo de Arcano en ritual, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
      };

      let zoneNotificationTimeout = null;

      ///======================   FUNCIONES ========================================
      function updateGameOverlayVisibility() {
        const overlay = document.getElementById("game-overlay");
        if (!overlay) {
          console.error("No se encontr√≥ el elemento #game-overlay.");
          return;
        }

        // El velo debe estar activo si la batalla est√° activa O si cualquier modal est√° abierto.
        const shouldBeActive = gameState.battle.active || isAnyModalOpen();

        if (shouldBeActive) {
          overlay.classList.add("active");
        } else {
          overlay.classList.remove("active");
        }
      }
      function getStoryNpcDialogue(npcId) {
        const player = gameState.player;
        const flags = player.worldState.storyFlags;

        switch (npcId) {
          case "anciana_su":
            if (!flags.metAncianaSu) {
              return "Joven disc√≠pulo... tu flujo de Qi es... peculiar. Me recuerda a las viejas leyendas. Sigue entrenando, estar√© observando.";
            }
            if (flags.knowsAboutCalamity) {
              return "La Gran Calamidad fue una herida profunda para nuestra secta. Siento que sus ecos a√∫n resuenan. Ten cuidado en tus misiones.";
            }
            return "El conocimiento del pasado es la llave del futuro. Si tienes preguntas, los archivos siempre est√°n abiertos.";

          case "maestro_jian":
            if (flags.knowsFullTruth) {
              return `La carga que llevas es inmensa. Toda la secta conf√≠a en ti. No dudes de tu camino.`;
            }
            if (flags.knowsAboutSoberano) {
              return `Ahora que conoces parte del secreto, debes entender la gravedad de la situaci√≥n. El sello se debilita. Cada victoria tuya nos da m√°s tiempo.`;
            }
            if (
              player.secta.rango === "Disc√≠pulo Interno" ||
              player.secta.rango === "Disc√≠pulo Principal"
            ) {
              return "Sigue as√≠, joven. Tu progreso es la esperanza de nuestra secta.";
            }
            return "El camino del cultivador es largo y arduo. Que el Viento Azure gu√≠e tus pasos.";
        }
        return "..."; // Di√°logo por defecto
      }
      function showZoneNotification(zoneName) {
      
        const notificationElement =
          document.getElementById("zone-notification");

        if (!notificationElement) {
        
          return;
        }
      

        if (zoneNotificationTimeout) {
          clearTimeout(zoneNotificationTimeout);
         
        }

        notificationElement.textContent = `Has entrado en: ${zoneName}`;
      

        notificationElement.classList.add("show");
        
       

        zoneNotificationTimeout = setTimeout(() => {
          notificationElement.classList.remove("show");
         
        }, 3000);
      
      }
      // --- FUNCIONES HELPER PARA UI M√ìVIL ---
      function isMobileView() {
        return (
          window.matchMedia("(max-width: 768px)").matches ||
          window.matchMedia("(hover: none) and (pointer: coarse)").matches
        );
      }

      /// <!-- CAMBIO TAMA√ëO MAPA M√ìVIL -->
      //TAMA√ëO TILE
      function calculateAndSetTileSize() {
        const mapContainerElement = document.querySelector(".map-container");
        if (!mapContainerElement) {
          console.warn(
            "calculateAndSetTileSize: mapContainerElement no encontrado, usando G_TILE_SIZE por defecto."
          );
          currentTileSize = G_TILE_SIZE;
          return G_TILE_SIZE;
        }

        if (isMobileView()) {
          const availableWidth = mapContainerElement.clientWidth;
          const availableHeight = mapContainerElement.clientHeight;

          // --- INICIO DE LA L√ìGICA DE ORIENTACI√ìN ---

          // Determina si estamos en modo horizontal (landscape) o vertical (portrait)
          const isLandscape = availableWidth > availableHeight;

          // Define cu√°ntos tiles queremos ver en cada orientaci√≥n.
          // Estos valores son la clave. ¬°Puedes ajustarlos a tu gusto!
          const TILES_VISIBLE_X_PORTRAIT = 7; // Menos tiles de ancho en vertical
          const TILES_VISIBLE_Y_PORTRAIT = 5; // M√°s tiles de alto en vertical

          const TILES_VISIBLE_X_LANDSCAPE = 8; // M√°s tiles de ancho en horizontal
          const TILES_VISIBLE_Y_LANDSCAPE = 6; // Menos tiles de alto en horizontal

          let tileSizeBasedOnWidth;
          let tileSizeBasedOnHeight;

          if (isLandscape) {
            // Si la pantalla es m√°s ancha que alta
            console.log("Orientaci√≥n: Horizontal (Landscape)");
            tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_LANDSCAPE;
            tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_LANDSCAPE;
          } else {
            // Si la pantalla es m√°s alta que ancha
            console.log("Orientaci√≥n: Vertical (Portrait)");
            tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_PORTRAIT;
            tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_PORTRAIT;
          }

          // --- FIN DE LA L√ìGICA DE ORIENTACI√ìN ---

          // El tama√±o del tile ser√° el menor de los dos c√°lculos para asegurar que todo quepa
          currentTileSize = Math.floor(
            Math.min(tileSizeBasedOnWidth, tileSizeBasedOnHeight)
          );
          currentTileSize = Math.max(20, currentTileSize); // Asegurar un tama√±o m√≠nimo razonable

          console.log(
            `Mobile View: Container W: ${availableWidth}, H: ${availableHeight}. Calculated Tile Size: ${currentTileSize}`
          );
        } else {
          currentTileSize = G_TILE_SIZE; // Usar el tama√±o fijo para escritorio
          console.log(`Desktop View: Using G_TILE_SIZE: ${currentTileSize}`);
        }
        return currentTileSize;
      }
      // <!-- FIN CAMBIO TAMA√ëO MAPA M√ìVIL -->

      function isAnyModalOpen() {
        const modals = [
          "interactionModal",
          "activeCultivationModal",
          "shopModal",
          "sectHallModal",
          "cultivationChoiceModal",
          "techniqueModal",
        ];
        for (const modalId of modals) {
          const modalElement = document.getElementById(modalId);
          if (modalElement && modalElement.style.display === "flex") {
            return true;
          }
        }
        return false;
      }

      // NUEVA FUNCI√ìN para controlar la visibilidad de la barra inferior
      function updateTopNavVisibility() {
        // Renombramos la funci√≥n para claridad
        if (!topNavBar) return;

        if (gameState.battle.active || isAnyModalOpen()) {
          topNavBar.classList.add("hidden");
        } else {
          topNavBar.classList.remove("hidden");
        }
      }

      function openMissionsModal() {
        const container = document.getElementById("missionsContainer");
        container.innerHTML = "";
        const player = gameState.player;

        if (player.secta.misionesActivas.length === 0) {
          container.innerHTML =
            "<p style='text-align: center;'>No tienes misiones activas en este momento.</p>";
        } else {
          player.secta.misionesActivas.forEach((misionActiva) => {
            const misionData = MISIONES_DATA[misionActiva.id];
            if (!misionData) return;

            // Reutilizamos la l√≥gica de la UI de la secta para mostrar el progreso
            let progresoTexto = "";
            const objetivo = misionActiva.objetivoOriginal;
            if (objetivo) {
              const npcEntregaNombre =
                SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre ||
                "el NPC correspondiente";
              if (objetivo.tipo === "eliminar_enemigo") {
                progresoTexto = `Progreso: ${misionActiva.progreso || 0}/${
                  objetivo.cantidad
                } ${objetivo.nombreDisplay || "objetivos"}`;
                if ((misionActiva.progreso || 0) >= objetivo.cantidad)
                  progresoTexto += ` <strong>(¬°Listo para entregar a ${npcEntregaNombre}!)</strong>`;
              } else if (objetivo.tipo === "entregar_item") {
                progresoTexto = `Reunir: ${
                  gameState.inventory[objetivo.item] || 0
                }/${objetivo.cantidad} ${objetivo.item}`;
                if (
                  (gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad
                )
                  progresoTexto += ` <strong>(¬°Listo para entregar a ${npcEntregaNombre}!)</strong>`;
              }
              // Puedes a√±adir m√°s casos para otros tipos de misiones
            }

            const div = document.createElement("div");
            div.style.border = "1px solid #d4af37";
            div.style.borderRadius = "8px";
            div.style.padding = "10px";
            div.style.marginBottom = "10px";
            div.style.background = "rgba(0,0,0,0.2)";

            div.innerHTML = `
                      <h4>${misionData.titulo}</h4>
                      <p style="font-size: 0.9em; margin-top: 5px;">${misionData.descripcion}</p>
                      <p style="font-size: 0.8em; color: #f4d03f; margin-top: 8px;">${progresoTexto}</p>
                  `;
            container.appendChild(div);
          });
        }

        document.getElementById("missionsModal").style.display = "flex";
        hideTouchControls();
        updateStatsPanelVisibility();
      }

      function closeMissionsModal() {
        document.getElementById("missionsModal").style.display = "none";
        showTouchControls();
        updateStatsPanelVisibility();
      }
      function showTouchControls() {
        const controlsOverlay = document.getElementById('touch-controls-overlay');
        const toggleBtn = document.getElementById('toggleMapControlsBtn');

        if (!controlsOverlay || !toggleBtn) return;

        // === CORRECCI√ìN CLAVE ===
        // Comprobamos si el navegador est√° en modo de pantalla completa.
        const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        
        // Los controles deben mostrarse si estamos en vista m√≥vil O si el juego est√° en pantalla completa.
        const forceShowDueToDeviceOrMode = isMobileView() || isFullscreen;

        // La condici√≥n final para mostrar los controles
        const shouldShow = forceShowDueToDeviceOrMode && !mapControlsManuallyHidden && !gameState.battle.active && !isAnyModalOpen();

        if (shouldShow) {
            controlsOverlay.style.display = 'block';
            toggleBtn.style.display = 'block';
        } else {
            controlsOverlay.style.display = 'none';
            // Tambi√©n ocultamos el bot√≥n de toggle si no estamos en una vista que los requiera
            if (!forceShowDueToDeviceOrMode) {
                toggleBtn.style.display = 'none';
            }
        }
    }

      function hideTouchControls() {
          const controlsOverlay = document.getElementById('touch-controls-overlay');
          if (controlsOverlay) {
              controlsOverlay.style.display = 'none';
          }
      }

      function toggleMapControlsVisibility() {
          mapControlsManuallyHidden = !mapControlsManuallyHidden;
          const btn = document.getElementById("toggleMapControlsBtn");
          
          if (mapControlsManuallyHidden) {
              btn.textContent = "Mostrar Controles";
              hideTouchControls(); // Esta funci√≥n ahora oculta el overlay completo
          } else {
              btn.textContent = "Ocultar Controles";
              showTouchControls(); // Esta funci√≥n ahora muestra el overlay completo si se cumplen las condiciones
          }
      }
      function handleTeleporterInteraction(entity) {
        if (!entity.teleporterId) return;

        const teleporterId = entity.teleporterId;
        const teleporterInfo = TELEPORTER_DATA[teleporterId];
        const player = gameState.player;

        if (!teleporterInfo) {
          console.error(
            `Datos no encontrados para el teletransportador con ID: ${teleporterId}`
          );
          return;
        }

        // Comprobar si ya est√° activado
        if (!player.unlockedTeleporters[teleporterId]) {
          // ¬°Primera activaci√≥n!
          player.unlockedTeleporters[teleporterId] = true;
          showModal(
            "Matriz Sintonizada",
            `Has canalizado tu Qi en la matriz. ¬°Ahora puedes viajar hacia y desde "${teleporterInfo.name}"!`
          );
          // Podr√≠amos abrir el men√∫ de teletransporte directamente despu√©s,
          // pero un mensaje de feedback primero es mejor.
        } else {
          // Si ya est√° activado, simplemente abrimos el men√∫ de viaje.
          openTeleportModal();
        }
      }

      function handleFullscreenChange() {
          updateFullscreenButton();
          // Vuelve a comprobar si los controles deben ser visibles despu√©s de cambiar de modo.
          showTouchControls(); 
      }

      function openTeleportModal() {
        const container = document.getElementById("teleportOptionsContainer");
        const player = gameState.player;
        container.innerHTML = ""; // Limpiar opciones anteriores

        let hasDestinations = false;

        for (const id in player.unlockedTeleporters) {
          // No mostrar la ubicaci√≥n actual como un destino
          const currentTeleporter = getTeleporterAt(player.x, player.y);
          if (currentTeleporter && currentTeleporter.id === id) {
            continue;
          }

          hasDestinations = true;
          const destinationInfo = TELEPORTER_DATA[id];
          const button = document.createElement("button");
          button.className = "cultivation-option-btn";
          button.textContent = `Viajar a: ${destinationInfo.name}`;
          button.onclick = () => teleportPlayer(id);
          container.appendChild(button);
        }

        if (!hasDestinations) {
          container.innerHTML =
            "<p>No has sintonizado otras Matrices de Teletransporte todav√≠a. ¬°Explora para activarlas!</p>";
        }

        document.getElementById("teleportModal").style.display = "flex";
        hideTouchControls();
      }

      function teleportPlayer(destinationId) {
        const destination = TELEPORTER_DATA[destinationId];
        if (!destination) return;

        // Actualizar coordenadas del jugador
        gameState.player.x = destination.x;
        gameState.player.y = destination.y;

        closeTeleportModal();

        // Mostrar un feedback visual r√°pido
        showModal("Viaje Espiritual", "Te materializas en tu destino...", true);
        setTimeout(() => {
          closeModal();
        }, 1200);

        // ¬°Muy importante! Actualizar la vista del mapa
        updatePlayerPosition("teleport");
      }

      function closeTeleportModal() {
        document.getElementById("teleportModal").style.display = "none";
        showTouchControls();
        updateStatsPanelVisibility();
      }

      // Peque√±a funci√≥n de ayuda para saber si el jugador est√° en un teletransportador
      function getTeleporterAt(x, y) {
        for (const id in TELEPORTER_DATA) {
          const tp = TELEPORTER_DATA[id];
          if (tp.x === x && tp.y === y) {
            return { ...tp, id: id };
          }
        }
        return null;
      }
      // --- FUNCIONES DEL JUEGO (MODIFICADAS Y EXISTENTES) ---

      function learnTechniqueFromRoll(playerState, techId) {
      
        
        
        const techInfo = techniqueData[techId];
        
        // Comprobaci√≥n 1: ¬øExiste la t√©cnica en nuestros datos maestros?
        if (!techInfo) {
            return "Error: T√©cnica desconocida.";
        }

        // Comprobaci√≥n 2: ¬øEl jugador ya la conoce?
        if (playerState.learnedTechniques[techId]) {
          return `Ya conoces esta t√©cnica: ${techInfo.name}.`;
        }

        // Comprobaci√≥n 3: ¬øEl jugador cumple con el requisito de rango?
        // Ahora todas las comprobaciones usan la variable 'techInfo' que ya existe.
        if (techInfo.requiredRank) {
            const playerRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === playerState.secta.rango);
            const requiredRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === techInfo.requiredRank);

            if (playerRankIndex < requiredRankIndex) {
                return `Rango insuficiente. Necesitas ser al menos <strong>${techInfo.requiredRank}</strong> para aprender '${techInfo.name}'.`;
            }
        }
        
        // Si todas las comprobaciones pasan, procedemos a aprender la t√©cnica.
        const techCultivationSettings = techInfo.cultivationSettings;
        
        playerState.learnedTechniques[techId] = {
          level: 1, 
          currentCultivationProgress: 0,
          cultivationTimeToNextLevel: techCultivationSettings
            ? Math.floor(techCultivationSettings.baseTimeToLevelUp * Math.pow(techCultivationSettings.levelTimeMultiplier, 1))
            : 120,
        };

        recalculatePlayerStats(); 

        if (techId === "qi_to_hp_conversion_1") {
          playerState.canUseQiConversion = true;
          updateToggleQiConversionButtonVisibility();
        }
        
      

        return `Has aprendido '${techInfo.name}' (Nivel 1). Puedes cultivarla para mejorarla.`;
      }

      function showModal(title, text, nonInteractive = false) {
        document.querySelector(".stats-panel").style.display = "none";
        const modalElement = document.getElementById("interactionModal");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalTextEl = document.getElementById("modalText");

        if (!modalElement || !modalTitleEl || !modalTextEl) {
          console.error(
            "CRITICAL: Modal o sus elementos internos no encontrados."
          );
          alert(`Error UI: Modal no encontrado.\nMensaje: ${title} - ${text}`);
          return;
        }

        modalTitleEl.textContent = title;
        modalTextEl.innerHTML = text.replace(/\n/g, "<br>");

        const closeButton = modalElement.querySelector(
          "button.close-modal-btn"
        ); // Busca por clase

        if (closeButton) {
          if (nonInteractive) {
            closeButton.style.display = "none"; // Ocultar si es no interactivo
          } else {
            closeButton.style.display = "block"; // Asegurar que sea visible si es interactivo
            // El onclick="closeModal()" ya est√° en el HTML, por lo que no necesitamos reasignarlo.
          }
        } else if (!nonInteractive) {
          console.warn(
            "#interactionModal no tiene un bot√≥n de cierre con clase .close-modal-btn y no es nonInteractive."
          );
        }

        modalElement.style.display = "flex";
        hideTouchControls();
        updateTopNavVisibility();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function closeModal() {
        const modalElement = document.getElementById("interactionModal");
        if (modalElement) {
          modalElement.style.display = "none";
        }

        if (!gameState.battle.active) {
          document.querySelector(".stats-panel").style.display = "block";
        }

        updatePlayerBarsOnMap();
        showTouchControls();
        updateTopNavVisibility();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }
      //ENEMIGOS Y NPC FIJOS
      function ensureFixedEntities() {
        const player = gameState.player;
        let entities = gameState.map.entities;

        let idsParaProcesar = [
          "shop",
          "secta_entrada_principal",
          "secta_entrada_principal_2",
          "secta_entrada_principal_3",
          "secta_entrada_principal_4",
          "npc_secta_guia",
          "npc_secta_admin",
          "transition_ruins_entrance",
          "transition_ruins_exit",
          "transition_valley_entrance",
          "tp_sect_hub",
          "tp_forest_shrine",
          "tp_desert_oasis",
          "tp_swamp_ruin",
          "tp_desfiladero",
          "tp_dragon_valley",
          "npc_maestro_jian",
          "npc_anciana_su",
          "transition_valley_exit",
          //ENEMIGOS
          "jabali_colmilludo_alfa",
          "boss_ancient_golem",
          
          "diacono_renegado_jin",
          "jabali_alfa_1",
          "jabali_alfa_2",
          "jabali_alfa_3",
          "jabali_alfa_4",
          "jabali_alfa_5",
          "jabali_alfa_6",
          "jabali_alfa_7",
          "jabali_alfa_8",
          "jabali_alfa_9",
          "jabali_alfa_10",
          "jabali_alfa_11",
          "jabali_alfa_12",

          // Puedes a√±adir otros IDs de entidades fijas aqu√≠ directamente
        ];

        // L√≥gica para jefes principales (actuales)
        if (
          player.worldState.currentBossToSpawn &&
          entityTypes[player.worldState.currentBossToSpawn]
        ) {
          const bossDef = entityTypes[player.worldState.currentBossToSpawn];
          if (
            bossDef.fixedLocation &&
            !player.worldState.defeatedBosses[
              player.worldState.currentBossToSpawn
            ]
          ) {
            if (
              !idsParaProcesar.includes(player.worldState.currentBossToSpawn)
            ) {
              idsParaProcesar.push(player.worldState.currentBossToSpawn);
            }
          }
        }
        player.secta.misionesActivas.forEach((misionActiva) => {
        const misionData = MISIONES_DATA[misionActiva.id];
        // Buscamos misiones cuyo objetivo sea derrotar a un NPC espec√≠fico
        if (misionData?.objetivo?.tipo === "derrotar_npc_especifico" && misionData.objetivo.npcId) {
            const npcId = misionData.objetivo.npcId;
            // Si este NPC tiene una ubicaci√≥n fija y a√∫n no est√° en nuestra lista para procesar, lo a√±adimos.
            if (entityTypes[npcId]?.fixedLocation && !idsParaProcesar.includes(npcId)) {
                console.log(`[EnsureFixed] A√±adiendo al NPC de misi√≥n '${npcId}' a la lista de aparici√≥n.`);
                idsParaProcesar.push(npcId);
            }
        }
    });
        // L√≥gica para rivales de desaf√≠o de secta (actuales)
        player.secta.misionesActivas.forEach((misionActiva) => {
          const misionData = MISIONES_DATA[misionActiva.id];
          if (
            misionData?.objetivo?.tipo === "derrotar_npc_especifico" &&
            misionData.objetivo.npcId
          ) {
            const rivalId = misionData.objetivo.npcId;
            if (
              entityTypes[rivalId]?.fixedLocation &&
              !player.secta.misionesCompletadas[misionActiva.id]
            ) {
              if (!idsParaProcesar.includes(rivalId)) {
                idsParaProcesar.push(rivalId);
              }
            }
          }
        });

        // Nueva l√≥gica: A√±adir entidades fijas que podr√≠an estar ligadas a misiones activas
        // (si implementas `missionRequirementId`)
        player.secta.misionesActivas.forEach((misionActiva) => {
          // Ejemplo: Si la misi√≥n "mision_cazar_bestia_especifica_1" est√° activa
          // y el jabal√≠ tiene un `missionRequirementId: "mision_cazar_bestia_especifica_1"`
          // y a√∫n no est√° en idsParaProcesar, lo a√±adir√≠as.
          // Este es un ejemplo, necesitar√≠as iterar sobre `entityTypes` para encontrar tales entidades.
          // Por ahora, como lo a√±adiste directamente a `idsParaProcesar`, esto es m√°s simple.
        });

        console.log(
          "[EnsureFixed] IDs a procesar:",
          JSON.parse(JSON.stringify(idsParaProcesar))
        );

        idsParaProcesar.forEach((entityTypeId) => {
          const definition = entityTypes[entityTypeId];
          if (!definition) {
            console.warn(
              `[EnsureFixed] Definici√≥n no encontrada para ${entityTypeId}`
            );
            return;
          }

          if (!definition.fixedLocation) {
            // Si una entidad en idsParaProcesar no tiene fixedLocation, no podemos colocarla as√≠.
            // Esto es un error de configuraci√≥n o la entidad no deber√≠a estar en esta lista.
            console.warn(
              `[EnsureFixed] La entidad ${entityTypeId} est√° en idsParaProcesar pero no tiene 'fixedLocation' en su definici√≥n.`
            );
            return;
          }

          const fixedX = definition.fixedLocation.x;
          const fixedY = definition.fixedLocation.y;

          const existingEntityInstance = entities.find(
            (e) =>
              (e.x === fixedX &&
                e.y === fixedY &&
                (e.type === (definition.typeOverride || entityTypeId) ||
                  e.originalEntityTypeId === entityTypeId)) ||
              (definition.npcId && e.npcId === definition.npcId) // Para NPCs
          );

          let debeExistir = true;

          // L√≥gica de si debe existir (para jefes, rivales, o entidades ligadas a misiones)
          if (definition.isSectChallengeRival && definition.npcId) {
            const desafioMision = Object.values(MISIONES_DATA).find(
              (m) =>
                m.objetivo?.tipo === "derrotar_npc_especifico" &&
                m.objetivo?.npcId === definition.npcId
            );
            const misionId = desafioMision
              ? Object.keys(MISIONES_DATA).find(
                  (key) => MISIONES_DATA[key] === desafioMision
                )
              : null;
            if (misionId) {
              if (player.secta.misionesCompletadas[misionId])
                debeExistir = false;
              else if (
                !player.secta.misionesActivas.some((m) => m.id === misionId)
              )
                debeExistir = false;
            } else debeExistir = false;
          } else if (definition.isBoss || definition.isMiniBoss) {
            // Tratar MiniBoss de forma similar a Boss para 'defeated'
            // Usaremos una nueva propiedad en player.worldState para rastrear minibosses fijos derrotados
            // si no quieres que reaparezcan inmediatamente.
            if (
              player.worldState.defeatedFixedEntities &&
              player.worldState.defeatedFixedEntities[entityTypeId]
            ) {
              // Si tiene un tiempo de respawn, podr√≠a reaparecer
              const lastDefeatedTime =
                player.worldState.defeatedFixedEntities[entityTypeId].time;
              const respawnTimeSeconds = definition.respawnTime; // ej. 300 segundos
              if (
                respawnTimeSeconds &&
                (Date.now() - lastDefeatedTime) / 1000 < respawnTimeSeconds
              ) {
                debeExistir = false; // A√∫n no es tiempo de reaparecer
              } else if (respawnTimeSeconds) {
                debeExistir = true; // Tiempo de respawn cumplido
                // Opcional: remover de defeatedFixedEntities para que no se re-evalue el tiempo hasta la pr√≥xima derrota
                // delete player.worldState.defeatedFixedEntities[entityTypeId];
              } else {
                debeExistir = false; // No tiene respawnTime, as√≠ que si est√° derrotado, no reaparece.
              }
            }
          } else if (definition.missionRequirementId) {
            // L√≥gica para entidades que dependen de una misi√≥n activa
            if (
              !player.secta.misionesActivas.some(
                (m) => m.id === definition.missionRequirementId
              )
            ) {
              debeExistir = false; // La misi√≥n requerida no est√° activa
            }
            // Podr√≠as a√±adir una comprobaci√≥n de si la misi√≥n ya fue completada y la entidad debe desaparecer.
            if (
              player.secta.misionesCompletadas[
                definition.missionRequirementId
              ] &&
              !definition.respawnTime
            ) {
              // Si la misi√≥n est√° completada y la entidad no tiene respawn, no debe existir.
              debeExistir = false;
            }
          }

          if (debeExistir) {
            if (!existingEntityInstance) {
             
              const newEntityData = {
                ...definition,
                x: fixedX,
                y: fixedY,
                type: definition.typeOverride || entityTypeId,
                symbol: definition.symbol,
                name: definition.name,
                interaction: definition.interaction,
                npcId: definition.npcId,
                discovered:
                  definition.discovered === true ||
                  definition.isBoss ||
                  definition.isMiniBoss, // Los jefes/minibosses suelen estar descubiertos
                isFixed: true,
                id: `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                  .toString(16)
                  .slice(2)}`,
                originalEntityTypeId: entityTypeId,
                // Copiar stats de combate y loot
              };
              if (newEntityData.hp && !newEntityData.maxHp)
                newEntityData.maxHp = newEntityData.hp;

              // No necesitamos `...definition` aqu√≠ porque ya estamos copiando expl√≠citamente y de entityTypes
              const finalEntity = { ...newEntityData };
              // delete finalEntity.fixedLocation; // No es necesario porque newEntityData no lo incluye

              entities.push(finalEntity);
            } else {
              // Actualizar propiedades de la instancia existente si es necesario
              existingEntityInstance.isFixed = true;
              if (
                definition.discovered === true ||
                definition.isBoss ||
                definition.isMiniBoss
              ) {
                existingEntityInstance.discovered = true;
              }
              if (!existingEntityInstance.id) {
                existingEntityInstance.id = `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                  .toString(16)
                  .slice(2)}`;
              }
              if (!existingEntityInstance.originalEntityTypeId) {
                existingEntityInstance.originalEntityTypeId = entityTypeId;
              }
              // Asegurar que las stats est√©n actualizadas si se recarga el juego
              // (esto puede ser importante si las definiciones cambian entre versiones)
              if (definition.hp) existingEntityInstance.hp = definition.hp;
              if (definition.maxHp)
                existingEntityInstance.maxHp = definition.maxHp;
              else if (definition.hp && !existingEntityInstance.maxHp)
                existingEntityInstance.maxHp = definition.hp;
              // ... podr√≠as actualizar otras stats aqu√≠ si es necesario ...
            }
          } else {
            // No debe existir
            if (existingEntityInstance) {
              console.log(
                `[EnsureFixed] ELIMINANDO instancia existente de ${entityTypeId} en (${fixedX}, ${fixedY}) porque 'debeExistir' es false.`
              );
              entities = entities.filter(
                (e) => e.id !== existingEntityInstance.id
              );
            }
          }
        });
        gameState.map.entities = entities; // Reasignar por si se filtraron entidades
      }
      //GENERAR MAPA!
      function generateMap(isFullReset = true) {
        calculateAndSetTileSize();

        if (isFullReset) {
          // Limpiar entidades que no son fijas
          gameState.map.entities = gameState.map.entities.filter(
            (e) => e.isFixed && !e.isDecorative
          ); // Quitamos tambi√©n las decoraciones viejas

          // Resetear contadores de spawn
          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings && zone.spawnSettings.targetEntities) {
              zone.spawnSettings.targetEntities.forEach((target) => {
                target.currentCount = 0;
              });
              zone.spawnSettings.respawnTimer = 0;
              zone.spawnSettings.lastSpawnCheck = 0;
            }
          });

          // Poblar cada zona con monstruos/recursos y luego con decoraciones
          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings) {
              console.log(
                `generateMap: Poblando spawns para la zona "${zone.name}".`
              );
              populateZoneWithObjects(zone, true);
            }
            // === L√ìGICA MODIFICADA ===
            if (zone.decorations) {
              console.log(
                `generateMap: Poblando decoraciones para la zona "${zone.name}".`
              );
              populateZoneWithDecorations(zone); // Llamamos a la nueva funci√≥n
            }
            // === FIN DE LA MODIFICACI√ìN ===
          });

          // Ya no necesitamos la funci√≥n global y aleatoria de decoraciones.
          // populateDecorativeElements(50); // <-- ELIMINA O COMENTA ESTA L√çNEA
        } else {
          gameState.map.entities = gameState.map.entities.filter(
            (e) => e.isFixed || e.isDecorative || (!e.zoneOrigin && !e.isFixed)
          );
        }

        updatePlayerPosition();
        showTouchControls();
        ensureFixedEntities();
      }

      function populateZoneWithDecorations(zone) {
        if (!zone.decorations || zone.decorations.length === 0) {
          return; // No hay nada que decorar en esta zona
        }

        console.log(`[Decor] Poblando decoraciones para la zona: ${zone.name}`);

        // Recorremos cada celda de la zona
        for (let y = zone.y1; y <= zone.y2; y++) {
          for (let x = zone.x1; x <= zone.x2; x++) {
            // Verificamos si la celda ya est√° ocupada por algo importante
            const isOccupied = gameState.map.entities.some(
              (e) => e.x === x && e.y === y
            );
            if (isOccupied) {
              continue; // Si ya hay un monstruo o recurso, no ponemos decoraci√≥n encima
            }

            // Iteramos sobre los tipos de decoraci√≥n definidos para la zona
            for (const deco of zone.decorations) {
              // Usamos Math.random() para decidir si colocar esta decoraci√≥n
              if (Math.random() < deco.density) {
                const decoDefinition = entityTypes[deco.entityTypeId];
                if (decoDefinition) {
                  const newDeco = {
                    ...decoDefinition,
                    x: x,
                    y: y,
                    type: deco.entityTypeId,
                    id: `${deco.entityTypeId}_${x}_${y}_${Math.random()}`,
                    discovered: true,
                    isFixed: true,
                    isDecorative: true,
                  };
                  gameState.map.entities.push(newDeco);
                  // IMPORTANTE: Una vez que ponemos una decoraci√≥n, salimos del bucle
                  // para no poner m√∫ltiples decoraciones (ej. un √°rbol y una roca) en la misma celda.
                  break;
                }
              }
            }
          }
        }
      }

      function populateDecorativeElements(numberOfElements = 3000) {
        const decorativeKeys = Object.keys(entityTypes).filter(
          (key) => entityTypes[key].isDecorative
        );
        if (decorativeKeys.length === 0) {
          console.log("[Decor] No decorative entity types found."); // LOG
          return;
        }
        // MODIFICACI√ìN: A√±adir las claves encontradas al log
        console.log(
          `[Decor] Attempting to populate ${numberOfElements} decorative elements. Found ${decorativeKeys.length} types:`,
          decorativeKeys.join(", ")
        );

        let addedCount = 0;
        for (let i = 0; i < numberOfElements; i++) {
          let spawnX,
            spawnY,
            attempts = 0;
          let positionFound = false;
          const randomDecoKey =
            decorativeKeys[Math.floor(Math.random() * decorativeKeys.length)];

          while (attempts < 20 && !positionFound) {
            // Intentos para encontrar posici√≥n
            spawnX = Math.floor(Math.random() * gameState.map.width);
            spawnY = Math.floor(Math.random() * gameState.map.height);

            // Para decorativos, la condici√≥n de "caminable" puede ser menos estricta
            // Lo importante es que la celda no est√© ya ocupada.
            const isOccupied = gameState.map.entities.some(
              (e) => e.x === spawnX && e.y === spawnY
            );
            const isPlayerPos =
              spawnX === gameState.player.x && spawnY === gameState.player.y;

            if (!isOccupied && !isPlayerPos) {
              positionFound = true;
            }
            attempts++;
          }

          if (positionFound) {
            const decoDefinition = entityTypes[randomDecoKey];
            if (!decoDefinition || !decoDefinition.symbol) {
              console.warn(
                `[Decor] Definition or symbol missing for deco key: ${randomDecoKey}`
              );
              continue;
            }
            const newDeco = {
              ...decoDefinition, // Copia todas las propiedades de la definici√≥n
              x: spawnX,
              y: spawnY,
              type: randomDecoKey, // El tipo ES la clave original de entityTypes
              id: `${randomDecoKey}_${Date.now()}_${i}_${Math.random()
                .toString(16)
                .slice(2)}`,
              discovered: true, // Importante: los decorativos suelen estar descubiertos
              isFixed: true, // Importante: para que no se limpien f√°cilmente
              isDecorative: true, // Asegura que sea true, incluso si la definici√≥n lo omite
            };

            gameState.map.entities.push(newDeco);
            addedCount++;
            // MODIFICACI√ìN: Log m√°s detallado, incluyendo si isDecorative es true en la instancia
            console.log(
              `[Decor] Added: ${newDeco.name} (Symbol: ${newDeco.symbol}, Type: ${newDeco.type}, IsDecorative: ${newDeco.isDecorative}) at ${spawnX},${spawnY}. ID: ${newDeco.id}`
            );
          } else {
            // console.log(`[Decor] Could not find position for a decorative element of type ${randomDecoKey} after 20 attempts.`);
          }
        }
        console.log(
          `[Decor] Finished populating. Added ${addedCount} decorative elements out of ${numberOfElements} attempts.`
        );
      }

      function populateZoneWithObjects(zone, initialPopulation = false) {
        if (!zone.spawnSettings) {
          console.log(
            `populateZoneWithObjects: Zone "${zone.name}" has no spawnSettings. Skipping.`
          );
          return;
        }

        console.log(
          `populateZoneWithObjects: Called for zone "${zone.name}". InitialPopulation: ${initialPopulation}`
        );

        zone.spawnSettings.targetEntities.forEach((targetSpawnInfo) => {
          console.log(
            `  Zone "${zone.name}": Processing target spawn info for entityTypeId "${targetSpawnInfo.entityTypeId}", count: ${targetSpawnInfo.count}, currentCount: ${targetSpawnInfo.currentCount}`
          );

          const entityTypeDefinition =
            entityTypes[targetSpawnInfo.entityTypeId];
          if (!entityTypeDefinition) {
            console.warn(
              `  Zone "${zone.name}": Definition for entityTypeId "${targetSpawnInfo.entityTypeId}" NOT FOUND in entityTypes.`
            );
            return;
          }

          let attemptSpawns =
            targetSpawnInfo.count - targetSpawnInfo.currentCount;
          console.log(
            `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Need to spawn ${attemptSpawns} (target: ${targetSpawnInfo.count}, current: ${targetSpawnInfo.currentCount})`
          );

          if (!initialPopulation && zone.spawnSettings.respawnTimer > 0) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Zone in cooldown (timer: ${zone.spawnSettings.respawnTimer}). Skipping spawn.`
            );
            return;
          }

          if (attemptSpawns <= 0 && !initialPopulation) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": No spawns needed and not initial population. Skipping.`
            );
            return;
          }
          if (
            attemptSpawns <= 0 &&
            initialPopulation &&
            targetSpawnInfo.currentCount >= targetSpawnInfo.count
          ) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Initial population, but already at target count. Skipping.`
            );
            return;
          }

          let spawnedThisCycle = 0;
          for (let i = 0; i < attemptSpawns; i++) {
            if (targetSpawnInfo.currentCount >= targetSpawnInfo.count) {
              console.log(
                `    Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Reached target count (${targetSpawnInfo.currentCount}/${targetSpawnInfo.count}). Stopping spawns for this type.`
              );
              break;
            }

            let spawnX,
              spawnY,
              attempts = 0;
            let positionFound = false;
            while (attempts < 20 && !positionFound) {
              spawnX =
                zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1 + 1));
              spawnY =
                zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1 + 1));

              const targetTerrainId = getTerrainTypeAt(spawnX, spawnY);
              const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
              const terrainWalkable =
                !targetTerrainData || targetTerrainData.walkable !== false;

              const isOccupied = gameState.map.entities.some(
                (e) => e.x === spawnX && e.y === spawnY
              );
              const isPlayerPos =
                spawnX === gameState.player.x && spawnY === gameState.player.y;

              if (terrainWalkable && !isOccupied && !isPlayerPos) {
                positionFound = true;
              }
              attempts++;
            }

            if (positionFound) {
              let newEntity;
              newEntity = {
                ...entityTypeDefinition, // <--- COPIAR TODAS LAS PROPIEDADES DE LA DEFINICI√ìN PRIMERO
                x: spawnX,
                y: spawnY,
                type:
                  entityTypeDefinition.typeOverride ||
                  targetSpawnInfo.entityTypeId,
                id: `${
                  targetSpawnInfo.entityTypeId
                }_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                zoneOrigin: zone.name,
                originalEntityTypeId: targetSpawnInfo.entityTypeId,
                discovered: false,
                //name: entityTypeDefinition.name,
                //symbol: entityTypeDefinition.symbol,
                //interaction: entityTypeDefinition.interaction,
                //reward: entityTypeDefinition.reward,
              };
              // Asegurar HP/MaxHP para entidades de combate y limpiar para no combatientes
              if (
                G_COMBAT_ENTITY_TYPES.includes(newEntity.type) ||
                newEntity.isBoss ||
                newEntity.isSectChallengeRival
              ) {
                // Si entityTypeDefinition ya tiene hp/maxHp, el spread ya los copi√≥.
                // Este bloque es m√°s para asegurar que existan o para poner valores por defecto.
                newEntity.hp = newEntity.hp ?? entityTypeDefinition.hp ?? 50;
                newEntity.maxHp = newEntity.maxHp ?? newEntity.hp;
                // Aqu√≠ 'attack', 'defense', 'exp', 'lootTable' ya deber√≠an estar copiados por el spread de entityTypeDefinition
              } else {
                // Para recursos u otras entidades no combativas
                delete newEntity.hp;
                delete newEntity.maxHp;
                delete newEntity.attack; // Asegurarse de que no tengan stats de combate
                delete newEntity.defense;
                delete newEntity.exp;
                // lootTable podr√≠a ser relevante para recursos si lo usaras para definir m√∫ltiples items de un nodo.
              }

              // Correcci√≥n espec√≠fica si es un recurso, para que su 'type' en el mapa sea solo 'resource' si as√≠ lo deseas
              // para la l√≥gica de interacci√≥n, o mantener el tipo espec√≠fico si prefieres.
              // La l√≥gica actual en handleEntityInteraction ya maneja bien `targetSpawnInfo.entityTypeId` como type.
              // if (entityTypeDefinition.type === "resource") newEntity.type = "resource";

              gameState.map.entities.push(newEntity);
              targetSpawnInfo.currentCount++;
              spawnedThisCycle++;
              console.log(
                `    SUCCESS: Spawned "${newEntity.name}" (Attack: ${newEntity.attack}, Final Type: ${newEntity.type}, OrigTypeID: ${newEntity.originalEntityTypeId}) in zone "${zone.name}" at (${spawnX},${spawnY}).`
              );
            } else {
              // console.log(`    FAILED: Could not find position for "${targetSpawnInfo.entityTypeId}" ...`);
              break;
            }
          }
          if (spawnedThisCycle > 0 && !initialPopulation) {
            zone.spawnSettings.respawnTimer =
              zone.spawnSettings.respawnCooldown;
            console.log(
              `  Zone "${zone.name}": Spawned ${spawnedThisCycle} of "${targetSpawnInfo.entityTypeId}". Setting respawn timer to ${zone.spawnSettings.respawnCooldown}s.`
            );
          }
        });
      }

      // Funci√≥n para llamar en el bucle principal del juego o con setInterval
      function gameTickUpdater() {
        // --- INICIO DE LA CORRECCI√ìN ---
        // Definimos la variable 'player' para que apunte al estado del jugador.
        const player = gameState.player; 
        // --- FIN DE LA CORRECCI√ìN ---

        const now = Date.now();
        const deltaTime = (now - gameState.lastGameTimeUpdate) / 1000;
        gameState.gameTime += deltaTime;
        gameState.lastGameTimeUpdate = now;

        // Ahora, esta l√≥gica de regeneraci√≥n funcionar√° porque 'player' est√° definido.
        if (player.passiveHpRegen > 0 && player.hp < player.maxHp) {
          player.hp = Math.min(
            player.maxHp,
            player.hp + player.passiveHpRegen * deltaTime
          );
          updateUI(); // Actualizar la UI para ver la regeneraci√≥n
        }

        gameState.map.terrainZones.forEach((zone) => {
          if (zone.spawnSettings) {
            if (zone.spawnSettings.respawnTimer > 0) {
              zone.spawnSettings.respawnTimer -= deltaTime;
              if (zone.spawnSettings.respawnTimer < 0)
                zone.spawnSettings.respawnTimer = 0;
            }

            let needsRespawn = false;
            for (const target of zone.spawnSettings.targetEntities) {
              if (target.currentCount < target.count) {
                needsRespawn = true;
                break;
              }
            }
            
            const SPAWN_CHECK_COOLDOWN = 10;
            if (
              needsRespawn &&
              zone.spawnSettings.respawnTimer <= 0 &&
              gameState.gameTime - (zone.spawnSettings.lastSpawnCheck || 0) >
                SPAWN_CHECK_COOLDOWN
            ) {
              zone.spawnSettings.lastSpawnCheck = gameState.gameTime; 
              populateZoneWithObjects(zone, false);
            }
          }
        });
      }

      let animationFrameIndex = 0; // Para ciclar a trav√©s de PLAYER_WALK_CYCLE
      let lastPlayerMoveTime = 0; // Para controlar el tiempo de la animaci√≥n

      function movePlayer(dx, dy) {
        movePlayerCallCount++;
        const callId = movePlayerCallCount;

        const now = Date.now();
        if (now - lastSuccessfulMoveTime < PLAYER_MOVE_COOLDOWN) {
          return;
        }

        const newX = gameState.player.x + dx;
        const newY = gameState.player.y + dy;
        let canMove = true;

        // L√≥gica de colisiones y movimiento (esta parte es correcta)
        if (
          newX < 0 ||
          newX >= gameState.map.width ||
          newY < 0 ||
          newY >= gameState.map.height
        ) {
          canMove = false;
        }
        if (canMove) {
          const targetTerrainId = getTerrainTypeAt(newX, newY);
          if (G_TERRAIN_TYPES[targetTerrainId]?.walkable === false) {
            canMove = false;
          }
        }
        if (canMove) {
          const entityAtNewPosition = gameState.map.entities.find(
            (e) => e.x === newX && e.y === newY
          );
          if (entityAtNewPosition) {
            if (
              G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) ||
              entityAtNewPosition.isBoss ||
              entityAtNewPosition.isSectChallengeRival
            ) {
              startBattle(entityAtNewPosition);
              return;
            }
            const entityTypeToCheck =
              entityAtNewPosition.originalEntityTypeId ||
              entityAtNewPosition.type;
            if (G_BLOCKING_ENTITY_TYPES.includes(entityTypeToCheck)) {
              canMove = false;
            }
          }
        }

        // Si el movimiento es v√°lido, ejecutamos la l√≥gica de zona
        if (canMove) {
          

          // 1. Obtenemos la zona ANTES de actualizar la posici√≥n del jugador
          const oldZone = getPlayerCurrentZone();
          const oldZoneName = oldZone ? oldZone.name : "Tierras Salvajes";
          

          // 2. ACTUALIZAMOS la posici√≥n del jugador en el gameState
          gameState.player.x = newX;
          gameState.player.y = newY;

          // 3. Obtenemos la nueva zona AHORA que el jugador se ha movido
          const newZone = getPlayerCurrentZone();
          const newZoneName = newZone ? newZone.name : "Tierras Salvajes";
          

          // 4. La comparaci√≥n clave
         
          if (newZoneName !== oldZoneName) {
           
            showZoneNotification(newZoneName);
          } else {
            console.log(`   ==> NO, el jugador sigue en la misma zona.`);
          }

          // 5. Actualizamos la propiedad del jugador para la UI del panel de estado.
          gameState.player.currentZoneName = newZoneName;

          // Actualizar el resto del juego
          updatePlayerPosition(`movePlayer_success_call_${callId}`);
          updateUI();
          lastSuccessfulMoveTime = now;

        }
      }

      //FIN FUNCION MOVE PLAYER
      function checkForAggressiveEnemies() {
        if (gameState.battle.active || isAnyModalOpen()) {
          return; // No iniciar combate si ya estamos en uno o en un modal.
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;

        // Comprobamos las 8 casillas adyacentes y la casilla actual
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue; // No comprobar la propia casilla del jugador

            const checkX = playerX + dx;
            const checkY = playerY + dy;

            const entity = gameState.map.entities.find(
              (e) => e.x === checkX && e.y === checkY
            );

            if (entity) {
              const isHostile =
                G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
                entity.isBoss ||
                entity.isMiniBoss;

              // Si la entidad es hostil, iniciamos la batalla
              if (isHostile) {
                showModal(
                  "¬°Emboscada!",
                  `¬°Un ${entity.name} te ataca al acercarte demasiado!`,
                  true
                );
                setTimeout(() => {
                  closeModal();
                  startBattle(entity);
                }, 1500);
                return; // Detenemos la funci√≥n para no iniciar m√∫ltiples combates
              }
            }
          }
        }
      }

      function getEnemyNameColor(playerLevel, enemyLevel) {
        const levelDiff = enemyLevel - playerLevel;

        if (levelDiff >= 5) {
          return { color: "#ff4d4d", fontWeight: "bold" }; // Rojo (Muy Peligroso)
        } else if (levelDiff >= 3) {
          return { color: "#ff9b57", fontWeight: "normal" }; // Naranja (Peligroso)
        } else if (levelDiff >= 1) {
          return { color: "#f4d03f", fontWeight: "normal" }; // Amarillo (M√°s fuerte)
        } else if (levelDiff <= -5) {
          return { color: "#a0a0a0", fontWeight: "normal" }; // Gris (Trivial)
        } else {
          return { color: "#f4e4bc", fontWeight: "normal" }; // Blanco (Normal)
        }
      }

      function gameLoop() {
        if (
          isAnyModalOpen() ||
          gameState.battle.active ||
          gameState.player.isCultivating
        ) {
          gameState.player.isMoving = false; // Detener animaci√≥n si el juego est√° pausado
          return;
        }

        handleMovement(); // Maneja la l√≥gica de movimiento
        checkForAggressiveEnemies();
        // Actualiza el frame de la animaci√≥n basado en el estado
        if (gameState.player.isMoving) {
          // Cicla entre los frames 1, 2, 3...
          const frameCount = gameState.player.animationFrames - 1; // e.g., si hay 4 frames, cicla entre 1,2,3
          gameState.player.currentFrame =
            (gameState.player.currentFrame % frameCount) + 1;
        } else {
          gameState.player.currentFrame = 0; // Frame 0 es quieto
        }

        updatePlayerSpriteVisual(); // Actualiza el sprite visualmente
      }

      // Ajuste menor en window.addEventListener('resize')
      window.addEventListener("resize", () => {
        calculateAndSetTileSize();
        // renderMap(); // updatePlayerPosition se encarga de esto
        updatePlayerPosition();
      });

      function getTerrainTypeAt(x, y) {
        if (
          x < 0 ||
          x >= gameState.map.width ||
          y < 0 ||
          y >= gameState.map.height
        ) {
          return null; // Fuera de los l√≠mites del mapa
        }

        // Opci√≥n A: Si usas terrainGrid directamente
        if (
          gameState.map.terrainGrid &&
          gameState.map.terrainGrid[y] &&
          gameState.map.terrainGrid[y][x]
        ) {
          return gameState.map.terrainGrid[y][x];
        }

        // Opci√≥n B: Usando terrainZones
        for (const zone of gameState.map.terrainZones) {
          if (x >= zone.x1 && x <= zone.x2 && y >= zone.y1 && y <= zone.y2) {
            return zone.type;
          }
        }
        return gameState.map.defaultTerrain; // Devuelve el terreno por defecto
      }

      function renderMap(callerId = "unknown") {
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!mapElement || !mapContainerElement) {
          return;
        }
        // --- INICIO DE LA L√ìGICA DE AISLAMIENTO DE ZONA ---
        const currentZone = getPlayerCurrentZone();
        let currentAmbientColor = "#1a3d2e"; // Color por defecto del mundo principal

        if (currentZone && currentZone.isIsolated) {
          // Si estamos en una zona aislada, cambiamos el fondo a un color de "vac√≠o"
          mapContainerElement.style.backgroundColor =
            currentZone.ambientColor || "#000";
        } else {
          // Si estamos en el mundo principal, el fondo es el definido en el CSS
          mapContainerElement.style.backgroundColor = "#1a3d2e"; // O el color original de tu .map-container
        }
        // --- FIN DE LA L√ìGICA DE AISLAMIENTO DE ZONA ---
        const currentContainerWidth = mapContainerElement.clientWidth;
        const currentContainerHeight = mapContainerElement.clientHeight;

        const playerScreenX = currentContainerWidth / 2 - currentTileSize / 2;
        const playerScreenY = currentContainerHeight / 2 - currentTileSize / 2;
        const mapExpectedScrollX =
          -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapExpectedScrollY =
          -(gameState.player.y * currentTileSize) + playerScreenY;

        const viewWorldXStart = Math.floor(
          -mapExpectedScrollX / currentTileSize
        );
        const viewWorldYStart = Math.floor(
          -mapExpectedScrollY / currentTileSize
        );
        const tilesInViewX =
          Math.ceil(currentContainerWidth / currentTileSize) + 2;
        const tilesInViewY =
          Math.ceil(currentContainerHeight / currentTileSize) + 2;
        const viewWorldXEnd = viewWorldXStart + tilesInViewX;
        const viewWorldYEnd = viewWorldYStart + tilesInViewY;

        mapElement.innerHTML = "";

        // 1. Renderizar TERRENO BASE
        for (let y = viewWorldYStart; y < viewWorldYEnd; y++) {
          for (let x = viewWorldXStart; x < viewWorldXEnd; x++) {
            let shouldDrawVoid = false;

            if (currentZone && currentZone.isIsolated) {
              if (
                x < currentZone.x1 ||
                x > currentZone.x2 ||
                y < currentZone.y1 ||
                y > currentZone.y2
              ) {
                shouldDrawVoid = true;
              }
            } else {
              // Si no estamos en una zona aislada, el "vac√≠o" es cualquier cosa fuera de los l√≠mites del mapa.
              if (
                x < 0 ||
                x >= gameState.map.width ||
                y < 0 ||
                y >= gameState.map.height
              ) {
                shouldDrawVoid = true;
              }
            }
            if (shouldDrawVoid) {
              const voidTile = document.createElement("div");
              voidTile.className = "tile void-tile";
              voidTile.style.left = `${x * currentTileSize}px`;
              voidTile.style.top = `${y * currentTileSize}px`;
              voidTile.style.width = `${currentTileSize}px`;
              voidTile.style.height = `${currentTileSize}px`;
              voidTile.style.backgroundColor = currentAmbientColor; // Rellena con el color de ambiente
              voidTile.style.zIndex = "0";
              const voidTerrainData = G_TERRAIN_TYPES.VOID;
              if (voidTerrainData && voidTerrainData.textureUrl) {
                voidTile.style.backgroundImage = `url('${voidTerrainData.textureUrl}')`;
                voidTile.style.backgroundSize = "cover";
              } else {
                // Si la textura del vac√≠o no se encuentra, vuelve a usar el color ambiental
                voidTile.style.backgroundColor = currentAmbientColor;
              }
              mapElement.appendChild(voidTile);
              continue; // Pasa al siguiente tile del bucle
            }
            const terrainId = getTerrainTypeAt(x, y);
            const terrainData = G_TERRAIN_TYPES[terrainId];
            if (terrainData) {
              const terrainTile = document.createElement("div");
              terrainTile.className = "tile terrain-tile";
              terrainTile.style.left = `${x * currentTileSize}px`;
              terrainTile.style.top = `${y * currentTileSize}px`;
              terrainTile.style.width = `${currentTileSize}px`;
              terrainTile.style.height = `${currentTileSize}px`;
              terrainTile.style.zIndex = "1";

              if (terrainData.textureUrl) {
                terrainTile.style.backgroundImage = `url('${terrainData.textureUrl}')`;
                terrainTile.style.backgroundSize = "cover";
              } else {
                terrainTile.style.backgroundColor = terrainData.color;
              }

              mapElement.appendChild(terrainTile);
            }
          }
        }

        // 2. Renderizar ENTIDADES
        gameState.map.entities.forEach((entity) => {
          if (entity.discovered) {
            if (
              entity.x >= viewWorldXStart &&
              entity.x < viewWorldXEnd &&
              entity.y >= viewWorldYStart &&
              entity.y < viewWorldYEnd
            ) {
              const entityContainer = document.createElement("div");
              entityContainer.style.position = "absolute";
              entityContainer.style.left = `${entity.x * currentTileSize}px`;
              entityContainer.style.top = `${entity.y * currentTileSize}px`;
              entityContainer.style.width = `${currentTileSize}px`;
              entityContainer.style.height = `${currentTileSize}px`;
              entityContainer.style.display = "flex";
              entityContainer.style.alignItems = "center";
              entityContainer.style.justifyContent = "center";
              entityContainer.style.zIndex = "5";

              const definition =
                entityTypes[entity.originalEntityTypeId] ||
                entityTypes[entity.type] ||
                (entity.typeOverride && entityTypes[entity.typeOverride]);

              // La URL del sprite se toma de la instancia, o de la definici√≥n encontrada.
              const spriteUrl =
                entity.spriteUrl || (definition ? definition.spriteUrl : null);
              if (spriteUrl) {
                entityContainer.style.backgroundImage = `url('${spriteUrl}')`;

                if (entity.originalEntityTypeId === "secta_entrada_principal") {
                  entityContainer.style.backgroundSize = "120%";
                  entityContainer.style.top = `${
                    (entity.y - 1.2) * currentTileSize
                  }px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                  // 1. Aumentamos el ancho del contenedor para que quepa el sprite
                  entityContainer.style.width = `${currentTileSize * 3}px`;

                  // 2. Ajustamos la posici√≥n izquierda para centrar el nuevo contenedor ancho
                  // Posici√≥n original: entity.x * currentTileSize
                  // Nuevo ancho: currentTileSize * 2.5
                  // Para centrarlo, debemos desplazarlo a la izquierda la mitad de su ancho extra.
                  // Ancho extra = (2.5 - 1) = 1.5. Mitad del ancho extra = 0.75.
                  entityContainer.style.left = `${
                    (entity.x - 0.75) * currentTileSize
                  }px`;
                } else if (entity.originalEntityTypeId === "shop") {
                  entityContainer.style.backgroundSize = "120%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.height = `${currentTileSize * 2}px`;
                  entityContainer.style.width = `${currentTileSize * 2}px`;
                  entityContainer.style.left = `${
                    (entity.x - 0.75) * currentTileSize
                  }px`;
                } else if (
                  entity.originalEntityTypeId === "deco_arbol_grande"
                ) {
                  entityContainer.style.backgroundSize = "120%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.height = `${currentTileSize * 1.2}px`;
                }else if (
                  entity.originalEntityTypeId === "deco_monta√±a_large"
                ) {
                  entityContainer.style.backgroundSize = "180%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 4}px`;
                  entityContainer.style.height = `${currentTileSize * 1}px`;
                }
                 else if (entity.originalEntityTypeId === "boss_dem") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (entity.originalEntityTypeId === "tp_sect_hub") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (entity.originalEntityTypeId === "tp_forest_shrine") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (entity.originalEntityTypeId === "tp_desert_oasis") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (
                  entity.originalEntityTypeId === "osa_mayor_esmeralda"
                ) {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1.5) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 1}px`;
                  entityContainer.style.height = `${currentTileSize * 2}px`;
                } else if (
                  entity.originalEntityTypeId === "monster_desierto_golem_arena"
                ) {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1.5) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 1}px`;
                  entityContainer.style.height = `${currentTileSize * 2}px`;
                } else if (entity.originalEntityTypeId === "tp_swamp_ruin") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                }else if (entity.originalEntityTypeId === "tp_desfiladero") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                }else if (entity.originalEntityTypeId === "tp_dragon_valley") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                }
                 else {
                  entityContainer.style.backgroundSize = "80%";
                }

                entityContainer.style.backgroundPosition = "center bottom";
                entityContainer.style.backgroundRepeat = "no-repeat";
              } else {
                entityContainer.textContent =
                  entity.symbol || (definition ? definition.symbol : "?");
                entityContainer.style.fontSize = `${
                  currentTileSize * (entity.isDecorative ? 0.5 : 0.6)
                }px`;
              }

              if (entity.isDecorative) {
                entityContainer.style.opacity = "0.7";
                entityContainer.style.zIndex = "3";
              }

              mapElement.appendChild(entityContainer);

              const isHostile =
                G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
                entity.isBoss ||
                entity.isMiniBoss;
              const isImportantNPC = entity.npcId && !isHostile;

              if (isHostile || isImportantNPC) {
                const namePlate = document.createElement("div");
                namePlate.className = "entity-name-plate";

                let displayText = entity.name;

                if (isHostile) {
                  // 1. A√±adir etiqueta de estatus si existe
                  if (entity.isBoss) {
                    displayText += ` (Jefe)`;
                  } else if (entity.isMiniBoss) {
                    displayText += ` (√âlite)`;
                  }

                  // 2. A√±adir SIEMPRE el nivel si la entidad lo tiene
                  if (entity.level) {
                    displayText += ` (Nv. ${entity.level})`;
                  }

                  // 3. Aplicar color
                  if (entity.isBoss) {
                    namePlate.style.color = "#ff4d4d"; // Rojo para Jefes
                    namePlate.style.fontWeight = "bold";
                  } else {
                    // Para todos los dem√°s enemigos (miniboss y comunes), usar la escala de color
                    const nameStyle = getEnemyNameColor(
                      gameState.player.level,
                      entity.level || 1
                    );
                    namePlate.style.color = nameStyle.color;
                    namePlate.style.fontWeight = nameStyle.fontWeight;
                  }
                }

                namePlate.textContent = displayText;
                entityContainer.appendChild(namePlate);
              }
            }
          }
        });

        updatePlayerVisualSize();
      }

      function updatePlayerSpriteVisual() {
        // Aseg√∫rate que el nombre sea este
        const player = gameState.player;
        const playerElement = document.getElementById("player");
        if (!playerElement) return;

        // Verificaci√≥n para depurar el error de la l√≠nea 2263
        if (
          !player.directionRowMap ||
          typeof player.currentDirection === "undefined"
        ) {
          console.error(
            "CRITICAL: player.directionRowMap o player.currentDirection no est√°n definidos en updatePlayerSpriteVisual.",
            player
          );
          // Podr√≠as establecer valores por defecto aqu√≠ como un parche temporal,
          // pero lo ideal es que est√©n bien inicializados en gameState.
          // player.currentDirection = player.currentDirection || 'down';
          // player.directionRowMap = player.directionRowMap || { 'down': 0, 'left': 1, 'right': 2, 'up': 3 };
          // player.currentFrame = player.currentFrame || 0;
          // player.frameWidth = player.frameWidth || 64;
          // player.frameHeight = player.frameHeight || 64;
          return; // Salir si faltan datos cruciales para evitar m√°s errores
        }

        const row = player.directionRowMap[player.currentDirection];
        const col = player.currentFrame;

        // Otra verificaci√≥n
        if (typeof row === "undefined" || typeof col === "undefined") {
          console.error(
            "CRITICAL: 'row' o 'col' son undefined en updatePlayerSpriteVisual.",
            {
              playerDir: player.currentDirection,
              playerFrame: player.currentFrame,
              map: player.directionRowMap,
            }
          );
          return;
        }

        const offsetX = col * player.frameWidth;
        const offsetY = row * player.frameHeight;

        playerElement.style.backgroundPosition = `-${offsetX}px -${offsetY}px`;

        if (gameState.battle.active) {
          const battlePlayerSprite = document.querySelector(
            ".battle-area .character-sprite"
          );
          if (battlePlayerSprite) {
            const battleRow = player.directionRowMap["down"];
            const battleFrame = 0;
            const battleOffsetX = battleFrame * player.frameWidth;
            const battleOffsetY = battleRow * player.frameHeight;
            battlePlayerSprite.style.backgroundPosition = `-${battleOffsetX}px -${battleOffsetY}px`;
          }
        }
      }

      function updatePlayerVisualSize() {
        const playerElement = document.getElementById("player");
        if (playerElement) {
          // ESTO ES CRUCIAL: El tama√±o del div del jugador DEBE ser el tama√±o de UN FRAME
          // Si currentTileSize representa el tama√±o deseado del jugador en pantalla,
          // y tus frames en la hoja de sprites son de un tama√±o fijo (ej. 64x64),
          // entonces el div del jugador tambi√©n debe ser de ese tama√±o fijo para que background-position funcione.
          // O, si quieres que el jugador se reescale con currentTileSize, entonces frameWidth/Height
          // deben ser iguales a currentTileSize, y background-size debe escalar la hoja completa.

          // Opci√≥n A: El jugador mantiene el tama√±o del frame original, y currentTileSize es solo para el mapa.
          playerElement.style.width = `${gameState.player.frameWidth}px`;
          playerElement.style.height = `${gameState.player.frameHeight}px`;
        }
      }

      function updatePlayerPosition(callerId = "unknown") {
        const playerElement = document.getElementById("player");
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!playerElement || !mapElement || !mapContainerElement) {
          console.error(
            "UpdatePlayerPosition: Elemento(s) clave no encontrado(s)."
          );
          return;
        }

        const playerVisualWidth = gameState.player.frameWidth; // Usar el tama√±o real del frame del sprite
        const playerVisualHeight = gameState.player.frameHeight;

        const playerScreenX =
          mapContainerElement.clientWidth / 2 - playerVisualWidth / 2;
        const playerScreenY =
          mapContainerElement.clientHeight / 2 - playerVisualHeight / 2;

        playerElement.style.left = `${playerScreenX}px`;
        playerElement.style.top = `${playerScreenY}px`;

        const mapScrollX =
          -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapScrollY =
          -(gameState.player.y * currentTileSize) + playerScreenY;

        mapElement.style.transform = `translate(${mapScrollX}px, ${mapScrollY}px)`;

        gameState.map.entities.forEach((entity) => {
          const distance =
            Math.abs(entity.x - gameState.player.x) +
            Math.abs(entity.y - gameState.player.y);
          if (distance <= G_PLAYER_DISCOVERY_RANGE) {
            if (!entity.discovered) entity.discovered = true;
          }
        });

        renderMap(callerId);
        updatePlayerSpriteVisual();
        updatePlayerVisualSize();
        updatePlayerBarsOnMap();
        updateExtraStatsUI();
      }

      function updateUI() {
        const player = gameState.player;
        document.getElementById("playerLevel").textContent = player.level;
        document.getElementById("playerRealm").textContent = player.realm;
        document.getElementById("hpText").textContent = `${Math.floor(
          player.hp
        )}/${player.maxHp}`;
        document.getElementById("manaText").textContent = `${Math.floor(
          player.mana
        )}/${player.maxMana}`;
        document.getElementById("expText").textContent = `${Math.floor(
          player.exp
        )}/${player.expToNext}`;

        // Barras del Sidebar
        const hpBarSidebar = document.getElementById("hpBar");
        const manaBarSidebar = document.getElementById("manaBar");
        const expBarSidebar = document.getElementById("expBar");

        if (hpBarSidebar)
          hpBarSidebar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        if (manaBarSidebar)
          manaBarSidebar.style.width = `${
            (player.mana / player.maxMana) * 100
          }%`;
        if (expBarSidebar)
          expBarSidebar.style.width = `${
            (player.exp / player.expToNext) * 100
          }%`;

        document.getElementById(
          "playerCoords"
        ).textContent = `X: ${player.x}, Y: ${player.y}`;

        updateExtraStatsUI();
        updateInventoryUI(); // Asumo que esta funci√≥n existe y es correcta
        updateSectUI(); // Asumo que esta funci√≥n existe y es correcta

        updatePlayerBarsOnMap(); // <--- LLAMADA A√ëADIDA para las barras sobre el jugador
      }

      function updateInventoryUI() {
        const inventoryDisplay = document.getElementById("inventory");
        inventoryDisplay.innerHTML = "";
        Object.entries(gameState.inventory).forEach(([itemName, count]) => {
          if (count <= 0 && itemName !== "Piedras Espirituales") return;

          const itemDiv = document.createElement("div");
          itemDiv.className = "inventory-item";

          const itemInfo = itemData[itemName];
          const description = itemInfo
            ? itemInfo.description
            : "Un objeto misterioso.";
          itemDiv.innerHTML = `<strong>${itemName}: ${count}</strong><br><small><em>${description}</em></small>`;

          if (count > 0 && itemInfo && itemInfo.effect) {
            const canBeUsedNow = itemInfo.canUse
              ? itemInfo.canUse(gameState.player)
              : true;
            itemDiv.style.cursor = canBeUsedNow ? "pointer" : "not-allowed";
            itemDiv.style.opacity = canBeUsedNow ? 1 : 0.6;
            itemDiv.title = canBeUsedNow
              ? `Usar ${itemName}`
              : `No puedes usar ${itemName} ahora.`;
            if (canBeUsedNow) {
              itemDiv.onclick = () => useItem(itemName);
            }
          } else {
            itemDiv.style.opacity = 0.8;
            itemDiv.style.cursor = "default";
          }
          inventoryDisplay.appendChild(itemDiv);
        });
      }

      function updateRefinementUI() {}

      let lastPlayerAnimationUpdateTime = 0; // Renombrado para claridad

      function handleMovement() {
        let dx = 0;
        let dy = 0;
        let newDirection = null;

        // Determina la direcci√≥n del movimiento
        if (playerMovementKeysDown.up) {
          dy = -1;
          newDirection = "up";
        } else if (playerMovementKeysDown.down) {
          dy = 1;
          newDirection = "down";
        } else if (playerMovementKeysDown.left) {
          dx = -1;
          newDirection = "left";
        } else if (playerMovementKeysDown.right) {
          dx = 1;
          newDirection = "right";
        }

        // Si hay una direcci√≥n presionada, intenta mover al jugador
        if (newDirection) {
          gameState.player.currentDirection = newDirection;
          movePlayer(dx, dy); // La l√≥gica de cooldown y colisi√≥n est√° dentro
        }

        // L√≥gica de animaci√≥n visual (separada de la l√≥gica de movimiento)
        const isActuallyMoving =
          playerMovementKeysDown.up ||
          playerMovementKeysDown.down ||
          playerMovementKeysDown.left ||
          playerMovementKeysDown.right;
        gameState.player.isMoving = isActuallyMoving;
      }

      function interact() {
        if (gameState.player.isCultivating) {
          showModal(
            "Acci√≥n no permitida",
            "Det√©n tu cultivo antes de interactuar."
          );
          return;
        }
        if (gameState.battle.active) {
          showModal(
            "Acci√≥n no permitida",
            "No puedes interactuar durante el combate."
          );
          return;
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        const offsets = [
          { dx: 0, dy: 0 },
          { dx: 0, dy: -1 },
          { dx: 1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: -1, dy: 0 },
        ];

        for (const offset of offsets) {
          const targetX = playerX + offset.dx;
          const targetY = playerY + offset.dy;
          const entity = gameState.map.entities.find(
            (e) => e.x === targetX && e.y === targetY
          );

          if (entity) {
            if (
              G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
              entity.isBoss ||
              entity.isSectChallengeRival
            ) {
              const desafioMision = gameState.player.secta.misionesActivas.find(
                (m) =>
                  MISIONES_DATA[m.id]?.objetivo?.tipo ===
                    "derrotar_npc_especifico" &&
                  MISIONES_DATA[m.id]?.objetivo?.npcId === entity.npcId
              );
              if (entity.isSectChallengeRival) {
                if (desafioMision) {
                  showModal(
                    "¬°Desaf√≠o Aceptado!",
                    `Te preparas para enfrentar a ${entity.name}.`,
                    true
                  );
                  setTimeout(() => {
                    closeModal();
                    startBattle(entity);
                  }, 1500);
                } else {
                  showModal(
                    "Paz, por ahora...",
                    `${entity.name} te observa, pero no hay raz√≥n para luchar.`
                  );
                }
              } else {
                showModal(
                  "¬°A la Batalla!",
                  `Decides enfrentar a ${entity.name}.`,
                  true
                );
                setTimeout(() => {
                  closeModal();
                  startBattle(entity);
                }, 1000);
              }
              return;
            } else if (
              entity.interaction ||
              entityTypes[entity.type]?.interaction ||
              [
                "resource",
                "master",
                "cultivation",
                "shop",
                "secta_entrada_principal",
              ].includes(entity.type)
            ) {
              handleEntityInteraction(entity);
              return;
            }
          }
        }
      }

      function handleEntityInteraction(entity) {
        if (!entity) return;

        let interactionType = entity.interaction; // Priorizar la interacci√≥n de la instancia

        // Si no hay interacci√≥n en la instancia, buscar en la definici√≥n de entityTypes
        // usando entity.originalEntityTypeId si est√° disponible, sino entity.type
        const definitionKey = entity.originalEntityTypeId || entity.type;
        if (!interactionType && entityTypes[definitionKey]) {
          interactionType = entityTypes[definitionKey].interaction;
        }
        // === INICIO DE LA NUEVA L√ìGICA DE TRANSICI√ìN ===
        if (interactionType === "transition") {
          const definition = entityTypes[definitionKey];
          if (
            definition &&
            typeof definition.targetX === "number" &&
            typeof definition.targetY === "number"
          ) {
            // Funci√≥n que se ejecutar√° si el jugador confirma
            const doTransition = () => {
              gameState.player.x = definition.targetX;
              gameState.player.y = definition.targetY;
              updatePlayerPosition(`transition_to_${definitionKey}`); // ¬°Muy importante!
              showModal(
                "Transici√≥n Completa",
                `Has llegado a ${definition.name}.`
              );
            };

            // Mostramos el modal de confirmaci√≥n
            showConfirmationModal(
              `Entrar a ${entity.name}`,
              "¬øDeseas pasar a la siguiente zona?",
              doTransition // Pasamos la funci√≥n como callback
            );
          } else {
            console.warn(
              `La entidad de transici√≥n ${definitionKey} no tiene coordenadas de destino (targetX, targetY).`
            );
          }
          return; // Detenemos la ejecuci√≥n para no procesar otros switches
        }
        if (interactionType === "activate_teleporter") {
          handleTeleporterInteraction(entity);
          return; // Detener para no procesar otros switches
        }
        if (interactionType) {
          switch (interactionType) {
            case "browse":
              if (entity.type === "shop") {
                openShop();
                return;
              }
              break;
            case "talk_story_npc":
              if (entity.npcId) {
                const dialogue = getStoryNpcDialogue(entity.npcId);
                showModal(`Hablando con ${entity.name}`, dialogue);
              }
              return;
            case "interact_shrine":
              if (entity.type === "story_shrine") {
                const player = gameState.player;
                if (
                  player.worldState.storyFlags.knowsAboutSoberano &&
                  !player.worldState.storyFlags.knowsFullTruth
                ) {
                  player.worldState.storyFlags.knowsFullTruth = true;
                  showModal(
                    "Un Eco del Pasado",
                    "Al tocar el santuario, una voz antigua resuena en tu mente...<br><br><em>'El Soberano Silente... fue nuestro mayor h√©roe, Longwei. Su poder amenaz√≥ con consumir todo, y lo sellamos. Pero el sello no es eterno... La resonancia en tu alma... el Arte del Coraz√≥n Celeste... no es para sellar, sino para purificar. Esa es tu verdadera prueba.'</em><br><br><strong>La verdad completa te ha sido revelada.</strong>"
                  );
                } else if (player.worldState.storyFlags.knowsFullTruth) {
                  showModal(
                    "Santuario del Eco",
                    "El santuario permanece en silencio, su prop√≥sito cumplido. El camino ahora es tuyo."
                  );
                } else {
                  showModal(
                    "Santuario del Eco",
                    "Sientes una energ√≠a antigua y melanc√≥lica, pero no puedes descifrar su significado... todav√≠a."
                  );
                }
              }
              return;
            case "talk_secta_npc":
              if (entity.npcId) {
                interactWithSectNPC(entity.npcId);
                return;
              }
              break;
            case "access_sect_hall":
              if (entity.type === "secta_entrada_principal") {
                openSectHallInterface();
                return;
              }
              break;
            case "collect_resource":
              const rewardItem =
                entity.reward ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].reward
                  : null) ||
                "Piedras Espirituales"; // √öltimo fallback

              const itemNameDisplay =
                entity.name ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].name
                  : entity.type);

              gameState.inventory[rewardItem] =
                (gameState.inventory[rewardItem] || 0) + 1;
              showModal(
                "Recurso Encontrado",
                `Has obtenido: 1 ${rewardItem}! (de ${itemNameDisplay})`
              );
              removeEntity(entity);
              updateInventoryUI();
              return;
            case "learn_from_master":
              const expGain =
                entity.expGain || entityTypes[entity.type]?.expGain || 50;
              gainExperience(expGain);
              showModal(
                "Encuentro con Maestro",
                `El ${entity.name} te ha ense√±ado sabidur√≠a. Ganas ${expGain} EXP!`
              );
              removeEntity(entity);
              return;
            case "meditate_spot":
              const manaGain =
                entity.manaGain || entityTypes[entity.type]?.manaGain || 20;
              gameState.player.mana = Math.min(
                gameState.player.maxMana,
                gameState.player.mana + manaGain
              );
              showModal(
                "Lugar de Cultivo",
                `Has meditado en '${entity.name}'. Recuperas ${manaGain} Man√°.`
              );
              removeEntity(entity);
              updateUI();
              return;
            default:
              console.warn(
                `Interacci√≥n '${interactionType}' desconocida para ${entity.name} (Tipo: ${entity.type}, ID: ${entity.id}).`
              );
              break;
          }
        } else {
          console.log(
            `No hay acci√≥n definida para tipo '${entity.type}' (Entidad: ${entity.name}, ID: ${entity.id}, OrigTypeID: ${entity.originalEntityTypeId}).`
          );
        }
      }

      function interactWithSectNPC(npcId) {
        const npcData = SECTA_DATA.npcs[npcId];
        const player = gameState.player;
        if (!npcData) {
          console.error(
            `[interactWithSectNPC] NPC Data no encontrada para npcId: ${npcId}`
          );
          return;
        }

        console.log(
          `[NPC Interaction] Starting interaction with NPC: ${npcData.nombre} (ID: ${npcId})`
        );
        console.log(
          `[NPC Interaction] Player Active Missions (Raw):`,
          JSON.parse(JSON.stringify(player.secta.misionesActivas))
        );
        console.log(
          `[NPC Interaction] Player Inventory:`,
          JSON.parse(JSON.stringify(gameState.inventory))
        );

        let modalContentHTML = `<h3>${npcData.nombre} (${npcData.rol})</h3>`;
        modalContentHTML += `<p><em>"${npcData.dialogoInicial}"</em></p><hr>`;

        const elementsToProcess = [];

        // --- SECCI√ìN: MISIONES PARA COMPLETAR ---
        modalContentHTML += `<h4>Misiones para Entregar/Reportar:</h4>`;
        let algunaMisionParaCompletar = false;

        player.secta.misionesActivas.forEach((misionActiva) => {
          const misionDef = MISIONES_DATA[misionActiva.id];

          // Log b√°sico para cada misi√≥n activa
          console.log(
            `[NPC Interaction] Evaluating Active Mission: "${misionDef?.titulo}" (ID: ${misionActiva.id})`
          );

          // Comprobaciones cruciales: misionDef, objetivo, y objetivoOriginal deben existir.
          if (
            !misionDef ||
            !misionDef.objetivo ||
            !misionActiva.objetivoOriginal
          ) {
            console.warn(
              `[NPC Interaction] Skipping mission ID ${misionActiva.id}: Missing misionDef, misionDef.objetivo, or misionActiva.objetivoOriginal.`
            );
            return; // Saltar esta misi√≥n si los datos esenciales faltan
          }

          const objetivo = misionActiva.objetivoOriginal; // Usar el objetivo original guardado

          console.log(
            `[NPC Interaction] Mission "${
              misionDef.titulo
            }": Target NPC for delivery/report is "${
              objetivo.npcEntrega
            }". Current NPC is "${npcId}". Match: ${
              objetivo.npcEntrega === npcId
            }`
          );

          // Solo procesar si el NPC actual es el NPC de entrega/reporte de la misi√≥n
          if (objetivo.npcEntrega === npcId) {
            let listaParaEntregar = false;
            let objetivoStatus = "";

            console.log(
              `[NPC Interaction] Mission "${misionDef.titulo}" IS for this NPC. Original objective type: ${objetivo.tipo}`
            );

            switch (objetivo.tipo) {
              case "entregar_item":
                const playerHasItem = gameState.inventory[objetivo.item] || 0;
                const needsItem = objetivo.cantidad;
                console.log(
                  `  - Type 'entregar_item'. Item: "${objetivo.item}", Needs: ${needsItem}, Player Has: ${playerHasItem}`
                );
                if (playerHasItem >= needsItem) {
                  listaParaEntregar = true;
                  objetivoStatus = `(Tienes ${playerHasItem}/${needsItem} ${objetivo.item})`;
                } else {
                  objetivoStatus = `(Necesitas ${
                    needsItem - playerHasItem
                  } m√°s ${objetivo.item})`;
                }
                break;

              case "eliminar_enemigo":
                const currentProgressElim = misionActiva.progreso || 0;
                const needsElim = objetivo.cantidad;
                console.log(
                  `  - Type 'eliminar_enemigo'. Target: "${objetivo.nombreDisplay}", Needs: ${needsElim}, Progress: ${currentProgressElim}`
                );
                if (currentProgressElim >= needsElim) {
                  listaParaEntregar = true; // Significa que los enemigos fueron eliminados, lista para 'reportar'
                  objetivoStatus = `(${currentProgressElim}/${needsElim} ${objetivo.nombreDisplay} eliminados)`;
                } else {
                  objetivoStatus = `(Elimina ${
                    needsElim - currentProgressElim
                  } m√°s ${objetivo.nombreDisplay})`;
                }
                break;

              case "recolectar_multiples_items":
                let todosRecolectados = true;
                let itemsStatusArray = [];
                console.log(
                  `  - Type 'recolectar_multiples_items'. Items required:`,
                  objetivo.items
                );
                for (const itemReq of objetivo.items) {
                  const playerHasMulti =
                    gameState.inventory[itemReq.nombre] || 0;
                  const needsMulti = itemReq.cantidad;
                  console.log(
                    `    - Item: "${itemReq.nombre}", Needs: ${needsMulti}, Player Has: ${playerHasMulti}`
                  );
                  if (playerHasMulti < needsMulti) {
                    todosRecolectados = false;
                  }
                  itemsStatusArray.push(
                    `${playerHasMulti}/${needsMulti} ${itemReq.nombre}`
                  );
                }
                if (todosRecolectados) {
                  listaParaEntregar = true;
                }
                objetivoStatus = `(${itemsStatusArray.join(", ")})`;
                break;
              case "derrotar_npc_especifico":
                // El progreso es 1 si el rival fue derrotado.
                if (misionActiva.progreso === 1) {
                  listaParaEntregar = true;
                  const rivalName =
                    entityTypes[objetivo.npcId]?.name || "el guardi√°n";
                  objetivoStatus = `(Has derrotado a ${rivalName})`;
                } else {
                  const rivalName =
                    entityTypes[objetivo.npcId]?.name || "el guardi√°n";
                  objetivoStatus = `(Debes derrotar a ${rivalName} en la arena)`;
                }
                break;

              case "cazar_y_recuperar_item_de_loot":
                const playerHasLootItem =
                  (gameState.inventory[objetivo.itemPrueba] || 0) >=
                  objetivo.cantidadItemPrueba;
                // El progreso a 1 indica que el tipo de enemigo que suelta el item fue derrotado.
                const killedCorrectEnemyType = misionActiva.progreso === 1;
                console.log(
                  `  - Type 'cazar_y_recuperar_item_de_loot'. Item: "${
                    objetivo.itemPrueba
                  }", Needs Qty: ${
                    objetivo.cantidadItemPrueba
                  }, Player Has Qty: ${
                    gameState.inventory[objetivo.itemPrueba] || 0
                  }. Killed enemy type: ${killedCorrectEnemyType}`
                );
                if (killedCorrectEnemyType && playerHasLootItem) {
                  // Debe haber matado al enemigo Y tener el √≠tem
                  listaParaEntregar = true;
                  objetivoStatus = `(Tienes ${objetivo.itemPrueba})`;
                } else if (!killedCorrectEnemyType) {
                  objetivoStatus = `(Caza al ${
                    entityTypes[objetivo.enemigoTipo]?.name ||
                    objetivo.enemigoTipo
                  } y consigue ${objetivo.itemPrueba})`;
                } else {
                  // Killed enemy, but doesn't have item (sold it? used it? or it never dropped - handle this in loot drop if needed)
                  objetivoStatus = `(Necesitas ${objetivo.itemPrueba}. ¬øLo perdiste o no lo obtuviste?)`;
                }
                break;

              // A√±adir m√°s casos aqu√≠ para otros tipos de misi√≥n que se completan con este NPC
              default:
                console.warn(
                  `[NPC Interaction] Unhandled objective type "${objetivo.tipo}" for mission "${misionDef.titulo}" completion check with NPC.`
                );
                objetivoStatus = `(Objetivo: ${objetivo.tipo} - estado no verificado aqu√≠)`;
                break;
            }

            console.log(
              `[NPC Interaction] Mission "${misionDef.titulo}": listaParaEntregar = ${listaParaEntregar}. Objetivo status display: ${objetivoStatus}`
            );

            // Solo mostrar el bot√≥n de completar si listaParaEntregar es true
            if (listaParaEntregar) {
              const buttonId = `complete-mission-btn-${misionActiva.id.replace(
                /\W/g,
                "_"
              )}`;
              modalContentHTML += `<div style="padding: 5px; border: 1px solid #55cc55; margin-bottom: 5px; background-color: rgba(85,204,85,0.1);">
                                              <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                              <button id="${buttonId}">Completar Misi√≥n</button>
                                          </div>`;
              elementsToProcess.push({
                buttonId: buttonId,
                action: () => {
                  console.log(
                    `[NPC Interaction] Clicked "Completar Misi√≥n" button for ${misionActiva.id}`
                  );
                  // Pasar npcId como npcIdEntregaManual a completeMission
                  if (completeMission(misionActiva.id, npcId)) {
                    // Si la misi√≥n se complet√≥ con √©xito, el modal del NPC se refrescar√°
                    // porque completeMission llama a showModal y al cerrarlo se actualiza el UI
                    // o, como alternativa, podemos forzar el refresco aqu√≠.
                    // closeModal(); // Cierra el modal de interacci√≥n actual
                    interactWithSectNPC(npcId); // Vuelve a abrir el modal del NPC con el estado actualizado
                  }
                  // Si completeMission devuelve false, generalmente ya muestra un modal de error/info.
                },
              });
              algunaMisionParaCompletar = true;
              console.log(
                `[NPC Interaction] SUCCESS: Added "Completar Misi√≥n" button for ${misionDef.titulo}`
              );
            } else {
              // Opcional: Mostrar la misi√≥n pero sin el bot√≥n de completar si no est√° lista
              modalContentHTML += `<div style="padding: 5px; border: 1px solid #777; margin-bottom: 5px; background-color: rgba(100,100,100,0.1);">
                                              <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                              <small><em>(A√∫n no cumples todos los requisitos para entregar/reportar esta misi√≥n)</em></small>
                                          </div>`;
              console.log(
                `[NPC Interaction] INFO: Mission "${misionDef.titulo}" is for this NPC but not ready for completion. Displaying status.`
              );
            }
          } else {
            // Log si la misi√≥n no es para este NPC
            // console.log(`[NPC Interaction] Mission "${misionDef.titulo}" is not designated for this NPC (Delivery NPC: ${objetivo.npcEntrega}).`);
          }
        });

        if (
          !algunaMisionParaCompletar &&
          !player.secta.misionesActivas.some(
            (m) => MISIONES_DATA[m.id]?.objetivo?.npcEntrega === npcId
          )
        ) {
          // Si no hay misiones para completar con ESTE NPC, y tampoco hay misiones activas que SEAN para este NPC (incluso si no est√°n listas)
          modalContentHTML +=
            "<p>No tienes misiones para entregarme o reportarme en este momento.</p>";
          console.log(
            `[NPC Interaction] No missions found that are completable OR assignable to this NPC for completion.`
          );
        } else if (!algunaMisionParaCompletar) {
          // Hay misiones asignadas a este NPC, pero ninguna est√° lista para completarse.
          modalContentHTML +=
            "<p>Revisa los objetivos de tus misiones activas. Parece que a√∫n no est√°n listas para entregar/reportar.</p>";
          console.log(
            `[NPC Interaction] Missions are assigned to this NPC, but none are ready for completion yet.`
          );
        }
        modalContentHTML += "<hr>";

        // --- SECCI√ìN: MISIONES DISPONIBLES (CON FILTRO DE NIVEL Y RANGO) ---
        // (Esta secci√≥n parece estar bien, la mantengo como estaba en tu c√≥digo anterior con la l√≥gica de requisitos)
        if (npcData.misionesOfrecidas && npcData.misionesOfrecidas.length > 0) {
          modalContentHTML += "<h4>Misiones Disponibles:</h4>";
          modalContentHTML += `<div id="npc-dynamic-content-missions" style="max-height: 200px; overflow-y: auto; border: 1px solid #444; padding: 10px; margin-bottom:10px;">`;
          let algunaMisionDisponibleMostrada = false;
          npcData.misionesOfrecidas.forEach((misionId, index) => {
            const mision = MISIONES_DATA[misionId];
            if (
              mision &&
              !player.secta.misionesActivas.some((m) => m.id === misionId) &&
              !player.secta.misionesCompletadas[misionId]
            ) {
              const nivelRequerido = mision.requisitoNivel || 0;
              const rangoRequeridoNombre = mision.requisitoRango;
              let cumpleRequisitos = true;

              if (player.level < nivelRequerido) {
                cumpleRequisitos = false;
              }
              if (rangoRequeridoNombre) {
                const indiceRangoJugador = SECTA_DATA.rangos.findIndex(
                  (r) => r.nombre === player.secta.rango
                );
                const indiceRangoRequerido = SECTA_DATA.rangos.findIndex(
                  (r) => r.nombre === rangoRequeridoNombre
                );
                if (indiceRangoJugador < indiceRangoRequerido) {
                  cumpleRequisitos = false;
                }
              }

              if (cumpleRequisitos) {
                let recompensaTextoResumido = `Recompensa: ${
                  mision.recompensa.pcs || 0
                } PCS, ${mision.recompensa.exp || 0} EXP`;
                if (mision.recompensa.items)
                  recompensaTextoResumido += ", Objetos";
                if (mision.recompensa.nuevoRango)
                  recompensaTextoResumido += `, Ascenso a ${mision.recompensa.nuevoRango}`;

                const buttonId = `accept-mission-btn-${misionId.replace(
                  /\W/g,
                  "_"
                )}-${index}`;
                const botonHTML = `<button id="${buttonId}">Aceptar Misi√≥n</button>`;

                modalContentHTML += `<div style="padding: 5px; border: 1px solid #555; margin-bottom: 5px;">
                                              <strong>${
                                                mision.titulo
                                              }</strong> (Req. Nv: ${
                  nivelRequerido > 0 ? nivelRequerido : "Ninguno"
                }${
                  rangoRequeridoNombre ? ", Rango: " + rangoRequeridoNombre : ""
                })<br><small>${mision.descripcion}</small><br>
                                              <small style="color: #aaa;"><em>${recompensaTextoResumido}</em></small><br>
                                              ${botonHTML}
                                          </div>`;
                elementsToProcess.push({
                  buttonId: buttonId,
                  missionIdToAccept: misionId,
                });
                algunaMisionDisponibleMostrada = true;
              }
            }
          });
          if (!algunaMisionDisponibleMostrada)
            modalContentHTML +=
              "<p>No hay nuevas misiones para ti en este momento que cumplan tus requisitos.</p>";
          modalContentHTML += `</div>`;
          modalContentHTML += "<hr>";
        } else {
          modalContentHTML +=
            "<p>No tengo misiones para ti en este momento.</p><hr>";
        }

        // --- SECCI√ìN: ENTREGA DE RECURSOS ---
        // (Esta secci√≥n parece estar bien, la mantengo)
        if (npcData.aceptaRecursos && npcData.aceptaRecursos.length > 0) {
          modalContentHTML += `<h4>Entregar Recursos:</h4>`;
          modalContentHTML += `<div id="npc-dynamic-content-resources" style="max-height: 150px; overflow-y: auto;">`;
          let puedeEntregarAlgo = false;
          npcData.aceptaRecursos.forEach((itemName) => {
            const cantidadPlayer = gameState.inventory[itemName] || 0;
            if (cantidadPlayer > 0) {
              const pcsPorItem =
                itemName === "Hierbas Medicinales"
                  ? 2
                  : itemName === "Cristales de Qi"
                  ? 5
                  : itemName === "N√∫cleo de Bestia Menor"
                  ? 10
                  : 1;
              const buttonIdEntregar1 = `entregar-1-${itemName.replace(
                /\W/g,
                "_"
              )}`;
              const buttonIdEntregarAll = `entregar-all-${itemName.replace(
                /\W/g,
                "_"
              )}`;
              modalContentHTML += `<p>${itemName} (Tienes: ${cantidadPlayer}):
                                      <button id="${buttonIdEntregar1}">Entregar 1 (${pcsPorItem} PCS)</button>
                                      ${
                                        cantidadPlayer > 1
                                          ? `<button id="${buttonIdEntregarAll}">Entregar Todo (${
                                              pcsPorItem * cantidadPlayer
                                            } PCS)</button>`
                                          : ""
                                      }
                                  </p>`;
              elementsToProcess.push({
                buttonId: buttonIdEntregar1,
                action: () => {
                  entregarRecursoSecta(itemName, 1, pcsPorItem);
                  interactWithSectNPC(npcId);
                },
              });
              if (cantidadPlayer > 1) {
                elementsToProcess.push({
                  buttonId: buttonIdEntregarAll,
                  action: () => {
                    entregarRecursoSecta(
                      itemName,
                      cantidadPlayer,
                      pcsPorItem * cantidadPlayer
                    );
                    interactWithSectNPC(npcId);
                  },
                });
              }
              puedeEntregarAlgo = true;
            }
          });
          if (!puedeEntregarAlgo)
            modalContentHTML +=
              "<p>No tienes recursos que pueda necesitar en este momento.</p>";
          modalContentHTML += `</div><hr>`;
        }

        showModal("Interacci√≥n con " + npcData.nombre, modalContentHTML);

        const modalTextEl = document.getElementById("modalText");
        if (modalTextEl) {
          elementsToProcess.forEach((item) => {
            const buttonElement = modalTextEl.querySelector(
              "#" + item.buttonId
            );
            if (buttonElement) {
              if (item.missionIdToAccept) {
                buttonElement.addEventListener("click", () => {
                  acceptMission(item.missionIdToAccept);
                  interactWithSectNPC(npcId);
                });
              } else if (item.action) {
                buttonElement.addEventListener("click", item.action);
              }
            } else {
              console.warn(
                "[NPC Interaction] Could not find button with ID:",
                item.buttonId,
                "in #modalText to attach listener."
              );
            }
          });
        } else {
          console.error(
            "[NPC Interaction] #modalText element not found for attaching listeners to dynamic buttons."
          );
        }
      }

      function entregarRecursoSecta(itemName, cantidad, pcsGanados) {
        if ((gameState.inventory[itemName] || 0) < cantidad) {
          showModal("Error", "No tienes suficientes objetos.");
          return;
        }
        gameState.inventory[itemName] -= cantidad;
        gameState.player.secta.puntosContribucion += pcsGanados;
        showModal(
          "Recurso Entregado",
          `Entregaste ${cantidad} ${itemName} y ganaste ${pcsGanados} PCS.`
        );
        updateSectUI();
        updateInventoryUI();
        checkAndActivateRankChallengeMissions();
        closeModal();
      }

      function acceptMission(misionId) {
        const misionData = MISIONES_DATA[misionId];
        const player = gameState.player;
        if (!misionData) {
          showModal("Error de Misi√≥n", "Datos no encontrados.");
          return;
        }
        if (
          player.secta.misionesActivas.some((m) => m.id === misionId) ||
          player.secta.misionesCompletadas[misionId]
        ) {
          showModal("Error de Misi√≥n", "Ya activa/completada.");
          return;
        }
        if (!misionData.objetivo) {
          showModal("Error de Misi√≥n", "Objetivo no definido.");
          return;
        }

        let nuevaMisionActiva;
        try {
          nuevaMisionActiva = {
            id: misionId,
            progreso: 0,
            objetivoOriginal: JSON.parse(JSON.stringify(misionData.objetivo)),
          };
        } catch (error) {
          showModal("Error de Misi√≥n", "Problema al procesar objetivo.");
          return;
        }

        player.secta.misionesActivas.push(nuevaMisionActiva);
        showModal("Misi√≥n Aceptada", `Has aceptado: ${misionData.titulo}`);
        updateSectUI();

        const npcInteractionModal = document.getElementById("interactionModal");
        const modalTitleElement = document.getElementById("modalTitle");
        if (
          npcInteractionModal.style.display === "flex" &&
          modalTitleElement &&
          modalTitleElement.textContent.includes("Interacci√≥n con Secta")
        ) {
          closeModal();
        }
      }

      function removeEntity(entityToRemove) {
        const index = gameState.map.entities.findIndex(
          (e) => e.id === entityToRemove.id
        ); // Usar ID √∫nico

        if (index > -1) {
          const removedEntity = gameState.map.entities.splice(index, 1)[0];

          // Si la entidad proven√≠a de una zona de spawn, actualizar el contador de esa zona
          if (removedEntity.zoneOrigin) {
            const originZone = gameState.map.terrainZones.find(
              (z) => z.name === removedEntity.zoneOrigin && z.spawnSettings
            );
            if (originZone) {
              const targetSpawnInfo =
                originZone.spawnSettings.targetEntities.find(
                  (t) => t.entityTypeId === removedEntity.originalEntityTypeId // <-- USAR ESTO
                );
              if (targetSpawnInfo && targetSpawnInfo.currentCount > 0) {
                targetSpawnInfo.currentCount--;
                // console.log(`Entidad ${removedEntity.name} eliminada de zona ${originZone.name}. Restantes de tipo ${targetSpawnInfo.entityTypeId}: ${targetSpawnInfo.currentCount}`);

                // Si el contador baja y el timer estaba en cooldown, podemos resetear el timer
                // para que intente reaparecer antes si la zona est√° por debajo del objetivo.
                // Opcional: Podr√≠as querer que el cooldown siempre se cumpla.
                // if (originZone.spawnSettings.respawnTimer > 10) { // Si estaba en cooldown largo
                //    originZone.spawnSettings.respawnTimer = 10; // Poner un cooldown corto para el pr√≥ximo chequeo
                // }
              }
            }
          }
          renderMap(); // Actualizar visualizaci√≥n
        }
      }

      function isRespawnNeeded() {
        const player = gameState.player;
        const activeBoss = gameState.map.entities.find(
          (e) =>
            e.isBoss &&
            !player.worldState.defeatedBosses[e.id || e.type] &&
            Math.abs(e.x - player.x) <= 5 &&
            Math.abs(e.y - player.y) <= 5
        );
        return !activeBoss;
      }

      function toggleCultivation() {
        if (gameState.battle.active) {
          showModal("Acci√≥n no permitida", "No puedes cultivar en combate.");
          return;
        }
        if (gameState.player.isCultivating) {
          showActiveCultivationModal();
        } else {
          openCultivationChoiceModal();
        }
      }

      function openCultivationChoiceModal() {
        const player = gameState.player;
        const techniquesListDiv = document.getElementById(
          "cultivableTechniquesList"
        );

        // Comprobaci√≥n de seguridad
        if (!techniquesListDiv) {
          console.error(
            "Error: El contenedor 'cultivableTechniquesList' no se encontr√≥ en el HTML."
          );
          return;
        }

        techniquesListDiv.innerHTML = ""; // Limpiar contenido anterior
        let hasCultivableTechniques = false;

        for (const techId in player.learnedTechniques) {
          const playerTech = player.learnedTechniques[techId];
          const techData = techniqueData[techId];
          if (
            techData &&
            techData.cultivationSettings &&
            playerTech.level < techData.maxLevel
          ) {
            hasCultivableTechniques = true;
            const techButton = document.createElement("button");
            techButton.className = "cultivation-option-btn";
            techButton.textContent = `${techData.name} (Nv. ${playerTech.level})`;

            // --- LA CORRECCI√ìN CLAVE EST√Å AQU√ç ---
            techButton.onclick = () => {
              // 1. Primero, cerramos el modal actual.
              closeCultivationChoiceModal();
              // 2. Despu√©s, iniciamos el nuevo modo de cultivo.
              startCultivationMode("technique", techId);
            };
            // --- FIN DE LA CORRECCI√ìN ---

            techniquesListDiv.appendChild(techButton);
          }
        }

        if (!hasCultivableTechniques) {
          techniquesListDiv.innerHTML =
            "<p>No tienes t√©cnicas que requieran m√°s cultivo.</p>";
        }

        document.getElementById("cultivationChoiceModal").style.display =
          "flex";
        hideTouchControls();
      }

      function closeCultivationChoiceModal() {
        document.getElementById("cultivationChoiceModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
      }

      function startCultivationMode(type, targetId = null) {
        // --- INICIO DE LA CORRECCI√ìN ---
        // Siempre que se inicie un modo de cultivo, cerramos el modal de elecci√≥n.
        closeCultivationChoiceModal();
        // --- FIN DE LA CORRECCI√ìN ---

        console.log(
          `[Cultivo LOG] ==> INTENTO DE INICIAR CULTIVO (Tipo: '${type}', T√©cnica: '${targetId}')`
        );
        if (gameState.player.isCultivating || gameState.cultivationInterval) {
          stopCultivation();
        }

        gameState.player.isCultivating = true;
        gameState.player.cultivationMode = {
          type,
          targetId,
          startTime: Date.now(),
          isConversionCultivation: false,
        };

        gameState.cultivationInterval = setInterval(
          processCultivationTick,
          1000
        );
        console.log(
          `[Cultivo LOG] -> NUEVO INTERVALO CREADO. ID: ${gameState.cultivationInterval}`
        );

        showActiveCultivationModal();
        renderQuickSlotBar();
      }

      function stopCultivation(
        showFeedbackModal = false,
        feedbackMessage = {}
      ) {
        const player = gameState.player;
        console.log(`[Cultivo LOG] ==> INTENTO DE DETENER CULTIVO`);

        if (!gameState.cultivationInterval) {
          console.log(
            `[Cultivo LOG]   -> No hay intervalo que detener. El cultivo ya estaba parado.`
          );
          // A√∫n as√≠, reseteamos el estado del jugador por si est√° desincronizado.
          player.isCultivating = false;
          player.cultivationMode = {
            type: null,
            targetId: null,
            startTime: 0,
            isConversionCultivation: false,
          };
          console.log(
            `[Cultivo LOG]   -> Estado del jugador reseteado por seguridad.`
          );
          return;
        }

        const intervalToClear = gameState.cultivationInterval;
        console.log(
          `[Cultivo LOG]   -> Limpiando intervalo con ID: ${intervalToClear}`
        );
        clearInterval(intervalToClear);
        gameState.cultivationInterval = null;
        console.log(
          `[Cultivo LOG]   -> Intervalo limpiado. gameState.cultivationInterval ahora es: ${gameState.cultivationInterval}`
        );

        player.isCultivating = false;
        player.cultivationMode = {
          type: null,
          targetId: null,
          startTime: 0,
          isConversionCultivation: false,
        };
        console.log(
          `[Cultivo LOG]   -> Estado del jugador reseteado: isCultivating = ${player.isCultivating}`
        );

        closeActiveCultivationModal();
        renderQuickSlotBar();
        updateUI();

        if (showFeedbackModal) {
          console.log(
            `[Cultivo LOG]   -> Mostrando modal de feedback: "${feedbackMessage.title}"`
          );
          showModal(
            feedbackMessage.title || "Cultivo Detenido",
            feedbackMessage.text || "Has dejado de cultivar."
          );
        }
      }

      function showActiveCultivationModal() {
        const player = gameState.player;
        const modal = document.getElementById("activeCultivationModal");
        if (!modal) return; // Salida temprana si el modal no existe.

        // Ocultar todas las secciones primero
        const techUI = document.getElementById("activeCultivationProgressUI");
        const recoveryUI = document.getElementById(
          "recoveryCultivationProgressUI"
        );
        const boostUI = document.getElementById("cultivationBoostSection");

        if (techUI) techUI.style.display = "none";
        if (recoveryUI) recoveryUI.style.display = "none";
        if (boostUI) boostUI.style.display = "none";

        if (!player.isCultivating) {
          modal.style.display = "none";
          return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        const titleEl = document.getElementById("activeCultivationTitle");
        const descEl = document.getElementById("activeCultivationDescription");
        if (!titleEl || !descEl) return;

        if (mode === "technique" && targetId) {
          const techData = techniqueData[targetId];
          const playerTech = player.learnedTechniques[targetId];

          if (techData && playerTech && techUI) {
            techUI.style.display = "block";
            if (boostUI) boostUI.style.display = "block";

            titleEl.textContent = `Cultivando: ${techData.name}`;
            descEl.textContent = techData.description;

            // Actualizar UI de la t√©cnica
            const nameSpan = document.getElementById(
              "activeCultivationTargetName"
            );
            const levelSpan = document.getElementById(
              "activeCultivationTargetLevel"
            );
            if (nameSpan) nameSpan.textContent = techData.name;
            if (levelSpan) levelSpan.textContent = playerTech.level;

            // L√≥gica de la barra de progreso
            const progressBar = document.getElementById(
              "activeCultivationProgressBar"
            );
            const progressText = document.getElementById(
              "activeCultivationProgressText"
            );
            if (progressBar && progressText) {
              const progress = playerTech.currentCultivationProgress || 0;
              const timeToNext =
                playerTech.cultivationTimeToNextLevel || Infinity;
              let percent =
                timeToNext > 0 && timeToNext !== Infinity
                  ? (progress / timeToNext) * 100
                  : playerTech.level >= techData.maxLevel
                  ? 100
                  : 0;

              progressBar.style.width = `${Math.min(100, percent)}%`;
              progressText.textContent =
                timeToNext === Infinity
                  ? "Nivel M√°ximo"
                  : `${Math.floor(progress)}s / ${timeToNext}s`;
            }

            // Actualizar secci√≥n de aceleraci√≥n
            const stonesDisplay = document.getElementById("cultivationModalPlayerStones");
            const boostButton1 = document.getElementById("boostCultivationButton1");
            const boostButton10 = document.getElementById("boostCultivationButton10");
            const currentStones = gameState.inventory["Piedras Espirituales"] || 0;
            if (stonesDisplay) stonesDisplay.textContent = currentStones;
            if (boostButton1) {
                boostButton1.disabled = currentStones < 1 || playerTech.level >= techData.maxLevel;
            }
            if (boostButton10) {
                boostButton10.disabled = currentStones < 10 || playerTech.level >= techData.maxLevel;
            }
          
          
              }

          
        } else if (mode === "recovery") {
          if (recoveryUI) {
            recoveryUI.style.display = "block";
            titleEl.textContent = "Meditaci√≥n Restauradora";
            descEl.textContent = "Recuperando energ√≠a...";

            // Actualizar barras de HP/Man√° del modal
            const hpText = document.getElementById("modalHpText");
            const hpBar = document.getElementById("modalHpBar");
            const manaText = document.getElementById("modalManaText");
            const manaBar = document.getElementById("modalManaBar");
            if (hpText)
              hpText.textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
            if (hpBar)
              hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
            if (manaText)
              manaText.textContent = `${Math.floor(player.mana)}/${
                player.maxMana
              }`;
            if (manaBar)
              manaBar.style.width = `${(player.mana / player.maxMana) * 100}%`;
          }
        }

        modal.style.display = "flex";
        hideTouchControls();
      }

      function updateStatsPanelVisibility() {
        const statsPanel = document.querySelector(".stats-panel");
        if (!statsPanel) {
          console.error(
            "No se encontr√≥ el elemento .stats-panel para actualizar su visibilidad."
          );
          return;
        }

        // El panel debe estar oculto si la batalla est√° activa O si cualquier modal est√° abierto.
        const shouldBeHidden = gameState.battle.active || isAnyModalOpen();

        if (shouldBeHidden) {
          statsPanel.classList.add("hidden");
        } else {
          statsPanel.classList.remove("hidden");
        }
      }

      function closeActiveCultivationModal() {
        document.getElementById("activeCultivationModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
      }

      function processCultivationTick() {
        const player = gameState.player;

        // Medida de seguridad: si el tick se ejecuta cuando no deber√≠a, se detiene.
        if (!player.isCultivating || !gameState.cultivationInterval) {
          stopCultivation();
          return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        // --- CULTIVO DE T√âCNICA (sin cambios, ya funciona bien) ---
        if (mode === "technique" && targetId) {
          const playerTech = player.learnedTechniques[targetId];
          const techData = techniqueData[targetId];
          if (playerTech && techData && playerTech.level < techData.maxLevel) {
            playerTech.currentCultivationProgress =
              (playerTech.currentCultivationProgress || 0) + 1;
            const progress = playerTech.currentCultivationProgress;
            const required = playerTech.cultivationTimeToNextLevel || Infinity;

            if (progress >= required) {
              playerTech.level++;
              playerTech.currentCultivationProgress = 0;
              playerTech.cultivationTimeToNextLevel =
                playerTech.level < techData.maxLevel
                  ? Math.floor(
                      techData.cultivationSettings.baseTimeToLevelUp *
                        Math.pow(
                          techData.cultivationSettings.levelTimeMultiplier,
                          playerTech.level
                        )
                    )
                  : Infinity;
              applyTechniqueEffect(targetId, playerTech.level);
              recalculatePlayerStats();
              stopCultivation(true, {
                title: "¬°T√©cnica Mejorada!",
                text: `¬°'${techData.name}' ha subido al Nivel ${playerTech.level}!`,
              });
              return;
            }
          } else {
            stopCultivation(true, {
              title: "Cultivo Detenido",
              text: "La t√©cnica ha alcanzado su m√°ximo potencial.",
            });
            return;
          }

          // --- CULTIVO DE RECUPERACI√ìN ---
        } else if (mode === "recovery") {
          // =========================================================================
          // === CORRECCI√ìN CLAVE: L√≥gica de Conversi√≥n de Qi (SI EST√Å ACTIVA) ===
          // =========================================================================
          if (player.cultivationMode.isConversionCultivation) {
            const conversionTechInfo = techniqueData["qi_to_hp_conversion_1"];
            const playerConversionTech =
              player.learnedTechniques["qi_to_hp_conversion_1"];

            if (conversionTechInfo?.effect && playerConversionTech?.level > 0) {
              const effectDef = conversionTechInfo.effect;
              const techLevel = playerConversionTech.level;

              const manaCost = Math.max(
                0.1,
                effectDef.baseManaCostPerSecond -
                  (effectDef.manaCostReductionPerLevel || 0) * (techLevel - 1)
              );
              const hpGain =
                effectDef.baseHpGainPerSecond +
                (effectDef.hpGainIncreasePerLevel || 0) * (techLevel - 1);

              // Si se puede convertir, se hace y se termina el tick.
              if (player.mana >= manaCost && player.hp < player.maxHp) {
                player.mana -= manaCost; // <-- Se resta el man√°.
                player.hp = Math.min(player.maxHp, player.hp + hpGain);
                // IMPORTANTE: No se ejecuta nada m√°s de recuperaci√≥n en este tick.
              } else {
                // Si no se puede, se detiene el cultivo con un mensaje.
                stopCultivation(true, {
                  title: "Conversi√≥n Detenida",
                  text: "Man√° insuficiente o vida al m√°ximo.",
                });
                return; // Salimos del tick para no hacer nada m√°s.
              }
            } else {
              // Si por alguna raz√≥n falta la t√©cnica, se detiene para evitar errores.
              stopCultivation(true, {
                title: "Error de T√©cnica",
                text: "No se encontr√≥ la t√©cnica de Conversi√≥n de Qi.",
              });
              return;
            }

            // ==================================================================================
            // === L√≥gica de Meditaci√≥n Restauradora Normal (SOLO SI LA CONVERSI√ìN NO EST√Å ACTIVA) ===
            // ==================================================================================
          } else {
            if (player.hp < player.maxHp) {
              player.hp = Math.min(
                player.maxHp,
                player.hp + player.hpPerSecondBase
              );
            }
            if (player.mana < player.maxMana) {
              player.mana = Math.min(
                player.maxMana,
                player.mana + player.qiPerSecondBase
              );
            }
            gainExperience(player.expPerSecondBase);
          }
        }

        // Al final del tick, se actualiza la UI con los nuevos valores.
        updateUI();
        showActiveCultivationModal();
      }

      function boostCultivationProgress(amount = 1) { // Acepta un argumento 'amount', con 1 como valor por defecto
        const player = gameState.player;
        const mode = player.cultivationMode;
        const timePerStone = 10; // 10 segundos de progreso por cada piedra

        if (!player.isCultivating || mode.type !== 'technique' || !mode.targetId) return;

        // Comprobamos si el jugador tiene suficientes piedras
        if ((gameState.inventory["Piedras Espirituales"] || 0) < amount) {
            showModal("Piedras Insuficientes", `Necesitas al menos ${amount} Piedras Espirituales para hacer esto.`);
            return;
        }

        const techId = mode.targetId;
        const playerTech = player.learnedTechniques[techId];
        const techData = techniqueData[techId];

        if (!playerTech || !techData || !techData.cultivationSettings || playerTech.level >= techData.maxLevel) {
            showModal("L√≠mite Alcanzado", "Esta t√©cnica ya est√° en su nivel m√°ximo.");
            return;
        }

        // Restamos la cantidad de piedras y a√±adimos el progreso correspondiente
        gameState.inventory["Piedras Espirituales"] -= amount;
        playerTech.currentCultivationProgress = (playerTech.currentCultivationProgress || 0) + (amount * timePerStone);
        
        let leveledUpThisBoost = false;
        let firstLevelUpMessage = "";

        // Bucle para comprobar si se sube de nivel (puede subir varios niveles de golpe)
        while (
            playerTech.currentCultivationProgress >= playerTech.cultivationTimeToNextLevel &&
            playerTech.level < techData.maxLevel
        ) {
            leveledUpThisBoost = true;
            const progressNeeded = playerTech.cultivationTimeToNextLevel;
            playerTech.currentCultivationProgress -= progressNeeded;
            playerTech.level++;

            if (!firstLevelUpMessage) {
                firstLevelUpMessage = `¬°Aceleraste '${techData.name}' al Nivel ${playerTech.level}!`;
                if (playerTech.level >= techData.maxLevel) {
                    firstLevelUpMessage += " (¬°Nivel M√°ximo alcanzado!)";
                }
            }

            if (playerTech.level < techData.maxLevel) {
                playerTech.cultivationTimeToNextLevel = Math.floor(
                    techData.cultivationSettings.baseTimeToLevelUp *
                    Math.pow(techData.cultivationSettings.levelTimeMultiplier, playerTech.level)
                );
            } else {
                playerTech.cultivationTimeToNextLevel = Infinity;
                playerTech.currentCultivationProgress = 0;
            }
            applyTechniqueEffect(techId, playerTech.level);
        }
        
        recalculatePlayerStats();
        updateUI();

        if (leveledUpThisBoost) {
            stopCultivation();
            showModal("¬°T√©cnica Mejorada con Aceleraci√≥n!", firstLevelUpMessage + "\n\nEl cultivo se ha detenido para que puedas ver los cambios.");
            return;
        }

        if (playerTech.level >= techData.maxLevel) {
            stopCultivation();
            showModal("Nivel M√°ximo Alcanzado", `La t√©cnica ${techData.name} ya est√° en su m√°ximo potencial.`);
            return;
        }
        
        // Si no se subi√≥ de nivel, solo actualizamos la UI del modal
        if (document.getElementById("activeCultivationModal").style.display === "flex") {
            showActiveCultivationModal();
        }
    }

      function toggleQiConversion() {
        const player = gameState.player;

        // Si ya hay un cultivo de CUALQUIER tipo activo...
        if (player.isCultivating) {
          // ...y ese cultivo es espec√≠ficamente el de conversi√≥n...
          if (player.cultivationMode.isConversionCultivation) {
            // ...entonces lo detenemos.
            console.log("Deteniendo cultivo de conversi√≥n de Qi activo.");
            stopCultivation(true, {
              title: "Conversi√≥n Detenida",
              text: "Has detenido la conversi√≥n de Man√° a Vida.",
            });
          } else {
            // Si es otro tipo de cultivo (ej. de t√©cnica), avisamos al jugador.
            showModal(
              "Acci√≥n no permitida",
              "Debes detener tu cultivo actual para iniciar la conversi√≥n de Qi."
            );
          }
          return;
        }

        // Si no hay ning√∫n cultivo activo, iniciamos el de conversi√≥n.
        console.log("Iniciando cultivo con CONVERSI√ìN DE QI.");

        // CORRECCI√ìN CLAVE 1:
        // Iniciamos el modo de cultivo de recuperaci√≥n, pero inmediatamente despu√©s,
        // marcamos que es un modo especial de conversi√≥n.
        startCultivationMode("recovery");
        player.cultivationMode.isConversionCultivation = true; // <-- Esta es la marca especial.

        // Tambi√©n actualizamos la UI para que el bot√≥n refleje el estado activo.
        renderQuickSlotBar();
      }

      function useItem(itemName) {
        if (gameState.battle.active) {
          showModal(
            "Acci√≥n no permitida",
            "No puedes usar objetos del inventario en combate desde aqu√≠."
          );
          return;
        }
        if (
          !gameState.inventory[itemName] ||
          gameState.inventory[itemName] <= 0
        ) {
          showModal("Inventario Vac√≠o", `No tienes ${itemName}.`);
          return;
        }
        const itemInfo = itemData[itemName];
        if (!itemInfo || !itemInfo.effect) {
          showModal(
            "Error",
            `${itemName} no tiene efecto o no se puede usar as√≠.`
          );
          return;
        }
        if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
          let reason = "No puedes usar esto ahora.";
          if (
            itemName === "Hierbas Medicinales" &&
            gameState.player.hp >= gameState.player.maxHp
          )
            reason = "Vida al m√°ximo.";
          if (
            itemName === "Cristales de Qi" &&
            gameState.player.mana >= gameState.player.maxMana
          )
            reason = "Man√° al m√°ximo.";
          showModal("No se puede usar", reason);
          return;
        }
        const message =
          itemName === "Piedras Espirituales" ||
          itemName === "N√∫cleo de Bestia Menor" ||
          (itemInfo.description &&
            (itemInfo.description.includes("Otorga") ||
              itemInfo.description.includes("otorga")))
            ? itemInfo.effect(gameState.player, gainExperience)
            : itemInfo.effect(gameState.player);

        // Solo decrementar si el mensaje no indica un error (por si el efecto mismo retorna un error)
        if (
          message &&
          !message.toLowerCase().includes("error") &&
          !message.toLowerCase().includes("al m√°ximo")
        ) {
          gameState.inventory[itemName]--;
        }
        showModal("Objeto Usado", message);
        updateUI();
      }

      function gainExperience(amount) {
        if (amount <= 0) return;
        gameState.player.exp += amount;
        while (gameState.player.exp >= gameState.player.expToNext) {
          levelUp();
        }
      }

      function levelUp() {
        const player = gameState.player;
        player.exp -= player.expToNext;
        player.level++;

        const hpIncrease = 20 + Math.floor(player.level / 2);
        const manaIncrease = 10 + Math.floor(player.level / 3);
        const attackIncrease = 2 + Math.floor(player.level / 4);
        const defenseIncrease = 1 + Math.floor(player.level / 5);

        player.baseMaxHp += hpIncrease;
        player.baseMaxMana += manaIncrease;
        player.baseAttack += attackIncrease;
        player.baseDefense += defenseIncrease;

        player.hp = player.baseMaxHp; // Rellenar HP y Mana al subir de nivel
        player.mana = player.baseMaxMana;
        player.expToNext = Math.floor(
          player.expToNext * (1.3 + player.level * 0.02)
        );

        const oldRealm = player.realm;
        const realms = [
          "Mortal",
          "Forjado del Cuerpo",
          "Condensaci√≥n de Qi",
          "Fundaci√≥n",
          "N√∫cleo Dorado",
          "Alma Naciente",
          "Esp√≠ritu Primordial",
        ];
        const realmIndex = Math.min(
          Math.floor((player.level - 1) / 5),
          realms.length - 1
        );
        player.realm = realms[realmIndex];
        let realmChangeMessage = "";
        if (player.realm !== oldRealm) {
          realmChangeMessage = `\n\n¬°Has avanzado al Reino de ${player.realm}! Sientes una profunda transformaci√≥n...`;
          generateMap(true);
        }
        recalculatePlayerStats();

        showModal(
          "¬°Nivel Aumentado!",
          `Nivel ${player.level}!\nReino: ${player.realm}\n+${hpIncrease} HP, +${manaIncrease} Man√°\n+${attackIncrease} Atk, +${defenseIncrease} Def${realmChangeMessage}`
        );
      }

      function recalculatePlayerStats() {
        const player = gameState.player;
        
        // 1. Reiniciar TODAS las estad√≠sticas a sus valores base.
        player.maxHp = player.baseMaxHp;
        player.maxMana = player.baseMaxMana;
        player.attack = player.baseAttack;
        player.defense = player.baseDefense;
        player.damageReduction = 0; // Reiniciamos la reducci√≥n de da√±o
        player.passiveHpRegen = 0;   // Reiniciamos la regeneraci√≥n pasiva
        // Reseteamos las estad√≠sticas de cultivo a sus valores por defecto antes de aplicar los bonos.
        player.qiPerSecondBase = 1;     // Valor base de Qi por segundo.
        player.expPerSecondBase = 0.5;   // Valor base de EXP por segundo.
        player.hpPerSecondBase = 1;      // Valor base de HP por segundo.
        // Limpiamos la lista de habilidades activas para reconstruirla.
        
        gameState.activeCombatAbilities = [];
        
        // 2. Iteramos sobre TODAS las t√©cnicas aprendidas por el jugador.
        for (const techId in player.learnedTechniques) {
            const playerTech = player.learnedTechniques[techId];
            const techInfo = techniqueData[techId];

            if (!techInfo || playerTech.level === 0) {
                continue; // Saltar si la t√©cnica no existe o no tiene nivel.
            }
            
            // 3. Aplicamos los efectos seg√∫n el tipo de t√©cnica.
            switch (techInfo.type) {
                case 'passive_stat':
                    // Aplicamos el efecto por cada nivel que tenga la t√©cnica.
                    const effectValue = techInfo.effect.value * playerTech.level;
                    const statToBoost = techInfo.effect.statToBoost;
                    
                    if (player.hasOwnProperty(statToBoost)) {
                        player[statToBoost] += effectValue;
                    } else {
                        // Para stats que no son base, como 'damageReduction'
                        player[statToBoost] = (player[statToBoost] || 0) + effectValue;
                    }
                    break;
                case 'passive_cultivation':
                    // Multiplicamos el valor del efecto por el nivel de la t√©cnica.
                    const cultivationBonus = techInfo.effect.value * playerTech.level;
                    const cultivationStatToBoost = techInfo.effect.statToBoost;
                    if (player.hasOwnProperty(cultivationStatToBoost)) {
                        player[cultivationStatToBoost] += cultivationBonus;
                    }
                    break;
                    
                case 'active_ability':
                    // Si es una habilidad activa, la a√±adimos a la lista para el combate.
                    gameState.activeCombatAbilities.push({
                        id: techInfo.abilityId,
                        name: techInfo.name,
                        sourceTechniqueId: techId
                    });
                    break;
                
                // Puedes a√±adir m√°s casos para otros tipos de t√©cnicas si es necesario.
            }
        }

        // 4. Asegurarse de que HP/Mana no excedan el nuevo m√°ximo.
        player.hp = Math.min(player.hp, player.maxHp);
        player.mana = Math.min(player.mana, player.maxMana);
        
        // 5. Finalmente, actualizamos la UI con los valores correctos y recalculados.
        // Ya no es necesario llamar a updateUI() desde aqu√≠, la funci√≥n que llama a recalculate se encargar√°.
    }

      function startBattle(mapEntity) {
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
        battleLogHistory = [];
        const toggleBtn = document.getElementById("toggleMapControlsBtn");
        if (toggleBtn) {
            toggleBtn.classList.add("hidden-during-battle");
        }
        const player = gameState.player;
        if (player.isCultivating) stopCultivation();
        hideTouchControls();
        document.getElementById('quickSlotBar').classList.add('hidden');
        player.isMoving = false;
        if (player.animationTimer) clearInterval(player.animationTimer);
        if (player.idleTimeout) clearTimeout(player.idleTimeout);
        player.currentFrame = 0;
        updatePlayerSpriteVisual();

        // Obtenemos la definici√≥n ORIGINAL y COMPLETA del enemigo.
        const enemyDefinition = entityTypes[mapEntity.originalEntityTypeId] || entityTypes[mapEntity.type];

        if (!enemyDefinition) {
            console.error(`¬°CR√çTICO! No se encontr√≥ la definici√≥n para el enemigo:`, mapEntity);
            showModal("Error de Batalla", "No se pudieron cargar los datos del enemigo.");
            return;
        }

        // Construimos el objeto del enemigo de forma segura.
        gameState.battle.active = true;
        gameState.battle.enemy = {
            ...enemyDefinition,         // 1. Copiamos el "molde" completo (con spriteUrl, abilities, etc.).
            ...mapEntity,               // 2. Sobreescribimos con el estado actual (como el hp).
            entityRef: mapEntity,       // 3. Guardamos la referencia a la entidad del mapa.
            // 4. Reseteamos los estados de combate.
            frozenTurns: 0,
            stunnedTurns: 0,
            burningTurns: 0,
            burnDamage: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            defenseReductionTurns: 0,
            defenseReductionAmount: 0,
            attackReductionTurns: 0,
            attackReductionAmount: 0,
            rootedTurns: 0,
            rootDamage: 0,
            silencedTurns: 0,
            sealedTurns: 0,
        };
        
        if (!gameState.battle.enemy.maxHp) {
            gameState.battle.enemy.maxHp = gameState.battle.enemy.hp;
        }
        
        gameState.battle.playerTurn = true;
        document.getElementById("battleScreen").style.display = "flex";
        
        // Ahora estas funciones recibir√°n un objeto enemigo COMPLETO y correcto.
        populateBattleActionButtons();
        updateBattleUI(); 
        updateGameOverlayVisibility();
        logBattle(`¬°Un ${gameState.battle.enemy.name} te enfrenta!`);
        updateTopNavVisibility();
        updatePlayerBarsOnMap();
    }
      function showFloatingText(targetElement, text, type) {
        // --- ¬°ESTA ES LA VERIFICACI√ìN CLAVE! ---
        if (
          !targetElement ||
          typeof targetElement.getBoundingClientRect !== "function"
        ) {
          console.warn(
            `[showFloatingText] Intento de mostrar texto flotante en un elemento inv√°lido. Texto: "${text}", Tipo: "${type}". El elemento era:`,
            targetElement
          );
          return; // Salir de la funci√≥n si el elemento no es v√°lido.
        }
        // --- FIN DE LA VERIFICACI√ìN ---

        const battleScreen = document.getElementById("battleScreen");
        if (!battleScreen) return; // Salida temprana si la pantalla de batalla no est√°

        const popup = document.createElement("div");
        popup.className = `damage-popup ${type}`;
        popup.textContent = text;

        // Lo a√±adimos al contenedor de la pantalla de batalla para que position:absolute funcione bien
        battleScreen.appendChild(popup);

        // Calculamos la posici√≥n inicial del popup
        const targetRect = targetElement.getBoundingClientRect();
        const battleRect = battleScreen.getBoundingClientRect();

        // Posici√≥n inicial en el centro-superior del objetivo
        const initialTop = targetRect.top - battleRect.top - 20;
        const initialLeft =
          targetRect.left -
          battleRect.left +
          targetRect.width / 2 -
          popup.offsetWidth / 2;

        popup.style.top = `${initialTop}px`;
        popup.style.left = `${initialLeft}px`;

        // Eliminar el elemento del DOM despu√©s de que termine la animaci√≥n
        popup.addEventListener("animationend", () => {
          // Usamos un try-catch por si el popup ya fue eliminado por otra raz√≥n (ej. fin de batalla)
          try {
            popup.remove();
          } catch (e) {}
        });
      }

      function populateBattleActionButtons() {
        const battleActionButtons = document.getElementById("battleActionButtons");
        battleActionButtons.innerHTML = `
              <button onclick="battleAction('attack')">‚öîÔ∏è Atacar</button>
              <button onclick="battleAction('defend')">üõ°Ô∏è Defender</button>
              <button onclick="battleAction('qi_fist')">üßò Pu√±o de Qi</button>
              <button onclick="battleAction('escape')">üèÉ Huir</button>
          `;
          
        // Iteramos sobre las t√©cnicas equipadas en los slots.
        gameState.player.equippedTechniques.forEach((techId) => {
            // Si el slot est√° vac√≠o (null) o la t√©cnica no existe (por un save antiguo), lo saltamos.
            if (!techId || !techniqueData[techId]) {
                return;
            }
            
            const techDetails = techniqueData[techId];
            const playerTech = gameState.player.learnedTechniques[techId];
            
            // Comprobaci√≥n de seguridad: si una t√©cnica est√° equipada pero el jugador ya no la conoce, no mostramos el bot√≥n.
            if (!playerTech) {
                console.warn(`T√©cnica equipada '${techId}' no encontrada en el libro de hechizos del jugador.`);
                return;
            }

            const abilityButton = document.createElement("button");
            const techLevel = playerTech.level || 0;

            let buttonText = `‚ú® ${techDetails.name} (Nv.${techLevel})`;
            let canUse = techLevel > 0;
            let reason = canUse ? "" : "Error: T√©cnica equipada sin nivel";
            
            const manaCost = techDetails.manaCost || 0;
            if (canUse && gameState.player.mana < manaCost) {
                canUse = false;
                reason = "Man√° insuficiente";
            }
            
            const cooldownTurns = gameState.player.abilityCooldowns[techDetails.abilityId] || 0;
            if (canUse && cooldownTurns > 0) {
                canUse = false;
                reason = `Enfriamiento: ${cooldownTurns} turnos`;
                buttonText += ` (${cooldownTurns}t)`;
            }

            abilityButton.textContent = buttonText;
            // El onclick pasa el ID de la acci√≥n a `battleAction`.
            abilityButton.onclick = () => battleAction(techDetails.abilityId);
            abilityButton.disabled = !canUse;
            abilityButton.title = reason;

            battleActionButtons.appendChild(abilityButton);
        });
    }

      function updateExtraStatsUI() {
        // Actualizar Zona
        const zoneEl = document.getElementById("playerZone");
        if (zoneEl) {
          const currentZone = getPlayerCurrentZone();
          zoneEl.textContent = currentZone
            ? currentZone.name
            : "Tierra Salvaje";
        }

        // Actualizar Piedras Espirituales
        const stonesEl = document.getElementById("playerStonesHud");
        if (stonesEl) {
          stonesEl.textContent =
            gameState.inventory["Piedras Espirituales"] || 0;
        }
      }

      function updateBattleUI() {
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const battleScreenActive = document.getElementById("battleScreen").style.display === "flex";

        // --- Declaraciones de Elementos del DOM al principio ---
        const playerBarsContainer = document.getElementById("playerInBattleSpriteBarsContainer");
        const playerSpriteInBattle = document.querySelector(".battle-area .character .character-sprite");
        const enemyInfoContainer = document.getElementById("enemyInBattleInfoContainer");
        const enemySpriteEl = document.getElementById("enemySprite");

        // --- L√≥gica del Jugador ---
        if (playerBarsContainer && playerSpriteInBattle && battleScreenActive) {
            playerBarsContainer.style.display = "flex";
            const spriteTop = playerSpriteInBattle.offsetTop;
            const spriteLeft = playerSpriteInBattle.offsetLeft;
            const spriteWidth = playerSpriteInBattle.offsetWidth;
            const barContainerHeight = playerBarsContainer.offsetHeight;

            playerBarsContainer.style.top = `${spriteTop - barContainerHeight - 3}px`;
            playerBarsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

            const playerHpFill = document.getElementById("playerInBattleSpriteHpFill");
            const playerManaFill = document.getElementById("playerInBattleSpriteManaFill");
            if (playerHpFill) playerHpFill.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
            if (playerManaFill) playerManaFill.style.width = `${Math.max(0, (player.mana / player.maxMana) * 100)}%`;
        } else if (playerBarsContainer) {
            playerBarsContainer.style.display = "none";
        }

        // --- L√≥gica del Enemigo ---
        if (enemy && enemySpriteEl && enemyInfoContainer && battleScreenActive) {
            // --- L√ìGICA DEL SPRITE (AHORA DENTRO DEL BLOQUE SEGURO) ---
            if (enemy.spriteUrl) {
                enemySpriteEl.style.backgroundImage = `url('${enemy.spriteUrl}')`;
                enemySpriteEl.textContent = "";
            } else {
                enemySpriteEl.style.backgroundImage = "none";
                enemySpriteEl.textContent = enemy.symbol || "?";
            }
            
            // El resto de la l√≥gica para las barras y el nombre del enemigo
            enemyInfoContainer.style.display = "flex";
            const spriteTop = enemySpriteEl.offsetTop;
            const spriteLeft = enemySpriteEl.offsetLeft;
            const spriteWidth = enemySpriteEl.offsetWidth;
            const infoContainerHeight = enemyInfoContainer.offsetHeight;

            enemyInfoContainer.style.top = `${spriteTop - infoContainerHeight - 5}px`;
            enemyInfoContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

            const enemyNameLevelEl = document.getElementById("enemyBattleNameLevel");
            const enemySpriteHpFill = document.getElementById("enemyInBattleSpriteHpFill");
            const enemyHpPercent = Math.max(0, (enemy.hp / (enemy.maxHp || enemy.hp)) * 100);

            if (enemyNameLevelEl) {
                let enemyDisplayName = enemy.name;
                if (enemy.isBoss) {
                    enemyDisplayName += ` (Jefe)`;
                } else if (enemy.isMiniBoss) {
                    enemyDisplayName += ` (√âlite)`;
                }
                if (enemy.level) {
                    enemyDisplayName += ` - Nv. ${enemy.level}`;
                }
                enemyNameLevelEl.textContent = enemyDisplayName;

                const nameStyle = getEnemyNameColor(player.level, enemy.level || 1);
                enemyNameLevelEl.style.color = nameStyle.color;
                enemyNameLevelEl.style.fontWeight = nameStyle.fontWeight;
            }
            if (enemySpriteHpFill) enemySpriteHpFill.style.width = `${enemyHpPercent}%`;

            // Paneles de HP/Nombre principales del enemigo
            document.getElementById("enemyName").textContent = enemy.name;
            document.getElementById("enemyHp").textContent = `${Math.floor(enemy.hp)}/${enemy.maxHp || enemy.hp}`;
            document.getElementById("enemyHpBar").style.width = `${enemyHpPercent}%`;
            
        } else if (enemyInfoContainer) {
            enemyInfoContainer.style.display = "none";
        }

        // --- L√≥gica de los Paneles Principales del Jugador ---
        if (battleScreenActive) {
            document.getElementById("playerBattleName").textContent = `Cultivador (Nv.${player.level})`;
            document.getElementById("playerBattleHp").textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
            document.getElementById("playerBattleHpBar").style.width = `${(player.hp / player.maxHp) * 100}%`;
        }
    }

    function battleAction(action) {
        if (!gameState.battle.playerTurn || !gameState.battle.active) return;
        
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const playerSprite = document.querySelector('.character-sprite');
        const enemySprite = document.getElementById('enemySprite');
        let actionTaken = true;

        // Reducir enfriamientos al inicio del turno del jugador
        for (const abilityId in player.abilityCooldowns) {
            if (player.abilityCooldowns[abilityId] > 0) {
                player.abilityCooldowns[abilityId]--;
            }
            if (player.abilityCooldowns[abilityId] <= 0) {
                delete player.abilityCooldowns[abilityId];
            }
        }
        populateBattleActionButtons(); // Actualizar botones para reflejar cooldowns reducidos

        // Procesar DoTs/HoTs y efectos en el jugador
        // (Esta l√≥gica se mantiene como est√°, no es necesario cambiarla)
        if (player.burningTurns > 0) { /* ... */ }
        // ... el resto de la l√≥gica de DoTs y Debuffs para el jugador ...

        if (player.hp <= 0) {
            // L√≥gica de derrota si el DoT lo derrota antes de actuar
            return;
        }

        // --- INICIO DE LA L√ìGICA DE HABILIDADES REFACTORIZADA ---
        
        // Buscamos si la acci√≥n corresponde a una habilidad definida
        const techInfoEntry = Object.entries(techniqueData).find(([key, value]) => value.abilityId === action);

        if (techInfoEntry) {
            // Si es una habilidad, ejecutamos la l√≥gica de t√©cnica
            const [sourceTechniqueId, techDetails] = techInfoEntry;
            const playerTech = player.learnedTechniques[sourceTechniqueId];
            
            if (!playerTech || playerTech.level === 0) {
                logBattle(`Intentas usar ${techDetails.name}, pero no la has dominado (Nivel 0).`);
                return; // No consume el turno, permite elegir otra acci√≥n
            }

            const playerTechLevel = playerTech.level;
            const manaCost = techDetails.manaCost || 0;

            if ((player.abilityCooldowns[action] || 0) > 0) {
                logBattle(`¬°La t√©cnica ${techDetails.name} a√∫n est√° en enfriamiento!`);
                return; // No consume el turno
            }

            if (player.mana < manaCost) {
                logBattle(`Man√° insuficiente para ${techDetails.name}.`);
                actionTaken = false;
            } else {
                player.mana -= manaCost;
                if (techDetails.cooldown) {
                    player.abilityCooldowns[action] = techDetails.cooldown;
                }

                let damageDealt = 0;
                let logMessage = "";
                const effect = techDetails.effect;

                // Delegamos al switch-case que ya ten√≠as, pero ahora 'playerTechLevel' es correcto.
                // El c√≥digo interno de cada 'case' usar√° 'playerTechLevel' para el c√°lculo.
                // El siguiente bloque 'switch' debe contener TODA tu l√≥gica de habilidades existente.
                // Lo que sigue es un ejemplo de c√≥mo debe quedar el caso de 'sword_t1'.

                switch (action) {
                  case "sword_t1"://Tajo del Viento Veloz
                    const swordTechDetails = techniqueData["sword_t1"];
                    const swordManaCost = swordTechDetails.manaCost || 10;
                    if (player.mana >= swordManaCost) {
                      player.mana -= swordManaCost;
                      // Calculamos el multiplicador de da√±o de forma gen√©rica, leyendo los valores de la definici√≥n.
                      const damageMultiplier =
                        swordTechDetails.effect.baseDamageMultiplier +
                        (playerTechLevel - 1) * (swordTechDetails.effect.multiplierIncreasePerLevel || 0);

                      const swordDamage = Math.max(
                        1,
                        Math.floor(player.attack * damageMultiplier) -
                          (enemy.defense || 0)
                      );
                      enemy.hp -= swordDamage;
                      logBattle(
                        `¬°${swordTechDetails.name} (Nv.${playerTechLevel}) causa ${swordDamage} da√±o!`
                      );
                      showFloatingText(
                        document.querySelector(".character-sprite"),
                        `Tajo Veloz`,
                        "ability"
                      );
                      showFloatingText(
                        document.getElementById("enemySprite"),
                        ` -${swordDamage}`,
                        "damage"
                      );
                    } else {
                      logBattle(`Man√° insuficiente para ${swordTechDetails.name}.`);
                      actionTaken = false;
                    }

                    break;
                  case "sword_t2"://Estocada Perfora-Armadura
                              // Obtenemos los detalles de la t√©cnica y su nivel
                    const estocadaDetails = techniqueData["sword_t2"];
                    const estocadaLevel = player.learnedTechniques["sword_t2"]?.level || 1;

                    // --- C√ÅLCULOS MEJORADOS ---
                    // El multiplicador de da√±o y la penetraci√≥n ahora escalan con el nivel de la t√©cnica
                    const damageMultiplier = estocadaDetails.effect.baseDamageMultiplier + ((estocadaLevel - 1) * 0.1);
                    const penetrationPercent = estocadaDetails.effect.defensePenetration + ((estocadaLevel - 1) * 0.02); // +2% por nivel

                    // Calculamos el da√±o
                    const defenseToIgnore = (enemy.defense || 0) * penetrationPercent;
                    const baseDamage = player.attack * damageMultiplier;
                    damageDealt = Math.max(1, Math.floor(baseDamage - ((enemy.defense || 0) - defenseToIgnore)));
                    
                    enemy.hp -= damageDealt;

                    logMessage = `¬°${estocadaDetails.name} (Nv.${estocadaLevel}) ignora ${Math.floor(defenseToIgnore)} de defensa y causa ${damageDealt} de da√±o!`;
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');

                    // --- L√ìGICA PARA LA HEMORRAGIA (BLEED) ---
                    const bleedChance = estocadaDetails.effect.bleedChance + ((estocadaLevel - 1) * 0.05); // La probabilidad de sangrado tambi√©n mejora
                    if (Math.random() < bleedChance) {
                        const bleedDmg = estocadaDetails.effect.bleedDamagePerTurn + (estocadaLevel * 2); // El da√±o de sangrado escala
                        const bleedDur = estocadaDetails.effect.bleedDuration;

                        // Para no crear una nueva propiedad, podemos reutilizar la de "poison" o "burn".
                        // Usemos "poison" como si fuera "bleed" para no a√±adir m√°s complejidad al enemyTurn.
                        enemy.poisonedTurns = Math.max(enemy.poisonedTurns, bleedDur);
                        enemy.poisonDamage = Math.max(enemy.poisonDamage, bleedDmg);
                        
                        logMessage += ` ¬°El golpe causa una herida abierta que sangra!`;
                        showFloatingText(enemySprite, 'Hemorragia', 'debuff');
                    }

                    logBattle(logMessage);
                    break;
                  case "sword_t3": { // Danza de Espada Cicl√≥nica
                        const hits = Math.round(effect.baseHits + (playerTechLevel - 1) * effect.hitsIncreasePerLevel);
                        let totalDamage = 0;
                        for (let i = 0; i < hits; i++) {
                            const damageDealt = Math.max(1, Math.floor((player.attack * effect.baseDamageMultiplier) - enemy.defense));
                            enemy.hp -= damageDealt;
                            totalDamage += damageDealt;
                        }
                        logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) golpea ${hits} veces, causando ${totalDamage} de da√±o!`;
                        showFloatingText(enemySprite, `-${totalDamage}`, 'damage');
                        break;
                    }
                  case "sword_t4": { // Intento de Espada del Tirano
                        const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.multiplierIncreasePerLevel;
                        const damageDealt = Math.max(1, Math.floor(player.attack * currentMultiplier) - enemy.defense);
                        enemy.hp -= damageDealt;
                        logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) golpea con ${damageDealt} de da√±o!`;
                        const stunChance = effect.baseStunChance + (playerTechLevel - 1) * effect.stunChanceIncreasePerLevel;
                        if (Math.random() < stunChance) {
                            enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                            logMessage += " ¬°El enemigo queda aturdido!";
                        }
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }
                  case "sword_t5": // Corte que Divide Cielos y Tierra
                    const sword5DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.floor(player.attack * sword5DmgMultiplier);
                    enemy.hp -= damageDealt;
                    logMessage = `¬°${techDetails.name} corta la realidad misma, infligiendo ${damageDealt} de da√±o absoluto!`;

                    const critChance = techDetails.effect.criticalChance + (playerTechLevel - 1) * (techDetails.effect.criticalChanceIncreasePerLevel || 0);
                    if (Math.random() < critChance) {
                        const critDamage = Math.floor(damageDealt * 0.5); // 50% extra de da√±o cr√≠tico
                        enemy.hp -= critDamage;
                        logMessage += ` ¬°Fue un golpe cr√≠tico, causando ${critDamage} de da√±o extra!`;
                        damageDealt += critDamage;
                    }

                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    break;
                  case "sword_t6": // Espada del Emperador Celestial
                        const executeThreshold = techDetails.effect.executeThreshold + (playerTechLevel - 1) * (techDetails.effect.executeThresholdIncreasePerLevel || 0);
                        logMessage = `¬°${techDetails.name} desata un poder absoluto!`;
                        if (enemy.hp / enemy.maxHp <= executeThreshold) {
                            damageDealt = enemy.hp;
                            enemy.hp = 0;
                            logMessage += " ¬°El enemigo es ejecutado por decreto celestial!";
                            showFloatingText(enemySprite, '¬°EJECUTADO!', 'damage');
                        } else {
                            const sword6DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                            damageDealt = Math.floor(player.attack * sword6DmgMultiplier);
                            enemy.hp -= damageDealt;
                            logMessage += ` Causa ${damageDealt} de da√±o que ignora toda protecci√≥n.`;
                            showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        }
                        break;
                  
                  case "fire_t1"://Chispa √çgnea
                    const fireDamageMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * fireDamageMultiplier) - (enemy.defense || 0));
                    enemy.hp -= damageDealt;

                    const burnDamage = techDetails.effect.burnDamagePerTurn + (playerTechLevel - 1) * (techDetails.effect.burnDamageIncreasePerLevel || 0);
                    enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                    enemy.burnDamage = Math.max(enemy.burnDamage, burnDamage);
                    
                    logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} de da√±o y quema al enemigo!`;
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    break;

                  case "fire_t2"://Aliento de Drag√≥n Menor
                    const fire2DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * fire2DmgMultiplier) - (enemy.defense || 0));
                    enemy.hp -= damageDealt;
                    
                    const burn2Damage = techDetails.effect.burnDamagePerTurn + (playerTechLevel - 1) * (techDetails.effect.burnDamageIncreasePerLevel || 0);
                    enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                    enemy.burnDamage = Math.max(enemy.burnDamage, burn2Damage);

                    logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} de da√±o e inflige una quemadura intensa!`;
                    break;
                  
                  case "fire_t4": { // Sol Abrasador
                        const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.multiplierIncreasePerLevel;
                        const damageDealt = Math.max(1, Math.floor(player.attack * currentMultiplier) - enemy.defense);
                        enemy.hp -= damageDealt;
                        logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) inflige ${damageDealt} de da√±o masivo!`;
                        
                        // --- INICIO DE LA MODIFICACI√ìN ---
                        // Calculamos el da√±o de la quemadura, incluyendo el escalado por nivel.
                        const burnDamage = effect.burnDamagePerTurn + (playerTechLevel - 1) * (effect.burnIncreasePerLevel || 0);
                        
                        // Aplicamos la quemadura al enemigo. Usamos Math.max para no reemplazar una quemadura m√°s fuerte.
                        enemy.burningTurns = Math.max(enemy.burningTurns, effect.burnDuration);
                        enemy.burnDamage = Math.max(enemy.burnDamage, burnDamage);
                        
                        // Actualizamos el mensaje del log y mostramos un texto flotante.
                        logMessage += ` ¬°El enemigo queda envuelto en llamas, sufriendo una quemadura intensa!`;
                        showFloatingText(enemySprite, '¬°Quemadura!', 'debuff');
                        // --- FIN DE LA MODIFICACI√ìN ---

                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }
                  case "fire_t5": // Llama del F√©nix Renaciente
                            damageDealt = Math.max(1, Math.floor(player.attack * techDetails.effect.baseDamageMultiplier) - enemy.defense);
                            enemy.hp -= damageDealt;
                            const reviveChance = techDetails.effect.reviveChance + (playerTechLevel - 1) * (techDetails.effect.reviveChanceIncreasePerLevel || 0);
                            if (Math.random() < reviveChance) {
                                player.canRevive = true;
                            }
                            logMessage = `¬°${techDetails.name} incinera al enemigo con ${damageDealt} de da√±o y te imbuye con la esencia del F√©nix!`;
                            showFloatingText(playerSprite, 'F√©nix Interior', 'ability');
                            showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                            break; 
                  

                  case "lightning_t1": // Dedo de Rel√°mpago
                      const lightningDmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                      damageDealt = Math.max(1, Math.floor(player.attack * lightningDmgMultiplier) - enemy.defense);
                      enemy.hp -= damageDealt;

                      const stunChance = techDetails.effect.stunChance + (playerTechLevel - 1) * (techDetails.effect.stunChanceIncreasePerLevel || 0);
                      logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) golpea con ${damageDealt} de da√±o!`;
                      
                      if (Math.random() < stunChance) {
                          enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                          logMessage += " ¬°El enemigo queda aturdido!";
                          showFloatingText(enemySprite, '¬°Aturdido!', 'debuff');
                      }
                      showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                      break;
                  case "lightning_t2": // L√°tigo de Trueno
                    const lightning2DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * lightning2DmgMultiplier) - enemy.defense);
                    
                    const defenseReduction = techDetails.effect.defenseReduction + (playerTechLevel - 1) * (techDetails.effect.defenseReductionIncreasePerLevel || 0);
                    const duration = techDetails.effect.duration;
                    
                    enemy.hp -= damageDealt;
                    enemy.defenseReductionTurns = Math.max(enemy.defenseReductionTurns, duration);
                    enemy.defenseReductionAmount = Math.max(enemy.defenseReductionAmount, defenseReduction);

                    logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} de da√±o y reduce la defensa del enemigo en ${defenseReduction}!`;
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    showFloatingText(enemySprite, 'Defensa ‚Üì', 'debuff');
                    break;
                  case "lightning_t3": { // Jaula de Rayos
                      const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.damageMultiplierIncreasePerLevel;
                      const damageDealt = Math.max(1, Math.floor(player.attack * currentMultiplier) - enemy.defense);
                      enemy.hp -= damageDealt;
                      logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) electrocuta con ${damageDealt} de da√±o!`;
                      const stunChance = effect.baseStunChance + (playerTechLevel - 1) * effect.stunChanceIncreasePerLevel;
                      if (Math.random() < stunChance) {
                          enemy.stunnedTurns = Math.max(enemy.stunnedTurns, effect.duration);
                          logMessage += ` ¬°El enemigo queda paralizado!`;
                          showFloatingText(enemySprite, '¬°Paralizado!', 'debuff');
                      }
                      showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                      break;
                  }
                  case "lightning_t4": { // Llamada del Juicio del Trueno
                        const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.multiplierIncreasePerLevel;
                        const damageDealt = Math.floor(player.attack * currentMultiplier); // Ignora defensa
                        enemy.hp -= damageDealt;
                        logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) ignora la defensa, causando ${damageDealt} de da√±o verdadero!`;
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }          
                  case "lightning_t5": // Tribulaci√≥n de los Nueve Cielos
                    const lightning5DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * lightning5DmgMultiplier) - enemy.defense);
                    enemy.hp -= damageDealt;
                    logMessage = `¬°Invocas la ${techDetails.name}, causando ${damageDealt} de da√±o celestial!`;

                    const paralyzeChance = techDetails.effect.paralyzeChance + (playerTechLevel - 1) * (techDetails.effect.paralyzeChanceIncreasePerLevel || 0);
                    if (Math.random() < paralyzeChance) {
                        enemy.stunnedTurns = Math.max(enemy.stunnedTurns, techDetails.effect.duration || 2);
                        logMessage += ` ¬°El poder de la tribulaci√≥n lo deja paralizado por ${enemy.stunnedTurns} turnos!`;
                        showFloatingText(enemySprite, '¬°Paralizado!', 'debuff');
                    }
                    showFloatingText(playerSprite, '¬°Tribulaci√≥n!', 'ability');
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    break;

                  case "movement_t1": { // Paso Veloz (TIER 1)
                      const defenseBonus = techDetails.effect.tempDefenseBuff + ((playerTechLevel - 1) * techDetails.effect.buffIncreasePerLevel);
                      
                      if(player.tempDefenseBoostAmount > 0) {
                          player.defense -= player.tempDefenseBoostAmount;
                      }
                      player.defense += defenseBonus;
                      player.tempDefenseBoostAmount = defenseBonus;
                      player.tempDefenseBoostTurns = techDetails.effect.buffDuration;
                      
                      logMessage = `¬°Ejecutas un ${techDetails.name}! Tu defensa aumenta en ${defenseBonus} por ${player.tempDefenseBoostTurns} turnos.`;
                      showFloatingText(playerSprite, `Defensa +${defenseBonus}`, 'ability');
                      break;
                  }
                  case "movement_t2"://Paso Et√©reo
                    const etereoDetails = techniqueData["movement_t2"];
                    const etereoLevel = player.learnedTechniques["movement_t2"]?.level || 1;

                    // --- L√ìGICA PARA APLICAR ESQUIVA Y BUFF ---
                    player.dodgeNextAttack = true;

                    // Calculamos y aplicamos el buff de defensa
                    const defenseBonus = etereoDetails.effect.tempDefenseBuff + (etereoDetails.effect.buffIncreasePerLevel * (etereoLevel - 1));
                    
                    // Evitamos acumular el mismo buff, lo refrescamos
                    if (player.tempDefenseBoostAmount > 0) {
                        player.defense -= player.tempDefenseBoostAmount; // Quita el buff anterior
                    }
                    player.defense += defenseBonus;
                    player.tempDefenseBoostAmount = defenseBonus;
                    player.tempDefenseBoostTurns = etereoDetails.effect.buffDuration;
                    
                    logMessage = `¬°Usas ${etereoDetails.name} (Nv.${etereoLevel})! Te preparas para esquivar y tu defensa aumenta en ${defenseBonus} por ${player.tempDefenseBoostTurns} turnos.`;
                    showFloatingText(playerSprite, '¬°Esquiva!', 'ability');
                    showFloatingText(playerSprite, `Defensa +${defenseBonus}`, 'ability');
                    
                    logBattle(logMessage);
                    break;              
                  case "movement_t3": { // Parpadeo de Sombra
                        const effect = techDetails.effect;
                        
                        // Calculamos el multiplicador actual: Base + (Nivel - 1) * AumentoPorNivel
                        const currentMultiplier = effect.baseDamageMultiplier + ((playerTechLevel - 1) * (effect.multiplierIncreasePerLevel || 0));
                        
                        let baseDamage = player.attack * currentMultiplier;

                        // Aplicamos el multiplicador de cr√≠tico si la t√©cnica lo especifica
                        if (effect.isCritical) {
                            baseDamage *= 1.5; // Multiplicador de cr√≠tico est√°ndar (150%)
                        }

                        const damageDealt = Math.max(1, Math.floor(baseDamage) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;

                        logMessage = `¬°Con ${techDetails.name} (Nv.${playerTechLevel}), apareces para un golpe cr√≠tico de ${damageDealt}!`;
                        showFloatingText(playerSprite, '¬°Golpe S√∫bito!', 'ability');
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }              
                  case "movement_t4": // Danza del Viento Espectral
                        const move4DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                        damageDealt = Math.max(1, Math.floor(player.attack * move4DmgMultiplier) - enemy.defense);
                        enemy.hp -= damageDealt;
                        player.dodgeNextAttack = true;
                        logMessage = `¬°Ejecutas la ${techDetails.name}! Causas ${damageDealt} de da√±o y te preparas para esquivar.`;
                        showFloatingText(playerSprite, '¬°Esquiva!', 'ability');
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                  case "movement_t5": // Paso del Vac√≠o Infinito
                    player.intangibleTurns = techDetails.effect.intangibleTurns;
                    const numHits = techDetails.effect.multiHit;
                    let totalVoidDamage = 0;
                    for (let i = 0; i < numHits; i++) {
                        damageDealt = Math.max(1, Math.floor((player.attack * (techDetails.effect.baseDamageMultiplier / numHits)) - enemy.defense));
                        enemy.hp -= damageDealt;
                        totalVoidDamage += damageDealt;
                    }
                    logMessage = `¬°Con ${techDetails.name} te vuelves intangible por ${player.intangibleTurns} turnos y golpeas ${numHits} veces, causando un total de ${totalVoidDamage} de da√±o!`;
                    showFloatingText(enemySprite, `-${totalVoidDamage}`, 'damage');
                    break;        

                  case "formation_t1":
                      const shieldDetails = techniqueData["formation_t1"];
                      const shieldLevel = player.learnedTechniques["formation_t1"]?.level || 1;

                      // --- C√ÅLCULO DE ESCUDO MEJORADO ---
                      const shieldBase = shieldDetails.effect.shieldValue;
                      const shieldBonusPerLevel = shieldDetails.effect.shieldIncreasePerLevel;
                      const shieldValue = shieldBase + (shieldBonusPerLevel * (shieldLevel - 1));
                      const shieldDuration = shieldDetails.effect.duration;

                      // Aplicamos el escudo
                      player.magicShieldValue = (player.magicShieldValue || 0) + shieldValue;
                      player.magicShieldTurns = Math.max(player.magicShieldTurns || 0, shieldDuration);

                      logMessage = `¬°${shieldDetails.name} (Nv.${shieldLevel}) crea un escudo que absorbe ${shieldValue} de da√±o! (Total: ${Math.floor(player.magicShieldValue)})`;
                      showFloatingText(playerSprite, `Escudo +${shieldValue}`, 'ability');

                      // --- L√ìGICA PARA LA CURACI√ìN SECUNDARIA ---
                      const healReqLevel = shieldDetails.effect.healOnCastLevelReq;
                      if (shieldLevel >= healReqLevel) {
                          const healBase = shieldDetails.effect.healOnCastAmount;
                          // La curaci√≥n tambi√©n puede escalar un poco
                          const healAmount = healBase + ((shieldLevel - healReqLevel) * 5);
                          
                          player.hp = Math.min(player.maxHp, player.hp + healAmount);
                          
                          logMessage += ` El flujo de Qi regenera ${healAmount} de vida.`;
                          showFloatingText(playerSprite, `+${healAmount}`, 'heal');
                      }
                      
                      logBattle(logMessage);
                      break;
                  case "formation_t2":
                    const rootTechDetails = techniqueData["formation_t2"];
                    const rootTechLevel = player.learnedTechniques["formation_t2"]?.level || 1;
                    const rootChance = (rootTechDetails.effect.rootChance || 0.7) + (rootTechLevel - 1) * 0.03;

                    if (Math.random() < rootChance) {
                      const rootDuration = rootTechDetails.effect.rootDuration;
                      const rootDmgPerTurn = rootTechDetails.effect.damagePerTurn + (rootTechLevel - 1) * (rootTechDetails.effect.damagePerTurnIncreasePerLevel || 0);
                      const shacklesHealth = rootTechDetails.effect.shacklesHP + (rootTechLevel - 1) * (rootTechDetails.effect.shacklesHPIncreasePerLevel || 0);

                      enemy.rootedTurns = rootDuration;
                      enemy.rootDamage = rootDmgPerTurn;

                      player.activeChanneledAbility.id = "formation_t2";
                      player.activeChanneledAbility.hp = shacklesHealth;
                      
                      logMessage = `¬°${rootTechDetails.name} (Nv.${rootTechLevel}) atrapa al enemigo con grilletes de ${shacklesHealth} de resistencia!`;
                      showFloatingText(enemySprite, "¬°Atrapado!", "debuff");
                    } else {
                      logMessage = `¬°${rootTechDetails.name} (Nv.${rootTechLevel}) falla y el enemigo esquiva los grilletes!`;
                      showFloatingText(enemySprite, "¬°Fall√≥!", "ability");
                    }
                    logBattle(logMessage);
                    break;
                  case "formation_t3": { // Matriz de Supresi√≥n Espiritual
                        const reduction = effect.baseReduction + (playerTechLevel - 1) * effect.reductionIncreasePerLevel;
                        enemy.defenseReductionTurns = Math.max(enemy.defenseReductionTurns, effect.duration);
                        enemy.defenseReductionAmount = Math.max(enemy.defenseReductionAmount, reduction);
                        enemy.attackReductionTurns = Math.max(enemy.attackReductionTurns, effect.duration);
                        enemy.attackReductionAmount = Math.max(enemy.attackReductionAmount, reduction);
                        logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) debilita al enemigo! Su Ataque y Defensa se reducen en ${reduction}.`;
                        showFloatingText(enemySprite, 'Ata/Def ‚Üì', 'debuff');
                        break;
                    }      
                  case "formation_t4": { // Santuario Dorado Protector
                      const duration = effect.baseDuration + (playerTechLevel >= effect.levelForExtraTurn ? 1 : 0);
                      player.intangibleTurns = duration;
                      logMessage = `¬°${techDetails.name} (Nv.${playerTechLevel}) te hace inmune al da√±o por ${duration} turnos!`;
                      showFloatingText(playerSprite, '¬°Invulnerable!', 'ability');
                      break;
                  }
                  case "formation_t5": // Matriz de Reversi√≥n del Cosmos
                    player.damageToHealingTurns = techDetails.effect.damageToHealingDuration;
                    logMessage = `¬°Activaste ${techDetails.name}! Durante ${player.damageToHealingTurns} turnos, el da√±o recibido te curar√°.`;
                    showFloatingText(playerSprite, 'Inversi√≥n C√≥smica', 'ability');
                    break;                  
                  case "formation_t6": // Matriz del Sello del Demonio
                          enemy.sealedTurns = techDetails.effect.sealDuration;
                          logMessage = `¬°${techDetails.name} sella completamente al enemigo por ${enemy.sealedTurns} turnos! No podr√° realizar ninguna acci√≥n.`;
                          showFloatingText(enemySprite, '¬°SELLADO!', 'debuff');
                          break; 

                    
                  default:
                        // Este bloque ahora se encarga de TODAS las habilidades que hemos estandarizado
                        logMessage = `Usando ${techDetails.name} (Nv.${playerTechLevel})...`;
                        let tempDamage = 0;
                        
                        // Da√±o base
                        if (effect.baseDamageMultiplier) {
                             const multiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * (effect.multiplierIncreasePerLevel || 0);
                             tempDamage = Math.max(1, Math.floor(player.attack * multiplier) - (enemy.defense || 0));
                             enemy.hp -= tempDamage;
                             logMessage += ` ¬°Causa ${tempDamage} de da√±o!`;
                             showFloatingText(enemySprite, `-${tempDamage}`, "damage");
                        }
                        // Aqu√≠ puedes a√±adir la l√≥gica gen√©rica para DoTs, stuns, etc. si lo deseas en el futuro
                        break;
                }
                 if(logMessage) logBattle(logMessage);
            }
        } else {
            // --- FIN DE LA L√ìGICA DE HABILIDADES ---
            // Si no es una habilidad, es una acci√≥n b√°sica (ataque, defensa, huida)
            switch (action) {
              case "attack":
                const damage = Math.max(
                  1,
                  player.attack -
                    (enemy.defense || 0) +
                    Math.floor(Math.random() * 5 - 2)
                );
                enemy.hp -= damage;
                logBattle(`Atacas causando ${damage} da√±o.`);
                showFloatingText(
                  document.getElementById("enemySprite"),
                  `-${damage}`,
                  "damage"
                );

                // ESTA L√çNEA DEBER√çA SER logBattle, NO showFloatingText.
                // O es un resto de una depuraci√≥n anterior que hay que eliminar.
                if (player.hp <= 0) {
                  logBattle("Has sucumbido antes de actuar.");
                  // ... L√≥gica de derrota ...
                }
                break; // <-- Fin del caso de ataque
              case "qi_fist":
                const qiFistCost = 10;
                if (player.mana >= qiFistCost) {
                  player.mana -= qiFistCost;
                  const magicDamage = Math.max(
                    1,
                    Math.floor(player.attack * 0.8 + player.maxMana * 0.2) -
                      (enemy.defense || 0)
                  );
                  enemy.hp -= magicDamage;
                  logBattle(`Pu√±o de Qi causa ${magicDamage} da√±o m√°gico.`);
                  showFloatingText(
                    document.querySelector(".character-sprite"),
                    `Pu√±o de QI`,
                    "ability"
                  );
                  showFloatingText(
                    document.getElementById("enemySprite"),
                    `-${magicDamage}`,
                    "damage"
                  );
                } else {
                  logBattle("Man√° insuficiente para Pu√±o de Qi.");
                  actionTaken = false;
                }

                break;
              case "defend":
                let healAmount = Math.floor(player.maxHp * 0.1);
                player.hp = Math.min(player.maxHp, player.hp + healAmount);
                showFloatingText(
                  document.querySelector(".character-sprite"),
                  `+${healAmount}`,
                  "heal"
                );
                logBattle(`Te defiendes y recuperas ${healAmount} HP.`);
                break;
              case "escape":
                if (enemy.isBoss) {
                  logBattle(`¬°No puedes huir de un ${enemy.name}!`);
                  showFloatingText(
                    document.querySelector(".character-sprite"),
                    "¬°Imposible!",
                    "debuff"
                  );
                  actionTaken = false; // La acci√≥n fall√≥, no se consume el turno
                } else if (Math.random() < 0.7) {
                  // Probabilidad de √©xito de huida

                  const escapeTile = findEscapeTile(player, enemy);

                  if (escapeTile) {
                    logBattle("¬°Escapaste con √©xito!");
                    showFloatingText(
                      document.querySelector(".character-sprite"),
                      "¬°Huida!",
                      "ability"
                    );

                    // Mover al jugador a la casilla segura ANTES de terminar la batalla
                    player.x = escapeTile.x;
                    player.y = escapeTile.y;

                    // Esperar un breve momento para que el texto flotante se vea
                    setTimeout(() => {
                      endBattle(false); // false = no fue una victoria
                      updatePlayerPosition("escape_success"); // Actualizar la posici√≥n visual en el mapa
                    }, 500);
                  } else {
                    logBattle("¬°Intentaste huir, pero no hay a d√≥nde ir!");
                    showFloatingText(
                      document.querySelector(".character-sprite"),
                      "¬°Atrapado!",
                      "debuff"
                    );
                    actionTaken = true; // El intento de huir consume el turno
                  }

                  // Como la huida (exitosa o no) ya manej√≥ el flujo, salimos de la funci√≥n
                  return;
                } else {
                  logBattle("¬°No pudiste escapar!");
                  showFloatingText(
                    document.querySelector(".character-sprite"),
                    "¬°Fall√≥!",
                    "debuff"
                  );
                  actionTaken = true; // El intento fallido tambi√©n consume el turno
                }
                break;
              default:
                logBattle("Acci√≥n desconocida.");
                actionTaken = false;
                break;
          }
        
        }
        
        if (!actionTaken) {
          updateBattleUI();
          return;
        }

        gameState.battle.playerTurn = false;
        updateBattleUI();

        if (enemy.hp <= 0) {
          handleEnemyDefeat();
        } else {
          let enemyDiedToDot = false;
          if (enemy.burningTurns > 0) {
            enemy.hp -= enemy.burnDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.burnDamage
              } por quemadura. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.poisonedTurns > 0) {
            enemy.hp -= enemy.poisonDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.poisonDamage
              } por veneno. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.rootedTurns > 0) {
            enemy.hp -= enemy.rootDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.rootDamage
              } por enredo. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }

          if (enemyDiedToDot) {
            handleEnemyDefeat();
          } else {
            setTimeout(enemyTurn, 1000);
          }
        }
      }



      function handleEnemyDefeat() {
        const enemy = gameState.battle.enemy;
        const player = gameState.player;

        logBattle(`¬°Has derrotado al ${enemy.name}!`);
        gainExperience(enemy.exp);

        const misionesActivasDelJugador = [...player.secta.misionesActivas];

        misionesActivasDelJugador.forEach((misionActiva) => {
          const misionDataOriginal = MISIONES_DATA[misionActiva.id];
          if (!misionDataOriginal || !misionActiva.objetivoOriginal) return;

          const objetivo = misionActiva.objetivoOriginal;

          // L√≥gica para actualizar el progreso de la misi√≥n de desaf√≠o
          if (
            objetivo.tipo === "derrotar_npc_especifico" &&
            enemy.isSectChallengeRival &&
            enemy.npcId === objetivo.npcId
          ) {
            misionActiva.progreso = 1; // 1 significa "objetivo cumplido".
            logBattle(`¬°Has superado la prueba! Reporta tu √©xito en la secta.`);
            console.log(
              `[Misi√≥n Desaf√≠o] Progreso de la misi√≥n '${misionActiva.id}' actualizado a 1.`
            );
          }
          // L√≥gica para otras misiones de eliminaci√≥n
          else if (
            objetivo.tipo === "eliminar_enemigo" &&
            (enemy.originalEntityTypeId === objetivo.enemigoTipo ||
              enemy.name === objetivo.nombreDisplay)
          ) {
            misionActiva.progreso = (misionActiva.progreso || 0) + 1;
            logBattle(
              `Progreso '${misionDataOriginal.titulo}': ${misionActiva.progreso}/${objetivo.cantidad}`
            );
          } else if (
            objetivo.tipo === "cazar_y_recuperar_item_de_loot" &&
            enemy.originalEntityTypeId === objetivo.enemigoTipo
          ) {
            misionActiva.progreso = 1;
            logBattle(
              `Has derrotado a un ${enemy.name}. Busca el ${objetivo.itemPrueba} entre el bot√≠n.`
            );
          }
        });

        updateSectUI();

        // El resto de la funci√≥n (loot, etc.) no cambia...
        let lootObtenidoTexto = "Bot√≠n Obtenido: ";
        let algoObtenido = false;
        if (enemy.lootTable) {
          enemy.lootTable.forEach((loot) => {
            if (Math.random() < loot.chance) {
              const cantidad =
                loot.quantity[0] +
                Math.floor(
                  Math.random() * (loot.quantity[1] - loot.quantity[0] + 1)
                );
              gameState.inventory[loot.itemName] =
                (gameState.inventory[loot.itemName] || 0) + cantidad;
              lootObtenidoTexto += `${cantidad} ${loot.itemName}, `;
              algoObtenido = true;
            }
          });
        }
        if (!algoObtenido) lootObtenidoTexto += "Nada.";
        else lootObtenidoTexto = lootObtenidoTexto.slice(0, -2) + ".";

        if (enemy.isBoss && enemy.originalEntityTypeId) {
          player.worldState.defeatedBosses[enemy.originalEntityTypeId] = true;
          if (enemy.nextBossId) {
            player.worldState.currentBossToSpawn = enemy.nextBossId;
          } else {
            player.worldState.currentBossToSpawn = null;
          }
        } else if (
          enemy.isMiniBoss &&
          enemy.isFixed &&
          enemy.originalEntityTypeId
        ) {
          if (!player.worldState.defeatedFixedEntities)
            player.worldState.defeatedFixedEntities = {};
          player.worldState.defeatedFixedEntities[enemy.originalEntityTypeId] =
            { time: Date.now() };
        }

        setTimeout(() => {
          endBattle(true);
          showModal(
            "¬°Victoria!",
            `Has ganado el combate.\n\n${lootObtenidoTexto}\n\nRevisa tu diario de misiones para ver el progreso.`
          );
        }, 1500);
      }

      function completeMission(misionId, npcIdEntregaManual = null) {
        const player = gameState.player;
        const misionActiva = player.secta.misionesActivas.find(
          (m) => m.id === misionId
        );
        const misionDataOriginal = MISIONES_DATA[misionId];

        if (!misionActiva || !misionDataOriginal) {
          showModal("Error de Misi√≥n", "Datos de la misi√≥n no encontrados.");
          return false;
        }

        const objetivo = misionActiva.objetivoOriginal;
        let objetivosCumplidos = false;

        switch (objetivo.tipo) {
          case "entregar_item":
            if (
              (gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad
            ) {
              if (
                npcIdEntregaManual &&
                npcIdEntregaManual === objetivo.npcEntrega
              ) {
                gameState.inventory[objetivo.item] -= objetivo.cantidad;
                updateInventoryUI();
                objetivosCumplidos = true;
              }
            } else {
              showModal(
                "Objetivo Incompleto",
                `A√∫n necesitas ${
                  objetivo.cantidad - (gameState.inventory[objetivo.item] || 0)
                } ${objetivo.item}.`
              );
              return false;
            }
            break;
          case "eliminar_enemigo":
            if (misionActiva.progreso >= objetivo.cantidad) {
              objetivosCumplidos = true;
            }
            break;
          case "derrotar_npc_especifico":
            if (misionActiva.progreso === 1) {
              objetivosCumplidos = true;
            } else {
              showModal(
                "Objetivo Incompleto",
                "A√∫n no has derrotado al oponente del desaf√≠o."
              );
              return false;
            }
            break;
          case "recolectar_multiples_items":
            let todosItemsRecolectados = true;
            for (const itemReq of objetivo.items) {
              if (
                (gameState.inventory[itemReq.nombre] || 0) < itemReq.cantidad
              ) {
                todosItemsRecolectados = false;
                break;
              }
            }
            if (todosItemsRecolectados) {
              if (npcIdEntregaManual === objetivo.npcEntrega) {
                for (const itemReq of objetivo.items) {
                  gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                }
                updateInventoryUI();
                objetivosCumplidos = true;
              }
            }
            break;
          case "cazar_y_recuperar_item_de_loot":
            if (
              misionActiva.progreso === 1 &&
              (gameState.inventory[objetivo.itemPrueba] || 0) >=
                objetivo.cantidadItemPrueba
            ) {
              if (npcIdEntregaManual === objetivo.npcEntrega) {
                gameState.inventory[objetivo.itemPrueba] -=
                  objetivo.cantidadItemPrueba;
                updateInventoryUI();
                objetivosCumplidos = true;
              }
            }
            break;
          default:
            showModal("Error de Misi√≥n", "Tipo de objetivo no reconocido.");
            return false;
        }

        if (!objetivosCumplidos) {
          console.log(
            `Objetivos no cumplidos para ${misionDataOriginal.titulo} al intentar completar.`
          );
          return false;
        }

        // --- Dar Recompensas ---
        player.secta.puntosContribucion +=
          misionDataOriginal.recompensa.pcs || 0;
        gainExperience(misionDataOriginal.recompensa.exp || 0);
        let recompensaItemsTexto = "";
        if (misionDataOriginal.recompensa.items) {
          for (const itemName in misionDataOriginal.recompensa.items) {
            gameState.inventory[itemName] =
              (gameState.inventory[itemName] || 0) +
              misionDataOriginal.recompensa.items[itemName];
            recompensaItemsTexto += `${misionDataOriginal.recompensa.items[itemName]} ${itemName}, `;
          }
          updateInventoryUI();
          if (recompensaItemsTexto)
            recompensaItemsTexto = recompensaItemsTexto.slice(0, -2);
        }

        let recompensaTextoGlobal = `Recompensas: ${
          misionDataOriginal.recompensa.pcs || 0
        } PCS, ${misionDataOriginal.recompensa.exp || 0} EXP`;
        if (recompensaItemsTexto)
          recompensaTextoGlobal += `, ${recompensaItemsTexto}`;

        player.secta.misionesActivas = player.secta.misionesActivas.filter(
          (m) => m.id !== misionId
        );
        player.secta.misionesCompletadas[misionId] = true;

        showModal(
          "¬°Misi√≥n Completada!",
          `Completaste: ${misionDataOriginal.titulo}.\n${recompensaTextoGlobal}`
        );

        if (misionDataOriginal.recompensa.nuevoRango) {
          const newRankName = misionDataOriginal.recompensa.nuevoRango;
          player.secta.rango = newRankName;

          setTimeout(
            () =>
              showModal(
                "¬°Ascenso en la Secta!",
                `¬°Felicidades! Ascendiste a ${player.secta.rango}.`
              ),
            2500
          );

          applyRankBenefits(player.secta.rango);

          // === INICIO DE LA MODIFICACI√ìN CLAVE ===
          // Comprobamos si el nuevo rango tiene una elecci√≥n de t√©cnica como recompensa.
          const rankData = SECTA_DATA.rangos.find(
            (r) => r.nombre === newRankName
          );
          if (rankData && rankData.techniqueChoice) {
            // Esperamos un poco m√°s para que no se solape con el modal de ascenso.
            setTimeout(() => {
              openRankUpRewardModal(newRankName);
            }, 4500);
          }
          // === FIN DE LA MODIFICACI√ìN CLAVE ===
        }

        updateSectUI();
        checkAndActivateRankChallengeMissions();
        // --- DISPARADORES DE HISTORIA POST-MISI√ìN ---
        const flags = player.worldState.storyFlags;

        // Hito de Anciana Su (Acto I)
        if (misionId === "mision_desafio_interno_1" && !flags.metAncianaSu) {
          flags.metAncianaSu = true;
          setTimeout(() => {
            showModal(
              "Una Invitaci√≥n Inesperada",
              "Poco despu√©s de tu ascenso, recibes una nota de la Anciana Su, la archivista de la secta. Te pide que la visites.<br><br><em>'Tu control sobre el Qi... es especial. Vis√≠tame en los archivos cuando puedas. Hay cosas que deber√≠as saber sobre el pasado de nuestra secta.'</em>"
            );
          }, 2000);
        }

        // Hito del Maestro Jian (Acto II)
        if (
          misionId === "mision_desafio_diacono_1" &&
          !flags.knowsAboutSoberano
        ) {
          flags.knowsAboutSoberano = true;
          setTimeout(() => {
            showModal(
              "La Convocatoria del Maestro",
              "Tu ascenso a Di√°cono no ha pasado desapercibido. El Maestro de Secta Jian te convoca a sus aposentos privados.<br><br><em>'Joven Di√°cono, debo confiarte un terrible secreto. La Gran Calamidad que hiri√≥ a nuestra secta no fue un accidente. Fue obra de nuestro m√°s grande patriarca, corrompido por un poder prohibido. Lo sellamos, pero ese sello... se est√° rompiendo.'</em><br><br><strong>Has aprendido sobre el Soberano Sellado.</strong>"
            );
          }, 2000);
        }

        // Hito del Santuario (Acto III) - El jugador lo descubre por s√≠ mismo, pero lo activamos aqu√≠.
        if (misionId === "mision_desafio_anciano_1") {
          const santuario = gameState.map.entities.find(
            (e) => e.type === "story_shrine"
          );
          if (santuario) {
            santuario.discovered = true;
            renderMap(); // Actualiza el mapa para mostrar el santuario
            setTimeout(() => {
              showModal(
                "Un Susurro en el Viento",
                "Al derrotar al Anciano Guardi√°n, sientes una extra√±a llamada desde el Valle del Drag√≥n Ca√≠do. Un lugar de poder oculto te est√° esperando. El Maestro Jian asiente, como si supiera que este momento llegar√≠a."
              );
            }, 2000);
          }
        }
        return true;
      }

      function openRankUpRewardModal(newRankName) {
        const modal = document.getElementById("rankUpRewardModal");
        const titleEl = document.getElementById("rankUpRewardTitle");
        const optionsContainer = document.getElementById(
          "rankUpRewardOptionsContainer"
        );

        if (!modal || !titleEl || !optionsContainer) {
          console.error(
            "Elementos del modal de recompensa de rango no encontrados."
          );
          return;
        }

        const rankData = SECTA_DATA.rangos.find(
          (r) => r.nombre === newRankName
        );
        if (
          !rankData ||
          !rankData.techniqueChoice ||
          rankData.techniqueChoice.length === 0
        ) {
          console.log(
            `No hay recompensas de t√©cnica para el rango ${newRankName}.`
          );
          return;
        }

        titleEl.textContent = `Recompensa por ascender a ${newRankName}`;
        optionsContainer.innerHTML = ""; // Limpiar opciones anteriores

        rankData.techniqueChoice.forEach((techId) => {
          const techInfo = techniqueData[techId];
          if (techInfo) {
            const button = document.createElement("button");
            button.className = "cultivation-option-btn";
            button.innerHTML = `
                      <strong>${techInfo.icon || "üìú"} ${techInfo.name}</strong>
                      <br>
                      <small style="opacity: 0.8;">${
                        techInfo.description
                      }</small>
                  `;
            button.onclick = () => claimRankUpReward(techId);
            optionsContainer.appendChild(button);
          }
        });

        modal.style.display = "flex";
        hideTouchControls();
      }

      function claimRankUpReward(techId) {
        // Buscamos el nombre del "Rollo" que ense√±a esta t√©cnica
        let scrollItemName = null;
        const techDefinition = techniqueData[techId];

        // Este bucle asume que el nombre de la t√©cnica en la definici√≥n y en el nombre del rollo coinciden.
        // Ej: techniqueData.sword_slash_1.name es "Corte de Espada B√°sico"
        // y el item se llama "Rollo: Corte de Espada B√°sico"
        if (techDefinition) {
          const expectedScrollName = `Rollo: ${techDefinition.name}`;
          if (itemData[expectedScrollName]) {
            scrollItemName = expectedScrollName;
          }
        }

        if (scrollItemName) {
          gameState.inventory[scrollItemName] =
            (gameState.inventory[scrollItemName] || 0) + 1;
          updateInventoryUI();
          closeRankUpRewardModal();
          showModal(
            "¬°Recompensa Obtenida!",
            `Has recibido el "${scrollItemName}".\nRevisa tu inventario para aprender la t√©cnica.`
          );
        } else {
          console.error(
            `No se pudo encontrar el objeto 'Rollo' para la t√©cnica con ID: ${techId}`
          );
          showModal(
            "Error de Recompensa",
            "No se pudo otorgar la recompensa. Contacta a un Anciano de la Secta (o al desarrollador)."
          );
        }
      }

      function closeRankUpRewardModal() {
        const modal = document.getElementById("rankUpRewardModal");
        if (modal) modal.style.display = "none";
        showTouchControls();
      }

      function updateSectUI() {
        const player = gameState.player;
        document.getElementById("sectaNombreDisplay").textContent =
          player.secta.nombre;
        document.getElementById("playerSectRank").textContent =
          player.secta.rango;
        document.getElementById("playerPCS").textContent =
          player.secta.puntosContribucion;

        const missionsListDiv = document.getElementById("activeMissionsList");
        missionsListDiv.innerHTML = "";

        if (player.secta.misionesActivas.length === 0) {
          missionsListDiv.innerHTML = "<p>Ninguna misi√≥n activa.</p>";
        } else {
          player.secta.misionesActivas.forEach((misionActiva) => {
            const misionDataOriginal = MISIONES_DATA[misionActiva.id];
            if (misionDataOriginal && misionActiva.objetivoOriginal) {
              // Asegurar que objetivoOriginal exista
              let progresoTexto = "";
              const objetivo = misionActiva.objetivoOriginal;
              const npcEntregaNombre =
                SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre ||
                "NPC correspondiente";

              if (objetivo.tipo === "eliminar_enemigo") {
                progresoTexto = ` (${misionActiva.progreso || 0}/${
                  objetivo.cantidad
                } ${objetivo.nombreDisplay || "objetivos"})`;
                if ((misionActiva.progreso || 0) >= objetivo.cantidad) {
                  progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "entregar_item") {
                const tiene = gameState.inventory[objetivo.item] || 0;
                const necesita = objetivo.cantidad;
                progresoTexto = ` (Tienes ${tiene}/${necesita} ${objetivo.item})`;
                if (tiene >= necesita) {
                  progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "recolectar_multiples_items") {
                let todosListos = true;
                let itemsStatusArray = objetivo.items.map((itemReq) => {
                  const tiene = gameState.inventory[itemReq.nombre] || 0;
                  const necesita = itemReq.cantidad;
                  if (tiene < necesita) todosListos = false;
                  return `${tiene}/${necesita} ${itemReq.nombre}`;
                });
                progresoTexto = ` (${itemsStatusArray.join(", ")})`;
                if (todosListos) {
                  progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot") {
                const tieneItem =
                  (gameState.inventory[objetivo.itemPrueba] || 0) >=
                  objetivo.cantidadItemPrueba;
                progresoTexto =
                  misionActiva.progreso === 1 && tieneItem
                    ? ` (Prueba '${objetivo.itemPrueba}' obtenida)`
                    : ` (Cazar ${objetivo.enemigoTipo} y obtener ${objetivo.itemPrueba})`;
                if (misionActiva.progreso === 1 && tieneItem) {
                  progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "derrotar_npc_especifico") {
                // Estas se autocompletan, as√≠ que no aparecer√°n mucho aqu√≠ si se completan r√°pido
                progresoTexto = ` (Derrotar a ${
                  entityTypes[objetivo.npcId]?.name || "objetivo"
                })`;
              }
              const p = document.createElement("p");
              p.innerHTML = `<strong>${misionDataOriginal.titulo}</strong><small>${progresoTexto}</small>`;
              missionsListDiv.appendChild(p);
            }
          });
        }
        updateStatsPanelVisibility();
      }

      function checkAndActivateRankChallengeMissions() {
        const player = gameState.player;
        const currentRankIndex = SECTA_DATA.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );

        if (currentRankIndex === -1) {
          console.error(
            "Error: Rango actual del jugador no encontrado en SECTA_DATA.rangos"
          );
          return;
        }

        if (currentRankIndex + 1 >= SECTA_DATA.rangos.length) {
          return;
        }

        const nextRankData = SECTA_DATA.rangos[currentRankIndex + 1];

        if (player.secta.puntosContribucion >= nextRankData.pcsRequeridos) {
          if (nextRankData.desafioRivalId) {
            // --- L√ìGICA MEJORADA PARA ENCONTRAR LA MISI√ìN ---
            const desafioMisionId = Object.keys(MISIONES_DATA).find((mId) => {
              const mision = MISIONES_DATA[mId];
              return (
                mision.autoActivarAlCumplirRequisitos === true &&
                mision.recompensa?.nuevoRango === nextRankData.nombre &&
                mision.objetivo?.npcId === nextRankData.desafioRivalId
              );
            });
            // --- FIN DE LA L√ìGICA MEJORADA ---

            if (desafioMisionId) {
              const isMissionActive = player.secta.misionesActivas.some(
                (m) => m.id === desafioMisionId
              );
              const isMissionCompleted =
                player.secta.misionesCompletadas[desafioMisionId];

              if (!isMissionActive && !isMissionCompleted) {
                acceptMission(desafioMisionId);
                const misionData = MISIONES_DATA[desafioMisionId];
                showModal(
                  "¬°Nuevo Desaf√≠o de Rango!",
                  `Has alcanzado los requisitos de PCS para el rango de ${nextRankData.nombre}.\n` +
                    `Se ha activado la misi√≥n de desaf√≠o: "${misionData.titulo}".\n` +
                    `¬°Prep√°rate y busca a tu oponente en la arena de la secta!`
                );

                // La funci√≥n ensureFixedEntities se encargar√° de hacer aparecer al guardi√°n
                // porque la misi√≥n est√° ahora activa.
                ensureFixedEntities();
                renderMap();
              }
            } else {
              console.warn(
                `No se encontr√≥ una misi√≥n de desaf√≠o auto-activable para el rival ${nextRankData.desafioRivalId} del rango ${nextRankData.nombre}.`
              );
            }
          }
        }
        updateSectUI();
      }

      function applyRankBenefits(newRankName) {
        const rankData = SECTA_DATA.rangos.find(
          (r) => r.nombre === newRankName
        );
        if (rankData) {
          showModal(
            "Beneficios de Rango",
            `Has obtenido beneficios de ${newRankName}: ${rankData.beneficios}`
          );
        }
        updateUI();
      }

      function enemyTurn() {
        if (!gameState.battle.active || gameState.battle.playerTurn) return;

        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const playerSprite = document.querySelector('.character-sprite');
        const enemySprite = document.getElementById('enemySprite');

        // --- PROCESAR EFECTOS DE ESTADO EN EL ENEMIGO AL INICIO DE SU TURNO ---
        let canEnemyAct = true;
        let reasonForInaction = "";
        let chosenAbility = null;
        const enemyBaseDamage = enemy.attack;

        // --- PROCESAMIENTO DE EFECTOS DE ESTADO (DoTs, Stuns, etc.) ---

        // 1. DA√ëO POR TURNO de efectos como Grilletes, Veneno, Quemadura
        if (enemy.rootedTurns > 0) {
            enemy.hp -= enemy.rootDamage;
            logBattle(`${enemy.name} sufre ${enemy.rootDamage} de da√±o por los grilletes. HP: ${Math.floor(enemy.hp)}`);
            showFloatingText(enemySprite, `-${enemy.rootDamage}`, 'damage');
            if (enemy.hp <= 0) { handleEnemyDefeat(); return; }
        }
        if (enemy.burningTurns > 0) {
            enemy.hp -= enemy.burnDamage;
            logBattle(`${enemy.name} sufre ${enemy.burnDamage} por quemadura. HP: ${Math.floor(enemy.hp)}`);
            showFloatingText(enemySprite, `-${enemy.burnDamage}`, 'damage');
            if (enemy.hp <= 0) { handleEnemyDefeat(); return; }
        }
        if (enemy.poisonedTurns > 0) {
            enemy.hp -= enemy.poisonDamage;
            logBattle(`${enemy.name} sufre ${enemy.poisonDamage} por veneno. HP: ${Math.floor(enemy.hp)}`);
            showFloatingText(enemySprite, `-${enemy.poisonDamage}`, 'damage');
            if (enemy.hp <= 0) { handleEnemyDefeat(); return; }
        }

        // 2. L√ìGICA DE CONTROL (Stun, Seal, Freeze) - Impiden la acci√≥n completamente
        if (enemy.sealedTurns > 0) {
            canEnemyAct = false;
            reasonForInaction = "¬°Sellado!";
            enemy.sealedTurns--;
        } else if (enemy.frozenTurns > 0) {
            canEnemyAct = false;
            reasonForInaction = "¬°Congelado!";
            enemy.frozenTurns--;
        } else if (enemy.stunnedTurns > 0) {
            canEnemyAct = false;
            reasonForInaction = "¬°Aturdido!";
            enemy.stunnedTurns--;
        }

        if (!canEnemyAct) {
            logBattle(`¬°${enemy.name} est√° ${reasonForInaction.toLowerCase().replace('!','')} y no puede actuar!`);
            showFloatingText(enemySprite, reasonForInaction, 'debuff');
            endEnemyTurn();
            return;
        }

        // 3. L√ìGICA DE GRILLETES (ROOTED) - Impide la acci√≥n si resisten
        if (enemy.rootedTurns > 0) {
            logBattle(`${enemy.name} intenta liberarse de los grilletes...`);
            player.activeChanneledAbility.hp -= enemyBaseDamage;

            if (player.activeChanneledAbility.hp <= 0) {
                logBattle(`¬°Con un golpe poderoso, ${enemy.name} rompe los grilletes!`);
                showFloatingText(enemySprite, '¬°Liberado!', 'ability');
                enemy.rootedTurns = 0;
                enemy.rootDamage = 0;
                player.activeChanneledAbility.id = null;
                player.activeChanneledAbility.hp = 0;
                canEnemyAct = false;
            } else {
                logBattle(`Los grilletes resisten el ataque. (Resistencia: ${Math.floor(player.activeChanneledAbility.hp)})`);
                showFloatingText(enemySprite, '¬°Atrapado!', 'debuff');
                canEnemyAct = false;
            }

            enemy.rootedTurns--;
            if (enemy.rootedTurns === 0 && player.activeChanneledAbility.id === 'formation_t2') {
                logBattle("Los grilletes de Qi se disipan por el paso del tiempo.");
                player.activeChanneledAbility.id = null;
                player.activeChanneledAbility.hp = 0;
            }
        }
        
        // 2. Reducir duraci√≥n de debuffs
        if(enemy.defenseReductionTurns > 0) {
            enemy.defenseReductionTurns--;
            if (enemy.defenseReductionTurns === 0) {
                logBattle(`La defensa de ${enemy.name} vuelve a la normalidad.`);
                // La restauraci√≥n de la estad√≠stica se maneja mejor en el momento de la aplicaci√≥n para evitar errores.
            }
        }
        if(enemy.attackReductionTurns > 0) {
            enemy.attackReductionTurns--;
            if (enemy.attackReductionTurns === 0) {
                logBattle(`El ataque de ${enemy.name} vuelve a la normalidad.`);
            }
        }
        // 4. EJECUCI√ìN DE LA ACCI√ìN DEL ENEMIGO
        if (canEnemyAct) {
            if (enemy.abilities && enemy.silencedTurns <= 0) {
                for (const abilityInfo of enemy.abilities) {
                    if (Math.random() < abilityInfo.chance) {
                        chosenAbility = enemyAbilityData[abilityInfo.abilityId];
                        if (chosenAbility) break;
                    }
                }
            }

            if (chosenAbility) {
                showFloatingText(enemySprite, chosenAbility.name, 'ability');
                const effect = chosenAbility.effect;
                let damage = 0;
                let finalDamage = 0;
                let heal = 0;

                // --- SWITCH COMPLETO PARA HABILIDADES DE ENEMIGO ---
                switch (chosenAbility.type) {
                    case 'buff_stat':
                        if (enemy.defenseBoostTurns === 0) {
                            enemy.defenseBoostAmount = effect.amount;
                            enemy.defense += effect.amount;
                            enemy.defenseBoostTurns = effect.duration;
                            logBattle(chosenAbility.logMessage(enemy.name, effect.amount, effect.duration));
                        } else {
                            logBattle(`${enemy.name} intenta fortalecerse, ¬°pero ya lo est√°!`);
                        }
                        break;

                    case 'debuff_stat':
                    case 'dot_damage':
                    case 'heal_damage':
                        damage = Math.floor(enemy.attack * (effect.baseDamageMultiplier || 1.0));
                        finalDamage = applyDamageToPlayer(damage, chosenAbility.name); // Usamos el da√±o real aplicado

                        if (effect.debuff && player.defenseReductionTurns === 0) {
                            player.defenseReductionAmount = effect.debuff.amount;
                            player.defense -= effect.debuff.amount;
                            player.defenseReductionTurns = effect.debuff.duration;
                            showFloatingText(playerSprite, 'Defensa ‚Üì', 'debuff');
                        }
                        if (effect.dot) {
                            if (effect.dot.type === 'burn') {
                                player.burningTurns = Math.max(player.burningTurns, effect.dot.duration);
                                player.burnDamage = Math.max(player.burnDamage, effect.dot.damagePerTurn);
                                showFloatingText(playerSprite, 'Quemadura', 'debuff');
                            } else if (effect.dot.type === 'poison') {
                                player.poisonedTurns = Math.max(player.poisonedTurns, effect.dot.duration);
                                player.poisonDamage = Math.max(player.poisonDamage, effect.dot.damagePerTurn);
                                showFloatingText(playerSprite, 'Envenenado', 'debuff');
                            }
                        }
                        if (effect.lifesteal) {
                            heal = Math.floor(finalDamage * effect.lifesteal);
                            enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                            showFloatingText(enemySprite, `+${heal}`, 'heal');
                        }
                        logBattle(chosenAbility.logMessage(enemy.name, finalDamage, heal || effect.debuff?.amount || effect.dot?.damagePerTurn, effect.debuff?.duration || effect.dot?.duration));
                        break;

                    case 'piercing_damage':
                        const defenseToIgnore = player.defense * (effect.armorPenetration || 0);
                        damage = Math.max(0, Math.floor(enemy.attack * (effect.baseDamageMultiplier || 1.0)) - (player.defense - defenseToIgnore));
                        applyDamageToPlayer(damage, chosenAbility.name);
                        logBattle(chosenAbility.logMessage(enemy.name, damage));
                        break;

                    case 'stun_chance':
                        damage = Math.floor(enemy.attack * (effect.baseDamageMultiplier || 1.0));
                        finalDamage = applyDamageToPlayer(damage, chosenAbility.name);
                        const didStun = Math.random() < (effect.stunChance || 0);
                        if (didStun && player.stunnedTurns === 0) {
                            player.stunnedTurns = 1;
                            showFloatingText(playerSprite, '¬°Aturdido!', 'debuff');
                        }
                        logBattle(chosenAbility.logMessage(enemy.name, finalDamage, didStun));
                        break;

                    case 'dot_resource':
                        if (effect.dot.resource === 'mana' && player.manaDrainTurns === 0) {
                            player.manaDrainTurns = effect.dot.duration;
                            player.manaDrainAmount = effect.dot.drainPerTurn;
                            showFloatingText(playerSprite, 'Maldici√≥n de Man√°', 'debuff');
                            logBattle(chosenAbility.logMessage(enemy.name, player.manaDrainAmount, player.manaDrainTurns));
                        } else {
                            logBattle(`${enemy.name} intenta maldecirte, ¬°pero ya est√°s bajo un efecto similar!`);
                        }
                        break;

                    case 'heal':
                        heal = effect.healAmount;
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                        showFloatingText(enemySprite, `+${heal}`, 'heal');
                        logBattle(chosenAbility.logMessage(enemy.name, heal));
                        break;
                    
                    // A√±ade aqu√≠ m√°s 'case' si defines nuevas habilidades de enemigo
                    
                    default:
                        logBattle(`(${chosenAbility.name}) ¬°La habilidad del enemigo no tuvo efecto!`);
                        break;
                }
            } else {
                // Ataque b√°sico si no se usa habilidad
                const damage = Math.max(0, enemy.attack - player.defense);
                applyDamageToPlayer(damage, `${enemy.name}`);
            }
        }

        endEnemyTurn();
    }

      function endEnemyTurn() {
        const player = gameState.player;
        
        // --- L√ìGICA DE MANTENIMIENTO (UPKEEP) ---
        // Se ejecuta al final del turno del enemigo, antes de devolver el control al jugador.
        if (player.activeChanneledAbility.id === 'formation_t2') {
            const upkeepCost = techniqueData['formation_t2'].effect.manaUpkeep;
            if (player.mana >= upkeepCost) {
                player.mana -= upkeepCost;
                logBattle(`Mantener los Grilletes de Qi consume ${upkeepCost} man√°.`);
            } else {
                logBattle(`¬°Man√° insuficiente para mantener los grilletes! Se disipan.`);
                // Romper el efecto si no hay man√°
                gameState.battle.enemy.rootedTurns = 0;
                gameState.battle.enemy.rootDamage = 0;
                player.activeChanneledAbility.id = null;
                player.activeChanneledAbility.hp = 0;
            }
        }
        // Desgaste del bono de defensa temporal de "Paso Veloz"
        if (player.tempDefenseBoostTurns > 0) {
            player.tempDefenseBoostTurns--;
            if (player.tempDefenseBoostTurns === 0) {
                player.defense -= player.tempDefenseBoostAmount; // Restaura la defensa
                logBattle(`El bono de agilidad de ${techniqueData["movement_t1"].name} se desvanece.`);
                player.tempDefenseBoostAmount = 0;
            }
        }

        if (player.hp <= 0) {
          player.hp = 0;
          logBattle("Has sucumbido a tus heridas antes de poder actuar.");
          updateBattleUI(); // Actualiza la UI para mostrar HP 0

          // L√≥gica de derrota centralizada
          setTimeout(() => {
            const expLoss = Math.floor(gameState.player.exp * 0.1);
            gameState.player.hp = Math.floor(gameState.player.maxHp * 0.1);
            gameState.player.mana = Math.floor(gameState.player.maxMana * 0.1);
            gameState.player.exp = Math.max(0, gameState.player.exp - expLoss);

            const safeCoords = findSafeRespawnLocation(
              G_SAFE_RESPAWN_X,
              G_SAFE_RESPAWN_Y
            );
            gameState.player.x = safeCoords.x;
            gameState.player.y = safeCoords.y;

            updatePlayerPosition("player_defeat_respawn");
            endBattle(false);
            showModal("Derrota", `Ca√≠ste en combate. Pierdes ${expLoss} EXP.`);
          }, 2000);
          return; // Detener la funci√≥n aqu√≠, el jugador no puede actuar.
        }
        
        // Devolvemos el control al jugador
        gameState.battle.playerTurn = true;
        
        updateBattleUI();
        populateBattleActionButtons();
    }

    function applyDamageToPlayer(damageAmount, sourceName = "Ataque") {
      const player = gameState.player;
      const playerSprite = document.querySelector('.character-sprite');
      let incomingDamage = damageAmount; 
      
      // 1. INMUNIDAD TOTAL (por Santuario Dorado, etc.)
      if (player.intangibleTurns > 0) {
            logBattle(`¬°Tu Santuario Dorado anula completamente el ataque de ${sourceName}!`);
            showFloatingText(playerSprite, '¬°Inmune!', 'ability');
            return 0; // No se recibe da√±o
        }
      // 2. CONVERSI√ìN DE DA√ëO A CURACI√ìN (por Matriz de Reversi√≥n)
      if (player.damageToHealingTurns > 0) {
            const healingAmount = Math.floor(incomingDamage * 1.2); // Convierte a 120% de curaci√≥n
            player.hp = Math.min(player.maxHp, player.hp + healingAmount);
            logBattle(`¬°La Matriz de Reversi√≥n convierte ${Math.floor(incomingDamage)} de da√±o en ${healingAmount} de curaci√≥n!`);
            showFloatingText(playerSprite, `+${healingAmount}`, 'heal');
            return 0; // No se recibe da√±o, al contrario
        }
      // 3. L√ìGICA DE ESQUIVAR ---
      // Ahora 'incomingDamage' ya est√° definido y se puede usar en la condici√≥n.
      if (player.dodgeNextAttack && incomingDamage > 0) {
          
          const etereoDetails = techniqueData["movement_t2"];
          const etereoLevel = player.learnedTechniques["movement_t2"]?.level || 1;
          // La mejora de "no consumir" (Opci√≥n 2) la implementaremos aqu√≠
          const noConsumeChance = (etereoDetails.effect.noConsumeChancePerLevel || 0) * (etereoLevel - 1);

          logBattle(`¬°Esquivas por completo el ataque de ${sourceName}!`);
          showFloatingText(playerSprite, '¬°Esquivado!', 'ability');

          // Comprobamos si el efecto se mantiene
          if (Math.random() > noConsumeChance) {
              player.dodgeNextAttack = false; // Se consume normalmente
          } else {
              logBattle("¬°Tu movimiento fue tan fluido que sigues listo para esquivar!");
              showFloatingText(playerSprite, '¬°A√∫n Et√©reo!', 'ability');
          }

          return 0; // Anulamos todo el da√±o y terminamos la funci√≥n.
      }
      
      // --- L√ìGICA DE ABSORCI√ìN DE DA√ëO POR ESCUDO ---
      if (incomingDamage > 0 && player.magicShieldValue > 0 && player.magicShieldTurns > 0) {
          
          const absorbedByShield = Math.min(incomingDamage, player.magicShieldValue);
          player.magicShieldValue -= absorbedByShield;
          incomingDamage -= absorbedByShield;

          logBattle(`¬°Tu escudo absorbe ${absorbedByShield} de da√±o! (Restante: ${Math.floor(player.magicShieldValue)})`);
          showFloatingText(playerSprite, `Absorbe ${absorbedByShield}`, 'ability');

          if (player.magicShieldValue <= 0) {
              logBattle("¬°Tu barrera m√°gica se ha roto!");
              player.magicShieldTurns = 0;
          }
      }

      // --- APLICAR DA√ëO RESTANTE ---
      if (incomingDamage > 0) {
          const reductionMultiplier = 1 - (player.damageReduction || 0);
          incomingDamage *= reductionMultiplier;
          player.hp -= incomingDamage;
          logBattle(`Recibes ${Math.floor(incomingDamage)} de da√±o de ${sourceName}.`);
          showFloatingText(playerSprite, `-${Math.floor(incomingDamage)}`, 'damage');
      } else if (damageAmount > 0) {
          logBattle(`¬°Tu defensa absorbi√≥ completamente el ataque de ${sourceName}!`);
          showFloatingText(playerSprite, '¬°Bloqueado!', 'ability');
      }

      return incomingDamage;
  }
      function showBattleReview() {
        const reviewLog = document.getElementById("battleReviewLog");
        reviewLog.innerHTML = ""; // Limpiar contenido anterior

        // Unimos todos los mensajes del historial con un salto de l√≠nea
        const formattedLog = battleLogHistory.join("<br>");
        reviewLog.innerHTML = formattedLog;

        document.getElementById("battleReviewModal").style.display = "flex";
      }

      function closeBattleReviewModal() {
        document.getElementById("battleReviewModal").style.display = "none";
      }

      function endBattle(victory) {
       // --- MODIFICACI√ìN PARA RESETEAR ESTADOS DE COMBATE ---
       const player = gameState.player;
        
        // Resetea todos los buffs/debuffs temporales del jugador al final del combate
        player.abilityCooldowns = {};
        player.defenseBoostTurns = 0;
        player.defenseBoostAmount = 0;
        player.dodgeNextAttack = false;
        player.healingRainTurns = 0;
        player.magicShieldValue = 0;
        player.magicShieldTurns = 0;
        player.canRevive = false; // El poder del F√©nix se desvanece fuera del combate
        player.intangibleTurns = 0;
        player.damageToHealingTurns = 0;

        gameState.battle.active = false;
        document.getElementById("battleScreen").style.display = "none";
        document.getElementById("battleLog").innerHTML = "";
        document.getElementById('quickSlotBar').classList.remove('hidden');
        // Ocultar las barras sobre el sprite en batalla expl√≠citamente al finalizar
        const barsInBattleContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        if (barsInBattleContainer) {
          barsInBattleContainer.style.display = "none";
        }
        if (victory && gameState.battle.enemy?.entityRef) {
          removeEntity(gameState.battle.enemy.entityRef);
        }
        gameState.battle.enemy = null;

        // Restaurar sprite a idle despu√©s de la batalla
        player.currentDirection = "down"; // O la √∫ltima direcci√≥n antes de la batalla
        player.currentFrame = 0;
        player.isMoving = false; // Asegurarse de que no est√© en estado de movimiento
        updatePlayerSpriteVisual();

        recalculatePlayerStats();
        updateUI();
        updateTopNavVisibility();
        showTouchControls();
        updatePlayerBarsOnMap();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function findEscapeTile(player, enemy) {
        const playerX = player.x;
        const playerY = player.y;

        // Calcular la direcci√≥n opuesta al enemigo
        const dx = playerX - enemy.x;
        const dy = playerY - enemy.y;

        // Normalizar la direcci√≥n para obtener un vector unitario (aproximado)
        let escapeX = playerX + Math.sign(dx);
        let escapeY = playerY + Math.sign(dy);

        const checkTile = (x, y) => {
          if (
            x < 0 ||
            x >= gameState.map.width ||
            y < 0 ||
            y >= gameState.map.height
          )
            return false;
          const terrain = G_TERRAIN_TYPES[getTerrainTypeAt(x, y)];
          if (terrain && terrain.walkable === false) return false;
          const isOccupied = gameState.map.entities.some(
            (e) => e.x === x && e.y === y
          );
          return !isOccupied;
        };

        // 1. Intentar moverse a la casilla directamente opuesta
        if (checkTile(escapeX, escapeY)) {
          return { x: escapeX, y: escapeY };
        }

        // 2. Si no es posible, buscar en las 8 casillas adyacentes una que est√© vac√≠a
        const possibleMoves = [
          { x: playerX, y: playerY - 1 },
          { x: playerX, y: playerY + 1 }, // Arriba, Abajo
          { x: playerX - 1, y: playerY },
          { x: playerX + 1, y: playerY }, // Izquierda, Derecha
          { x: playerX - 1, y: playerY - 1 },
          { x: playerX + 1, y: playerY - 1 }, // Diagonales
          { x: playerX - 1, y: playerY + 1 },
          { x: playerX + 1, y: playerY + 1 },
        ];

        for (const move of possibleMoves) {
          if (checkTile(move.x, move.y)) {
            return move;
          }
        }

        return null; // No se encontr√≥ ninguna casilla segura para huir
      }

      function findSafeRespawnLocation(preferredX, preferredY) {
        const isHostile = (entity) =>
          G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss;
        let preferredSpotOccupiedByHostile = gameState.map.entities.some(
          (e) => e.x === preferredX && e.y === preferredY && isHostile(e)
        );
        if (!preferredSpotOccupiedByHostile)
          return { x: preferredX, y: preferredY };
        for (let r = 1; r <= G_SAFE_RESPAWN_SEARCH_RADIUS; r++) {
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
              const cx = preferredX + dx;
              const cy = preferredY + dy;
              if (
                cx < 0 ||
                cx >= gameState.map.width ||
                cy < 0 ||
                cy >= gameState.map.height
              )
                continue;
              const isCompletelyEmpty = !gameState.map.entities.some(
                (e) => e.x === cx && e.y === cy
              );
              if (isCompletelyEmpty) return { x: cx, y: cy };
            }
          }
        }
        return { x: preferredX, y: preferredY };
      }

      function logBattle(message) {
        battleLogHistory.push(message);
      }

      function showTechniquePanel() {
        const container = document.getElementById("learnedTechniquesContainer");
        container.innerHTML = ""; // Limpiar contenido anterior
        
        const player = gameState.player;
        if (Object.keys(player.learnedTechniques).length === 0) {
            container.innerHTML = "<p style='text-align: center; opacity: 0.7;'>A√∫n no has aprendido ninguna t√©cnica.</p>";
        } else {
            // Ordenamos las t√©cnicas para una mejor visualizaci√≥n (opcional)
            const sortedTechIds = Object.keys(player.learnedTechniques).sort();

            sortedTechIds.forEach(techId => {
                const techInfo = techniqueData[techId];
                const playerTech = player.learnedTechniques[techId];
                if (!techInfo) return; // Salto de seguridad

                const div = document.createElement("div");
                // Usamos la misma clase que los √≠tems del inventario para un estilo consistente
                div.className = "inventory-modal-item"; 
                
                let levelText = playerTech.level >= techInfo.maxLevel 
                    ? `<span style="color: #f4d03f;">(MAX)</span>`
                    : `(Nv. ${playerTech.level} / ${techInfo.maxLevel})`;
                
                // --- LLAMADA A LA NUEVA FUNCI√ìN DE DETALLES ---
                const detailsText = getTechniqueDetailsAsText(techInfo, playerTech.level);
                
                let cultivationProgressText = '';
                if (techInfo.cultivationSettings && playerTech.level < techInfo.maxLevel) {
                    const progress = playerTech.currentCultivationProgress || 0;
                    const timeToNext = playerTech.cultivationTimeToNextLevel || (techInfo.cultivationSettings.baseTimeToLevelUp || Infinity);
                    cultivationProgressText = `<div style="font-size: 0.8em; opacity: 0.7; margin-top: 5px;">Progreso de Cultivo: ${Math.floor(progress)}s / ${timeToNext}s</div>`;
                }

                div.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${techInfo.icon || "üìú"} ${techInfo.name} ${levelText}</div>
                        <div class="item-description">${techInfo.description}</div>
                        ${detailsText}
                        ${cultivationProgressText}
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        document.getElementById("techniqueModal").style.display = "flex";
        hideTouchControls();
    }

    function getTechniqueDetailsAsText(techInfo, currentLevel) {
      if (!techInfo) return "";

      const effect = techInfo.effect || {};
      let details = [];
      const isMaxLevel = currentLevel >= techInfo.maxLevel;
      const nextLevel = currentLevel + 1;

      // Funci√≥n de ayuda interna para calcular valores y generar texto
      const createDetailLine = (label, baseValue, increasePerLevel, unit = '', decimals = 2, isPercentage = false) => {
          if (baseValue === undefined) return null;

          const scaleFactor = isPercentage ? 100 : 1;
          const currentVal = baseValue + ((currentLevel - 1) * (increasePerLevel || 0));
          const nextVal = baseValue + ((nextLevel - 1) * (increasePerLevel || 0));
          
          let text = `${label}: ${(currentVal * scaleFactor).toFixed(decimals)}${unit}`;
          
          if (!isMaxLevel && nextVal.toFixed(decimals + 2) !== currentVal.toFixed(decimals + 2)) {
              text += ` <span style="color:#66ff66;">(Pr√≥x: ${(nextVal * scaleFactor).toFixed(decimals)}${unit})</span>`;
          }
          return text;
      };
      
      // --- L√ìGICA DE DETALLES REFACTORIZADA ---

      // 1. Da√±o
      let damageLine = createDetailLine("Da√±o", effect.baseDamageMultiplier, effect.multiplierIncreasePerLevel, 'x Ataque', 2);
      if (damageLine) details.push(damageLine);
      
      // 2. Da√±o por Turno (DoT)
      let dotLine = createDetailLine("Da√±o/Turno", effect.damagePerTurn || effect.burnDamagePerTurn || effect.bleedDamagePerTurn, 2, '', 0); // Asumiendo un escalado fijo de +2 por nivel
      if (dotLine) details.push(dotLine);

      // 3. Probabilidad de Efecto
      let chanceLine = createDetailLine("Prob. Efecto", effect.baseStunChance || effect.bleedChance || effect.stunChance, effect.stunChanceIncreasePerLevel || 0.03, '%', 0, true);
      if (chanceLine) details.push(chanceLine);

      // 4. Reducci√≥n de Stats
      let reductionLine = createDetailLine("Reducci√≥n Stats", effect.baseReduction, effect.reductionIncreasePerLevel, '', 0);
      if (reductionLine) details.push(reductionLine);

      // 5. Duraci√≥n
      if (effect.duration || effect.baseDuration) {
          const currentDuration = effect.duration || effect.baseDuration;
          let text = `Duraci√≥n: ${currentDuration} turnos`;
          if (!isMaxLevel && effect.levelForExtraTurn && nextLevel >= effect.levelForExtraTurn && currentLevel < effect.levelForExtraTurn) {
              text += ` <span style="color:#66ff66;">(Pr√≥x: ${currentDuration + 1} turnos)</span>`;
          }
          details.push(text);
      }

      // 6. Golpes M√∫ltiples
      if (effect.baseHits) {
          const currentHits = Math.round(effect.baseHits + (currentLevel - 1) * (effect.hitsIncreasePerLevel || 0));
          const nextHits = Math.round(effect.baseHits + (nextLevel - 1) * (effect.hitsIncreasePerLevel || 0));
          let text = `Golpes: ${currentHits}`;
          if (!isMaxLevel && nextHits > currentHits) text += ` <span style="color:#66ff66;">(Pr√≥x: ${nextHits})</span>`;
          details.push(text);
      }
      
      // 7. Habilidades Pasivas que mejoran STATS BASE (ej. Piel de Acero)
      if (techInfo.type === 'passive_stat' && effect.statToBoost) {
          // Las pasivas se aplican una vez por cada nivel que se sube, no tienen un "pr√≥ximo nivel" visible.
          // Mostramos el beneficio total que se obtiene por cada nivel de la t√©cnica.
          details.push(`Efecto Pasivo: +${effect.value} a ${effect.statToBoost.replace('base','').replace('Max',' M√°ximo ')} por nivel.`);
      }

      // 8. Habilidades Pasivas de CULTIVO (ej. Absorci√≥n de Qi)
      if (techInfo.type === 'passive_cultivation' && effect.statToBoost) {
          details.push(`Efecto de Cultivo: +${effect.value} a ${effect.statToBoost.replace('Base','/s')} por nivel.`);
      }

      // 9. Efectos √önicos y Fijos
      if (effect.isCritical) details.push("Especial: Siempre es un Golpe Cr√≠tico.");
      if (effect.ignoreDefense) details.push("Especial: Ignora la defensa del enemigo.");
      if (effect.dodgeNextAttack) details.push("Especial: Esquiva el pr√≥ximo ataque.");
      
      // Construir el string final
      if (details.length > 0) {
          return `<div style="margin-top: 8px; padding-left: 10px; border-left: 2px solid #555; font-size: 0.85em; line-height: 1.6;">
                      ${details.join('<br>')}
                  </div>`;
      }

      return "";
  }

      function startTechniqueRefinement(techId) {}

      function stopTechniqueRefinement() {}

      function applyTechniqueEffect(techId, newLevel) {
        // La l√≥gica de aplicar efectos espec√≠ficos se ha movido a `recalculatePlayerStats`.
        // Esta funci√≥n ahora solo necesita asegurarse de que, despu√©s de que una t√©cnica
        // suba de nivel, todas las estad√≠sticas del jugador se actualicen correctamente
        // para reflejar el cambio.
        
        recalculatePlayerStats(); // Esto recalcular√° todo basado en los niveles actuales.
        updateUI(); // Actualiza la interfaz para mostrar los cambios.
      }

      function closeTechniqueModal() {
        document.getElementById("techniqueModal").style.display = "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
      }

      let currentShopPage = 1;
      const shopItemsPerPage = 6;

      function openShop() {
        document.getElementById(
          "playerSpiritualStones"
        ).textContent = `Piedras Espirituales: ${
          gameState.inventory["Piedras Espirituales"] || 0
        }`;
        document.getElementById("shopModal").style.display = "flex";
        renderShopProducts();
        hideTouchControls();
      }

      function renderShopProducts() {
        const shopProductsEl = document.getElementById("shopProducts");
        shopProductsEl.innerHTML = "";
        const activeCategory =
          document.querySelector("#shopCategories .active")?.dataset.category ||
          "all";
        const searchTerm = document
          .getElementById("shopSearch")
          .value.toLowerCase();
        const priceVal = parseInt(document.getElementById("priceRange").value);
        document.getElementById(
          "priceRangeValue"
        ).textContent = `${priceVal} PS`;
        const playerRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === gameState.player.secta.rango);

        let filteredItems = shopData.inventory.filter((item) => {
          const itemNameLower = item.itemName.toLowerCase();
          const itemCategory = item.category || "other";
          const itemTypeForFilter =
            item.type ||
            (itemNameLower.includes("rollo:") ? "scroll" : "other");

          if (
            searchTerm &&
            !itemNameLower.includes(searchTerm) &&
            !(
              item.description &&
              item.description.toLowerCase().includes(searchTerm)
            )
          )
            return false;
          if (item.price > priceVal) return false;
          if (itemNameLower.startsWith("rollo: ")) {
              const techName = item.itemName.substring(7);
              const techId = Object.keys(techniqueData).find(id => techniqueData[id].name === techName);
              
              if (techId && techniqueData[techId].requiredRank) {
                  const requiredRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === techniqueData[techId].requiredRank);
                  
                  // El jugador debe tener un rango igual o superior al requerido.
                  if (playerRankIndex < requiredRankIndex) {
                      return false; // No mostrar si el rango es insuficiente.
                  }
              }
          }

          if (activeCategory !== "all") {
            if (activeCategory === "combat" && !techIsCombat(item.itemName))
              return false;
            if (
              activeCategory === "cultivation" &&
              !techIsCultivation(item.itemName)
            )
              return false;
            if (
              activeCategory === "scroll" &&
              !itemNameLower.startsWith("rollo: ")
            )
              return false;
            if (
              activeCategory === "consumable" &&
              itemTypeForFilter !== "consumable" &&
              ![
                "Hierbas Medicinales",
                "Cristales de Qi",
                "P√≠ldora de Recuperaci√≥n Menor",
              ].includes(item.itemName)
            )
              return false;
            if (activeCategory === "weapon" && itemCategory !== "weapon")
              return false;
            if (activeCategory === "armor" && itemCategory !== "armor")
              return false;
            if (activeCategory === "material" && !isMaterial(item.itemName))
              return false;
          }
          return true;
        });

        const totalPages = Math.ceil(filteredItems.length / shopItemsPerPage);
        const startIndex = (currentShopPage - 1) * shopItemsPerPage;
        const pageItems = filteredItems.slice(
          startIndex,
          startIndex + shopItemsPerPage
        );

        pageItems.forEach((item) => {
          const itemInfo = itemData[item.itemName] || {};
          const productCard = document.createElement("div");
          productCard.className = "product-card";
          let itemIcon = getItemIcon(item.itemName, item.category);
          let itemType = getItemShopType(
            item.itemName,
            item.category,
            item.type
          );

          productCard.innerHTML = `
                  <div class="product-header">
                      <div>
                          <div class="product-name">${itemIcon} ${
            item.itemName
          }</div>
                          <span class="product-type">${itemType}</span>
                      </div>
                      <div class="product-price">${item.price} PS</div>
                  </div>
                  <div class="product-description">${
                    itemInfo.description ||
                    item.description ||
                    "Un objeto misterioso."
                  }</div>
                  ${
                    item.levelRequirement
                      ? `<div><strong>Req:</strong> Nv ${item.levelRequirement}</div>`
                      : ""
                  }
                  ${
                    typeof item.stock === "number"
                      ? `<div><strong>Disp:</strong> ${item.stock}</div>`
                      : ""
                  }
                  <div class="product-actions">
                      <button class="buy-btn" data-item="${
                        item.itemName
                      }" data-price="${item.price}">Comprar</button>
                  </div>`;
          const buyBtn = productCard.querySelector(".buy-btn");
          if (
            (gameState.inventory["Piedras Espirituales"] || 0) < item.price ||
            item.stock === 0
          ) {
            buyBtn.disabled = true;
            buyBtn.title =
              item.stock === 0 ? "Agotado" : "Piedras insuficientes";
          }
          buyBtn.addEventListener("click", () => buyFromShop(item.itemName));
          shopProductsEl.appendChild(productCard);
        });
        renderShopPagination(totalPages);
      }

      function techIsCombat(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "active_ability" ||
            techniqueData[techId].abilityId)
        );
      }

      function techIsCultivation(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "passive_cultivation" ||
            techniqueData[techId].type === "passive_stat" ||
            techniqueData[techId].type === "active_refinement_effect")
        );
      }

      function isMaterial(itemName) {
        const knownMaterials = [
          "Cristal de Hielo",
          "Esencia de Fuego",
          "N√∫cleo de Tormenta",
          "Venenos Mortales",
          "Fragmentos de Jade",
          "Esencia Oscura",
          "Almas Condenadas",
          "N√∫cleo de V√≥rtice",
          "Roc√≠o Celestial",
          "Cristales Ps√≠quicos",
          "Mineral de Hierro Espiritual",
          "Plumas de F√©nix",
          "Semillas Ancestrales",
          "Escamas de Drag√≥n",
          "Espejos Astrales",
          "Relojes de Arena",
          "Sangre de Demonio",
          "L√°grimas de Unicornio",
          "N√∫cleo Elemental",
          "Polvo de Arcano",
          "Piedras Espirituales",
          "Cristales de Qi",
          "Hierbas Medicinales",
        ];
        return knownMaterials.includes(itemName);
      }

      function getItemIcon(itemName, category) {
        if (itemName.includes("Espada") || category === "weapon") return "‚öîÔ∏è";
        if (itemName.includes("Armadura") || category === "armor") return "üõ°Ô∏è";
        if (itemName.includes("Hierba")) return "üåø";
        if (itemName.includes("Cristal")) return "üíé";
        if (itemName.includes("Piedra")) return "üíé";
        if (itemName.startsWith("Rollo:")) return "üìú";
        return "üì¶";
      }

      function getItemShopType(itemName, category, type) {
        if (itemName.startsWith("Rollo: ")) return "T√©cnica";
        if (category === "weapon") return "Arma";
        if (category === "armor") return "Armadura";
        if (
          type === "consumable" ||
          [
            "Hierbas Medicinales",
            "Cristales de Qi",
            "P√≠ldora de Recuperaci√≥n Menor",
          ].includes(itemName)
        )
          return "Consumible";
        if (isMaterial(itemName)) return "Material";
        return "Objeto";
      }

      function renderShopPagination(totalPages) {
        const pagination = document.getElementById("shopPagination");
        pagination.innerHTML = "";
        if (totalPages <= 1) return;
        const prevBtn = document.createElement("button");
        prevBtn.className = "page-btn";
        prevBtn.textContent = "¬´";
        prevBtn.addEventListener("click", () => {
          if (currentShopPage > 1) {
            currentShopPage--;
            renderShopProducts();
          }
        });
        pagination.appendChild(prevBtn);
        const startPage = Math.max(1, currentShopPage - 1);
        const endPage = Math.min(totalPages, currentShopPage + 1);
        for (let i = startPage; i <= endPage; i++) {
          const pageBtn = document.createElement("button");
          pageBtn.className = `page-btn ${
            i === currentShopPage ? "active" : ""
          }`;
          pageBtn.textContent = i;
          pageBtn.addEventListener("click", () => {
            currentShopPage = i;
            renderShopProducts();
          });
          pagination.appendChild(pageBtn);
        }
        const nextBtn = document.createElement("button");
        nextBtn.className = "page-btn";
        nextBtn.textContent = "¬ª";
        nextBtn.addEventListener("click", () => {
          if (currentShopPage < totalPages) {
            currentShopPage++;
            renderShopProducts();
          }
        });
        pagination.appendChild(nextBtn);
      }

      function closeShopModal() {
        document.getElementById("shopModal").style.display = "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function buyFromShop(itemName) {
        const itemToBuy = shopData.inventory.find(
          (i) => i.itemName === itemName
        );
        const playerStones = gameState.inventory["Piedras Espirituales"] || 0;
        if (
          !itemToBuy ||
          itemToBuy.stock === 0 ||
          playerStones < itemToBuy.price
        ) {
          showModal(
            "Error Compra",
            "No se puede comprar (fondos insuficientes, agotado o no existe)."
          );
          return;
        }
        gameState.inventory["Piedras Espirituales"] -= itemToBuy.price;
        if (itemToBuy.type === "equipment" && itemToBuy.attackBonus) {
          gameState.player.baseAttack += itemToBuy.attackBonus;
          recalculatePlayerStats();
          showModal(
            "¬°Equipo Comprado!",
            `Compraste ${itemName}. Ataque base +${itemToBuy.attackBonus}.`
          );
        } else {
          gameState.inventory[itemName] =
            (gameState.inventory[itemName] || 0) + 1;
          if (
            itemData[itemName] &&
            itemData[itemName].effect &&
            itemName.startsWith("Rollo: ")
          ) {
            showModal(
              "¬°Rollo Comprado!",
              `Has comprado ${itemName}. √ösalo desde tu inventario para aprender la t√©cnica.`
            );
          } else {
            showModal("¬°Objeto Comprado!", `Has comprado ${itemName}.`);
          }
        }
        if (typeof itemToBuy.stock === "number" && itemToBuy.stock > 0)
          itemToBuy.stock--;
        openShop();
        updateUI();
      }
      
    function openManageTechniquesModal() {
        // Primero cerramos el modal de visualizaci√≥n para evitar que se superpongan.
        closeTechniqueModal();

        const player = gameState.player;
        const equippedList = document.getElementById('equipped-techniques-list');
        const availableList = document.getElementById('available-techniques-list');
        
        equippedList.innerHTML = '';
        availableList.innerHTML = '';

        // --- Rellenar los slots de t√©cnicas equipadas ---
        for (let i = 0; i < 3; i++) {
            const techId = player.equippedTechniques[i];
            const slotDiv = document.createElement('div');
            slotDiv.className = 'inventory-modal-item';
            slotDiv.style.cursor = 'pointer';

            if (techId && techniqueData[techId]) {
                const techInfo = techniqueData[techId];
                slotDiv.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${techInfo.icon || 'üìú'} ${techInfo.name}</div>
                        <div class="item-description">Slot ${i + 1} - Clic para desequipar</div>
                    </div>
                `;
                slotDiv.onclick = () => unequipTechnique(i);
            } else {
                slotDiv.innerHTML = `
                    <div class="item-details" style="opacity: 0.5;">
                        <div class="item-name">Slot ${i + 1} (Vac√≠o)</div>
                    </div>
                `;
            }
            equippedList.appendChild(slotDiv);
        }

        // --- Rellenar la lista de t√©cnicas disponibles ---
        for (const techId in player.learnedTechniques) {
            const techInfo = techniqueData[techId];
            const playerTech = player.learnedTechniques[techId];

            if (techInfo && techInfo.type === 'active_ability' && playerTech.level > 0) {
                if (player.equippedTechniques.includes(techId)) {
                    continue;
                }

                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventory-modal-item assignable-item';
                itemDiv.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${techInfo.icon || 'üìú'} ${techInfo.name} (Nv. ${playerTech.level})</div>
                        <div class="item-description">${techInfo.description}</div>
                    </div>
                `;
                itemDiv.onclick = () => equipTechnique(techId);
                availableList.appendChild(itemDiv);
            }
        }
        
        document.getElementById('manageTechniquesModal').style.display = 'flex';
        hideTouchControls();
    }
    function closeManageTechniquesModal() {
        document.getElementById('manageTechniquesModal').style.display = 'none';
        showTouchControls();
        // Al cerrar, volvemos a mostrar el panel de t√©cnicas para una experiencia fluida.
        showTechniquePanel();
    }

    function equipTechnique(techId) {
        const player = gameState.player;
        const firstEmptySlot = player.equippedTechniques.indexOf(null);

        if (firstEmptySlot !== -1) {
            player.equippedTechniques[firstEmptySlot] = techId;
            openManageTechniquesModal(); // Refrescar el modal
        } else {
            showModal("Slots Llenos", "No tienes m√°s slots de t√©cnicas disponibles. Desequipa una para hacer espacio.");
            setTimeout(() => closeModal(), 2000);
        }
    }

    function unequipTechnique(slotIndex) {
        gameState.player.equippedTechniques[slotIndex] = null;
        openManageTechniquesModal(); // Refrescar el modal
    }  
    function sellToShop(itemName, quantityToSell, totalStonesEarned) {}

      function saveGame() {
        try {
          const gameStateToSave = JSON.parse(JSON.stringify(gameState));
          const gameDataJson = JSON.stringify(gameStateToSave, null, 2);
          const blob = new Blob([gameDataJson], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "camino_del_cultivador_save.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showModal("Partida Guardada", "Progreso guardado como archivo JSON.");
        } catch (error) {
          showModal("Error al Guardar", `Hubo un problema: ${error.message}`);
        }
      }

      function triggerFileUpload() {
        document.getElementById("fileInput").click();
      }

      // --- CARGA DE PARTIDA ---

      // Reemplaza tu funci√≥n 'loadGameFromFile(event)' existente con esta versi√≥n mejorada.

      function loadGameFromFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                if (gameState.player.isCultivating) stopCultivation();
                if (gameState.battle.active) endBattle(false);

                const loadedGameState = JSON.parse(e.target.result);

                if (!loadedGameState.player || !loadedGameState.map || !loadedGameState.inventory) {
                    throw new Error("Formato de guardado incorrecto o datos esenciales faltantes.");
                }

                // --- INICIO DE LA L√ìGICA DE COMPATIBILIDAD MEJORADA ---

                const loadedPlayer = loadedGameState.player;

                // 1. Saneamiento B√°sico de propiedades del jugador
                if (!loadedPlayer.abilityCooldowns) loadedPlayer.abilityCooldowns = {};
                if (!loadedPlayer.equippedTechniques) loadedPlayer.equippedTechniques = [null, null, null, null, null];

                // 2. Saneamiento profundo de las T√âCNICAS APRENDIDAS
                const techniquesToSanitize = loadedPlayer.learnedTechniques || {};
                const sanitizedTechniques = {}; 

                for (const techId in techniquesToSanitize) {
                    // Si la t√©cnica ya no existe en la versi√≥n actual del juego, la ignoramos.
                    if (techniqueData[techId]) {
                        const savedTechData = techniquesToSanitize[techId];
                        const masterTechData = techniqueData[techId];

                        // Creamos una nueva copia saneada de la t√©cnica del jugador.
                        const sanitizedPlayerTech = { ...savedTechData };
                        
                        // Aseguramos que las propiedades b√°sicas de cultivo existan
                        if (typeof sanitizedPlayerTech.level === 'undefined') sanitizedPlayerTech.level = 0;
                        if (typeof sanitizedPlayerTech.currentCultivationProgress === 'undefined') sanitizedPlayerTech.currentCultivationProgress = 0;
                        if (typeof sanitizedPlayerTech.cultivationTimeToNextLevel === 'undefined') {
                            sanitizedPlayerTech.cultivationTimeToNextLevel = masterTechData.cultivationSettings?.baseTimeToLevelUp || Infinity;
                        }

                        // ¬°Este es el paso clave! Comparamos con la definici√≥n maestra.
                        // Si en el futuro a√±ades m√°s propiedades a 'effect', esta l√≥gica las cubrir√°.
                        if (masterTechData.effect) {
                             // Si el objeto de efecto no existe en el guardado, lo creamos.
                            if (!sanitizedPlayerTech.effect) {
                                sanitizedPlayerTech.effect = {};
                            }
                            // Recorremos las propiedades del efecto maestro...
                            for (const effectProp in masterTechData.effect) {
                                // ...y si una propiedad no existe en el guardado, la a√±adimos.
                                if (typeof sanitizedPlayerTech.effect[effectProp] === 'undefined') {
                                    sanitizedPlayerTech.effect[effectProp] = masterTechData.effect[effectProp];
                                    console.warn(`Partida antigua: A√±adida propiedad faltante '${effectProp}' a la t√©cnica '${techId}'.`);
                                }
                            }
                        }
                        sanitizedTechniques[techId] = sanitizedPlayerTech;
                    } else {
                        console.warn(`T√©cnica obsoleta '${techId}' eliminada del guardado.`);
                    }
                }
                loadedPlayer.learnedTechniques = sanitizedTechniques;

                // 3. Asignamos los datos saneados al estado del juego
                gameState.player = loadedPlayer;
                gameState.inventory = JSON.parse(JSON.stringify(loadedGameState.inventory));
                gameState.map.entities = loadedGameState.map.entities ? JSON.parse(JSON.stringify(loadedGameState.map.entities)) : [];
                
                // --- FIN DE LA L√ìGICA DE COMPATIBILIDAD ---

                // Resetear estados transitorios
                gameState.player.isCultivating = false;
                if (gameState.cultivationInterval) {
                    clearInterval(gameState.cultivationInterval);
                    gameState.cultivationInterval = null;
                }

                // Reconstruir el juego con los datos actualizados
                generateMap(true);
                recalculatePlayerStats(); // Es crucial recalcular stats DESPU√âS de sanear los datos
                renderQuickSlotBar();
                updatePlayerPosition("loadGameFromFile_end");

                showModal("Partida Cargada", "¬°Partida restaurada con √©xito! (Se aplicaron actualizaciones de compatibilidad)");

            } catch (error) {
                showModal("Error al Cargar", `Hubo un problema: ${error.message}`);
                console.error("Error loading game:", error);
            } finally {
                event.target.value = null; // Permite cargar el mismo archivo de nuevo
            }
        };
        reader.onerror = () => {
            showModal("Error de Lectura", "No se pudo leer el archivo de guardado.");
            event.target.value = null;
        };
        reader.readAsText(file);
    }

      function renderQuickSlotBar() {
        const bar = document.getElementById("quickSlotBar");
        if (!bar) return;
        bar.innerHTML = "";

        // ---- INICIO DE LA L√ìGICA DE TAP vs LONG PRESS ----
        const LONG_PRESS_DURATION = 800; // 800 milisegundos para un toque largo

        gameState.player.quickSlots.forEach((itemName, index) => {
          const slot = document.createElement("div");
          slot.className = "quick-slot";

          let pressTimer = null; // Temporizador para el toque largo
          let isLongPress = false; // Bandera para saber si se activ√≥ el toque largo

          // Evento: cuando el usuario empieza a tocar/presionar
          const handlePressStart = (event) => {
            // Prevenir comportamiento por defecto si es t√°ctil (como el men√∫ contextual en algunos navegadores)
            if (event.type === "touchstart") {
              event.preventDefault();
            }
            isLongPress = false;
            pressTimer = setTimeout(() => {
              isLongPress = true;
              // Si el temporizador se completa, es un toque largo
              console.log(
                `Toque largo detectado en slot ${index + 1}. Abriendo modal.`
              );
              openItemAssignmentModal(index);
            }, LONG_PRESS_DURATION);
          };

          // Evento: cuando el usuario deja de tocar/presionar
          const handlePressEnd = (event) => {
            clearTimeout(pressTimer); // Cancelar el temporizador del toque largo
            // Si no fue un toque largo, entonces es un toque corto (tap/click)
            if (!isLongPress) {
              console.log(
                `Toque corto detectado en slot ${index + 1}. Usando √≠tem.`
              );
              useQuickSlotItem(index);
            }
          };

          // Evento: si el usuario mueve el dedo, cancelamos todo
          const handlePressCancel = (event) => {
            clearTimeout(pressTimer);
          };

          // Asignar los listeners
          slot.addEventListener("mousedown", handlePressStart);
          slot.addEventListener("touchstart", handlePressStart, {
            passive: false,
          });

          slot.addEventListener("mouseup", handlePressEnd);
          slot.addEventListener("mouseleave", handlePressCancel);
          slot.addEventListener("touchend", handlePressEnd);
          slot.addEventListener("touchcancel", handlePressCancel);
          slot.addEventListener("touchmove", handlePressCancel); // Cancelar si se desliza

          // ---- FIN DE LA L√ìGICA DE TAP vs LONG PRESS ----

          const keyHint = document.createElement("span");
          keyHint.className = "slot-key-hint";
          keyHint.textContent = index + 1;
          slot.appendChild(keyHint);

          if (itemName && itemData[itemName]) {
            const itemCount = gameState.inventory[itemName] || 0;
            slot.innerHTML += getItemIcon(itemName);
            const countDisplay = document.createElement("span");
            countDisplay.className = "slot-item-count";
            countDisplay.textContent = itemCount;
            slot.appendChild(countDisplay);

            if (itemCount === 0) {
              slot.style.opacity = 0.5;
              slot.title = `Slot ${
                index + 1
              }: ${itemName} (Agotado)\nToque largo para reasignar.`;
            } else {
              slot.title = `Slot ${
                index + 1
              }: ${itemName} (x${itemCount})\nToque para usar, toque largo para reasignar.`;
            }
          } else {
            slot.classList.add("empty");
            slot.title = `Slot ${index + 1} (Vac√≠o)\nToque para asignar.`;
            // Para los slots vac√≠os, no necesitamos la l√≥gica de toque largo, un simple clic es suficiente.
            // Sobrescribimos el `onclick` para que sea m√°s directo.
            slot.onclick = () => {
              clearTimeout(pressTimer); // Asegurarse de limpiar cualquier temporizador
              openItemAssignmentModal(index);
            };
          }
          bar.appendChild(slot);
        });

        // --- El resto de la funci√≥n para Cultivar y Conversi√≥n no cambia ---
        const cultivateSlot = document.createElement("div");
        cultivateSlot.className = "quick-slot cultivate-slot";
        cultivateSlot.title = "Cultivar (üßò)";
        cultivateSlot.innerHTML = "üßò";
        cultivateSlot.onclick = () => toggleCultivation();
        if (gameState.player.isCultivating) {
          cultivateSlot.classList.add("active-cultivation");
          cultivateSlot.title = "Ver/Detener Cultivo";
        }
        bar.appendChild(cultivateSlot);

        if (gameState.player.canUseQiConversion) {
          const conversionSlot = document.createElement("div");
          conversionSlot.className = "quick-slot conversion-slot";
          conversionSlot.innerHTML = "‚òØÔ∏è";
          conversionSlot.onclick = () => toggleQiConversion();
          if (
            gameState.player.isCultivating &&
            gameState.player.cultivationMode.isConversionCultivation
          ) {
            conversionSlot.classList.add("active-conversion");
            conversionSlot.title = "Conversi√≥n ACTIVA (clic para detener)";
          } else {
            conversionSlot.title = "Iniciar Conversi√≥n de Man√° a Vida";
          }
          bar.appendChild(conversionSlot);
        }
      }

      function unassignQuickSlot(slotIndex) {
        gameState.player.quickSlots[slotIndex] = null;
        closeModal();
        renderQuickSlotBar();
      }

      function useQuickSlotItem(slotIndex) {
        const itemName = gameState.player.quickSlots[slotIndex];
        if (!itemName) {
          console.log(`Slot ${slotIndex + 1} est√° vac√≠o.`);
          openItemAssignmentModal(slotIndex); // Correcto, permite asignar si est√° vac√≠o
          return;
        }

        const item = itemData[itemName];
        const itemCount = gameState.inventory[itemName] || 0;

        if (itemCount <= 0) {
          showModal("Agotado", `No te quedan m√°s ${itemName}.`);
          gameState.player.quickSlots[slotIndex] = null; // Limpiar el slot si se agot√≥
          renderQuickSlotBar(); // <-- Importante actualizar la UI
          return;
        }

        if (item && item.canUse && !item.canUse(gameState.player)) {
          showModal("No se puede usar", `No puedes usar ${itemName} ahora.`);
          return;
        }

        // Usar el objeto
        const message = item.effect
          ? item.effect(gameState.player, gainExperience)
          : `No se puede usar ${itemName}.`;

        if (
          message &&
          !message.toLowerCase().includes("error") &&
          !message.toLowerCase().includes("al m√°ximo")
        ) {
          gameState.inventory[itemName]--;
          showModal("Objeto Usado", message);
          updateUI();

          // Despu√©s de usar el √≠tem, verificamos si se agot√≥.
          const newCount = gameState.inventory[itemName] || 0;
          if (newCount <= 0) {
            // Si la cantidad es 0, vaciamos el slot.
            gameState.player.quickSlots[slotIndex] = null;
            console.log(
              `√çtem ${itemName} agotado. Vaciando slot ${slotIndex + 1}.`
            );
          }

          renderQuickSlotBar(); // Vuelve a renderizar la barra para actualizar la cantidad o mostrar el slot vac√≠o.
        } else {
          showModal("Acci√≥n no posible", message);
        }
      }

      function showHelp() {
        showModal(
          "Ayuda - Camino del Cultivador",
          "Explora y convi√©rtete en un cultivador poderoso.\n\n" +
            'üßò Cultiva (Bot√≥n "Cultivar") para mejorar HP/Man√°/EXP y tus T√©cnicas.\n' +
            "üìñ Aprende y Refina T√©cnicas para obtener nuevas habilidades y mejoras pasivas.\n" +
            "‚¨ÜÔ∏è Sube de Nivel para aumentar tus estad√≠sticas base.\n" + // Actualizado
            "üëπ Combate demonios y rivales.\n" +
            "üíé Recolecta recursos y tesoros.\n" +
            "üìú Busca o compra rollos de t√©cnicas para volverte m√°s fuerte\n\n" + // Eliminada menci√≥n al √°rbol de habilidades
            "Controles (Teclado):\n" +
            "  WASD/Flechas: Moverse\n" +
            "  ESPACIO: Interactuar\n\n" +
            "Controles (T√°ctil):\n" +
            "  Joystick: Moverse\n" +
            '  Bot√≥n "Acci√≥n": Interactuar'
        );
        updateStatsPanelVisibility();
      }
      //ACTUALIZAR BARRAS DEL JUGADOR
      function updatePlayerBarsOnMap() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerOnMapBarsContainer"
        );
        const hpFill = document.getElementById("playerOnMapHpFill");
        const manaFill = document.getElementById("playerOnMapManaFill");
        const playerElement = document.getElementById("player"); // El sprite del jugador

        if (!barsContainer || !hpFill || !manaFill || !playerElement) {
          // console.warn("Elementos de barras sobre el jugador no encontrados en el DOM.");
          return;
        }

        // Ocultar barras si el jugador est√° en batalla o si alg√∫n modal principal est√° abierto.
        if (gameState.battle.active || isAnyModalOpen()) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // La posici√≥n del playerElement (sprite) ya est√° calculada y centrada en updatePlayerPosition.
        // Usamos su 'top' y 'left' (que son relativos al map-container) como referencia.
        const playerVisualTop = parseFloat(playerElement.style.top) || 0;
        const playerVisualLeft = parseFloat(playerElement.style.left) || 0;
        const playerVisualWidth = playerElement.offsetWidth;

        // Posicionar las barras ligeramente encima del sprite del jugador.
        const barHeightWithGap = barsContainer.offsetHeight || 13; // Alto total aprox. de las 2 barras + gap
        barsContainer.style.top = `${playerVisualTop - barHeightWithGap - 5}px`; // 5px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // El 'transform: translateX(-50%)' en el CSS ayuda con esto si 'left' es el centro.
        barsContainer.style.left = `${
          playerVisualLeft + playerVisualWidth / 2
        }px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      function updatePlayerBarsInBattle() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        const hpFill = document.getElementById("playerInBattleSpriteHpFill");
        const manaFill = document.getElementById(
          "playerInBattleSpriteManaFill"
        );
        const playerSpriteInBattle = document.querySelector(
          ".battle-area .character .character-sprite"
        );

        if (!barsContainer || !hpFill || !manaFill || !playerSpriteInBattle) {
          // console.warn("Elementos de barras sobre el sprite del jugador en batalla no encontrados.");
          if (barsContainer) barsContainer.style.display = "none"; // Ocultar si faltan elementos
          return;
        }

        // Solo mostrar si la pantalla de batalla est√° activa
        if (
          !gameState.battle.active ||
          document.getElementById("battleScreen").style.display !== "flex"
        ) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // Posicionar las barras ligeramente encima del sprite del jugador en batalla.
        // El sprite (.character-sprite) es un div, necesitamos su offsetTop y offsetLeft
        // relativo a su padre (.character) que ahora es 'position: relative'.

        const spriteTop = playerSpriteInBattle.offsetTop; // Distancia desde el borde superior del .character
        const spriteLeft = playerSpriteInBattle.offsetLeft; // Distancia desde el borde izquierdo del .character
        const spriteWidth = playerSpriteInBattle.offsetWidth;

        const barHeightWithGap = barsContainer.offsetHeight || 12; // Alto total aprox. de las 2 barras + gap

        // El 'top' de las barras ser√° el 'top' del sprite menos la altura de las barras y un peque√±o margen.
        barsContainer.style.top = `${spriteTop - barHeightWithGap - 3}px`; // 3px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // 'left' ser√° el 'left' del sprite m√°s la mitad del ancho del sprite.
        // El 'transform: translateX(-50%)' en CSS centra el contenedor de barras.
        barsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      const joystickContainer = document.getElementById("joystick-container");
      const joystickPad = document.getElementById("joystick-pad");
      const joystickHandle = document.getElementById("joystick-handle");
      const actionButtonTouch = document.getElementById("action-button-touch");
      let joystickActive = false;
      let joystickCurrentDx = 0; // Guardar la direcci√≥n actual del joystick
      let joystickCurrentDy = 0;

      const JOYSTICK_THRESHOLD = 15;
      const JOYSTICK_GAME_MOVE_INTERVAL = 300;
      let joystickGameMoveTimerId = null;
      let lastJoystickMoveTime = 0;
      let joystickLoopId = null;
      let joystickTouchIdentifier = null; // <!-- CAMBIO JOYSTICK: Para seguir el dedo correcto -->

      function initJoystick() {
        if (
          !joystickContainer ||
          !joystickPad ||
          !joystickHandle ||
          !actionButtonTouch
        ) {
          console.error(
            "Error inicializando joystick: Elementos no encontrados."
          );
          return;
        }
        resetJoystickHandle();

        joystickPad.addEventListener(
          "touchstart",
          (event) => {
            if (
              gameState.player.isCultivating ||
              gameState.battle.active ||
              joystickActive
            )
              return;
            const touch = event.changedTouches[0];
            if (!touch) return;
            const padRect = joystickPad.getBoundingClientRect();
            if (
              touch.clientX < padRect.left ||
              touch.clientX > padRect.right ||
              touch.clientY < padRect.top ||
              touch.clientY > padRect.bottom
            ) {
              return;
            }
            event.preventDefault();
            joystickActive = true;
            joystickTouchIdentifier = touch.identifier;
            document.addEventListener("touchmove", handleJoystickMove, {
              passive: false,
            });
            document.addEventListener("touchend", handleJoystickEnd, {
              passive: false,
            });
            document.addEventListener("touchcancel", handleJoystickEnd, {
              passive: false,
            });

            // No iniciar el gameMoveTimer aqu√≠, la animaci√≥n la maneja handlePlayerMovementInput
            // updateJoystickHandlePosition y determinar direcci√≥n inicial
            updateJoystickHandlePosition(touch, true); // true para indicar que es el inicio
          },
          { passive: false }
        );

        actionButtonTouch.addEventListener("click", () => {
          if (!gameState.player.isCultivating && !gameState.battle.active) {
            interact();
          }
        });
      }
      function resetJoystickHandle() {
        if (joystickHandle)
          joystickHandle.style.transform = "translate(0px, 0px)";
        joystickCurrentDx = 0;
        joystickCurrentDy = 0;
      }
      // <!-- CAMBIO JOYSTICK: Modificaciones en los manejadores -->
      function handleJoystickStart(event) {
        if (
          gameState.player.isCultivating ||
          gameState.battle.active ||
          joystickActive
        )
          return;

        // Solo procesar el primer toque en el pad
        const touch = event.changedTouches[0];
        if (!touch) return;

        // Comprobar si el toque est√° realmente dentro del joystickPad (opcional, pero bueno para evitar activaciones accidentales)
        const padRect = joystickPad.getBoundingClientRect();
        if (
          touch.clientX < padRect.left ||
          touch.clientX > padRect.right ||
          touch.clientY < padRect.top ||
          touch.clientY > padRect.bottom
        ) {
          return;
        }

        event.preventDefault(); // Prevenir scroll/zoom si el toque es para el joystick

        joystickActive = true;
        joystickTouchIdentifier = touch.identifier; // Guardar el ID del dedo

        // A√±adir listeners de movimiento y fin al documento para seguir el dedo fuera del pad
        document.addEventListener("touchmove", handleJoystickMove, {
          passive: false,
        });
        document.addEventListener("touchend", handleJoystickEnd, {
          passive: false,
        });
        document.addEventListener("touchcancel", handleJoystickEnd, {
          passive: false,
        });

        // if (!joystickGameMoveTimerId) {
        //   joystickGameMoveTimerId = setInterval(
        //     processJoystickGameMove,
        //     JOYSTICK_GAME_MOVE_INTERVAL
        //   );
        // }
        updateJoystickHandlePosition(touch);
        // console.log("Joystick Start, ID:", joystickTouchIdentifier);
      }
      function handleJoystickMove(event) {
        if (!joystickActive) return;

        // Encontrar el toque correcto
        let touch = null;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touch = event.changedTouches[i];
            break;
          }
        }

        if (touch) {
          event.preventDefault(); // Prevenir scroll si el movimiento es del dedo del joystick
          updateJoystickHandlePosition(touch);
          // console.log("Joystick Move");
        }
      }

      function updateJoystickHandlePosition(touch) {
        const padRect = joystickPad.getBoundingClientRect();
        if (padRect.width === 0) return;

        const joystickCenterX = padRect.left + padRect.width / 2;
        const joystickCenterY = padRect.top + padRect.height / 2;

        const currentX = touch.clientX - joystickCenterX;
        const currentY = touch.clientY - joystickCenterY;

        const angle = Math.atan2(currentY, currentX);
        const maxDistance =
          joystickPad.offsetWidth / 2 - joystickHandle.offsetWidth / 2;
        if (maxDistance <= 0) return;

        const distance = Math.min(maxDistance, Math.hypot(currentX, currentY));
        const limitedX = distance * Math.cos(angle);
        const limitedY = distance * Math.sin(angle);
        if (joystickHandle) {
          joystickHandle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
        }

        // --- L√ìGICA DE CONTROL SIMPLIFICADA ---
        // Primero, reseteamos todas las direcciones del joystick.
        playerMovementKeysDown.up = false;
        playerMovementKeysDown.down = false;
        playerMovementKeysDown.left = false;
        playerMovementKeysDown.right = false;

        // Ahora, activamos la direcci√≥n correcta si el joystick est√° lo suficientemente inclinado.
        const magnitude = Math.hypot(currentX, currentY);
        if (magnitude > JOYSTICK_THRESHOLD) {
          if (Math.abs(currentX) > Math.abs(currentY)) {
            // Movimiento horizontal (izquierda o derecha)
            if (currentX > 0) {
              playerMovementKeysDown.right = true;
            } else {
              playerMovementKeysDown.left = true;
            }
          } else {
            // Movimiento vertical (arriba o abajo)
            if (currentY > 0) {
              playerMovementKeysDown.down = true;
            } else {
              playerMovementKeysDown.up = true;
            }
          }
        }
      }

      function handleJoystickEnd(event) {
        if (!joystickActive) return;

        let touchEndedIsOurs = false;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touchEndedIsOurs = true;
            break;
          }
        }

        if (touchEndedIsOurs) {
          joystickActive = false;
          joystickTouchIdentifier = null;
          resetJoystickHandle();

          // --- LIMPIEZA DE BANDERAS ---
          // Al soltar el joystick, nos aseguramos de que ninguna tecla de movimiento quede "presionada"
          playerMovementKeysDown.up = false;
          playerMovementKeysDown.down = false;
          playerMovementKeysDown.left = false;
          playerMovementKeysDown.right = false;

          document.removeEventListener("touchmove", handleJoystickMove);
          document.removeEventListener("touchend", handleJoystickEnd);
          document.removeEventListener("touchcancel", handleJoystickEnd);
        }
      }
      // processJoystickGameMove se mantiene igual
      // <!-- FIN CAMBIO JOYSTICK -->
      function processJoystickGameMove() {
        // Esta funci√≥n se llama cada JOYSTICK_GAME_MOVE_INTERVAL
        if (
          joystickActive &&
          (joystickCurrentDx !== 0 || joystickCurrentDy !== 0)
        ) {
          // console.log(`[processJoystickGameMove] Effective move: dx=${joystickCurrentDx}, dy=${joystickCurrentDy}. Calling movePlayer.`);
          movePlayer(joystickCurrentDx, joystickCurrentDy);
        }
      }
      function joystickLoop() {
        if (!joystickActive) {
          joystickLoopId = null;
          return;
        }
        const now = Date.now();
        if (now - lastJoystickMoveTime > JOYSTICK_MOVE_INTERVAL) {
          let dx = 0,
            dy = 0;
          const magnitude = Math.hypot(joystickCurrentX, joystickCurrentY);
          if (magnitude > JOYSTICK_THRESHOLD) {
            if (Math.abs(joystickCurrentX) > Math.abs(joystickCurrentY)) {
              dx = joystickCurrentX > 0 ? 1 : -1;
            } else {
              dy = joystickCurrentY > 0 ? 1 : -1;
            }
          }
          if (dx !== 0 || dy !== 0) {
            movePlayer(dx, dy);
            lastJoystickMoveTime = now;
          }
        }
        joystickLoopId = requestAnimationFrame(joystickLoop);
      }
      // --- NUEVAS FUNCIONES PARA LOS MODALES DE INVENTARIO Y PERSONAJE (EJEMPLOS) ---

      // Modal para Inventario Detallado (si decides usar un modal en lugar del sidebar)
      function openInventoryModal() {
        let inventoryContent = `
              <h2 style="text-align: center; margin-bottom: 20px;">Inventario</h2>
              <div id="inventory-modal-list" style="text-align: left;">
          `;

        // Filtrar para mostrar solo los √≠tems que el jugador posee
        const itemsToShow = Object.entries(gameState.inventory).filter(
          ([itemName, count]) => count > 0
        );

        if (itemsToShow.length === 0) {
          inventoryContent +=
            "<p style='text-align: center; opacity: 0.7;'>No tienes ning√∫n objeto.</p>";
        } else {
          itemsToShow.forEach(([itemName, count]) => {
            const itemInfo = itemData[itemName] || {};
            const canBeUsed = itemInfo.canUse
              ? itemInfo.canUse(gameState.player)
              : false;

            inventoryContent += `
                      <div class="inventory-modal-item">
                          <div class="item-details">
                              <div class="item-name">${getItemIcon(
                                itemName,
                                ""
                              )} ${itemName} (x${count})</div>
                              <div class="item-description">${
                                itemInfo.description || "Un objeto misterioso."
                              }</div>
                          </div>
                          <div class="item-actions">
                              ${
                                itemInfo.effect
                                  ? `<button class="use-item-btn" data-itemname="${itemName}" ${
                                      canBeUsed ? "" : "disabled"
                                    } title="${
                                      canBeUsed
                                        ? "Usar objeto"
                                        : "No se puede usar ahora"
                                    }">Usar</button>`
                                  : ""
                              }

                          </div>
                      </div>
                  `;
          });
        }

        inventoryContent += "</div>";

        // Usamos el modal gen√©rico para mostrar el contenido
        showModal("Detalles del Inventario", inventoryContent);
        // Ocultamos el t√≠tulo por defecto del modal gen√©rico, ya que hemos puesto el nuestro.
        document.getElementById("modalTitle").style.display = "none";

        // A√ëADIMOS LOS LISTENERS DESPU√âS DE QUE EL MODAL ES VISIBLE
        document.querySelectorAll(".use-item-btn").forEach((button) => {
          button.addEventListener("click", function () {
            const itemName = this.dataset.itemname;
            // Usamos la funci√≥n de uso de √≠tem, que ya da feedback y actualiza la UI
            useItem(itemName);
            // Cerramos y reabrimos el modal para reflejar los cambios (ej. item gastado)
            closeModal();
            openInventoryModal();
          });
        });

        document.querySelectorAll(".assign-slot-btn").forEach((button) => {
          button.addEventListener("click", function () {
            const itemName = this.dataset.itemname;
            assignItemToQuickSlot(itemName);
          });
        });
        updateStatsPanelVisibility();
      }

      function openItemAssignmentModal(slotIndex) {
        let assignmentContent = `
              <h2 style="text-align: center; margin-bottom: 20px;">Asignar al Slot ${
                slotIndex + 1
              }</h2>
              <p style="text-align: center; opacity: 0.8; margin-bottom: 15px;">Selecciona un objeto consumible para este acceso r√°pido.</p>
              <div id="assignment-modal-list" style="text-align: left;">
          `;

        // Filtrar para mostrar solo los √≠tems consumibles que el jugador posee
        const assignableItems = Object.entries(gameState.inventory).filter(
          ([itemName, count]) => {
            const itemInfo = itemData[itemName];
            return count > 0 && itemInfo && itemInfo.canUse; // 'canUse' es nuestro indicador de consumible
          }
        );

        if (assignableItems.length === 0) {
          assignmentContent +=
            "<p style='text-align: center; opacity: 0.7;'>No tienes objetos consumibles para asignar.</p>";
        } else {
          assignableItems.forEach(([itemName, count]) => {
            const itemInfo = itemData[itemName];
            assignmentContent += `
                      <div class="inventory-modal-item assignable-item" data-itemname="${itemName}">
                          <div class="item-details">
                              <div class="item-name">${getItemIcon(
                                itemName,
                                ""
                              )} ${itemName} (x${count})</div>
                              <div class="item-description">${
                                itemInfo.description
                              }</div>
                          </div>
                      </div>
                  `;
          });
        }

        // --- A√ëADIMOS EL BOT√ìN DE DESASIGNAR ---
        assignmentContent += `</div><button onclick="unassignQuickSlot(${slotIndex})" style="margin-top:20px; background-color: #883333;">Quitar Objeto del Slot</button>`;

        // Mostramos el modal
        showModal("Asignar Objeto", assignmentContent);
        document.getElementById("modalTitle").style.display = "none";

        // A√±adimos listeners a los √≠tems clicables
        document.querySelectorAll(".assignable-item").forEach((itemDiv) => {
          itemDiv.addEventListener("click", function () {
            const itemName = this.dataset.itemname;
            // Asignar el √≠tem al slot correspondiente
            gameState.player.quickSlots[slotIndex] = itemName;
            // Cerrar el modal y actualizar la barra
            closeModal();
            renderQuickSlotBar();
          });
        });
        updateStatsPanelVisibility();
      }
      function unassignQuickSlot(slotIndex) {
        gameState.player.quickSlots[slotIndex] = null;
        closeModal();
        renderQuickSlotBar();
      }

      // Modal para Personaje (Stats, Equipo, etc.)
      function openCharacterModal() {
        const player = gameState.player;
        let characterContent = `
                  <h2>${player.realm} - Nivel ${player.level}</h2>
                  <div style="text-align: left; margin-top: 15px;">
                  <p><strong>Vida:</strong> ${Math.floor(player.hp)} / ${
          player.maxHp
        }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill hp-fill" style="width: ${
                    (player.hp / player.maxHp) * 100
                  }%;"></div></div>
                  <p><strong>Man√°:</strong> ${Math.floor(player.mana)} / ${
          player.maxMana
        }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill mana-fill" style="width: ${
                    (player.mana / player.maxMana) * 100
                  }%;"></div></div>
                  <p><strong>Experiencia:</strong> ${Math.floor(
                    player.exp
                  )} / ${player.expToNext}</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill exp-fill" style="width: ${
                    (player.exp / player.expToNext) * 100
                  }%;"></div></div>
                  <hr style="margin: 15px 0;">
                  <p><strong>Ataque:</strong> ${player.attack}</p>
                  <p><strong>Defensa:</strong> ${player.defense}</p>
                  <p><strong>Piedras Espirituales:</strong> ${
                    gameState.inventory["Piedras Espirituales"] || 0
                  }</p>
                  <hr style="margin: 15px 0;">
                  <h4>Secta: ${player.secta.nombre}</h4>
                  <p><strong>Rango:</strong> ${player.secta.rango}</p>
                  <p><strong>Puntos de Contribuci√≥n:</strong> ${
                    player.secta.puntosContribucion
                  } PCS</p>
                  </div>
                  `;
        // Aqu√≠ podr√≠as a√±adir una secci√≥n para el equipo si lo implementas.
        showModal("Detalles del Personaje", characterContent);
        updateStatsPanelVisibility();
      }

      // Placeholder para un futuro modal de men√∫ principal
      function openMainMenuModal() {
        let menuContent = `
                  <h2>Men√∫ Principal</h2>
                  <button class="cultivation-option-btn" onclick="saveGame(); closeModal();">üíæ Guardar Partida</button>
                  <button class="cultivation-option-btn" onclick="triggerFileUpload(); closeModal();">üìÅ Cargar Partida</button>
                  <button id="fullscreenBtn" class="cultivation-option-btn" onclick="toggleFullscreen()">
                      <span id="fullscreenIcon">‚õ∂</span> Pantalla Completa
                  </button>
                  <button class="cultivation-option-btn" onclick="showHelp();">‚ùì Ayuda</button>
                  <button class="cultivation-option-btn" onclick="closeModal();">‚Ü©Ô∏è Volver al Juego</button>
              `;
        // Usamos el showModal gen√©rico pero sin el bot√≥n de cierre por defecto, ya que "Volver al Juego" hace esa funci√≥n.
        // Para ello, tu showModal necesitar√≠a una forma de ocultar su propio bot√≥n de cierre.
        // Si showModal no lo permite, necesitar√≠as un modal espec√≠fico para el men√∫.
        // Por ahora, asumir√© que el showModal gen√©rico tiene un bot√≥n de cierre que se ocultar√°
        // o que el usuario usar√° el bot√≥n "Volver al Juego".

        // Modificamos el modal gen√©rico para que no muestre su propio bot√≥n "Cerrar" si se lo indicamos
        const modalElement = document.getElementById("interactionModal");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalTextEl = document.getElementById("modalText");
        const closeButton = modalElement.querySelector(
          "button.close-modal-btn"
        );

        modalTitleEl.textContent = "Men√∫ Principal"; // El H2 ya est√° en menuContent
        modalTextEl.innerHTML = menuContent.replace(
          "<h2>Men√∫ Principal</h2>",
          ""
        ); // Quitar el H2 duplicado
        if (closeButton) closeButton.style.display = "none"; // Ocultar el bot√≥n de cierre por defecto del modal

        modalElement.style.display = "flex";
        hideTouchControls();
        updateTopNavVisibility();
        updateStatsPanelVisibility();
      }

      function toggleFullscreen() {
          if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
              openFullscreen();
          } else {
              closeFullscreen();
          }
      }
      function openFullscreen() {
          const elem = document.documentElement; // Queremos que todo el documento sea pantalla completa
          if (elem.requestFullscreen) {
              elem.requestFullscreen();
          } else if (elem.mozRequestFullScreen) { /* Firefox */
              elem.mozRequestFullScreen();
          } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
              elem.webkitRequestFullscreen();
          } else if (elem.msRequestFullscreen) { /* IE/Edge */
              elem.msRequestFullscreen();
          }
          updateFullscreenButton();
      }
      function closeFullscreen() {
          if (document.exitFullscreen) {
              document.exitFullscreen();
          } else if (document.mozCancelFullScreen) { /* Firefox */
              document.mozCancelFullScreen();
          } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
              document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) { /* IE/Edge */
              document.msExitFullscreen();
          }
          updateFullscreenButton();
      }
      function updateFullscreenButton() {
          const fullscreenBtn = document.getElementById('fullscreenBtn');
          const fullscreenIcon = document.getElementById('fullscreenIcon');
          if (!fullscreenBtn || !fullscreenIcon) return; // Salida temprana si el modal no est√° abierto

          // Comprobamos si alg√∫n navegador est√° en modo de pantalla completa
          if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
              fullscreenBtn.innerHTML = '<span id="fullscreenIcon"> keluar </span> Salir de Pantalla Completa';
          } else {
              fullscreenBtn.innerHTML = '<span id="fullscreenIcon">‚õ∂</span> Pantalla Completa';
          }
      }

      function openSectHallInterface() {
        const player = gameState.player;
        const sectData = SECTA_DATA;

        document.getElementById(
          "sectHallModalTitle"
        ).textContent = `Sal√≥n ${player.secta.nombre}`;
        document.getElementById("sectHallPlayerRank").textContent =
          player.secta.rango;
        document.getElementById("sectHallPlayerPCS").textContent =
          player.secta.puntosContribucion;

        const availableMissionsDiv = document.getElementById(
          "sectHallAvailableMissions"
        );
        availableMissionsDiv.innerHTML =
          "<p>Habla con Gu√≠a Lin o Admin Yao para asignaciones generales.</p>";

        const rankChallengesDiv = document.getElementById(
          "sectHallRankChallenges"
        );
        rankChallengesDiv.innerHTML = "";

        const currentRankIndex = sectData.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );
        let challengeButtonAdded = false;

        if (
          currentRankIndex !== -1 &&
          currentRankIndex + 1 < sectData.rangos.length
        ) {
          const nextRankData = sectData.rangos[currentRankIndex + 1];
          const challengeButton = document.createElement("button");
          challengeButton.textContent = `Consultar Desaf√≠o para ${nextRankData.nombre}`;
          challengeButton.className = "cultivation-option-btn";
          challengeButton.style.marginBottom = "10px";

          // --- INICIO DE LA CORRECCI√ìN CLAVE ---
          challengeButton.onclick = () => {
            // 1. Cerramos el modal actual del Sal√≥n de la Secta.
            closeSectHallModal();

            // 2. Preparamos y mostramos el NUEVO modal con la informaci√≥n del desaf√≠o.
            // (La l√≥gica interna para generar el mensaje no cambia)
            const pcsNecesarios = nextRankData.pcsRequeridos;
            const tieneSuficientesPCS =
              player.secta.puntosContribucion >= pcsNecesarios;
            const rivalIdParaDesafio = nextRankData.desafioRivalId;
            let mensajeDesafio = `<strong>Desaf√≠o para ascender a ${nextRankData.nombre}:</strong><br>`;
            let misionDesafioActiva = null;
            let misionDesafioDataObj = null;
            let idDeLaMisionAsociada = null;

            if (rivalIdParaDesafio) {
              const misionEntry = Object.entries(MISIONES_DATA).find(
                ([mKey, mVal]) =>
                  mVal.autoActivarAlCumplirRequisitos === true &&
                  mVal.recompensa?.nuevoRango === nextRankData.nombre &&
                  mVal.objetivo?.npcId === rivalIdParaDesafio
              );

              if (misionEntry) {
                idDeLaMisionAsociada = misionEntry[0];
                misionDesafioDataObj = misionEntry[1];
                misionDesafioActiva = player.secta.misionesActivas.find(
                  (m) => m.id === idDeLaMisionAsociada
                );
                mensajeDesafio += `<em>"${misionDesafioDataObj.descripcion}"</em><br>`;
                mensajeDesafio += `Oponente: <strong>${
                  entityTypes[rivalIdParaDesafio]?.name ||
                  "Guardi√°n Desconocido"
                }</strong>.<br>`;
                mensajeDesafio += `Recompensas: ${
                  misionDesafioDataObj.recompensa.pcs || 0
                } PCS, ${misionDesafioDataObj.recompensa.exp || 0} EXP, Rango ${
                  nextRankData.nombre
                }.<br><hr>`;
              }
            } else {
              mensajeDesafio += `Este rango no parece requerir un desaf√≠o de combate.<br><hr>`;
            }

            mensajeDesafio += `<strong>Requisitos Actuales:</strong><br>`;
            mensajeDesafio += `Puntos de Contribuci√≥n (PCS): ${player.secta.puntosContribucion} / ${pcsNecesarios} PCS. `;
            mensajeDesafio += tieneSuficientesPCS
              ? "<span style='color: #66ff66;'>(Cumplido)</span><br>"
              : `<span style='color: #ffcc66;'>(Faltan ${
                  pcsNecesarios - player.secta.puntosContribucion
                } PCS)</span><br>`;

            if (misionDesafioActiva) {
              mensajeDesafio +=
                "<br><strong style='color: #66ff66;'>¬°El desaf√≠o est√° ACTIVO!</strong> Dir√≠gete a la arena.";
            } else if (
              idDeLaMisionAsociada &&
              player.secta.misionesCompletadas[idDeLaMisionAsociada]
            ) {
              mensajeDesafio +=
                "<br><strong style='color: #aaa;'>Ya has completado este desaf√≠o.</strong>";
            } else if (
              tieneSuficientesPCS &&
              rivalIdParaDesafio &&
              misionDesafioDataObj &&
              idDeLaMisionAsociada
            ) {
              mensajeDesafio += `<br><button id="activar-desafio-btn-specific">Activar Misi√≥n de Desaf√≠o Ahora</button>`;
              // Guardamos la informaci√≥n necesaria para el listener del bot√≥n
              window.tempChallengeActivationInfo = {
                misionId: idDeLaMisionAsociada,
                nextRankName: nextRankData.nombre,
              };
            } else if (!tieneSuficientesPCS) {
              mensajeDesafio +=
                "<br>A√∫n no cumples los requisitos de PCS para activar este desaf√≠o.";
            }

            // 3. Mostramos el modal de informaci√≥n. `showModal` se encargar√° de gestionar el velo y los stats.
            showModal("Informaci√≥n del Desaf√≠o de Rango", mensajeDesafio);

            // 4. Asignamos el listener al bot√≥n de activar, si existe.
            if (
              window.tempChallengeActivationInfo &&
              document.getElementById("activar-desafio-btn-specific")
            ) {
              document.getElementById("activar-desafio-btn-specific").onclick =
                () => {
                  const info = window.tempChallengeActivationInfo;
                  acceptMission(info.misionId);
                  closeModal(); // Cierra el modal de informaci√≥n del desaf√≠o
                  showModal(
                    "¬°Desaf√≠o Aceptado!",
                    "La misi√≥n de desaf√≠o ha sido a√±adida a tu diario. ¬°Ve a la arena!"
                  );
                  ensureFixedEntities();
                  renderMap();
                  delete window.tempChallengeActivationInfo;
                };
            }
          };
          // --- FIN DE LA CORRECCI√ìN CLAVE ---

          rankChallengesDiv.appendChild(challengeButton);
          challengeButtonAdded = true;
        }

        if (!challengeButtonAdded) {
          if (currentRankIndex === -1) {
            rankChallengesDiv.innerHTML =
              "<p>Error al determinar tu rango actual.</p>";
          } else {
            rankChallengesDiv.innerHTML =
              "<p>¬°Has alcanzado el rango m√°s alto o no hay m√°s desaf√≠os definidos!</p>";
          }
        }

        document.getElementById("sectHallModal").style.display = "flex";
        hideTouchControls();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function acceptMissionFromSectHall(misionId) {
        acceptMission(misionId);
        if (document.getElementById("sectHallModal").style.display === "flex") {
          openSectHallInterface();
        }
      }
      function closeSectHallModal() {
        document.getElementById("sectHallModal").style.display = "none";
        showTouchControls();
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }
      function openSectShop() {
        showModal("Tienda de Secta", "El Dep√≥sito a√∫n est√° siendo abastecido.");
      }
      // Variable global para almacenar la acci√≥n a confirmar
      let onConfirmAction = null;

      function getPlayerCurrentZone() {
        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        
        for (const zone of gameState.map.terrainZones) {
          if (
            playerX >= zone.x1 &&
            playerX <= zone.x2 &&
            playerY >= zone.y1 &&
            playerY <= zone.y2
          ) {
            // console.log(`[getPlayerCurrentZone] ==> Encontrado en zona: "${zone.name}"`); // Descomenta si necesitas depurar esta funci√≥n espec√≠ficamente
            return zone;
          }
        }
        // console.log(`[getPlayerCurrentZone] ==> No se encontr√≥ en ninguna zona definida. Retornando null.`); // Descomenta si necesitas depurar esta funci√≥n espec√≠ficamente
        return null;
      }

      function showConfirmationModal(title, text, onConfirm) {
        document.getElementById("confirmationModalTitle").textContent = title;
        document.getElementById("confirmationModalText").innerHTML = text;

        onConfirmAction = onConfirm; // Guardamos la funci√≥n que se ejecutar√° si se confirma

        const confirmButton = document.getElementById("confirmBtn");
        // Usamos .onclick para reemplazar cualquier listener anterior
        confirmButton.onclick = () => {
          if (typeof onConfirmAction === "function") {
            onConfirmAction();
          }
          closeConfirmationModal();
        };

        document.getElementById("confirmationModal").style.display = "flex";
        hideTouchControls();
      }

      function closeConfirmationModal() {
        document.getElementById("confirmationModal").style.display = "none";
        onConfirmAction = null; // Limpiamos la acci√≥n
        showTouchControls();
        updateStatsPanelVisibility();
      }
      // --- INICIALIZACI√ìN ---
      document.addEventListener("DOMContentLoaded", () => {
        const mobileMenuButton = document.getElementById("mobileMenuBtn");
        const topNavBar = document.getElementById("topNavBar"); // Ya deber√≠as tener esta variable
        if (mobileMenuButton && topNavBar) {
          mobileMenuButton.addEventListener("click", (e) => {
            e.stopPropagation(); // Evita que otros clicks se disparen
            topNavBar.classList.toggle("open");
          });
        }

        // A√±adir un listener para cerrar el men√∫ si se hace clic fuera de √©l
        document.addEventListener("click", (e) => {
          if (
            topNavBar.classList.contains("open") &&
            !topNavBar.contains(e.target)
          ) {
            topNavBar.classList.remove("open");
          }
        });
        renderQuickSlotBar();
        const navBtnMissions = document.getElementById("navBtnMissions");
        if (navBtnMissions) {
          navBtnMissions.addEventListener("click", openMissionsModal);
        }
        const navBtnInventory = document.getElementById("navBtnInventory");
        console.log(
          "Dentro de DOMContentLoaded, navBtnInventory:",
          navBtnInventory
        );
        if (navBtnInventory) {
          navBtnInventory.addEventListener("click", () => {
            openInventoryModal(); // Llama a nuestra nueva y mejorada funci√≥n
            if (isMobileView() && topNavBar.classList.contains("open")) {
              topNavBar.classList.remove("open");
            }
          });
        }

        if (navBtnCharacter) {
          navBtnCharacter.addEventListener("click", () => {
            // Necesitas una funci√≥n para abrir un MODAL de personaje
            openCharacterModal(); // Tendr√≠as que crear esta funci√≥n y el modal
          });
        }

        if (navBtnCultivate) {
          navBtnCultivate.addEventListener("click", () => {
            toggleCultivation(); // Tu funci√≥n existente para iniciar/detener cultivo
          });
        }

        if (navBtnTechniques) {
          navBtnTechniques.addEventListener("click", () => {
            showTechniquePanel(); // Tu funci√≥n existente para mostrar el modal de t√©cnicas
          });
        }

        if (navBtnMenu) {
          navBtnMenu.addEventListener("click", () => {
            // Siempre abre el modal del men√∫ principal.
            openMainMenuModal();

            // Adicional: En m√≥vil, cierra el men√∫ desplegable despu√©s de hacer clic.
            if (isMobileView() && topNavBar.classList.contains("open")) {
              topNavBar.classList.remove("open");
            }
          });
        }

        // Llamada inicial para asegurar el estado correcto de la barra
        updateTopNavVisibility();

        // --- INICIO DEL REEMPLAZO DE EVENT LISTENERS ---
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        document.addEventListener("keydown", (e) => {
          if (
            isAnyModalOpen() ||
            gameState.battle.active ||
            gameState.player.isCultivating
          ) {
            Object.keys(playerMovementKeysDown).forEach(
              (k) => (playerMovementKeysDown[k] = false)
            );
            return;
          }
          // --- INICIO DE LA MODIFICACI√ìN PARA ACCESO R√ÅPIDO ---
          if (e.code.startsWith("Digit")) {
            const slotIndex = parseInt(e.code.replace("Digit", ""), 10) - 1;
            if (slotIndex >= 0 && slotIndex < 5) {
              e.preventDefault();
              useQuickSlotItem(slotIndex);
              return; // Importante para que no procese el movimiento
            }
          }
          // --- FIN DE LA MODIFICACI√ìN ---
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
            case "Space":
              e.preventDefault();
              interact();
              return;
          }

          if (direction) {
            e.preventDefault();
            playerMovementKeysDown[direction] = true;
          }
        });

        document.addEventListener("keyup", (e) => {
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
          }

          if (direction) {
            e.preventDefault();
            playerMovementKeysDown[direction] = false;
          }
        });

        // Helper para convertir direcci√≥n a dx/dy para movePlayer
        function dxFromDirection(direction) {
          if (direction === "left") return -1;
          if (direction === "right") return 1;
          return 0;
        }

        function dyFromDirection(direction) {
          if (direction === "up") return -1;
          if (direction === "down") return 1;
          return 0;
        }

        const fileInput = document.getElementById("fileInput");
        if (fileInput) fileInput.addEventListener("change", loadGameFromFile);

        const toggleControlsBtn = document.getElementById(
          "toggleMapControlsBtn"
        );
        if (toggleControlsBtn)
          toggleControlsBtn.addEventListener(
            "click",
            toggleMapControlsVisibility
          );

        // Listener para redimensionar y recalcular el tama√±o de los tiles
        window.addEventListener("resize", () => {
          calculateAndSetTileSize();
          renderMap(); // Vuelve a dibujar con el nuevo tama√±o
          updatePlayerPosition(); // Asegura que el jugador est√© bien posicionado
        });

        // Iniciar el bucle de actualizaci√≥n del juego
        setInterval(gameTickUpdater, 1000); // Llama cada segundo, ajusta seg√∫n necesidad
        initJoystick();
        setInterval(gameLoop, 100);
        calculateAndSetTileSize();
        // generateMap() ahora es m√°s simple, isRespawn = false para carga inicial completa
        gameState.lastGameTimeUpdate = Date.now(); // Inicializar antes del primer tick

        generateMap(true); // Usar true para la generaci√≥n inicial completa, incluyendo decorativos

        recalculatePlayerStats();
        updatePlayerVisualSize(); // Asegura el tama√±o correcto del div del jugador
        updatePlayerSpriteVisual(); // Establece el sprite inicial
        updatePlayerPosition("DOMContentLoaded_init"); // Llama despu√©s de sprite visual

        updatePlayerSpriteVisual(); // Llamar una vez para establecer el sprite inicial

        showTouchControls();
        const initialZone = getPlayerCurrentZone();
        gameState.player.currentZoneName = initialZone
          ? initialZone.name
          : "Tierras Salvajes";

        showModal(
          "Despertar del Cultivador",
          "Has despertado en un mundo de cultivadores buscando poder supremo. " +
            "Te encuentras cerca de la <strong>Secta del Viento Azure</strong>. Quiz√°s all√≠ encuentres tu camino.\n\n" +
            "<strong>Objetivo:</strong> Asciende en la secta, domina t√©cnicas, derrota enemigos y desvela secretos.\n\n" +
            "Busca al <strong>Gu√≠a Lin</strong> en la secta (‚õ©Ô∏è) para comenzar.\n\n" +
            'Usa Controles (Teclado/T√°ctil) para moverte e interactuar. Presiona "?" para ayuda.'
        );
        document
          .querySelectorAll("#shopCategories .category-item")
          .forEach((item) => {
            item.addEventListener("click", function () {
              document
                .querySelectorAll("#shopCategories .category-item")
                .forEach((i) => i.classList.remove("active"));
              this.classList.add("active");
              currentShopPage = 1;
              renderShopProducts();
            });
          });
        document.getElementById("shopSearch").addEventListener("input", () => {
          currentShopPage = 1;
          renderShopProducts();
        });
        document.getElementById("priceRange").addEventListener("input", (e) => {
          document.getElementById(
            "priceRangeValue"
          ).textContent = `${e.target.value} PS`;
          currentShopPage = 1;
          renderShopProducts();
        });
      });
    </script>
    <!-- BARRA DE ACCESO R√ÅPIDO INFERIOR -->
    <div class="quick-slot-bar" id="quickSlotBar">
      <!-- Los slots se generar√°n con JavaScript -->
    </div>
  </body>
</html>
