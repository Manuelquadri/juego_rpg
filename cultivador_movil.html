<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Camino del Cultivador</title>
    <style>
   /****************************************
       * 1. ESTILOS GENERALES Y LAYOUT
       ****************************************/
       * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", monospace;
        background: linear-gradient(135deg, #2c1810, #8b4513);
        color: #f4e4bc;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Evita el scroll indeseado */
      }

      .game-container {
        display: flex;
        flex-grow: 1;
        /* El padding-top crea el espacio para la barra de navegación superior */
        padding-top: 55px; /* Ajusta este valor si cambia la altura de la barra */
      }

      .sidebar {
        display: none; /* La barra lateral ya no se usa, se oculta permanentemente */
      }
      
      button {
        background: linear-gradient(135deg, #d4af37, #b8941f);
        color: #2c1810;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      button:hover {
        background: linear-gradient(135deg, #f4d03f, #d4af37);
        transform: translateY(-2px);
      }

      button:disabled {
        background: #666;
        color: #999;
        cursor: not-allowed;
        transform: none;
      }
      /* Esta regla se aplicará a TODAS las barras de estadísticas del juego */
      .stat-bar {
          width: 100%;
          height: 18px; /* Una altura estándar y visible. Puedes ajustarla. */
          background-color: rgba(0, 0, 0, 0.4);
          border-radius: 9px;
          overflow: hidden; /* Asegura que el relleno no se salga */
          border: 1px solid rgba(212, 175, 55, 0.2);
          margin: 8px 0; /* Un poco de espacio vertical para que no se pegue a otros elementos */
      }

      /* El relleno de la barra */
      .stat-fill {
          height: 100%; /* Ahora esto funcionará, porque el padre (.stat-bar) tiene una altura fija */
          transition: width 0.3s linear;
      }
      /****************************************
       * 2. INTERFAZ PRINCIPAL (HUD, BARRAS, BOTONES)
       ****************************************/
      
      /* --- Barra de Navegación Superior --- */
      .top-nav-bar {
        position: fixed;
        top: 0; 
        left: 0;
        width: 100%;
        height: 55px; /* Altura fija para el cálculo de padding */
        background: linear-gradient(180deg, #2c1810, #1a1a1a);
        border-bottom: 2px solid #d4af37;
        display: flex;
        justify-content: space-around;
        align-items: center;
        z-index: 250;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease-in-out;
        transform: translateY(0);
      }

      .top-nav-bar.hidden {
        transform: translateY(-100%); 
      }
      
      .nav-button {
        position: relative;
        background: transparent;
        border: none;
        color: #f4e4bc;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 8px 5px;
        cursor: pointer;
        font-family: "Courier New", monospace;
        font-size: 0.75rem;
        flex-grow: 1;
        max-width: 20%;
        transition: background-color 0.2s, color 0.2s;
      }

      .nav-button:hover,
      .nav-button.active {
        background-color: rgba(212, 175, 55, 0.15);
        color: #f4d03f;
      }

      .nav-icon {
        font-size: 1.5rem;
        margin-bottom: 3px;
      }
      
      /* --- HUD de Stats del Jugador (Esquina superior izquierda) --- */
      .stats-panel {
        position: fixed; /* FIJO en la ventana, no relativo al mapa */
        top: 70px; /* 55px de la barra + 15px de margen */
        left: 15px;
        z-index: 100;
        width: 180px;
        background: rgba(26, 26, 26, 0.75);
        backdrop-filter: blur(4px);
        border: 2px solid #d4af37;
        border-radius: 8px;
        padding: 10px;
        margin: 0;
      }

      .stats-panel .stat-bar {
        width: 100%;
        height: 12px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 7px;
        margin-top: 3px;
        margin-bottom: 8px;
        overflow: hidden;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }
      
      .stat-fill {
        height: 100%;
        transition: width 0.3s;
      }
      .stats-panel .stat-line, 
      .stats-panel .stat-block {
        margin-bottom: 8px; /* Espaciado consistente */
      }

      .stats-panel .stat-stones {
          color: #f4d03f; /* Destacar las piedras espirituales */
          font-weight: bold;
          margin-top: 4px;
      }
      
      .stats-panel .stat-block span {
          display: block; /* Asegura que el texto esté en su propia línea */
          font-size: 0.9em;
          margin-bottom: 2px;
      }
      .hp-fill { background: linear-gradient(90deg, #ff4444, #ff6666); }
      .mana-fill { background: linear-gradient(90deg, #4444ff, #6666ff); }
      .exp-fill { background: linear-gradient(90deg, #44ff44, #66ff66); }

      /* --- Barra de Acceso Rápido Inferior --- */
      .quick-slot-bar {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        padding: 8px;
        background: rgba(26, 26, 26, 0.8);
        border: 2px solid #d4af37;
        border-radius: 12px;
        z-index: 150;
        box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
        backdrop-filter: blur(4px);
      }

      .quick-slot {
        width: 55px;
        height: 55px;
        border: 2px solid rgba(212, 175, 55, 0.5);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        position: relative;
        transition: all 0.2s;
      }
      .quick-slot:hover {
        background-color: rgba(212, 175, 55, 0.2);
        border-color: #f4d03f;
      }
      .quick-slot.empty { border-style: dashed; }

      .slot-item-count {
        position: absolute;
        bottom: 2px;
        right: 4px;
        font-size: 14px;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px black;
      }

      .slot-key-hint {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 12px;
        color: #f4e4bc;
        opacity: 0.7;
      }
      .cultivate-slot {
            font-size: 28px; /* Hacemos el emoji un poco más grande */
            border-style: solid; /* Para que no se vea punteado como un slot vacío */
        }

        /* Estilo para cuando el cultivo está activo */
        .cultivate-slot.active-cultivation {
            background-color: rgba(139, 69, 19, 0.5); /* Un brillo sutil de color del tema */
            border-color: #f4d03f;
            box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
            animation: pulse-cultivation 2s infinite;
        }
        .conversion-slot {
            font-size: 28px;
            border-style: solid;
            color: #f4e4bc;
            opacity: 0.6; /* Un poco tenue cuando está inactivo */
            transition: all 0.3s;
        }

        .conversion-slot:hover {
            opacity: 1;
        }

        .conversion-slot.active-conversion {
            opacity: 1;
            background-color: rgba(68, 68, 255, 0.3); /* Brillo azulado */
            border-color: #6666ff;
            box-shadow: 0 0 10px rgba(102, 102, 255, 0.7);
            animation: pulse-conversion 2s infinite;
        }

        @keyframes pulse-conversion {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes pulse-cultivation {
            0% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 15px rgba(244, 208, 63, 0.8);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
            }
        }

      /* --- Botones de Control Superpuestos (Móvil) --- */
      #mobileMenuBtn {
        display: none;
        position: fixed;
        top: 10px;
        right: 10px; /* <--- CORREGIDO */
        z-index: 1000;
        width: 45px;
        height: 45px;
        font-size: 24px;
        padding: 0;
        }
      
        #toggleMapControlsBtn {
        display: none;
        position: fixed;
        top: 60px; /* <--- CORREGIDO (10px + 45px del botón de arriba + 5px de espacio) */
        right: 10px;
        z-index: 1005;
        padding: 8px 12px;
        font-size: 14px;
        }

      #toggleMapControlsBtn.hidden-during-battle {
        display: none !important;
      }

      /****************************************
       * 3. MAPA Y ELEMENTOS DEL MAPA
       ****************************************/
      .map-container {
        flex: 1;
        position: relative;
        background: #1a3d2e;
        border: 3px solid #d4af37;
        overflow: hidden;
      }

      .map {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .tile {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .player {
        z-index: 10;
        color: transparent; /* Oculta el emoji de fallback */
        font-size: 0;
        background-image: url("img/tu_sprite_sheet.png"); /* Asegúrate que la ruta sea correcta */
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: 256px 256px; /* Ajusta al tamaño total de tu spritesheet */
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }

      /* Barras de stats sobre el jugador en el mapa */
      #playerOnMapBarsContainer {
        position: absolute;
        width: 48px;
        display: none; /* JS lo controla */
        flex-direction: column;
        gap: 1px;
        z-index: 15;
        pointer-events: none;
        transform: translateX(-50%);
      }

      .on-map-stat-bar {
        width: 100%;
        height: 6px;
        background-color: rgba(50, 50, 50, 0.7);
        border: 1px solid rgba(0, 0, 0, 0.5);
        border-radius: 2px;
        overflow: hidden;
      }

      .on-map-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerOnMapHpFill { background-color: #f44336; }
      #playerOnMapManaFill { background-color: #2196f3; }
      .entity-name-plate {
        position: absolute; /* Para posicionarlo relativo al mapa */
        bottom: 100%; /* Lo coloca justo encima del 'top' del sprite */
        left: 50%;
        transform: translateX(-50%); /* Lo centra horizontalmente */
        background-color: rgba(10, 10, 10, 0.7);
        color: #f4e4bc;
        padding: 2px 5px;
        border-radius: 4px;
        font-size: 10px; /* Un tamaño de fuente pequeño y legible */
        font-weight: bold;
        white-space: nowrap; /* Evita que el nombre se parta en dos líneas */
        z-index: 6; /* Asegura que esté por encima de la entidad */
        pointer-events: none; /* Evita que la etiqueta intercepte clics del ratón */
        border: 1px solid rgba(212, 175, 55, 0.3);
    }

      /****************************************
       * 4. PANTALLA DE BATALLA
       ****************************************/
       
      .battle-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        display: none;
        flex-direction: column;
        z-index: 300;
        overflow: hidden;
      }

      .battle-area {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: space-around;
        padding: 20px 10px;
        gap: 10px;
        overflow-y: auto;
      }

      .character, .enemy {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-basis: 45%;
        max-width: 280px;
        min-width: 120px;
        padding: 60px 0;
      }

      .character-sprite, .enemy-sprite {
        width: 80px;
        height: 80px;
        font-size: 60px;
        margin-bottom: 10px;
      }
      .enemy-sprite {
            background-size: contain; /* Asegura que la imagen quepa completa en el div */
            background-repeat: no-repeat;
            background-position: center; /* Centra la imagen del sprite */
            image-rendering: pixelated; /* Mantiene la estética pixel-art si la tienes */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

      .character-sprite {
        background-image: url("img/tu_sprite_sheet.png");
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: auto;
        color: transparent;
      }

      .battle-actions {
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-top: 2px solid #d4af37;
        flex-shrink: 0;
      }

      .action-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 5px;
        margin-bottom: 10px;
      }
      
      .battle-actions button {
        padding: 8px 10px;
        font-size: 0.8em;
      }
      
      .log { display: none; }

      /* Barras sobre sprites en batalla */
      #playerInBattleSpriteBarsContainer, #enemyInBattleInfoContainer {
        position: absolute;
        display: none;
        flex-direction: column;
        gap: 2px;
        z-index: 5;
        pointer-events: none;
        transform: translateX(-50%);
      }

      #playerInBattleSpriteBarsContainer { width: 60px; }
      #enemyInBattleInfoContainer {
        min-width: 70px;
        max-width: 190px;
        align-items: center;
        padding: 2px 4px;
        background-color: rgba(10, 10, 10, 0.6);
        border-radius: 3px;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      .in-battle-sprite-stat-bar {
        width: 100%;
        height: 5px;
        background-color: rgba(50, 50, 50, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.6);
        border-radius: 2px;
        overflow: hidden;
      }
      .in-battle-sprite-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }
      
      #playerInBattleSpriteHpFill { background-color: #e53935; }
      #playerInBattleSpriteManaFill { background-color: #1e88e5; }
      #enemyInBattleSpriteHpFill { background-color: #c62828; }

      .enemy-battle-name-level {
        font-size: 0.8em;
        color: #f4e4bc;
        font-weight: bold;
        white-space: nowrap;
      }

      /****************************************
       * 5. MODALES Y ELEMENTOS DE UI
       ****************************************/
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 500; /* Más alto que la batalla */
        padding: 10px;
      }

      .modal-content {
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        border: 3px solid #d4af37;
        border-radius: 15px;
        padding: 20px;
        max-width: 95%;
        width: 500px;
        text-align: center;
        max-height: 90vh;
        overflow-y: auto;
      }
      
      .cultivation-option-btn {
        display: block;
        width: 100%;
        padding: 10px;
        margin-bottom: 8px;
        text-align: left;
      }

      /* Controles táctiles del mapa (Joystick, Botón Acción) */
      #joystick-container {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
        z-index: 200;
        display: none;
        opacity: 0.7;
      }
      #joystick-pad {
        z-index: 1;
        width: 100%;
        height: 100%;
        background-color: rgba(128, 128, 128, 0.5);
        border-radius: 50%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid rgba(255, 255, 255, 0.7);
      }
      #joystick-handle {
        width: 50px;
        height: 50px;
        background-color: rgba(80, 80, 80, 0.8);
        border-radius: 50%;
        position: absolute;
        border: 2px solid rgba(200, 200, 200, 0.9);
      }
      #action-button-touch {
        position: fixed;
        bottom: 60px;
        right: 60px;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        z-index: 200;
        display: none;
        font-size: 0.8em;
      }
      /* --- Estilos para Modal de Inventario --- */
        .inventory-modal-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            padding: 10px;
            margin-bottom: 8px;
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.15);
        }

        .inventory-modal-item .item-details {
            flex-grow: 1;
        }

        .inventory-modal-item .item-name {
            font-weight: bold;
            color: #f4d03f;
            font-size: 1.1em;
        }

        .inventory-modal-item .item-description {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 4px;
        }

        .inventory-modal-item .item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .inventory-modal-item .item-actions button {
            padding: 6px 10px;
            font-size: 0.8em;
        }
        .assignable-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .assignable-item:hover {
            background-color: rgba(212, 175, 55, 0.1);
            border-color: rgba(212, 175, 55, 0.4);
        }
        /* --- Fin Estilos Modal Inventario --- */

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
          @media (max-width: 768px), 
              (max-height: 500px), 
              (hover: none) and (pointer: coarse)  {
        .game-container {
          padding-top: 0; /* En móvil, no hay espacio arriba, el menú es un overlay */
          /* --- CORRECCIÓN CLAVE --- */
          /* Hacemos que el contenedor del juego pueda estar detrás de la barra */
          position: relative;
          z-index: 1; 
        }
        
        .map-container {
          height: 100vh;
        }

        #mobileMenuBtn, #toggleMapControlsBtn {
          display: block;
        }
        
        .top-nav-bar {
          flex-direction: column;
          justify-content: flex-start;
          align-items: stretch;
          height: auto;
          padding-top: 60px;
          /* --- CORRECCIÓN CLAVE --- */
          /* Aseguramos que la barra esté por encima del game-container */
          z-index: 200; 
          transform: translateY(-100%);
          transition: transform 0.4s ease-in-out;
        }

        .top-nav-bar.open {
          transform: translateY(0);
        }

        .top-nav-bar .nav-button {
          justify-content: flex-start;
          padding: 15px 20px;
          max-width: 100%;
        }

        .stats-panel .desktop-only {
          display: none;
        }

        .stats-panel {
            /* Ajustes existentes para móvil */
            width: 180px; /* Un poco más ancho para la nueva info */
            padding: 8px;
            font-size: 0.8em; /* Un poco más grande para legibilidad */
            top: 10px;
            left: 10px;
            backdrop-filter: blur(2px);
        }
        
        #toggleMapControlsBtn {
            top: 60px; /* Vuelve a su posición original en móvil */
        }

        .character-sprite, .enemy-sprite {
            width: 60px; height: 60px; font-size: 55px;
        }
      }

      @media (max-width: 480px) {
        .nav-text { display: none; }
        .nav-icon { font-size: 1.8rem; margin-bottom: 0; }
        .nav-button { padding: 10px 5px; }
        
        .stats-panel {
            width: 160px;
            font-size: 0.8em;
        }
        .stats-panel h3 { font-size: 1.1em; }
        
        .character-sprite, .enemy-sprite {
            width: 50px; height: 50px; font-size: 50px;
        }
        .battle-actions button {
            padding: 6px 8px; font-size: 0.75em;
        }

    }
    /****************************************
       * NUEVO: 7. ESTILOS DE LA TIENDA
       ****************************************/
      
       #shopModal .modal-content {
        max-width: 90%;
        width: 1000px; /* Un ancho mayor para la tienda */
        height: 90vh;
        display: flex;
        flex-direction: column;
      }

      .shop-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        flex-shrink: 0;
      }

      .shop-stats {
        font-size: 1.1em;
        color: #f4d03f;
      }

      .shop-container {
        display: flex;
        gap: 20px;
        flex-grow: 1;
        overflow: hidden; /* Evita que el contenedor principal scrollee */
      }
      
      .shop-filters {
        flex: 0 0 220px; /* No crece, no se encoge, base de 220px */
        padding-right: 15px;
        border-right: 1px solid rgba(212, 175, 55, 0.2);
        overflow-y: auto;
      }
      
      .shop-products {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .products-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 15px;
        overflow-y: auto; /* El scroll ahora está aquí */
        padding: 5px;
        flex-grow: 1;
      }

      .section-title {
        color: #f4d03f;
        margin-bottom: 10px;
        border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        padding-bottom: 5px;
      }

      .search-box {
        width: 100%;
        padding: 8px;
        background-color: rgba(0,0,0,0.3);
        border: 1px solid #555;
        border-radius: 5px;
        color: #f4e4bc;
        margin-bottom: 15px;
      }

      .filter-group {
        margin-bottom: 20px;
      }
      .filter-title {
        font-weight: bold;
        margin-bottom: 8px;
        font-size: 0.9em;
        opacity: 0.8;
      }

      .category-list {
        list-style: none;
      }
      .category-item {
        padding: 8px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .category-item:hover {
        background-color: rgba(212, 175, 55, 0.1);
      }
      .category-item.active {
        background-color: rgba(212, 175, 55, 0.2);
        color: #f4d03f;
        font-weight: bold;
      }

      .product-card {
        background: rgba(0,0,0,0.2);
        border: 1px solid rgba(212, 175, 55, 0.3);
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
      }

      .product-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 10px;
      }

      .product-name {
        font-weight: bold;
        color: #f4d03f;
      }
      .product-type {
        font-size: 0.8em;
        opacity: 0.7;
      }
      .product-price {
        font-weight: bold;
        white-space: nowrap;
      }
      
      .product-description {
        font-size: 0.9em;
        margin: 10px 0;
        opacity: 0.9;
        flex-grow: 1; /* Hace que la descripción empuje el botón hacia abajo */
      }

      .product-actions {
        margin-top: auto; /* Empuja el botón al final de la tarjeta */
      }
      .buy-btn {
        width: 100%;
      }

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
      @media (max-width: 768px) {
        /* ... (tus otras media queries) ... */
      
        /* AÑADE ESTAS REGLAS DENTRO DE LA MEDIA QUERY DE 768px */
        #shopModal .modal-content {
            width: 95%; /* Ocupa más ancho en móvil */
            /* Quitamos la altura fija para que se adapte al contenido en móvil */
            height: auto; 
            max-height: 85vh; /* Ponemos una altura máxima para que no ocupe toda la pantalla */
        }

        .shop-container {
            flex-direction: column; /* Apila los filtros encima de los productos */
            /* Hacemos que el scroll sea manejado por el .modal-content general en móvil */
            overflow: visible; 
        }

        .shop-filters {
            flex: 0 0 auto; /* No debe crecer, su tamaño será determinado por su contenido */
            border-right: none;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            padding-bottom: 15px;
            margin-bottom: 15px;
            overflow-y: visible; /* Correcto, no queremos scroll aquí */
        }

        .shop-products {
            /* Quitamos el overflow: hidden que podría estar ocultando el contenido */
            overflow: visible;
        }

        .products-grid {
            grid-template-columns: 1fr; /* Una sola columna para los productos en móvil */
            overflow-y: visible; /* El scroll lo maneja el padre */
            /* Quitamos el flex-grow para evitar conflictos */
        }
    }
    /****************************************
       * NUEVO: 8. ESTILOS DE COMBATE FLOTANTES
       ****************************************/
      .damage-popup {
        position: absolute;
        z-index: 310; /* Encima de todo en la batalla */
        font-family: 'Courier New', monospace;
        font-weight: bold;
        pointer-events: none; /* Para que no intercepte clics */
        text-shadow: 2px 2px 3px rgba(0,0,0,0.7);
        animation: floatUpAndFade 1.5s ease-out forwards;
      }

      /* Estilos específicos */
      .damage-popup.damage { color: #ff4d4d; font-size: 1.8em; }
      .damage-popup.heal { color: #66ff66; font-size: 1.8em; }
      .damage-popup.mana { color: #87CEFA; font-size: 1.5em; }
      .damage-popup.ability { color: #f4d03f; font-size: 1.2em; }
      .damage-popup.debuff { color: #dda0dd; font-size: 1.2em; }

      @keyframes floatUpAndFade {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        100% {
          transform: translateY(-80px) scale(1.2);
          opacity: 0;
        }
      }
   
    </style>
  </head>
  <body>
      <!-- BOTÓN DE MENÚ PARA MÓVILES -->
      <button id="mobileMenuBtn">☰</button>
      <!-- FIN DEL BOTÓN -->

      <!-- ================================================================= -->
      <!-- CORRECCIÓN 1: PANEL DE ESTADÍSTICAS MOVIDO AQUÍ -->
      <!-- Este panel ahora es un hijo directo del body. Gracias a `position: fixed` en su CSS,
          se quedará anclado en la esquina superior izquierda sin importar el resto del layout. -->
     <div class="stats-panel">
        <!-- Estos se mostrarán siempre -->
        <p class="stat-line stat-coords">Coords: <span id="playerCoords">X: 0, Y: 0</span></p>
        <p class="stat-line stat-zone">Zona: <span id="playerZone">Desconocida</span></p>
        
        <!-- Estos se ocultarán en móvil -->
        <p class="stat-line stat-level desktop-only">Nivel: <span id="playerLevel">1</span></p>
        <p class="stat-line stat-realm desktop-only">Reino: <span id="playerRealm">Mortal</span></p>

        <div class="stat-block desktop-only">
          <span>Vida: <span id="hpText">100/100</span></span>
          <div class="stat-bar">
            <div class="stat-fill hp-fill" id="hpBar" style="width: 100%"></div>
          </div>
        </div>

        <div class="stat-block desktop-only">
          <span>Maná: <span id="manaText">50/50</span></span>
          <div class="stat-bar">
            <div
              class="stat-fill mana-fill"
              id="manaBar"
              style="width: 100%"
            ></div>
          </div>
        </div>
        
        <!-- Estos se mostrarán siempre -->
        <div class="stat-block">
            <span>Experiencia: <span id="expText">0/100</span></span>
            <div class="stat-bar">
              <div class="stat-fill exp-fill" id="expBar" style="width: 0%"></div>
            </div>
        </div>
        <p class="stat-line stat-stones">P. Espirituales: <span id="playerStonesHud">0</span></p>
    </div>
      <!-- ================================================================= -->
  
      <!-- PANEL LATERAL -->
      <input type="file" id="fileInput" accept=".json" style="display: none" />
      <button id="toggleMapControlsBtn">Ocultar Controles</button>
      <!-- Botón para ocultar/mostrar controles -->

      <div class="game-container">
          
        <div class="map-container">
          
          <div class="map" id="gameMap"></div>
          <div class="tile player" id="player">🧘</div>

          <!-- Este contenedor ahora SÓLO tiene las barras pequeñas que van sobre el sprite en el mapa -->
          <div id="playerOnMapBarsContainer">
            <div class="on-map-stat-bar">
              <!-- Barra de Vida -->
              <div class="on-map-stat-fill" id="playerOnMapHpFill"></div>
            </div>
            <div class="on-map-stat-bar">
              <!-- Barra de Maná -->
              <div class="on-map-stat-fill" id="playerOnMapManaFill"></div>
            </div>
          </div>
          
        <div id="joystick-container">
          <div id="joystick-pad">
            <div id="joystick-handle"></div>
          </div>
        </div>
        <button id="action-button-touch">Acción</button>

        <div class="sidebar">
          <div class="inventory-panel">
            <h3>Inventario</h3>
            <div class="inventory-grid" id="inventory"></div>
          </div>

          <div class="controls-panel">
            <h3>Controles</h3>
            <p><strong>Escritorio:</strong></p>
            <p>WASD/Flechas: Moverse</p>
            <p>ESPACIO: Interactuar</p>
            <p style="margin-top: 5px"><strong>Móvil:</strong></p>
            <p>Joystick: Moverse</p>
            <p>Botón Acción: Interactuar</p>
            <p>
              "Ocultar/Mostrar Controles": Alterna visibilidad de controles
              táctiles.
            </p>

            <button id="cultivateButton" onclick="toggleCultivation()">
              🧘‍♀️ Cultivar
            </button>
            <button onclick="showTechniquePanel()">📖 Técnicas</button>
            
            <button onclick="saveGame()">💾 Guardar Partida</button>
            <button onclick="triggerFileUpload()">📁 Cargar Partida</button>
            <button onclick="showHelp()">❓ Ayuda</button>
          </div>
          <div class="secta-panel">
            <h3><span id="sectaNombreDisplay">Secta</span></h3>
            <p>Rango: <span id="playerSectRank">Discípulo Externo</span></p>
            <p>Puntos de Contribución: <span id="playerPCS">0</span> PCS</p>
            <h4>Misiones Activas:</h4>
            <div
              id="activeMissionsList"
              style="font-size: 0.9em; max-height: 150px; overflow-y: auto"
            >
              <p>Ninguna misión activa.</p>
            </div>
          </div>
        </div>
      </div>
      <!-- FIN PANEL LATERAL -->
      <!-- Pantalla de Combate -->
      <div class="battle-screen" id="battleScreen">
        <div class="battle-area">
          <div class="character">
            <!-- NUEVO: Contenedor para barras SOBRE el sprite en batalla -->
            <div id="playerInBattleSpriteBarsContainer">
              <div class="in-battle-sprite-stat-bar">
                <!-- Barra de Vida -->
                <div
                  class="in-battle-sprite-stat-fill"
                  id="playerInBattleSpriteHpFill"
                ></div>
              </div>
              <div class="in-battle-sprite-stat-bar">
                <!-- Barra de Maná -->
                <div
                  class="in-battle-sprite-stat-fill"
                  id="playerInBattleSpriteManaFill"
                ></div>
              </div>
            </div>
            <!-- FIN NUEVO -->
            <div class="character-sprite">🧘</div>
            <h3 id="playerBattleName">Cultivador</h3>
            <div>Vida: <span id="playerBattleHp">100/100</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill hp-fill"
                id="playerBattleHpBar"
                style="width: 100%"
              ></div>
            </div>
          </div>

          <div class="enemy">
            <!-- === NUEVO: Contenedor para información y barras SOBRE el sprite del ENEMIGO === -->
            <div id="enemyInBattleInfoContainer">
              <div class="enemy-battle-name-level" id="enemyBattleNameLevel">
                Enemigo (Nv. X)
              </div>
              <div class="in-battle-sprite-stat-bar enemy-hp-bar">
                <!-- Barra de Vida del Enemigo -->
                <div
                  class="in-battle-sprite-stat-fill"
                  id="enemyInBattleSpriteHpFill"
                ></div>
              </div>
            </div>
            <!-- === FIN NUEVO === -->
            <div class="enemy-sprite" id="enemySprite"></div>
            <h3 id="enemyName">Demonio</h3>
            <div>Vida: <span id="enemyHp">80/80</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill hp-fill"
                id="enemyHpBar"
                style="width: 100%"
              ></div>
              <div
                class="stat-fill hp-fill"
                id="enemyHpBar"
                style="width: 100%"
              ></div>
            </div>
          </div>
        </div>

        <div class="battle-actions">
          <div class="action-buttons" id="battleActionButtons">
            {/* Botones de batalla se generan por JS */}
          </div>
          <div class="log" id="battleLog"></div>
        </div>
      </div>

      <!-- Modal para Cultivo Activo -->
  <div class="modal" id="activeCultivationModal">
      <div class="modal-content" style="max-width: 450px;">
          <h3 id="activeCultivationTitle">Cultivando...</h3>
          <p id="activeCultivationDescription">Concentrando tu energía...</p>

          <!-- SECCIÓN PARA CULTIVO DE TÉCNICA -->
          <div id="activeCultivationProgressUI" style="display: none;">
              <p>
                  Progreso:
                  <span id="activeCultivationTargetName">Técnica X</span> (Nv.
                  <span id="activeCultivationTargetLevel">Y</span>)
              </p>
              <!-- El contenedor de la barra -->
              <div class="stat-bar"style="background: #444; margin: 10px 0;"> 
                  <!-- La barra de relleno -->
                  <div class="stat-fill" id="activeCultivationProgressBar" style="width: 0%; background: linear-gradient(90deg, #ffd700, #ffae42);"></div>
              </div>
              <p id="activeCultivationProgressText" style="text-align: center; font-size: 0.9em;">0s / 0s</p>
          </div>

          <!-- SECCIÓN PARA MEDITACIÓN RESTAURADORA -->
          <div id="recoveryCultivationProgressUI" style="display: none; margin-top: 15px;">
              <p>Absorbiendo Qi del entorno...</p>
              <div style="margin-top: 15px; font-size: 0.9em;">
                  <div>Vida: <span id="modalHpText">100/100</span></div>
                  <div class="stat-bar">
                      <div class="stat-fill hp-fill" id="modalHpBar" style="width: 100%;"></div>
                  </div>
                  <div>Maná: <span id="modalManaText">50/50</span></div>
                  <div class="stat-bar">
                      <div class="stat-fill mana-fill" id="modalManaBar" style="width: 100%;"></div>
                  </div>
              </div>
          </div>

          <!-- SECCIÓN PARA ACELERACIÓN -->
          <div id="cultivationBoostSection" style="display: none; margin-top: 15px; padding-top: 10px; border-top: 1px solid #555;">
              <p>Piedras Espirituales: <span id="cultivationModalPlayerStones">0</span></p>
              <button id="boostCultivationButton" onclick="boostCultivationProgress()" style="margin-top: 8px; width: 100%;">⚡ Acelerar Cultivo (1 Piedra = 10s)</button>
          </div>

          <!-- Botón para detener -->
          <button onclick="stopCultivation(true)" style="margin-top: 20px;">🚫 Detener Cultivo</button>
      </div>
  </div>


      <!-- Modal para tienda -->
      <div class="modal" id="shopModal">
        <div class="modal-content">
          
          <div class="shop-header">
            <h2 id="shopName">Pabellón de Tesoros del Dragón Oculto</h2>
            <div class="shop-stats">
              <span id="playerSpiritualStones">Piedras Espirituales: 0</span>
            </div>
          </div>
          <div class="shop-container">
            <div class="shop-filters">
              <h3 class="section-title">Filtros</h3>
              <input
                type="text"
                class="search-box"
                id="shopSearch"
                placeholder="Buscar..."
              />
              <div class="filter-group">
                <div class="filter-title">Categorías</div>
                <ul class="category-list" id="shopCategories">
                  <li class="category-item active" data-category="all">Todas</li>
                  <li class="category-item" data-category="combat">T. Combate</li>
                  <li class="category-item" data-category="cultivation">
                    T. Cultivo
                  </li>
                  <li class="category-item" data-category="weapon">Armas</li>
                  <li class="category-item" data-category="armor">Armaduras</li>
                  <li class="category-item" data-category="consumable">
                    Consumibles
                  </li>
                  <li class="category-item" data-category="material">
                    Materiales
                  </li>
                  <li class="category-item" data-category="scroll">Rollos</li>
                </ul>
              </div>
              <div class="filter-group">
                <div class="filter-title">Rango de Precio</div>
                <div>
                  <input
                    type="range"
                    id="priceRange"
                    min="0"
                    max="1000"
                    value="1000"
                    style="width: 100%"
                  />
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    font-size: 0.8em;
                  "
                >
                  <span>0 PS</span><span id="priceRangeValue">1000 PS</span>
                </div>
              </div>
            </div>
            <div class="shop-products">
              <h3 class="section-title">Técnicas y Objetos</h3>
              <div class="products-grid" id="shopProducts"></div>
              <div class="pagination" id="shopPagination"></div>
            </div>
          </div>
          <div>
            <button onclick="closeShopModal()" style="margin-top: 20px">
              Salir de la Tienda
            </button>
          </div>
        </div>
      </div>

      <!-- Modal para Secta -->
      <div class="modal" id="sectHallModal">
        <div class="modal-content" style="max-width: 600px; text-align: left">
          <h3 id="sectHallModalTitle">Salón de la Secta del Viento Azure</h3>
          <div id="sectHallOptions">
            <p>
              Bienvenido, Discípulo <span id="sectHallPlayerRank">Externo</span>.
            </p>
            <p>Puntos de Contribución: <span id="sectHallPlayerPCS">0</span></p>
            <hr />
            <h4>Tablón de Misiones</h4>
            <div
              id="sectHallAvailableMissions"
              style="
                max-height: 150px;
                overflow-y: auto;
                margin-bottom: 10px;
                border: 1px solid #444;
                padding: 5px;
              "
            >
              <p>Habla con el Guía Lin para nuevas asignaciones.</p>
            </div>
            <h4>Contribuciones a la Secta</h4>
            <div id="sectHallContributions" style="margin-bottom: 10px">
              <p>Visita al Administrador Yao para entregar recursos.</p>
            </div>
            <h4>Desafíos de Rango</h4>
            <div id="sectHallRankChallenges" style="margin-bottom: 10px">
              <p id="sectHallChallengeStatus">
                Consulta con el Maestro de la Arena.
              </p>
            </div>
            <h4>Tienda de la Secta</h4>
            <button onclick="openSectShop()">Visitar Depósito de la Secta</button>
            <hr />
          </div>
          <button
            onclick="closeSectHallModal()"
            style="display: block; margin: 20px auto 0"
          >
            Salir del Salón
          </button>
        </div>
      </div>
      <!-- Modal genérico para confirmaciones (Sí/No) -->
    <div class="modal" id="confirmationModal">
      <div class="modal-content" style="max-width: 450px;">
        <h3 id="confirmationModalTitle">Confirmar Acción</h3>
        <p id="confirmationModalText" style="margin: 15px 0; line-height: 1.5;">¿Estás seguro?</p>
        <div style="display: flex; justify-content: space-around; margin-top: 20px;">
          <button id="confirmBtn" style="background-color: #4CAF50;">Confirmar</button>
          <button id="cancelBtn" onclick="closeConfirmationModal()" style="background-color: #f44336;">Cancelar</button>
        </div>
      </div>
    </div>
      <!-- Modal para Misiones -->
      <div class="modal" id="missionsModal">
          <div class="modal-content" style="max-width: 600px; text-align: left;">
          <h3 style="text-align: center;">Diario de Misiones</h3>
          <div id="missionsContainer" style="margin-top: 15px; max-height: 400px; overflow-y: auto; padding-right: 10px;">
              <!-- El contenido de las misiones se generará aquí -->
          </div>
          <button onclick="closeMissionsModal()" style="display: block; margin: 20px auto 0;">Cerrar</button>
          </div>
      </div>
      <!-- Modal para Revisión de Batalla -->
      <div class="modal" id="battleReviewModal">
          <div class="modal-content" style="max-width: 600px; text-align: left;">
          <h3 style="text-align: center;">Resumen del Combate</h3>
          <div id="battleReviewLog" style="margin-top: 15px; max-height: 60vh; overflow-y: auto; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; font-size: 0.9em; line-height: 1.5;">
              <!-- El log de la batalla se insertará aquí -->
          </div>
          <button onclick="closeBattleReviewModal()" style="display: block; margin: 20px auto 0;">Cerrar</button>
          </div>
      </div>
      
      <!-- Modal para Selección de Cultivo -->
      <div class="modal" id="cultivationChoiceModal">
        <div class="modal-content" style="max-width: 500px; text-align: left">
          <h3>¿Qué deseas cultivar?</h3>
          <div id="cultivationOptionsContainer">
            <button
              class="cultivation-option-btn"
              onclick="startCultivationMode('recovery')"
            >
              🧘 Meditación Restauradora
            </button>
            <hr />
            <h4>Cultivar Técnica:</h4>
            <div
              id="cultivableTechniquesList"
              style="max-height: 200px; overflow-y: auto"
            ></div>
          </div>
          <button
            onclick="closeCultivationChoiceModal()"
            style="margin-top: 20px"
          >
            Cancelar
          </button>
        </div>
      </div>

      <!-- Modal genérico para interacciones y notificaciones -->
      <div class="modal" id="interactionModal">
        <div class="modal-content" style="max-width: 450px">
          <h3 id="modalTitle">Título del Modal</h3>
          <p
            id="modalText"
            style="margin-top: 15px; margin-bottom: 20px; line-height: 1.5"
          >
            Texto.
          </p>
          <button onclick="closeModal()" class="close-modal-btn">Cerrar</button>
        </div>
      </div>

      <!-- Modal para Técnicas -->
      <div class="modal" id="techniqueModal">
        <div class="modal-content" style="max-width: 600px; text-align: left">
          <h3 style="text-align: center">Técnicas Aprendidas</h3>
          <div
            id="learnedTechniquesContainer"
            style="
              margin-top: 15px;
              max-height: 400px;
              overflow-y: auto;
              padding-right: 10px;
            "
          ></div>
          <button
            onclick="closeTechniqueModal()"
            style="display: block; margin: 20px auto 0"
          >
            Cerrar
          </button>
        </div>
      </div>

      <!-- Modal para Recompensa de Ascenso de Rango -->
      <div class="modal" id="rankUpRewardModal">
        <div class="modal-content" style="max-width: 550px; text-align: left;">
          <h3 id="rankUpRewardTitle">Recompensa por Ascenso</h3>
          <p>Como reconocimiento a tu progreso, la secta te otorga un manual de técnica. Elige sabiamente, pues este conocimiento definirá tu camino.</p>
          <div id="rankUpRewardOptionsContainer" style="margin-top: 15px;">
            <!-- Las opciones de recompensa se generarán aquí -->
          </div>
          <button onclick="closeRankUpRewardModal()" style="margin-top: 20px;">Decidiré más tarde</button>
        </div>
      </div>

      <!-- ================================================================= -->
      <!-- CORRECCIÓN 2: BARRA DE NAVEGACIÓN SUPERIOR RELLENADA CON BOTONES -->
      <!-- Se han añadido los botones que faltaban. Ahora el JavaScript podrá encontrarlos
          y asignarles las funciones de click correspondientes. -->
      <nav class="top-nav-bar" id="topNavBar">
          <button id="navBtnCharacter" class="nav-button">
              <div class="nav-icon">👤</div>
              <span class="nav-text">Personaje</span>
          </button>
          <button id="navBtnMissions" class="nav-button">
              <div class="nav-icon">📖</div>
              <span class="nav-text">Misiones</span>
          </button>
          <button id="navBtnInventory" class="nav-button">
              <div class="nav-icon">🎒</div>
              <span class="nav-text">Inventario</span>
          </button>
          <button id="navBtnCultivate" class="nav-button">
              <div class="nav-icon">🧘</div>
              <span class="nav-text">Cultivar</span>
          </button>
          <button id="navBtnTechniques" class="nav-button">
              <div class="nav-icon">📜</div>
              <span class="nav-text">Técnicas</span>
          </button>
          <button id="navBtnMenu" class="nav-button">
              <div class="nav-icon">⚙️</div>
              <span class="nav-text">Menú</span>
          </button>
      </nav>
      <!-- ================================================================= -->
      <script>

  let lastSuccessfulMoveTime = 0;
          const PLAYER_MOVE_COOLDOWN = 250;  // <-- ¡ESTE ES EL NÚMERO QUE AJUSTARÁS! (en milisegundos)
          const topNavBar = document.getElementById("topNavBar");
        const navBtnInventory = document.getElementById('navBtnInventory');
          console.log("Botón de Inventario (navBtnInventory):", navBtnInventory);     
        const navBtnCharacter = document.getElementById("navBtnCharacter");
        const navBtnCultivate = document.getElementById("navBtnCultivate");
        const navBtnTechniques = document.getElementById("navBtnTechniques");
        const navBtnMenu = document.getElementById("navBtnMenu");
        let movePlayerCallCount = 0;
        // --- ESTADO DEL JUEGO ---
        let gameState = {
          /* ... (tu gameState existente sin cambios) ... */
        };
        // Estado del juego y datos principales
        gameState = {
          player: {
            x: 11,
            y: 15,
            level: 1,
            baseMaxHp: 100,
            baseMaxMana: 50,
            baseAttack: 15,
            baseDefense: 5,
            hp: 100,
            maxHp: 100,
            mana: 50,
            maxMana: 50,
            attack: 15,
            defense: 5,
            exp: 0,
            expToNext: 100,
            realm: "Mortal",
            quickSlots: [null, null, null, null, null], // 5 slots, inicialmente vacíos
            isCultivating: false,
            cultivationMode: {
              type: null,
              targetId: null,
              startTime: 0,

            },
            cultivationStartTime: 0,
            qiPerSecondBase: 1,
            expPerSecondBase: 0.5,
            hpPerSecondBase: 1,
            learnedTechniques: {},
            activeRefiningTechniqueId: null,
            canUseQiConversion: false,
            isQiConversionActive: false,
            worldState: {
              defeatedBosses: {},
              currentBossToSpawn: "boss_dem",
              defeatedFixedEntities: {},
            },
            secta: {
              nombre: "Secta del Viento Azure",
              rango: "Discípulo Externo",
              puntosContribucion: 0,
              misionesActivas: [],
              misionesCompletadas: {},
              rivalesDerrotadosClave: {},
            },
            // ---- PROPIEDADES DE ANIMACIÓN DEL SPRITE - ASEGÚRATE QUE ESTÉN AQUÍ Y CORRECTAS ----
            spriteSheetUrl: "img/personaje_cultivador_spritesheet.png",
            frameWidth: 64, // Ancho de un solo frame del sprite
            frameHeight: 64, // Alto de un solo frame del sprite
            directionRowMap: {
              // Mapeo de dirección a la fila Y en la hoja de sprites (0-indexed)
              down: 0, // Fila 0 para mirar/caminar hacia abajo
              left: 1, // Fila 1 para mirar/caminar hacia la izquierda
              right: 2, // Fila 2 para mirar/caminar hacia la derecha
              up: 3, // Fila 3 para mirar/caminar hacia arriba
            },
            animationFrames: 4, // Número de frames por dirección en la hoja
            currentFrame: 0, // Frame actual de la animación (0 a animationFrames - 1)
            currentDirection: "down", // Dirección inicial: 'up', 'down', 'left', 'right'
            isMoving: false,
            animationTimer: null, // Para el intervalo de la animación de caminar
            idleTimeout: null, // Para volver al estado idle después de moverse
            animationSpeed: 150, // Milisegundos entre frames de animación
            // ---- FIN PROPIEDADES DE ANIMACIÓN ----
            // NUEVO: Para animación de sprites
            sprites: {
              idle: "img/personaje_cultivador_idle.png", // O 'img/personaje_cultivador_down.png' si es tu frontal
              up: "img/personaje_cultivador_up.png",
              down: "img/personaje_cultivador_down.png",
              left: "img/personaje_cultivador_left.png",
              right: "img/personaje_cultivador_right.png",
            },
            currentSpriteKey: "idle", // 'idle', 'up', 'down', 'left', 'right'
            movementAnimationTimeout: null,
            
            defenseBoostTurns: 0,
            defenseBoostAmount: 0,
            // ===  DEBUFFS ===
            defenseReductionTurns: 0,
            defenseReductionAmount: 0,
            attackReductionTurns: 0,
            attackReductionAmount: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            burningTurns: 0,
            burnDamage: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            // ===================================
            dodgeNextAttack: false,
            healingRainTurns: 0,
            
            defenseBoostTurns: 0,
            defenseBoostAmount: 0,
            dodgeNextAttack: false,
            healingRainTurns: 0,
            healingRainAmount: 0,
            // Para Ritual de Sangre
            bloodRitualTurns: 0,
            bloodRitualAttackBoost: 0,
            // Nuevos estados para técnicas de alto nivel
            isImmuneToStatus: false, // Inmunidad a quemaduras, veneno, stun, etc.
            passiveHpRegen: 0, // Cantidad de HP a regenerar por segundo pasivamente
            reviveChance: 0, // Probabilidad de resucitar al morir
            deathSaveChance: 0, // Probabilidad de sobrevivir con 1 HP
            damageToHealingTurns: 0, // Turnos para convertir daño en curación
            intangibleTurns: 0, // Turnos de ser intangible (inmune a daño directo)
            canRevive: false, // Flag activado por Llama del Fénix
            // Fin nuevos estados
            // Para Aura de Pureza
            immuneTurns: 0,
          },
          cultivationInterval: null,
          inventory: {
            "Piedras Espirituales": 0,
            "Hierbas Medicinales": 0,
            "Cristales de Qi": 0,
          },
          map: {
            width: 600, // Más pequeño para pruebas iniciales
            height: 600,
            defaultTerrain: "GRASSLAND",
            terrainZones: [


              // ARENA DE LA SECTA
              {
                x1: 4,
                y1: 12,
                x2: 8,
                y2: 16, // Ejemplo de coordenadas (ajusta según tu mapa)
                type: "ARENA", // Puedes usar 'DESERT' o crear un G_TERRAIN_TYPES.ARENA
                name: "Arena de la Secta",
                // No necesita spawnSettings por ahora, a menos que quieras pequeños mobs decorativos allí.
              },
              // Ejemplo de Zona de Inicio cerca de la Secta (PRADERA)
             //ZONAS
              

             {
                x1: 2,
                y1: 10,
                x2: 29,
                y2: 24,
               

                
                type: "GRASSLAND",
                name: "Terreno de la Secta (Seguro)", 
             
              },
              {
                x1: 2,
                y1: 25,
                x2: 29,
                y2: 39,
               

                
                type: "GRASSLAND",
                name: "Praderas de la Secta",
                spawnSettings: {
                  targetEntities: [
                    // Lista de objetivos de spawn para esta zona
                    {
                      entityTypeId: "monster_secta_debil",
                      count: 10,
                      currentCount: 0,
                    },
                    { entityTypeId: "monster", count: 10, currentCount: 0 },
                    {
                      entityTypeId: "resource_hierbas_bosque",
                      count: 3,
                      currentCount: 0,
                    },
                    { entityTypeId: "cristal_qi", count: 3, currentCount: 0 },
                    {
                      entityTypeId: "cultivator_rival_low",
                      count: 5,
                      currentCount: 0,
                    },
                  ],
                  respawnTimer: 0, // Cuando llegue a 0, puede reaparecer
                  respawnCooldown: 300, // Segundos para reaparecer después de vaciarse o parcialmente
                  lastSpawnCheck: 0, // Timestamp del último intento de spawn
                },
              },
              // Bosque Esmeralda
              {
                  x1: 30,
                  y1: 10,
                  x2: 59,
                  y2: 39,
                  type: "GRASSLAND", // <-- El terreno base ahora es hierba
                  name: "Bosque Esmeralda",
                  decorations: [ 
                      { entityTypeId: 'deco_arbol_grande', density: 0.1 }, // 10% de las celdas tendrán un árbol grande
                      { entityTypeId: 'deco_arbol_normal', density: 0.3 }, // 30% tendrán un árbol normal
                      { entityTypeId: 'deco_roca_musgosa', density: 0.05 }  // 5% tendrán una roca
                  ],
                  spawnSettings: { 
                      targetEntities: [
                          { entityTypeId: "monster_bosque_lobo", count: 8, currentCount: 0 },
                          { entityTypeId: "monster_bosque_arana", count: 5, currentCount: 0 },
                          { entityTypeId: "resource_hierbas_bosque", count: 3, currentCount: 0 },
                          { entityTypeId: "monster_alpha", count: 5, currentCount: 0 },
                      ],
                      respawnTimer: 0,
                      respawnCooldown: 450,
                      lastSpawnCheck: 0,
                  },
              },
              // Desierto Abrasador
              {
                x1: 1,
                y1: 41,
                x2: 90,
                y2: 69,
                type: "DESERT",
                name: "Desierto Abrasador",
                decorations: [ 
                      { entityTypeId: 'deco_desierto', density: 0.05 }, // 5% de las celdas tendrán un árbol grande
                      
              
                  ],
                spawnSettings: {
                  targetEntities: [
                    {
                      entityTypeId: "monster_desierto_escorpion",
                      count: 7,
                      currentCount: 0,
                    },
                    {
                      entityTypeId: "monster_desierto_golem_arena",
                      count: 2,
                      currentCount: 0,
                      isElite: true,
                    }, // Golem como elite
                  ],
                  respawnTimer: 0,
                  respawnCooldown: 600,
                  lastSpawnCheck: 0,
                },
              },
              // RUINAS
              {
                x1: 500, y1: 500,
                x2: 550, y2: 550,
                type: "RUINS",
                name: "Corazón de las Ruinas Olvidadas",
                decorations: [ 
                      
                      { entityTypeId: 'deco_ruina_pilar', density: 0.02 }, 
                     
                  ],
                isIsolated: true,          // Marca esta zona como un "mapa" separado
                ambientColor: '#1a1a1a',   // Color del "vacío" alrededor de la zona
                spawnSettings: {
                  targetEntities: [
                    { entityTypeId: "esqueleto_podrido", count: 25, currentCount: 0 },
                    { entityTypeId: "boss_ancient_golem", count: 25, currentCount: 0 }, 
                  ],
                  respawnTimer: 0,
                  respawnCooldown: 400,
                  lastSpawnCheck: 0,
                },
              },
              // Ciénaga Sombría
              {
                x1: 60,
                y1: 15,
                x2: 90,
                y2: 45,
                type: "SWAMP",
                name: "Ciénaga Sombría",
                decorations: [ // <-- NUEVA PROPIEDAD
                      { entityTypeId: 'deco_arbol_pantano', density: 0.1 }, // 10% de las celdas tendrán un árbol grande
                      { entityTypeId: 'deco_agua_estancada', density: 0.05 }
              
                  ],
                spawnSettings: {
                  targetEntities: [
                    {
                      entityTypeId: "monster_cienaga_serpiente",
                      count: 4,
                      currentCount: 0,
                    },
                  ],
                  respawnTimer: 0,
                  respawnCooldown: 400,
                  lastSpawnCheck: 0,
                },
              },
              //LÍMITES DE MAPA
              // ... otras zonas (montañas, ruinas, agua sin spawns de monstruos terrestres)
              {
                x1: 0,
                y1: 0,
                x2: 190,
                y2: 8,
                type: "MOUNTAIN_SUP",
                name: "Montañas del Norte",
              }, // Sin spawnSettings = no spawns
              {
                x1:-20,
                y1: 0,
                x2: 0,
                y2: 600,
                type: "MOUNTAIN_SUP",
                name: "Montañas del Norte",
              }, // Sin spawnSettings = no spawns
              {
                x1: 92,
                y1: 0,
                x2: 190,
                y2: 600,
                type: "MOUNTAIN_SUP",
                name: "Montañas del Norte",
              }, // Sin spawnSettings = no spawns
              {
                x1: 91,
                y1: 9,
                x2: 91,
                y2: 9,
                type: "MOUNTAIN_SUP_DER",
                name: "Montañas del Norte",
              }, // Sin spawnSettings = no spawns
               {
                x1: 1,
                y1: 9,
                x2: 1,
                y2: 9,
                type: "MOUNTAIN_SUP_IZQ",
                name: "Montañas del Norte",
              }, // Sin spawnSettings = no spawns
              {
                x1: 1,
                y1: 40,
                x2: 1,
                y2: 40,
                type: "MOUNTAIN_INF_IZQ",
                name: "Montañas del Norte",
              }, // Sin spawnSettings = no spawns
               {
                x1: 1,
                y1: 69,
                x2: 1,
                y2: 69,
                type: "MOUNTAIN_INF_IZQ",
                name: "borde desierto",
              }, // Sin spawnSettings = no spawns
               {
                x1: 2,
                y1: 40,
                x2: 23,
                y2: 40,
                type: "MOUNTAIN_ABAJO_SUP",
                name: "frontera pradera-desierto",
              }, // Sin spawnSettings = no spawns
              {
                x1: 26,
                y1: 40,
                x2: 89,
                y2: 40,
                type: "MOUNTAIN_ABAJO_SUP",
                name: "frontera pradera-desierto",
              }, // Sin spawnSettings = no spawns
                {
                x1: 1,
                y1: 70,
                x2: 89,
                y2: 70,
                type: "MOUNTAIN_ABAJO_SUP_DES",
                name: "límite inferior desierto",
              }, // Sin spawnSettings = no spawns
              {
                x1: 1,
                y1: 71,
                x2: 89,
                y2: 90,
                type: "MOUNTAIN_SUP",
                name: "límite inferior desierto",
              }, // Sin spawnSettings = no spawns
              
          
              {
                x1: 2,
                y1: 9,
                x2: 90,
                y2: 9,
                type: "MOUNTAIN_FRENTE",
                name: "límite norte",
              }, // Sin spawnSettings = no spawns
              {
                x1: 91,
                y1: 10,
                x2: 91,
                y2: 600,
                type: "MOUNTAIN_DER",
                name: "Límite este",
              }, // Sin spawnSettings = no spawns
              {
                x1: 1,
                y1: 10,
                x2: 1,
                y2: 39,
                type: "MOUNTAIN_IZQ",
                name: "límite oeste pradera",
              }, // Sin spawnSettings = no spawns
              // ...
            
              
            ],
            terrainGrid: null,
            entities: [],
          },
          battle: {
            active: false,
            enemy: null,
            playerTurn: true,
          },
          gameTime: 0, // Un simple contador de segundos del juego para los temporizadores
          lastGameTimeUpdate: Date.now(),
          activeCombatAbilities: [],
        };

        let battleLogHistory = [];

        // --- CONSTANTES Y DATOS DEL JUEGO --- (sin cambios, deben estar aquí)
        let G_TILE_SIZE = 100; // Valor por defecto para escritorio
        const G_PLAYER_DISCOVERY_RANGE = 3;
        // --- VARIABLES GLOBALES ADICIONALES PARA CONTROL UI MÓVIL ---
        let mapControlsManuallyHidden = false;
        let currentTileSize = G_TILE_SIZE; // Usaremos este para los cálculos de renderizado
        let recoveryProgress = 0;
        let recoveryDirection = 1; // 1 para aumentar, -1 para disminuir
        const RECOVERY_CYCLE_DURATION = 2;
        const G_COMBAT_ENTITY_TYPES = [
          "monster",
          "esqueleto_podrido",
          "bandido_desfiladero",
          "monster_desierto_escorpion",
          "monster_secta_debil",
          "monster_alpha",
          "cultivator_rival_low",
          "cultivator_adept_hostile",
          "boss_dem",
          "boss_ancient_golem",
          "monster_cienaga_serpiente",
          "monster_bosque_lobo",
          "monster_bosque_arana",
          "monster_desierto_golem_arena",
          "jabali_colmilludo_alfa",
          "jabali_alfa_1",
          "jabali_alfa_2",
          "jabali_alfa_3",
          "jabali_alfa_4",
          "jabali_alfa_5",
          "jabali_alfa_6",
          "jabali_alfa_7",
          "jabali_alfa_8",
          "jabali_alfa_9",
          "jabali_alfa_10",
          "jabali_alfa_11",
          "jabali_alfa_12",
           
        ];
        const G_MAX_MAP_ENTITIES = 30;
        const G_RESPAWN_THRESHOLD = 15;
        const G_SAFE_RESPAWN_X = 10;
        const G_SAFE_RESPAWN_Y = 10;
        const G_SAFE_RESPAWN_SEARCH_RADIUS = 3;
        const G_TERRAIN_TYPES = {
          VOID: {
            textureUrl: "img/mont_sup.png", // ¡Asegúrate de que esta imagen exista!
            name: "Vacío"
          },
          ARENA: { 
            symbol: "🏟️",
            textureUrl: "img/b_arena.png", 
            color: "#D2B48C", 
            name: "Arena" },

          GRASSLAND: { 
              symbol: "🟩", 
              textureUrl: "img/grassland.png",
              color: "#34A853", 
              name: "Pradera" 
          
          }, // Verde para pastizales
          FOREST: { 
              symbol: "🌲", 
              textureUrl: "img/grassland.png",
              color: "#1E824C", 
              name: "Bosque" 
          }, // Verde oscuro para bosques
          MOUNTAIN_FRENTE: { 
              symbol: "⛰️", 
              textureUrl: "img/mont_frente.png",
              color: "#A9A9A9", 
              name: "Montaña" 
          }, // Gris para montañas
          MOUNTAIN_SUP: { 
              symbol: "⛰️", 
              textureUrl: "img/mont_sup.png",
              color: "#A9A9A9", 
              name: "Montaña" 
          }, 
            MOUNTAIN_SUP_DER: { 
              symbol: "⛰️", 
              textureUrl: "img/mont_sup_der.png",
              color: "#A9A9A9", 
              name: "Montaña" 
          }, 
          MOUNTAIN_SUP_IZQ: { 
              symbol: "⛰️", 
              textureUrl: "img/mont_sup_izq.png",
              color: "#A9A9A9", 
              name: "Montaña" 
          }, 
           MOUNTAIN_DER: { 
              symbol: "⛰️", 
              textureUrl: "img/mont_der.png",
              color: "#A9A9A9", 
              name: "Montaña" 
          }, 
          MOUNTAIN_IZQ: { 
              symbol: "⛰️", 
              textureUrl: "img/mont_izq.png",
              color: "#A9A9A9", 
              name: "Montaña" 
          }, 
           MOUNTAIN_INF_IZQ: { 
              symbol: "⛰️", 
              textureUrl: "img/mont_int_inf_izq.png",
              color: "#A9A9A9", 
              name: "Montaña" 
          }, 
          MOUNTAIN_ABAJO_SUP: { 
              symbol: "⛰️", 
              textureUrl: "img/mont_abajo_sup.png",
              color: "#A9A9A9", 
              name: "Montaña" 
          }, 
             MOUNTAIN_ABAJO_SUP_DES: { 
              symbol: "⛰️", 
              textureUrl: "img/mont_abajo_sup_des.png",
              color: "#A9A9A9", 
              name: "Montaña" 
          },
          WATER: { 
              symbol: "🟦", 
              color: "#4A86E8", 
              name: "Agua" }, // Azul para agua (intransitable)
          RUINS: { 
              symbol: "🏛️", 
              textureUrl: "img/suelo_ruinas.png",
              color: "#706050", 
              name: "Ruinas" 
          }, // Marrón/Gris para ruinas
          DESERT: { 
              symbol: "🟨",
              textureUrl: "img/arena.png", 
              color: "#F9E79F", 
              name: "Desierto" 
          }, // Amarillo claro para desierto
          SWAMP: { 
              symbol: "🟪", 
              textureUrl: "img/pantano.png",
              color: "#5D3A9A", 
              name: "Pantano" 
          }, // Púrpura/Verde oscuro para pantano
          
          // Añade más según necesites
        };

        const PLAYER_SPRITE_FRAME_WIDTH = 64; // <--- ¡AJUSTA ESTO AL ANCHO DE UN FRAME DE TU SPRITE!
        const PLAYER_SPRITE_FRAME_HEIGHT = 64; // <--- ¡AJUSTA ESTO AL ALTO DE UN FRAME DE TU SPRITE!
        const PLAYER_ANIMATION_SPEED = 150; // Milisegundos entre frames de caminata (ajusta a gusto)
        const PLAYER_WALK_CYCLE = [0, 1, 0, 2]; // Los frames de columna a ciclar para caminar.
        // Si tu animación es 0-1-2-1, sería [0,1,2,1]
        // Si es 0-1-0-2 sería [0,1,0,2] (para un efecto de pie y luego paso)
        // Para tu sprite de 4 frames por dirección: [0, 1, 2, 3] y el frame 0 es el de "quieto"
        // o puedes usar [1,2,3,0] si el 0 es un frame de paso
        // Una animación común es "quieto" -> paso1 -> "quieto" -> paso2
        // O para ciclo continuo: paso1 -> paso2 -> paso3 -> paso4 -> paso1 ...
        // Para el sprite que mostraste, parece ser:
        // Frame 0: Quieto
        // Frame 1: Paso A
        // Frame 2: Quieto (o un frame intermedio)
        // Frame 3: Paso B
        // Entonces un ciclo podría ser [0, 1, 0, 3] o [1,0,3,0] para animación mientras se mueve
        // O si todos son frames de paso: [0,1,2,3]
        // VAMOS A USAR UN CICLO [1,0,3,0] (asumiendo frame 0 es el base/quieto y 1,3 son pasos)
        // Si el frame 0 es un paso y el personaje se "desliza" al estar quieto, cambia esto.
        // Definir las posiciones Y del sprite sheet para cada dirección
        const PLAYER_SPRITE_DIRECTIONS_Y = {
          down: 0 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 1 (índice 0) para caminar hacia abajo
          left: 1 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 2 (índice 1) para caminar hacia la izquierda
          right: 2 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 3 (índice 2) para caminar hacia la derecha
          up: 3 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 4 (índice 3) para caminar hacia arriba
        };
        // Podríamos añadir una propiedad 'walkable' a cada tipo de terreno
        G_TERRAIN_TYPES.MOUNTAIN_FRENTE.walkable = false; // Ejemplo, montañas podrían ser no transitables 
        G_TERRAIN_TYPES.MOUNTAIN_SUP.walkable = false; // Ejemplo, montañas podrían ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_SUP_DER.walkable = false; // Ejemplo, montañas podrían ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_DER.walkable = false; // Ejemplo, montañas podrían ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_IZQ.walkable = false; // Ejemplo, montañas podrían ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP.walkable = false; // Ejemplo, montañas podrían ser no transitables
        G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP_DES.walkable = false
        G_TERRAIN_TYPES.WATER.walkable = false;
        // Por defecto, asumimos que son transitables si no se especifica 'walkable: false'
        const G_BLOCKING_ENTITY_TYPES = [
          "shop",
          "secta_entrada_principal",
          "npc_secta_guia",
          "npc_secta_admin",

          // Añade aquí otros 'originalEntityTypeId' o 'type' de entidades que deben bloquear
          // Por ejemplo, si tus NPCs tienen un 'type' específico o los identificas por 'npcId'
        ];
        const SECTA_DATA = {
          nombre: "Secta del Viento Azure",
          rangos: [
            {
              nombre: "Discípulo Externo",
              pcsRequeridos: 0,
              beneficios: "Acceso básico a la secta.",
            },
            {
              nombre: "Discípulo Interno", // GRADO 1
              pcsRequeridos: 50,
              desafioRivalId: "rival_interno_1",
              beneficios: "Acceso al Patio Interno, misiones de mayor nivel, +5% ganancia de Qi al cultivar en la secta.",
              techniqueChoice: ["sword_t1", "body_t1", "formation_t1", "fire_t1", "lightning_t1"]
            },
            {
              nombre: "Discípulo Principal", // GRADO 2
              pcsRequeridos: 200,
              desafioRivalId: "rival_principal_1",
              beneficios: "Acceso a la Biblioteca de Técnicas (nuevas técnicas), +10% ganancia de EXP en misiones de secta.",
              techniqueChoice: ["sword_t2", "body_t2", "formation_t2", "movement_t2", "fire_t2"]
            },
            {
              nombre: "Diácono", // GRADO 3
              pcsRequeridos: 500,
              desafioRivalId: "guardian_diacono_1",
              beneficios: "Asignación semanal de Piedras Espirituales, puede dirigir pequeños grupos de discípulos (mecánica futura).",
              techniqueChoice: ["sword_t3", "body_t3", "formation_t3", "lightning_t3", "movement_t3"]
            },
            {
              nombre: "Anciano", // GRADO 4
              pcsRequeridos: 1500,
              desafioRivalId: "guardian_anciano_1",
              beneficios: "Asignación semanal de Piedras Espirituales, puede dirigir medianos grupos de discípulos (mecánica futura).",
              techniqueChoice: ["sword_t4", "body_t4", "fire_t4", "lightning_t4", "formation_t4"]
            },
            {
              nombre: "Gran Anciano", // GRADO 5
            pcsRequeridos: 2500,
            desafioRivalId: "guardian_gran_anciano_1",
            beneficios: "Asignación semanal de Piedras Espirituales, puede dirigir grandes grupos de discípulos (mecánica futura).",
            techniqueChoice: ["sword_t5", "body_t5", "fire_t5", "lightning_t5", "formation_t5", "movement_t5"]
          },
          {
            nombre: "Maestro de Secta", // GRADO 6
            pcsRequeridos: 5000,
            desafioRivalId: "guardian_maestro_1",
            beneficios: "Asignación semanal de Piedras Espirituales, puede dirigir la secta completa (mecánica futura).",
            techniqueChoice: ["sword_t6", "body_t6", "fire_t6", "lightning_t6", "formation_t6", "movement_t6"]
          },
          // === NUEVOS RANGOS AÑADIDOS ===
          {
            nombre: "Patriarca", // GRADO 7
            pcsRequeridos: 10000,
            desafioRivalId: "guardian_patriarca_1", // Necesitarías definir este rival
            beneficios: "Tu influencia trasciende la secta. Obtienes acceso a dominios secretos.",
            techniqueChoice: ["sword_t7", "body_t7", "fire_t7", "lightning_t7", "formation_t7", "movement_t7"]
          },
          {
            nombre: "Soberano Inmortal", // GRADO 8
            pcsRequeridos: 25000,
            desafioRivalId: "guardian_soberano_1", // Necesitarías definir este rival
            beneficios: "Tu nombre es leyenda. El mundo mortal ya no puede contenerte.",
            techniqueChoice: ["sword_t8", "body_t8", "fire_t8", "lightning_t8", "formation_t8", "movement_t8"]
          },
          {
            nombre: "Soberano del Dao", // GRADO 9
            pcsRequeridos: 50000,
            desafioRivalId: "guardian_dao_1", // Necesitarías definir este rival
            beneficios: "Te has fusionado con el Gran Dao. Eres uno con la creación.",
            techniqueChoice: ["sword_t9"] // Ejemplo con una sola técnica definitiva
          },
          ],
          npcs: {
            guia_lin: {
              nombre: "Guía Lin",
              rol: "Maestro de Reclutas",
              dialogoInicial:
                "Bienvenido, joven aspirante... ¿Estás listo para empezar? Compra Items con Piedras espirituales,aprende técnicas, completa misiones y sube de rango en la secta",
                
              misionesOfrecidas: [
                "mision_recolectar_hierbas_1", // Aunque la entrega sea a Yao, Lin puede ofrecerla
                "mision_eliminar_demonios_1",
                "mision_lobos_bosque_1", // Nueva misión ofrecida por Lin
                "mision_cultivador_hostil_1", // Nueva misión ofrecida por Lin
                "mision_componentes_alquimia_1",
                "mision_investigar_anomalia_1",
                "mision_cazar_bestia_especifica_1",
                "mision_escolta_mercader_1",
                "mision_recuperar_artefacto_1",
                // ... añade más ID de misiones que Lin ofrezca
              ],
            },
            admin_yao: {
              nombre: "Administrador Yao",
              rol: "Intendente de la Secta",
              dialogoInicial:
                "Entrega recursos valiosos o completa encargos para ganar Puntos de Contribución. También puedes adquirir algunos suministros aquí.",
              aceptaRecursos: [
                "Hierbas Medicinales",
                "Cristales de Qi",
                "Núcleo de Bestia Menor",
              ], // ...etc.
              tiendaSectaId: "tienda_secta_basica",
              misionesOfrecidas: [
                "mision_escorpiones_desierto_1", // Nueva misión ofrecida por Yao
                // ... añade más ID de misiones que Yao ofrezca
              ],
            },
          },
        };
        const MISIONES_DATA = {
          mision_recolectar_hierbas_1: {
            titulo: "Suministros para la Enfermería",
            descripcion:
              "La hermana mayor Mei necesita 10 Hierbas Medicinales para reponer las existencias de la enfermería. Recolecta Hierbas Medicinales y entrégaselas al Administrador Yao.",
            objetivo: {
              tipo: "entregar_item",
              item: "Hierbas Medicinales",
              cantidad: 10,
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 50,
              exp: 100,
              items: { "Piedras Espirituales": 20 },
            },
            npcInicio: "guia_lin",
          },
          mision_eliminar_demonios_1: {
              titulo: "Limpiando la pradera de la secta",
              descripcion:
              "Pequeños demonios han estado merodeando en la pradera cercana al sur de la secta. Elimina 5 Demonios Menores para asegurar el área y reporta tu éxito al Guía Lin.",
              objetivo: {
                  tipo: "eliminar_enemigo",
                  enemigoTipo: "monster",
                  cantidad: 5,
                  nombreDisplay: "Demonio Menor",
                  npcEntrega: "guia_lin",
              },
              recompensa: {
                  pcs: 75,
                  exp: 150,
                  items: { "Piedras Espirituales": 30 },
              },
              npcInicio: "guia_lin", // Ahora esta es la última propiedad
          },
          mision_componentes_alquimia_1: {
            titulo: "Medicina Urgente",
            descripcion:
              "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Raíces de Fuego Terrenal' para una píldora vital. Se dice que crecen en zonas con fluctuaciones elementales.",
            objetivo: {
              tipo: "recolectar_multiples_items",
              items: [
                { nombre: "Flor de Luna Escarchada", cantidad: 3 },
                { nombre: "Raíz de Fuego Terrenal", cantidad: 2 },
              ],
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 120,
              exp: 250,
              items: {
                "Píldora de Recuperación Menor": 2,
                "Piedras Espirituales": 50,
              },
            },
            npcInicio: "guia_lin",
            requisitoRango: "Discípulo Externo",
          },
          
          
          /* mision_escolta_mercader_1: {
            titulo: "Protección Mercantil",
            descripcion:
              "Un mercader aliado de la secta necesita una escolta para atravesar el Desfiladero Sombrío, conocido por sus bandidos. Asegúrate de que llegue a salvo al Puesto Comercial del Oeste.",
            objetivo: {
              tipoSimplificado: "eliminar_enemigos_en_area",
              enemigoTipo: "bandido_desfiladero",
              cantidad: 5,
              areaNombre: "Desfiladero Sombrío",
              npcReporte: "admin_yao",
            },
            recompensa: {
              pcs: 250,
              exp: 500,
              items: {
                "Mapa del Tesoro Fragmentado": 1,
                "Piedras Espirituales": 150,
              },
            },
            npcInicio: "guia_lin",
            requisitoRango: "Discípulo Interno",
          }, */
          mision_recuperar_artefacto_1: {
            titulo: "El Compás Espiritual Perdido",
            descripcion:
              "Un antiguo Compás Espiritual, vital para la navegación en las Ruinas Olvidadas, fue robado por cultivadores renegados. Infíltrate en su campamento en las colinas y recupera el artefacto.",
            objetivo: {
              tipo: "derrotar_mini_boss_y_recuperar_item",
              enemigoMiniBossId: "lider_renegado_1",
              itemArtefacto: "Compás Espiritual Antiguo",
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 300,
              exp: 600,
              items: {
                "Manual de Formación Básica": 1,
                "Piedras Espirituales": 200,
              },
            },
            npcInicio: "guia_lin",
            requisitoRango: "Discípulo Interno",
            requisitoNivel: 8,
          },
          mision_desafio_interno_1: {
            titulo: "Prueba de Discípulo Interno",
            descripcion:
              "Para ser reconocido como Discípulo Interno, debes demostrar tu fuerza venciendo al Guardián de la Prueba, Han Li. Encuéntralo en la arena de desafíos de la secta.",
            objetivo: {
              tipo: "derrotar_npc_especifico",
              npcId: "rival_interno_1",    
              npcEntrega: "guia_lin", 
            },
            recompensa: { pcs: 200, exp: 300, nuevoRango: "Discípulo Interno" },
            autoActivarAlCumplirRequisitos: true,
          },
          mision_desafio_principal_1: {
            titulo: "Prueba de Discípulo Principal",
            descripcion:
              "La Anciana Shui espera en la arena. Demuestra que eres digno del rango de Discípulo Principal.",
            objetivo: {
              tipo: "derrotar_npc_especifico",
              npcId: "rival_principal_1",
              npcEntrega: "guia_lin",
            },
            recompensa: { pcs: 500, exp: 800, nuevoRango: "Discípulo Principal" },
            autoActivarAlCumplirRequisitos: true,
          },
          // Misiones de Ejemplo por Nivel:
          mision_lobos_bosque_1: {
            titulo: "Amenaza Lupina",
            descripcion:
              "Una manada de Lobos del Bosque se ha vuelto agresiva. El Guía Lin te pide que elimines 3 de ellos.",
            objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "monster_bosque_lobo",
              cantidad: 3,
              nombreDisplay: "Lobo del Bosque",
              npcEntrega: "guia_lin",
            },
            recompensa: {
              pcs: 100,
              exp: 200,
              items: { "Piedras Espirituales": 10, "Colmillo de Lobo": 1 },
            },
            npcInicio: "guia_lin",
            requisitoNivel: 5, // Se desbloquea al nivel 5
          },
          mision_escorpiones_desierto_1: {
            titulo: "Aguijones Peligrosos",
            descripcion:
              "Los Escorpiones de las Dunas están causando problemas a las caravanas. Elimina 5 y reporta al Administrador Yao.",
            objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "monster_desierto_escorpion",
              cantidad: 5,
              nombreDisplay: "Escorpión de las Dunas",
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 150,
              exp: 350,
              items: { "Piedras Espirituales": 11, "Aguijón de Escorpión": 2 },
            },
            npcInicio: "admin_yao", // Puede ser otro NPC
            requisitoNivel: 10, // Se desbloquea al nivel 10
          },
          mision_cultivador_hostil_1: {
            titulo: "Rivalidad Temprana",
            descripcion:
              "Un Cultivador Novato Hostil ha estado desafiando a discípulos de nuestra secta. El Guía Lin quiere que le des una lección. Derrótalo.",
            objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "cultivator_rival_low",
              cantidad: 10,
              nombreDisplay: "Cultivador Novato Hostil",
              npcEntrega: "guia_lin",
            },
            recompensa: {
              pcs: 200,
              exp: 400,
              items: {
                "Píldora de Recuperación Menor": 1,
                "Piedras Espirituales": 12,
              },
            },
            npcInicio: "guia_lin",
            requisitoNivel: 8,
          },
          // Asegúrate de que las misiones que quieres que se entreguen a un NPC tengan `npcEntrega` en su `objetivo`.
          mision_componentes_alquimia_1: {
            titulo: "Medicina Urgente",
            descripcion:
              "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Raíces de Fuego Terrenal' para una píldora vital. Se dice que crecen en zonas con fluctuaciones elementales. Entrégalas al Administrador Yao.",
            objetivo: {
              tipo: "recolectar_multiples_items",
              items: [
                { nombre: "Flor de Luna Escarchada", cantidad: 3 },
                { nombre: "Raíz de Fuego Terrenal", cantidad: 2 },
              ],
              npcEntrega: "admin_yao",
            },
            recompensa: {
              pcs: 120,
              exp: 250,
              items: {
                "Píldora de Recuperación Menor": 2,
                "Piedras Espirituales": 10,
              },
            },
            npcInicio: "guia_lin",
            requisitoRango: "Discípulo Externo",
          },
          mision_cazar_bestia_especifica_1: {
            titulo: "La Amenaza del Jabalí Colmilludo",
            descripcion:
              "Un Jabalí Colmilludo particularmente agresivo ha estado atacando a los recolectores de la secta en lo profundo del bosque. Caza a esta bestia y trae su 'Colmillo intacto' como prueba al Guía Lin.",
            objetivo: {
              tipo: "cazar_y_recuperar_item_de_loot",
              enemigoTipo: "jabali_colmilludo_alfa",
              itemPrueba: "Colmillo de Jabalí Alfa",
              cantidadItemPrueba: 1,
              npcEntrega: "guia_lin",
            },
            recompensa: {
              pcs: 150,
              exp: 300,
              items: { "Piedras Espirituales": 20, "Carne de Bestia Exótica": 3 },
            },
            npcInicio: "guia_lin",
            requisitoNivel: 10,
          },
          mision_cazar_bestia_especifica_1: {
            titulo: "Elimina el golem de piedra",
            descripcion:
              "Elimina al golem de piedra Geo al sur de la pradera de la secta.Regresa con el Guía Lin luego de eliminarlo.",
            objetivo: {
              objetivo: {
              tipo: "eliminar_enemigo",
              enemigoTipo: "cultivator_rival_low",
              cantidad: 1,
              nombreDisplay: "Cultivador Novato Hostil",
              npcEntrega: "guia_lin",
            },
            },
            recompensa: {
              pcs: 150,
              exp: 300,
              items: { "Piedras Espirituales": 20, "Carne de Bestia Exótica": 3 },
            },
            npcInicio: "guia_lin",
            requisitoNivel: 10,
          },
        };

        const shopData = {
          name: "Pabellón de Tesoros del Dragón Oculto",
          inventory: [
            { itemName: "Hierbas Medicinales", price: 1, stock: 100 },
            { itemName: "Cristales de Qi", price: 1, stock: 100 },
            {
              itemName: "Espada de Hierro",
              type: "equipment",
              category: "weapon",
              attackBonus: 5,
              price: 50,
              stock: 1,
              description: "Una espada básica pero fiable. (+5 Ataque)",
            },
            { itemName: "Rollo: Tajo del Viento Veloz", price: 150, stock: 3 },
          { itemName: "Rollo: Físico de Buey de Piedra", price: 200, stock: 2 },
          { itemName: "Rollo: Matriz de Escudo de Qi", price: 180, stock: 3 },
          { itemName: "Rollo: Chispa Ígnea", price: 170, stock: 3 },
          { itemName: "Rollo: Dedo de Relámpago", price: 220, stock: 2 },
            { itemName: "Rollo: Absorción de Qi Menor", price: 15, stock: 10 },
            { itemName: "Rollo: Corte de Espada Básico", price: 50, stock: 10 },
            { itemName: "Rollo: Conversión de Qi", price: 25, stock: 10 },
            { itemName: "Rollo: Prisión de Hielo", price: 180, stock: 5 },
            { itemName: "Rollo: Golpe de Llamas", price: 170, stock: 5 },
            { itemName: "Rollo: Furia del Trueno", price: 190, stock: 5 },
            { itemName: "Rollo: Dardo Venenoso", price: 150, stock: 5 },
            { itemName: "Rollo: Piel de Piedra", price: 175, stock: 5 },
            { itemName: "Rollo: Paso de las Sombras", price: 220, stock: 3 },
            { itemName: "Rollo: Drenaje de Alma", price: 200, stock: 3 },
            { itemName: "Rollo: Golpe Ciclón", price: 250, stock: 3 },
            { itemName: "Rollo: Lluvia Curativa", price: 210, stock: 3 },
            { itemName: "Rollo: Explosión Mental", price: 230, stock: 3 },
            { itemName: "Rollo: Voluntad de Hierro", price: 200, stock: 3 },
            { itemName: "Rollo: Flecha Celestial", price: 280, stock: 2 },
            { itemName: "Rollo: Abrazo de la Naturaleza", price: 190, stock: 3 },
            { itemName: "Rollo: Rugido de Dragón", price: 300, stock: 2 },
            { itemName: "Rollo: Clon Fantasma", price: 240, stock: 2 },
            { itemName: "Rollo: Cambio Temporal", price: 260, stock: 2 },
            { itemName: "Rollo: Ritual de Sangre", price: 210, stock: 3 },
            { itemName: "Rollo: Aura de Pureza", price: 230, stock: 3 },
            { itemName: "Rollo: Invocar Elemental", price: 320, stock: 1 },
            { itemName: "Rollo: Barrera Mística", price: 220, stock: 3 },
          ],
        };
        const techniqueData = {
          // =================================================================
          // == GRADO 1 (Rango: Discípulo Externo)
          // =================================================================
          "qi_to_hp_conversion_1": { id: "qi_to_hp_conversion_1", name: "Técnica de Conversión de Qi", description: "Permite activar/desactivar la conversión de Maná en HP al cultivar. Mejora la tasa de conversión y eficiencia con cada nivel de refinamiento.", type: "active_refinement_effect", effect: { baseManaCostPerSecond: 2.0, baseHpGainPerSecond: 1.0, hpGainIncreasePerLevel: 2, manaCostReductionPerLevel: 0.1 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 90, levelTimeMultiplier: 1.6 }, refinementCost: { baseTime: 60, materials: { "Cristales de Qi": 5, "Piedras Espirituales": 10 }, levelRequirement: 1 }, icon: "☯️" },
          "qi_absorption_boost_1": { id: "qi_absorption_boost_1", name: "Técnica de Absorción de Qi Menor", description: "Aumenta la cantidad de Qi ganado por segundo al cultivar en 0.5.", type: "passive_cultivation", effect: { statToBoost: "qiPerSecondBase", value: 0.5 }, maxLevel: 100, cultivationSettings: { baseTimeToLevelUp: 60, levelTimeMultiplier: 1.5 }, refinementCost: { baseTime: 30, materials: { "Piedras Espirituales": 20 }, levelRequirement: 1 }, icon: "📜" },
        
          
          // =================================================================
          // == GRADO 1 (Rango: Discípulo Interno) - Nivel Mortal
          // =================================================================
          sword_t1: {
            id: "sword_t1", name: "Tajo del Viento Veloz", icon: "💨",
            description: "Un corte de espada rápido y eficiente. Un pilar del combate básico.",
            type: "active_ability", abilityId: "sword_t1",
            effect: { baseDamageMultiplier: 1.2 }, manaCost: 10,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 90, levelTimeMultiplier: 1.6 },
          },
          body_t1: {
            id: "body_t1", name: "Físico de Buey de Piedra", icon: "🐂",
            description: "Fortalece pasivamente tu cuerpo, aumentando tu Vida Máxima base.",
            type: "passive_stat", effect: { statToBoost: "baseMaxHp", value: 25 },
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 120, levelTimeMultiplier: 1.7 },
          },
          formation_t1: {
            id: "formation_t1", name: "Matriz de Escudo de Qi", icon: "💠",
            description: "Crea un escudo temporal que absorbe una pequeña cantidad de daño.",
            type: "active_ability", abilityId: "formation_t1",
            effect: { shieldValue: 40, duration: 3 }, manaCost: 20,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 100, levelTimeMultiplier: 1.8 },
          },
          fire_t1: {
            id: "fire_t1", name: "Chispa Ígnea", icon: "🔥",
            description: "Lanza una pequeña bola de fuego que causa daño y puede aplicar una quemadura menor.",
            type: "active_ability", abilityId: "fire_t1",
            effect: { baseDamageMultiplier: 0.8, burnDamagePerTurn: 5, burnDuration: 2 }, manaCost: 15,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 110, levelTimeMultiplier: 1.7 },
          },
          lightning_t1: {
              id: "lightning_t1", name: "Dedo de Relámpago", icon: "⚡",
              description: "Un rápido chispazo de relámpago que puede aturdir brevemente al enemigo.",
              type: "active_ability", abilityId: "lightning_t1",
              effect: { baseDamageMultiplier: 0.9, stunChance: 0.2 }, manaCost: 18,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 130, levelTimeMultiplier: 1.8 },
          },

          // =================================================================
          // == GRADO 2 (Rango: Discípulo Principal) - Nivel Terrenal
          // =================================================================
          sword_t2: {
            id: "sword_t2", name: "Estocada Perfora-Armadura", icon: "🗡️",
            description: "Un ataque preciso que ignora una porción de la defensa del enemigo.",
            type: "active_ability", abilityId: "sword_t2",
            effect: { baseDamageMultiplier: 1.1, defensePenetration: 0.25 }, manaCost: 25,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 180, levelTimeMultiplier: 1.6 },
          },
          body_t2: {
            id: "body_t2", name: "Piel de Acero Fundido", icon: "🦾",
            description: "Aumenta pasivamente tu Defensa base, haciéndote más resistente.",
            type: "passive_stat", effect: { statToBoost: "baseDefense", value: 5 },
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 200, levelTimeMultiplier: 1.7 },
          },
          formation_t2: {
            id: "formation_t2", name: "Matriz de Grilletes de Qi", icon: "🔗",
            description: "Una formación que intenta enraizar al enemigo, impidiendo su movimiento y causando daño leve.",
            type: "active_ability", abilityId: "formation_t2",
            effect: { rootDuration: 2, damagePerTurn: 10, rootChance: 0.7 }, manaCost: 30,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 190, levelTimeMultiplier: 1.8 },
          },
          movement_t2: {
            id: "movement_t2", name: "Paso Etéreo", icon: "👟",
            description: "Te mueves como el viento, dándote una alta probabilidad de esquivar el próximo ataque.",
            type: "active_ability", abilityId: "movement_t2",
            effect: { dodgeNextAttack: true }, manaCost: 40,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 220, levelTimeMultiplier: 1.9 },
          },
          fire_t2: {
            id: "fire_t2", name: "Aliento de Dragón Menor", icon: "🐲",
            description: "Exhalas un cono de fuego que quema con mayor intensidad.",
            type: "active_ability", abilityId: "fire_t2",
            effect: { baseDamageMultiplier: 1.0, burnDamagePerTurn: 15, burnDuration: 3 }, manaCost: 35,
            maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 200, levelTimeMultiplier: 1.7 },
          },
          
          // =================================================================
          // == GRADO 3 (Rango: Diácono) - Nivel Celestial
          // =================================================================
          sword_t3: {
              id: "sword_t3", name: "Danza de Espada Ciclónica", icon: "🌪️",
              description: "Giras como un ciclón, golpeando al enemigo múltiples veces en un solo ataque devastador.",
              type: "active_ability", abilityId: "sword_t3",
              effect: { baseDamageMultiplier: 2.5 }, manaCost: 50,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 300, levelTimeMultiplier: 1.6 },
          },
          body_t3: {
              id: "body_t3", name: "Corazón de Voluntad Indomable", icon: "❤️‍🔥",
              description: "Pasivamente, tu voluntad de hierro reduce una porción de todo el daño recibido.",
              type: "passive_stat", effect: { statToBoost: "damageReduction", value: 0.05 }, // Esto necesitará lógica en el cálculo de daño
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 350, levelTimeMultiplier: 1.7 },
          },
          formation_t3: {
              id: "formation_t3", name: "Matriz de Supresión Espiritual", icon: "🕸️",
              description: "Crea un campo que debilita al enemigo, reduciendo su ataque y defensa por varios turnos.",
              type: "active_ability", abilityId: "formation_t3",
              effect: { attackReduction: 15, defenseReduction: 15, duration: 4 }, manaCost: 45,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 320, levelTimeMultiplier: 1.8 },
          },
          lightning_t3: {
              id: "lightning_t3", name: "Jaula de Rayos", icon: "⛓️",
              description: "Encierra al enemigo en una jaula eléctrica, causando daño continuo y con alta probabilidad de aturdir.",
              type: "active_ability", abilityId: "lightning_t3",
              effect: { baseDamageMultiplier: 1.2, damagePerTurn: 20, stunChance: 0.5, duration: 3 }, manaCost: 60,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 380, levelTimeMultiplier: 1.8 },
          },
          movement_t3: {
              id: "movement_t3", name: "Parpadeo de Sombra", icon: "👻",
              description: "Te teletransportas instantáneamente detrás del enemigo para un golpe crítico garantizado.",
              type: "active_ability", abilityId: "movement_t3",
              effect: { baseDamageMultiplier: 2.0, isCritical: true }, manaCost: 55, // isCritical necesitará lógica en battleAction
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 400, levelTimeMultiplier: 1.9 },
          },

          // =================================================================
          // == GRADO 4 (Rango: Anciano) - Nivel Soberano
          // =================================================================
          sword_t4: {
              id: "sword_t4", name: "Intento de Espada del Tirano", icon: "👑",
              description: "Canalizas tu Qi en la espada para liberar una onda de energía que daña y aturde.",
              type: "active_ability", abilityId: "sword_t4",
              effect: { baseDamageMultiplier: 2.8, stunChance: 0.4 }, manaCost: 70,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 500, levelTimeMultiplier: 1.5 },
          },
          body_t4: {
              id: "body_t4", name: "Cuerpo Dorado Inmortal", icon: "🌟",
              description: "Tu cuerpo se vuelve tan duro que regenera vida pasivamente incluso fuera del cultivo.",
              type: "passive_stat", effect: { statToBoost: "passiveHpRegen", value: 0.5 }, // Necesitará lógica en el game tick
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 600, levelTimeMultiplier: 1.6 },
          },
          fire_t4: {
              id: "fire_t4", name: "Sol Abrasador", icon: "☀️",
              description: "Creas un sol en miniatura que explota, causando daño masivo a todos los enemigos.",
              type: "active_ability", abilityId: "fire_t4",
              effect: { baseDamageMultiplier: 2.5, aoe: true }, manaCost: 80,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 550, levelTimeMultiplier: 1.6 },
          },
          lightning_t4: {
              id: "lightning_t4", name: "Llamada del Juicio del Trueno", icon: "🌩️",
              description: "Invocas un rayo celestial que golpea al enemigo, ignorando toda su defensa.",
              type: "active_ability", abilityId: "lightning_t4",
              effect: { baseDamageMultiplier: 2.0, ignoreDefense: true }, manaCost: 75,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 580, levelTimeMultiplier: 1.7 },
          },
          formation_t4: {
              id: "formation_t4", name: "Santuario Dorado Protector", icon: "🏰",
              description: "Una matriz defensiva definitiva que te hace inmune al daño por 2 turnos.",
              type: "active_ability", abilityId: "formation_t4",
              effect: { immunityDuration: 2 }, manaCost: 100,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 620, levelTimeMultiplier: 1.8 },
          },
          
            // =================================================================
          // == GRADO 5 (Rango: Gran Anciano) - Nivel Transcendente
          // =================================================================
          sword_t5: {
              id: "sword_t5", name: "Corte que Divide Cielos y Tierra", icon: "⚔️",
              description: "Una técnica legendaria que corta a través de cualquier defensa y causa daño verdadero.",
              type: "active_ability", abilityId: "sword_t5",
              effect: { baseDamageMultiplier: 4.0, trueDamage: true, criticalChance: 0.3 }, manaCost: 120,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 800, levelTimeMultiplier: 1.4 },
          },
          body_t5: {
              id: "body_t5", name: "Constitución de Dragón Ancestral", icon: "🐉",
              description: "Tu cuerpo alcanza la perfección dracónica, ganando inmunidad a efectos de estado y regeneración poderosa.",
              type: "passive_stat", effect: { statToBoost: "statusImmunity", value: true, passiveHpRegen: 2.0 },
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 900, levelTimeMultiplier: 1.5 },
          },
          fire_t5: {
              id: "fire_t5", name: "Llama del Fénix Renaciente", icon: "🔥",
              description: "Invocas el fuego sagrado del fénix que causa daño masivo y puede resucitarte al morir.",
              type: "active_ability", abilityId: "fire_t5",
              effect: { baseDamageMultiplier: 3.5, aoe: true, reviveChance: 0.25 }, manaCost: 150,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 850, levelTimeMultiplier: 1.5 },
          },
          lightning_t5: {
              id: "lightning_t5", name: "Tribulación de los Nueve Cielos", icon: "🌩️",
              description: "Canalizas el poder de la tribulación celestial para devastar a todos los enemigos.",
              type: "active_ability", abilityId: "lightning_t5",
              effect: { baseDamageMultiplier: 3.0, aoe: true, paralyzeChance: 0.6, duration: 2 }, manaCost: 140,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 880, levelTimeMultiplier: 1.6 },
          },
          formation_t5: {
              id: "formation_t5", name: "Matriz de Reversión del Cosmos", icon: "🌌",
              description: "Una formación que invierte el daño recibido, convirtiéndolo en curación.",
              type: "active_ability", abilityId: "formation_t5",
              effect: { damageToHealingDuration: 3, reflectDamage: 0.5 }, manaCost: 180,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 950, levelTimeMultiplier: 1.7 },
          },
          movement_t5: {
              id: "movement_t5", name: "Paso del Vacío Infinito", icon: "🌀",
              description: "Te mueves entre dimensiones, volviéndote intangible y atacando desde múltiples ángulos.",
              type: "active_ability", abilityId: "movement_t5",
              effect: { baseDamageMultiplier: 2.5, intangibleTurns: 2, multiHit: 3 }, manaCost: 130,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 820, levelTimeMultiplier: 1.8 },
          },

          // =================================================================
          // == GRADO 6 (Rango: Patriarca) - Nivel Mítico
          // =================================================================
          sword_t6: {
              id: "sword_t6", name: "Espada del Emperador Celestial", icon: "👑",
              description: "El arte supremo de la espada que puede cortar a través del destino mismo.",
              type: "active_ability", abilityId: "sword_t6",
              effect: { baseDamageMultiplier: 6.0, ignoreAllEffects: true, executeThreshold: 0.2 }, manaCost: 200,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1200, levelTimeMultiplier: 1.3 },
          },
          body_t6: {
              id: "body_t6", name: "Cuerpo Inmortal de Jade", icon: "💎",
              description: "Tu cuerpo trasciende la mortalidad, volviéndose prácticamente indestructible.",
              type: "passive_stat", effect: { statToBoost: "damageReduction", value: 0.25, deathSaveChance: 0.5 },
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1400, levelTimeMultiplier: 1.4 },
          },
          fire_t6: {
              id: "fire_t6", name: "Incineración del Mundo Mortal", icon: "🌋",
              description: "Reduces todo a cenizas con el fuego que arde desde el núcleo de la creación.",
              type: "active_ability", abilityId: "fire_t6",
              effect: { baseDamageMultiplier: 5.0, aoe: true, burnDamagePerTurn: 100, burnDuration: 5 }, manaCost: 250,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1300, levelTimeMultiplier: 1.4 },
          },
          lightning_t6: {
              id: "lightning_t6", name: "Decreto del Señor del Trueno", icon: "⚡",
              description: "Como señor de las tormentas, tu palabra se convierte en ley absoluta.",
              type: "active_ability", abilityId: "lightning_t6",
              effect: { baseDamageMultiplier: 4.5, aoe: true, silenceDuration: 3, stunChance: 0.8 }, manaCost: 220,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1350, levelTimeMultiplier: 1.5 },
          },
          formation_t6: {
              id: "formation_t6", name: "Matriz del Sello del Demonio", icon: "🔒",
              description: "Sella completamente al enemigo, impidiendo todas sus acciones por varios turnos.",
              type: "active_ability", abilityId: "formation_t6",
              effect: { sealDuration: 4, damagePerTurn: 50 }, manaCost: 300,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1500, levelTimeMultiplier: 1.6 },
          },
          movement_t6: {
              id: "movement_t6", name: "Omnipresencia Divina", icon: "👁️",
              description: "Existes en múltiples lugares simultáneamente, atacando desde todas partes.",
              type: "active_ability", abilityId: "movement_t6",
              effect: { baseDamageMultiplier: 3.0, unavoidable: true, multiHit: 5 }, manaCost: 280,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 1250, levelTimeMultiplier: 1.7 },
          },

          // =================================================================
          // == GRADO 7 (Rango: Soberano Supremo) - Nivel Legendario
          // =================================================================
          sword_t7: {
              id: "sword_t7", name: "Lamento del Fin del Mundo", icon: "🗡️",
              description: "Una técnica que lleva la esencia de la destrucción apocalíptica.",
              type: "active_ability", abilityId: "sword_t7",
              effect: { baseDamageMultiplier: 8.0, aoe: true, ignoreAllDefenses: true, lifeSteal: 0.5 }, manaCost: 350,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2000, levelTimeMultiplier: 1.2 },
          },
          body_t7: {
              id: "body_t7", name: "Forma del Ancestro Primordial", icon: "🌟",
              description: "Tu cuerpo alcanza la forma perfecta de los antiguos dioses creadores.",
              type: "passive_stat", effect: { statToBoost: "allStats", multiplier: 2.0, regenAllPerTurn: true },
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2500, levelTimeMultiplier: 1.3 },
          },
          fire_t7: {
              id: "fire_t7", name: "Génesis Ígneo", icon: "🔥",
              description: "El fuego que creó el universo, capaz de destruir y recrear la realidad.",
              type: "active_ability", abilityId: "fire_t7",
              effect: { baseDamageMultiplier: 7.0, aoe: true, resetEnemyBuffs: true, burnDamagePerTurn: 200 }, manaCost: 400,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2200, levelTimeMultiplier: 1.3 },
          },
          lightning_t7: {
              id: "lightning_t7", name: "Cólera del Emperador Celestial", icon: "⚡",
              description: "La ira divina se manifiesta como rayos que juzgan a todos los seres.",
              type: "active_ability", abilityId: "lightning_t7",
              effect: { baseDamageMultiplier: 6.5, aoe: true, judgmentEffect: true, chainLightning: 10 }, manaCost: 380,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2300, levelTimeMultiplier: 1.4 },
          },
          formation_t7: {
              id: "formation_t7", name: "Matriz del Caos Primordial", icon: "🌀",
              description: "Invocas el caos que existía antes de la creación para deshacer a tus enemigos.",
              type: "active_ability", abilityId: "formation_t7",
              effect: { randomCatastrophicEffects: true, reality_distortion: 5 }, manaCost: 450,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2800, levelTimeMultiplier: 1.5 },
          },
          movement_t7: {
              id: "movement_t7", name: "Danza del Tejido Espacio-Tiempo", icon: "🌌",
              description: "Manipulas el espacio y el tiempo para existir en múltiples momentos simultáneamente.",
              type: "active_ability", abilityId: "movement_t7",
              effect: { baseDamageMultiplier: 4.0, timeLoop: 3, spacialDistortion: true }, manaCost: 420,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 2400, levelTimeMultiplier: 1.6 },
          },

          // =================================================================
          // == GRADO 8 (Rango: Emperador Inmortal) - Nivel Épico
          // =================================================================
          sword_t8: {
              id: "sword_t8", name: "Decreto Imperial: Extinción", icon: "👑",
              description: "Como emperador, tu palabra es ley absoluta. Decretas la extinción de tus enemigos.",
              type: "active_ability", abilityId: "sword_t8",
              effect: { baseDamageMultiplier: 12.0, instantKillChance: 0.3, ignoreAllProtections: true }, manaCost: 500,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 3500, levelTimeMultiplier: 1.1 },
          },
          body_t8: {
              id: "body_t8", name: "Avatar del Dao Eterno", icon: "☯️",
              description: "Te conviertes en la manifestación física del Dao, trascendiendo todas las limitaciones.",
              type: "passive_stat", effect: { statToBoost: "transcendence", value: true, immuneToAll: true },
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 4000, levelTimeMultiplier: 1.2 },
          },
          fire_t8: {
              id: "fire_t8", name: "Apocalipsis de Llamas Divinas", icon: "🔥",
              description: "El fuego que consume universos enteros, purificando la existencia misma.",
              type: "active_ability", abilityId: "fire_t8",
              effect: { baseDamageMultiplier: 10.0, aoe: true, purificationEffect: true, universeScaleDamage: true }, manaCost: 600,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 3800, levelTimeMultiplier: 1.2 },
          },
          lightning_t8: {
              id: "lightning_t8", name: "Tribulación del Fin de los Tiempos", icon: "⚡",
              description: "Invocas la tribulación final que marcará el fin de una era.",
              type: "active_ability", abilityId: "lightning_t8",
              effect: { baseDamageMultiplier: 9.0, aoe: true, eraEndingEffect: true, temporalDamage: true }, manaCost: 550,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 3600, levelTimeMultiplier: 1.3 },
          },
          formation_t8: {
              id: "formation_t8", name: "Matriz de Reescritura de la Realidad", icon: "📜",
              description: "Reescribes las leyes fundamentales de la realidad a tu favor.",
              type: "active_ability", abilityId: "formation_t8",
              effect: { realityRewrite: true, lawManipulation: true, existenceControl: 7 }, manaCost: 700,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 4500, levelTimeMultiplier: 1.4 },
          },
          movement_t8: {
              id: "movement_t8", name: "Trascendencia Dimensional", icon: "🌀",
              description: "Trasciendes las limitaciones dimensionales, existiendo en todas las dimensiones.",
              type: "active_ability", abilityId: "movement_t8",
              effect: { baseDamageMultiplier: 6.0, dimensionalTravel: true, omnipresence: true }, manaCost: 650,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 4200, levelTimeMultiplier: 1.5 },
          },

          // =================================================================
          // == GRADO 9 (Rango: Soberano del Dao) - Nivel Mítico Supremo
          // =================================================================
          sword_t9: {
              id: "sword_t9", name: "Corte del Origen Absoluto", icon: "⚔️",
              description: "Cortas a través del origen mismo de la existencia, negando la realidad de tus enemigos.",
              type: "active_ability", abilityId: "sword_t9",
              effect: { baseDamageMultiplier: 20.0, existenceNegation: true, conceptualDamage: true }, manaCost: 800,
              maxLevel: 10, cultivationSettings: { baseTimeToLevelUp: 6000, levelTimeMultiplier: 1.0 },
          },
        };
        
// ===  DICCIONARIO DE HABILIDADES DE ENEMIGOS ===
      const enemyAbilityData = {
        poison_sting: {
          name: "Aguijón Venenoso",
          type: "debuff_damage",
          logMessage: (enemyName, damage, poisonDmg, duration) => `¡${enemyName} te clava su Aguijón Venenoso! Recibes ${damage} de daño y quedas envenenado por ${poisonDmg} de daño durante ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 0.5, // El golpe inicial no es tan fuerte
            poison: {
              damagePerTurn: 10, // Daño base del veneno
              duration: 3
            }
          }
        },
        armor_break: {
            name: "Golpe Rompe-Armadura",
            type: "debuff_stat",
            logMessage: (enemyName, damage, reduction, duration) => `¡${enemyName} usa un Golpe Rompe-Armadura! Recibes ${damage} de daño y tu defensa se reduce en ${reduction} por ${duration} turnos.`,
            effect: {
                baseDamageMultiplier: 1.2,
                debuff: {
                    stat: "defense",
                    amount: 10,
                    duration: 3
                }
            }
        },
        intimidating_roar: {
            name: "Rugido Intimidante",
            type: "debuff_stat_no_damage",
            logMessage: (enemyName, reduction, duration) => `¡${enemyName} suelta un Rugido Intimidante! Tu ataque se reduce en ${reduction} por ${duration} turnos.`,
            effect: {
                debuff: {
                    stat: "attack",
                    amount: 8,
                    duration: 3
                }
            }
        },
        curacion_basica: {
            name: "Curación",
            type: "buff",
            logMessage: (enemyName,healAmount) => `¡${enemyName} Toma una medicina y se cura ${healAmount}.`,
            effect: {
                healAmount:50,
            }
        },
        life_drain: {
            name: "Drenaje Vital",
            type: "heal_damage",
            logMessage: (enemyName, damage, healAmount) => `¡${enemyName} usa Drenaje Vital! Te roba ${damage} de vida y se cura ${healAmount}.`,
            effect: {
                baseDamageMultiplier: 0.8,
                lifesteal: 0.5 // 50% del daño infligido se convierte en curación para el enemigo
            }
        }
      };
      
 
        const entityTypes = {
          //FIJOS
          shop: {
            symbol: "🏪",
            name: "Tienda Misteriosa",
            spriteUrl: "img/shop.png",
            interaction: "browse",
            type: "shop", // 'type' es importante para la interacción
            // fixedX: 12, // Podrías tener esto
            // fixedY: 13, // O esto
            fixedLocation: { x: 12, y: 13 }, // O esto (preferiblemente esto)
            discovered: true, // ¡IMPORTANTE para que se muestre desde el inicio!
          },

          secta_entrada_principal: {
            symbol: "⛩️",
            name: "Salón Principal de la Secta",
            spriteUrl: "img/secta.png",
            interaction: "access_sect_hall",
            // fixedX: 12, // Si tenías esto antes
            // fixedY: 15, // Si tenías esto antes
            // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
            fixedLocation: { x: 15, y: 15 }, // O las coordenadas correctas para tu secta
            discovered: true,
          },

          // --- ELEMENTOS DECORATIVOS ---
          deco_pino: {
            symbol: "🌳",
            name: "Pino",
            spriteUrl: "img/pino.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_arbol_pequeño: {
            symbol: "🌳",
            name: "Pino",
            spriteUrl: "img/arbol.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_arbol_normal: {
            symbol: "",
            name: "Otro arbol",
            spriteUrl: "img/arbol.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_desierto: {
            symbol: "🪨",
            name: "Roca Musgosa",
            spriteUrl: "img/deco_desierto.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_agua_estancada: {
            
            name: "Agua Estancada",
            spriteUrl: "img/agua_estancada.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_arbol_pantano: {
            symbol: "🌳",
            name: "Arbol Pantano",
            spriteUrl: "img/arbol_pantano.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          },
          deco_ruina_pilar: {
            symbol: "🏛",
            name: "Pilar Caído",
            spriteUrl: "img/columnas.png",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          }, // Usar un símbolo diferente si '🏛️' ya está en uso
          deco_flor_rara: {
            symbol: "🌸",
            name: "Flor Luminiscente",
            isDecorative: true,
            noInteraction: true,
            discovered: true,
          }, // Diferente de tu lugar de cultivo
          // ... añade más según necesites
          //NPCS
       
          npc_secta_guia: {
            symbol: "👨‍🏫",
            name: "Guía Lin",
            spriteUrl: "img/guia_lin.png",
            interaction: "talk_secta_npc",
            npcId: "guia_lin",
            fixedLocation: { x: 13, y: 15 },
            discovered: true,
          },
          npc_secta_admin: {
            symbol: " 👴",
            name: "Administrador Yao",
            spriteUrl: "img/adm_yao.png",
            interaction: "talk_secta_npc",
            npcId: "admin_yao",
            fixedLocation: { x: 17, y: 15 },
            discovered: true,
          },
          rival_interno_1: {
            symbol: "😠",
            name: "Han Li (Guardián Interno)",
            spriteUrl: "img/lobo_bosque.png",
            typeOverride: "monster",
            hp: 250,
            attack: 60,
            defense: 15,
            exp: 150,
            maxHp: 250,
            isSectChallengeRival: true,
            npcId: "rival_interno_1",
            fixedLocation: { x: 5, y: 12 },
          },
          rival_principal_1: {
            symbol: "😡",
            name: "Anciana Shui (Prueba Principal)",
            typeOverride: "monster",
            hp: 600,
            attack: 90,
            defense: 25,
            exp: 400,
            maxHp: 600,
            isSectChallengeRival: true,
            npcId: "rival_principal_1",
            fixedLocation: { x: 4, y: 12 },
            specialChance: 0.2,
            specialAttackMultiplier: 1.6,
          },
          //== FIN NPC===
          //RECURSOS
          cristal_qi: {
            symbol: "💎",
            name: "Cristal de Qi",
            spriteUrl: "img/cristal_de_qi.png",
            reward: "Cristales de Qi",
            interaction: "collect_resource",
          },
          piedras_espirituales: {
            symbol: "💎",
            name: "Piedra espiritual",
            spriteUrl: "img/piedra_esp.png",
            reward: "Piedras Espirituales",
            interaction: "collect_resource",
          },
          cultivation: {
            symbol: "🌸",
            name: "Lugar de Cultivo",
            benefit: "mana",
            manaGain: 20,
            interaction: "meditate_spot",
          },
          resource_hierbas_bosque: {
            symbol: "🌿", // <--- ¡ASEGÚRATE DE QUE ESTO ESTÉ!
            name: "Hierbas del Bosque Profundo",
            spriteUrl: "img/hierbas.png",
            type: "resource",
            reward: "Hierbas Medicinales",
            interaction: "collect_resource",
          },

           // === NUEVAS ENTIDADES DE TRANSICIÓN ===
          transition_ruins_entrance: {
            symbol: "🌀",
            name: "Entrada a las Ruinas",
            spriteUrl: "img/entrada_ruinas.png", // Crea o usa una imagen para el portal
            interaction: "transition",
            fixedLocation: { x: 45, y: 45 }, // Ubicación en el mundo principal
            targetX: 501, // Coordenada X de destino (dentro de la zona de ruinas)
            targetY: 501, // Coordenada Y de destino
            discovered: true,
          },
          transition_ruins_exit: {
            symbol: "🌀",
            name: "Salida de las Ruinas",
            spriteUrl: "img/portal.png",
            interaction: "transition",
            fixedLocation: { x: 501, y: 500 }, // Ubicación DENTRO de las ruinas
            targetX: 45,  // Coordenada X de destino (de vuelta al mundo principal)
            targetY: 46,  // Coordenada Y de destino (aparece al lado de la entrada)
            discovered: true,
          },


//ENEMIGOS
          monster: {
            symbol: "👹",
            name: "Demonio Menor",
            spriteUrl: "img/demonio_menor.png",
            level:2,
            hp: 60,
            attack: 30,
            defense: 2,
            exp: 25,
            maxHp: 60,
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
              { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            ],
          },
          monster_secta_debil: {
            symbol: "🐾",
            name: "Bestia Menor de Pradera",
            spriteUrl: "img/monstruo_pradera.png",
            level:1,
            hp: 40,
            attack: 30,
            defense: 1,
            exp: 12,
            maxHp: 40,
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            ],
          },
          monster_bosque_lobo: {
            symbol: "🐺",
            name: "Lobo del Bosque",
            spriteUrl: "img/lobo_bosque.png",
            hp: 70,
            level:2,
            attack: 40,
            defense: 3,
            exp: 20,
            maxHp: 70,
            lootTable: [
              { itemName: "Colmillo de Lobo", quantity: [1, 1], chance: 0.4 },
              {
                itemName: "Flor de Luna Escarchada",
                quantity: [1, 2],
                chance: 0.6,
              },
              { itemName: "Carne Fresca", quantity: [1, 2], chance: 0.6 },
              { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            ],
          },
          monster_bosque_arana: {
            symbol: "🕷️",
            name: "Araña Tejesombras",
            hp: 50,
            level:1,
            attack: 45,
            defense: 5,
            exp: 18,
            maxHp: 50,
            lootTable: [
              { itemName: "Seda de Araña", quantity: [1, 3], chance: 0.7 },
              { itemName: "Veneno Débil", quantity: [1, 1], chance: 0.2 },
              { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            ],
          },

          monster_desierto_escorpion: {
            symbol: "🦂",
            name: "Escorpión de las Dunas",
            hp: 90,
            level:5,
            attack: 30,
            defense: 8,
            exp: 35,
            maxHp: 90,
            specialChance: 0.35,
            specialAttackMultiplier: 1.8,
            aabilities: [
          {
            abilityId: "poison_sting", // ID de la habilidad en enemyAbilityData
            chance: 0.40 // 40% de probabilidad de usar esta habilidad en su turno
          }
        ],
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "Aguijón de Escorpión", quantity: [1, 1], chance: 0.5 },
              { itemName: "Quitina Resistente", quantity: [1, 1], chance: 0.3 },
              { itemName: "Piedras Espirituales", quantity: [2, 4], chance: 1 },
            ],
          },
          monster_desierto_golem_arena: {
            symbol: "🧱",
            name: "Golem de Tormenta de Arena",
            hp: 200,
            level:9,
            attack: 35,
            defense: 15,
            exp: 80,
            maxHp: 200,
            specialChance: 0.35,
            specialAttackMultiplier: 1.8,
            abilities: [
              {
                name: "Tornado de arena",
                damageMultiplier: 2.0,
                chance: 0.2,
                type: "area_attack_simulated",
              },
              {
                name: "stone_skin_1",
                effect: { defenseBoost: 15, duration: 3, manaCost: 25 },
                chance: 0.2,
                type: "area_attack_simulated",
              },
            ],
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "Núcleo de Arena", quantity: [1, 1], chance: 0.6 },
              { itemName: "Fragmento Desértico", quantity: [1, 2], chance: 0.4 },
              { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
            ],
          },
          monster_cienaga_serpiente: {
            symbol: "🐍",
            name: "Serpiente de Ciénaga",
            hp: 60,
            level:3,
            attack: 28,
            defense: 2,
            exp: 22,
            maxHp: 60,
            specialChance: 0.35,
            specialAttackMultiplier: 1.8,
            abilities: [
              {
                name: "Mordida Venenosa",
                damageMultiplier: 2.0,
                chance: 0.4,
                type: "area_attack_simulated",
              },
            ],
            lootTable: [
              { itemName: "Escama de Serpiente", quantity: [1, 2], chance: 0.5 },
              {
                itemName: "Raíz de Fuego Terrenal",
                quantity: [1, 1],
                chance: 0.3,
              },
              { itemName: "Veneno de Ciénaga", quantity: [1, 1], chance: 0.3 },
              { itemName: "Piedras Espirituales", quantity: [2, 4], chance: 1 },
            ],
          },
          cultivator_rival_low: {
            symbol: "😠",
            name: "Cultivador Novato Hostil",
            spriteUrl: "img/cultivador_hostil.png",
            hp: 150,
            level:5,
            attack: 50,
            defense: 5,
            exp: 80,
            maxHp: 150,
            specialChance: 0.2,
            specialAttackMultiplier: 1.5,
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
              { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            ],
          },
          monster_alpha: {
            symbol: "🐺",
            name: "Lobo Alfa",
            spriteUrl: "img/lobo_alfa.png",
            hp: 200,
            level:9,
            attack: 60,
            defense: 4,
            exp: 35,
            maxHp: 200,
            abilities: [
                { abilityId: "armor_break", chance: 0.3 },
                { abilityId: "intimidating_roar", chance: 0.2 }
            ],
            lootTable: [
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
              { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
              {
                itemName: "Núcleo de Bestia Menor",
                quantity: [1, 1],
                chance: 0.25,
              },
              { itemName: "Cristal de Hielo", quantity: [1, 2], chance: 0.1 },
              { itemName: "Esencia de Fuego", quantity: [1, 2], chance: 0.1 },
              { itemName: "Piedras Espirituales", quantity: [4, 10], chance: 1 },
            ],
          },
          cultivator_adept_hostile: {
            symbol: "😡",
            name: "Cultivador Adepto Agresivo",
            hp: 400,
            level:15,
            attack: 80,
            defense: 10,
            exp: 250,
            maxHp: 400,
            specialChance: 0.25,
            specialAttackMultiplier: 1.7,
            healChance: 0.1,
            lootTable: [
              { itemName: "Piedras Espirituales", quantity: [1, 10], chance: 1 },
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
              { itemName: "Venenos Mortales", quantity: [1, 3], chance: 0.05 },
              { itemName: "Fragmentos de Jade", quantity: [1, 2], chance: 0.02 },
              { itemName: "Esencia Oscura", quantity: [1, 1], chance: 0.05 },
              {
                itemName: "Rollo: Dardo Venenoso",
                quantity: [1, 1],
                chance: 0.05,
              },
              {
                itemName: "Rollo: Piel de Piedra",
                quantity: [1, 1],
                chance: 0.05,
              },
              {
                itemName: "Rollo: Voluntad de Hierro",
                quantity: [1, 1],
                chance: 0.015,
              },
              {
                itemName: "Rollo: Flecha Celestial",
                quantity: [1, 1],
                chance: 0.05,
              },
              {
                itemName: "Rollo: Abrazo de la Naturaleza",
                quantity: [1, 1],
                chance: 0.01,
              },
              {
                itemName: "Rollo: Rugido de Dragón",
                quantity: [1, 1],
                chance: 0.01,
              },
              {
                itemName: "Rollo: Clon Fantasma",
                quantity: [1, 1],
                chance: 0.01,
              },
            ],
          },

          flor_luna_escarchada_guardian: {
            symbol: "❄️",
            name: "Espíritu de Hielo Protector",
            typeOverride: "monster",
            hp: 120,
            level:5,
            attack: 35,
            defense: 10,
            exp: 40,
            maxHp: 120,
            lootTable: [
              {
                itemName: "Flor de Luna Escarchada",
                quantity: [1, 2],
                chance: 0.8,
              },
              { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            ],
          },
          raiz_fuego_terrenal_elemental: {
            symbol: "🔥",
            name: "Elemental de Magma Menor",
            typeOverride: "monster",
            hp: 150,
            level:7,
            attack: 40,
            defense: 5,
            exp: 45,
            maxHp: 150,
            lootTable: [
              {
                itemName: "Raíz de Fuego Terrenal",
                quantity: [1, 1],
                chance: 0.7,
              },
              {
                itemName: "Piedras Espirituales",
                quantity: [5, 10],
                chance: 0.5,
              },
            ],
          },
          bandido_desfiladero: {
            symbol: "😠",
            name: "Bandido del Desfiladero",
            typeOverride: "monster",
            hp: 180,
            level:9,
            attack: 45,
            defense: 10,
            exp: 60,
            maxHp: 180,
            healChance: 0.15,
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [10, 30],
                chance: 0.5,
              },
              { itemName: "Daga Oxidada", quantity: [1, 1], chance: 0.2 },
            ],
            fixedLocation: { x: 25, y: 40 },
          },

          esqueleto_podrido: {
            symbol: "💀",
            name: "Esqueleto podrido",
            spriteUrl: "img/esqueleto_1.png",
            typeOverride: "monster",
            hp: 180,
            level:9,
            attack: 45,
            defense: 10,
            exp: 60,
            maxHp: 180,
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [8, 10],
                chance: 0.8,
              },
              
            ],
          },
             jabali_alfa_1: { 
              symbol: "🐗",
              name: "Jabalí Colmilludo",
              spriteUrl: "img/jabali.png",
              typeOverride: "monster",
              hp: 300, 
              level:9, 
              attack: 55, 
              defense: 20, 
              exp: 120, 
              maxHp: 300,
              
              lootTable: [
                
                { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
                
                { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
              ],
              fixedLocation: { x: 53, y: 26 },
          },
          jabali_alfa_2: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 55, y: 26 },
          },
          jabali_alfa_3: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 57, y: 26 },
          },
          jabali_alfa_4: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 59, y: 26 },
          },
          jabali_alfa_5: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 50, y: 28 },
          },
          jabali_alfa_6: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 52, y: 28 },
          },
          jabali_alfa_7: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 54, y: 28 },
          },
           jabali_alfa_8: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 56, y: 30 },
          },
           jabali_alfa_9: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, level:9, attack: 55, defense: 20, exp: 120, maxHp: 300,
            
            lootTable: [ /* (mismo loot) */ ],
            fixedLocation: { x: 58, y: 30 },
          },
           jabali_alfa_10: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",      
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 55, y: 32 },
          },
          jabali_alfa_10: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 52, y: 30 },
          },
          jabali_alfa_11: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 52, y: 32 },
          },
          jabali_alfa_12: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 300, 
            level:9, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            
             lootTable: [
              
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              
              { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
            ],
            fixedLocation: { x: 52, y: 34 },
          },
          
          //BOSSES
           jabali_colmilludo_alfa: { 
            symbol: "🐗",
            name: "Jabalí Colmilludo Alfa (BOSS)",
            spriteUrl: "img/jabali.png",
            typeOverride: "monster",
            hp: 400, 
            level:10, 
            attack: 55, 
            defense: 20, 
            exp: 120, 
            maxHp: 300,
            isBoss: true,
            healChance: 0.2,
            lootTable: [
              { itemName: "Colmillo de Jabalí Alfa", quantity: [1, 1], chance: 0.9, },
              { itemName: "Carne de Bestia Exótica", quantity: [1, 3], chance: 0.6, },
              { itemName: "Piel Resistente", quantity: [1, 2], chance: 0.4 },
              { itemName: "Piedras Espirituales", quantity: [6, 10], chance: 1 },
            ],
            fixedLocation: { x: 57, y: 28 },
      },
        
          golem_de_piedra: {
            symbol: "🗿",
            name: "Golem Ancestral de Jade",
            spriteUrl: "img/golem_jade.png",
            typeOverride: "monster",
            hp: 800,
            level:11,
            attack: 35,
            defense: 50,
            exp: 500,
            maxHp: 800,
            isBoss: true,
            abilities: [
              {
                name: "Golpe Sísmico",
                damageMultiplier: 2.0,
                chance: 0.2,
                type: "area_attack_simulated",
              },
              { name: "Restauración Pétrea", healPercentage: 0.2, chance: 0.1 },
            ],
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [10, 15],
                chance: 1.0,
              },
              {
                itemName: "Corazón de Golem de Jade",
                quantity: [1, 1],
                chance: 0.9,
              },
      
              { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
              {
                itemName: "Núcleo Elemental",
                quantity: [1, 2],
                chance: 0.3,
                extraData: { elementalType: "earth" },
              },
              
            ],
            
          },

          lider_renegado_1: {
            symbol: "👤",
            name: "Líder Cultor Renegado Kai",
            typeOverride: "monster",
            hp: 500,
            level:15,
            attack: 70,
            defense: 25,
            exp: 250,
            maxHp: 500,
            isMiniBoss: true,
            specialChance: 0.25,
            specialAttackMultiplier: 1.6,
            lootTable: [
              {
                itemName: "Compás Espiritual Antiguo",
                quantity: [1, 1],
                chance: 1.0,
              },
              {
                itemName: "Píldora de Qi Condensado",
                quantity: [1, 1],
                chance: 0.3,
              },
              {
                itemName: "Piedras Espirituales",
                quantity: [10, 20],
                chance: 0.8,
              },
            ],
            fixedLocation: { x: 17, y: 12 },
          },

          //BOSSES

          boss_dem: {
            symbol: "👿",
            name: "General Demonio",
            spriteUrl: "img/boss_dem.png",
            typeOverride: "monster",
            hp: 500,
            level:10,
            attack: 45,
            defense: 20,
            exp: 300,
            maxHp: 500,
            isBoss: true,
            specialChance: 0.35,
            specialAttackMultiplier: 1.8,
            healChance: 0.15,
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [15, 30],
                chance: 1.0,
              },
              {
                itemName: "Núcleo Demoníaco Mayor",
                quantity: [1, 1],
                chance: 0.8,
              },
              {
                itemName: "Rollo: Palma Destructora de Montañas",
                quantity: [1, 1],
                chance: 0.25,
              },
             
              {
                itemName: "Rollo: Barrera Mística",
                quantity: [1, 1],
                chance: 0.25,
              },
            ],
            nextBossId: "boss_ancient_golem",
            fixedLocation: { x: 9, y: 36 },
          },

          boss_ancient_golem: {
            symbol: "🗿",
            name: "Golem Ancestral de Jade",
            spriteUrl: "img/golem_jade.png",
            typeOverride: "monster",
            hp: 800,
            level:11,
            attack: 35,
            defense: 50,
            exp: 500,
            maxHp: 800,
            isBoss: true,
            abilities: [
              {
                name: "Golpe Sísmico",
                damageMultiplier: 2.0,
                chance: 0.2,
                type: "area_attack_simulated",
              },
              { name: "Restauración Pétrea", healPercentage: 0.2, chance: 0.1 },
            ],
            lootTable: [
              {
                itemName: "Piedras Espirituales",
                quantity: [10, 15],
                chance: 1.0,
              },
              {
                itemName: "Corazón de Golem de Jade",
                quantity: [1, 1],
                chance: 0.9,
              },
      
              { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
              {
                itemName: "Núcleo Elemental",
                quantity: [1, 2],
                chance: 0.3,
                extraData: { elementalType: "earth" },
              },
              
            ],
            nextBossId: null,
            fixedLocation: { x: 72, y: 51 },
          },
        };

        const itemData = {
          "Hierbas Medicinales": {
            description: "Restaura un 30 de HP.",
            effect: (ps) => {
              if (ps.hp >= ps.maxHp) return "Vida al máximo.";
              const h = 30;
              const o = ps.hp;
              ps.hp = Math.min(ps.maxHp, ps.hp + h);
              return `Usada Píldora, recuperado ${ps.hp - o} HP.`;
            },
            canUse: (ps) => ps.hp < ps.maxHp,
          },
          "Cristales de Qi": {
            description: "Restaura un 30% de tu Maná Máximo.",
            effect: (ps) => {
              if (ps.mana >= ps.maxMana) return "Maná al máximo.";
              const h = Math.floor(ps.maxMana * 0.3);
              const o = ps.mana;
              ps.mana = Math.min(ps.maxMana, ps.mana + h);
              return `Recuperado ${ps.mana - o} Maná.`;
            },
            canUse: (ps) => ps.mana < ps.maxMana,
          },
          "Piedras Espirituales": {
            description: "Imbuida de energía. Otorga 50 EXP.",
            effect: (ps, gex) => {
              gex(50);
              return `Absorbido Piedra Espiritual y ganado 50 EXP.`;
            },
            canUse: () => true,
          },
          "Flor de Luna Escarchada": {
            description: "Flor brillante usada en alquimia.Item de misión",
            canUse: () => false,
          },
          "Raíz de Fuego Terrenal": {
            description: "Raíz que irradia calor, ingrediente alquímico.",
            canUse: () => false,
          },
          "Píldora de Recuperación Menor": {
            description: "Píldora alquímica que restaura 50 HP.",
            effect: (ps) => {
              if (ps.hp >= ps.maxHp) return "Vida al máximo.";
              const h = 50;
              const o = ps.hp;
              ps.hp = Math.min(ps.maxHp, ps.hp + h);
              return `Usada Píldora, recuperado ${ps.hp - o} HP.`;
            },
            canUse: (ps) => ps.hp < ps.maxHp,
          },
          "Talismán de Percepción": {
            description: "Agudiza sentidos. Otorga EXP.",
            effect: (ps, gex) => {
              gex(100);
              return `Estudiado Talismán, ganado 100 EXP.`;
            },
            canUse: () => true,
          },
          "Colmillo de Jabalí Alfa": {
            description: "Colmillo intacto de Jabalí Alfa. Item de misión de caza.",
            canUse: () => false,
          },
          "Carne de Bestia Exótica": {
            description: "Nutritiva. Restaura 25% HP y 10% Maná.",
            effect: (ps) => {
              let m = "";
              const hA = Math.floor(ps.maxHp * 0.25);
              if (ps.hp < ps.maxHp) {
                const o = ps.hp;
                ps.hp = Math.min(ps.maxHp, ps.hp + hA);
                m += `Recuperado ${ps.hp - o} HP. `;
              }
              const mA = Math.floor(ps.maxMana * 0.1);
              if (ps.mana < ps.maxMana) {
                const o = ps.mana;
                ps.mana = Math.min(ps.maxMana, ps.mana + mA);
                m += `Recuperado ${ps.mana - o} Maná.`;
              }
              return m || "HP y Maná al máximo.";
            },
            canUse: (ps) => ps.hp < ps.maxHp || ps.mana < ps.maxMana,
          },
          "Mapa del Tesoro Fragmentado": {
            description: "Fragmento de mapa antiguo. ¿Otras partes?",
            effect: (ps, gex) => {
              gex(50);
              return `Examinado fragmento, ganado 50 EXP. Indica zona montañosa...`;
            },
            canUse: () => true,
          },
          "Compás Espiritual Antiguo": {
            description: "Artefacto de secta que resuena con energías.",
            canUse: () => false,
          },
          "Manual de Formación Básica": {
            description: "Enseña principios de formaciones defensivas.",
            effect: (ps) => {
              ps.baseDefense += 2;
              recalculatePlayerStats();
              return `Estudiado Manual. Defensa base +2.`;
            },
            canUse: () => true,
          },
          "Núcleo de Bestia Menor": {
            description: "Núcleo de bestia demoníaca. Otorga 20 EXP.",
            effect: (ps, gex) => {
              gex(20);
              return `Absorbido Núcleo, ganado 20 EXP.`;
            },
            canUse: () => true,
          },
          // -- Rollos Grado 1 --
        "Rollo: Tajo del Viento Veloz": { description: "Enseña 'Tajo del Viento Veloz'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t1"), canUse: () => true },
        "Rollo: Físico de Buey de Piedra": { description: "Enseña 'Físico de Buey de Piedra'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t1"), canUse: () => true },
        "Rollo: Matriz de Escudo de Qi": { description: "Enseña 'Matriz de Escudo de Qi'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t1"), canUse: () => true },
        "Rollo: Chispa Ígnea": { description: "Enseña 'Chispa Ígnea'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t1"), canUse: () => true },
        "Rollo: Dedo de Relámpago": { description: "Enseña 'Dedo de Relámpago'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t1"), canUse: () => true },

        // -- Rollos Grado 2 --
        "Rollo: Estocada Perfora-Armadura": { description: "Enseña 'Estocada Perfora-Armadura'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t2"), canUse: () => true },
        "Rollo: Piel de Acero Fundido": { description: "Enseña 'Piel de Acero Fundido'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t2"), canUse: () => true },
        "Rollo: Matriz de Grilletes de Qi": { description: "Enseña 'Matriz de Grilletes de Qi'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t2"), canUse: () => true },
        "Rollo: Paso Etéreo": { description: "Enseña 'Paso Etéreo'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t2"), canUse: () => true },
        "Rollo: Aliento de Dragón Menor": { description: "Enseña 'Aliento de Dragón Menor'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t2"), canUse: () => true },

        // -- Rollos Grado 3 --
        "Rollo: Danza de Espada Ciclónica": { description: "Enseña 'Danza de Espada Ciclónica'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t3"), canUse: () => true },
        "Rollo: Corazón de Voluntad Indomable": { description: "Enseña 'Corazón de Voluntad Indomable'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t3"), canUse: () => true },
        "Rollo: Matriz de Supresión Espiritual": { description: "Enseña 'Matriz de Supresión Espiritual'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t3"), canUse: () => true },
        "Rollo: Jaula de Rayos": { description: "Enseña 'Jaula de Rayos'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t3"), canUse: () => true },
        "Rollo: Parpadeo de Sombra": { description: "Enseña 'Parpadeo de Sombra'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t3"), canUse: () => true },

        // -- Rollos Grado 4 --
        "Rollo: Intento de Espada del Tirano": { description: "Enseña 'Intento de Espada del Tirano'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t4"), canUse: () => true },
        "Rollo: Cuerpo Dorado Inmortal": { description: "Enseña 'Cuerpo Dorado Inmortal'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t4"), canUse: () => true },
        "Rollo: Sol Abrasador": { description: "Enseña 'Sol Abrasador'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t4"), canUse: () => true },
        "Rollo: Llamada del Juicio del Trueno": { description: "Enseña 'Llamada del Juicio del Trueno'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t4"), canUse: () => true },
        "Rollo: Santuario Dorado Protector": { description: "Enseña 'Santuario Dorado Protector'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t4"), canUse: () => true },
        // -- Rollos Grado 5 --
        "Rollo: Corte que Divide Cielos y Tierra": { description: "Enseña 'Corte que Divide Cielos y Tierra'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"), canUse: () => true },
        "Rollo: Constitución de Dragón Ancestral": { description: "Enseña 'Constitución de Dragón Ancestral'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"), canUse: () => true },
        "Rollo: Llama del Fénix Renaciente": { description: "Enseña 'Llama del Fénix Renaciente'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"), canUse: () => true },
        "Rollo: Tribulación de los Nueve Cielos": { description: "Enseña 'Tribulación de los Nueve Cielos'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"), canUse: () => true },
        "Rollo: Matriz de Reversión del Cosmos": { description: "Enseña 'Matriz de Reversión del Cosmos'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"), canUse: () => true },
        "Rollo: Paso del Vacío Infinito": { description: "Enseña 'Paso del Vacío Infinito'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"), canUse: () => true },

        // -- Rollos Grado 6 --
        "Rollo: Espada del Emperador Celestial": { description: "Enseña 'Espada del Emperador Celestial'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"), canUse: () => true },
        "Rollo: Cuerpo Inmortal de Jade": { description: "Enseña 'Cuerpo Inmortal de Jade'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t6"), canUse: () => true },
        "Rollo: Incineración del Mundo Mortal": { description: "Enseña 'Incineración del Mundo Mortal'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t6"), canUse: () => true },
        "Rollo: Decreto del Señor del Trueno": { description: "Enseña 'Decreto del Señor del Trueno'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t6"), canUse: () => true },
        "Rollo: Matriz del Sello del Demonio": { description: "Enseña 'Matriz del Sello del Demonio'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t6"), canUse: () => true },
        "Rollo: Omnipresencia Divina": { description: "Enseña 'Omnipresencia Divina'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t6"), canUse: () => true },
        // -- Rollos Grado 7 --
        "Rollo: Lamento del Fin del Mundo": { description: "Enseña 'Lamento del Fin del Mundo'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"), canUse: () => true },
        "Rollo: Forma del Ancestro Primordial": { description: "Enseña 'Forma del Ancestro Primordial'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"), canUse: () => true },
        "Rollo: Génesis Ígneo": { description: "Enseña 'Génesis Ígneo'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"), canUse: () => true },
        "Rollo: Cólera del Emperador Celestial": { description: "Enseña 'Cólera del Emperador Celestia'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"), canUse: () => true },
        "Rollo: Matriz del Caos Primordial": { description: "Enseña 'Matriz del Caos Primordial'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"), canUse: () => true },
        "Rollo: Danza del Tejido Espacio-Tiempo": { description: "Enseña 'Danza del Tejido Espacio-Tiempo'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"), canUse: () => true },

        // -- Rollos Grado 8 --
        "Rollo: Decreto Imperial: Extinción": { description: "Decreto Imperial: Extinción'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"), canUse: () => true },
        "Rollo: Avatar del Dao Eterno": { description: "Enseña 'Avatar del Dao Eterno'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t6"), canUse: () => true },
        "Rollo: Apocalipsis de Llamas Divinas": { description: "Enseña 'Apocalipsis de Llamas Divinas'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t6"), canUse: () => true },
        "Rollo: Tribulación del Fin de los Tiempos": { description: "Enseña 'Tribulación del Fin de los Tiempos'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t6"), canUse: () => true },
        "Rollo: Matriz de Reescritura de la Realidad": { description: "Enseña 'Matriz de Reescritura de la Realidad'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t6"), canUse: () => true },
        "Rollo: Trascendencia Dimensional": { description: "Enseña 'Trascendencia Dimensional'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t6"), canUse: () => true },
        // -- Rollos Grado 9 --
        "Rollo: Corte del Origen Absoluto": { description: "Enseña 'Corte del Origen Absoluto'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t5"), canUse: () => true },
        "Rollo: Constitución de Dragón Ancestral": { description: "Enseña 'Constitución de Dragón Ancestral'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t5"), canUse: () => true },
        "Rollo: Llama del Fénix Renaciente": { description: "Enseña 'Llama del Fénix Renaciente'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t5"), canUse: () => true },
        "Rollo: Tribulación de los Nueve Cielos": { description: "Enseña 'Tribulación de los Nueve Cielos'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t5"), canUse: () => true },
        "Rollo: Matriz de Reversión del Cosmos": { description: "Enseña 'Matriz de Reversión del Cosmos'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t5"), canUse: () => true },
        "Rollo: Paso del Vacío Infinito": { description: "Enseña 'Paso del Vacío Infinito'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t5"), canUse: () => true },

        // -- Rollos Grado 10 --
        "Rollo: Espada del Emperador Celestial": { description: "Enseña 'Espada del Emperador Celestial'.", effect: (ps) => learnTechniqueFromRoll(ps, "sword_t6"), canUse: () => true },
        "Rollo: Cuerpo Inmortal de Jade": { description: "Enseña 'Cuerpo Inmortal de Jade'.", effect: (ps) => learnTechniqueFromRoll(ps, "body_t6"), canUse: () => true },
        "Rollo: Incineración del Mundo Mortal": { description: "Enseña 'Incineración del Mundo Mortal'.", effect: (ps) => learnTechniqueFromRoll(ps, "fire_t6"), canUse: () => true },
        "Rollo: Decreto del Señor del Trueno": { description: "Enseña 'Decreto del Señor del Trueno'.", effect: (ps) => learnTechniqueFromRoll(ps, "lightning_t6"), canUse: () => true },
        "Rollo: Matriz del Sello del Demonio": { description: "Enseña 'Matriz del Sello del Demonio'.", effect: (ps) => learnTechniqueFromRoll(ps, "formation_t6"), canUse: () => true },
        "Rollo: Omnipresencia Divina": { description: "Enseña 'Omnipresencia Divina'.", effect: (ps) => learnTechniqueFromRoll(ps, "movement_t6"), canUse: () => true },
        
        

          "Rollo: Absorción de Qi Menor": {
            description: "Enseña 'Técnica de Absorción de Qi Menor'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "qi_absorption_boost_1"),
            canUse: () => true,
          },


          "Rollo: Fortificación Corporal Básica": {
            description: "Enseña 'Fortificación Corporal Básica'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "body_fortification_1"),
            canUse: () => true,
          },
          "Rollo: Corte de Espada Básico": {
            description: "Enseña 'Corte de Espada Básico'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "sword_slash_1"),
            canUse: () => true,
          },
          "Rollo: Conversión de Qi": {
            description: "Enseña 'Técnica de Conversión de Qi'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "qi_to_hp_conversion_1"),
            canUse: () => true,
          },
          "Rollo: Prisión de Hielo": {
            description: "Enseña 'Prisión de Hielo'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "ice_prison_1"),
            canUse: () => true,
          },
          "Rollo: Golpe de Llamas": {
            description: "Enseña 'Golpe de Llamas'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "flame_strike_1"),
            canUse: () => true,
          },
          "Rollo: Furia del Trueno": {
            description: "Enseña 'Furia del Trueno'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "thunder_fury_1"),
            canUse: () => true,
          },
          "Rollo: Dardo Venenoso": {
            description: "Enseña 'Dardo Venenoso'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "poison_dart_1"),
            canUse: () => true,
          },
          "Rollo: Piel de Piedra": {
            description: "Enseña 'Piel de Piedra'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "stone_skin_1"),
            canUse: () => true,
          },
          "Rollo: Paso de las Sombras": {
            description: "Enseña 'Paso de las Sombras'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "shadow_step_1"),
            canUse: () => true,
          },
          "Rollo: Drenaje de Alma": {
            description: "Enseña 'Drenaje de Alma'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "soul_drain_1"),
            canUse: () => true,
          },
          "Rollo: Golpe Ciclón": {
            description: "Enseña 'Golpe Ciclón'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "cyclone_strike_1"),
            canUse: () => true,
          },
          "Rollo: Lluvia Curativa": {
            description: "Enseña 'Lluvia Curativa'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "healing_rain_1"),
            canUse: () => true,
          },
          "Rollo: Explosión Mental": {
            description: "Enseña 'Explosión Mental'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "mind_blast_1"),
            canUse: () => true,
          },
          "Rollo: Voluntad de Hierro": {
            description: "Enseña 'Voluntad de Hierro'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "iron_will_1"),
            canUse: () => true,
          },
          "Rollo: Flecha Celestial": {
            description: "Enseña 'Flecha Celestial'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "celestial_arrow_1"),
            canUse: () => true,
          },
          "Rollo: Abrazo de la Naturaleza": {
            description: "Enseña 'Abrazo de la Naturaleza'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "nature_grasp_1"),
            canUse: () => true,
          },
          "Rollo: Rugido de Dragón": {
            description: "Enseña 'Rugido de Dragón'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "dragon_roar_1"),
            canUse: () => true,
          },
          "Rollo: Clon Fantasma": {
            description: "Enseña 'Clon Fantasma'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "phantom_clone_1"),
            canUse: () => true,
          },
          "Rollo: Cambio Temporal": {
            description: "Enseña 'Cambio Temporal'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "temporal_shift_1"),
            canUse: () => true,
          },
          "Rollo: Ritual de Sangre": {
            description: "Enseña 'Ritual de Sangre'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "blood_ritual_1"),
            canUse: () => true,
          },
          "Rollo: Aura de Pureza": {
            description: "Enseña 'Aura de Pureza'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "aura_of_purity_1"),
            canUse: () => true,
          },
          "Rollo: Invocar Elemental": {
            description: "Enseña 'Invocar Elemental'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "summon_elemental_1"),
            canUse: () => true,
          },
          "Rollo: Barrera Mística": {
            description: "Enseña 'Barrera Mística'.",
            effect: (ps) => learnTechniqueFromRoll(ps, "mystic_barrier_1"),
            canUse: () => true,
          },
          "Cristal de Hielo": {
            description: "Cristal gélido. Otorga 25 EXP.",
            effect: (ps, gex) => {
              gex(25);
              return `Absorbido Cristal de Hielo, ganado 25 EXP.`;
            },
            canUse: () => true,
          },
          "Esencia de Fuego": {
            description: "Energía ígnea concentrada. Otorga 25 EXP.",
            effect: (ps, gex) => {
              gex(25);
              return `Absorbido Esencia de Fuego, ganado 25 EXP.`;
            },
            canUse: () => true,
          },
          "Núcleo de Tormenta": {
            description: "Corazón de tormenta. Otorga 50 EXP.",
            effect: (ps, gex) => {
              gex(50);
              return `Absorbido Núcleo de Tormenta, ganado 50 EXP.`;
            },
            canUse: () => true,
          },
          "Venenos Mortales": {
            description: "Venenos potentes. Otorga 15 EXP.",
            effect: (ps, gex) => {
              gex(15);
              return `Estudiado Venenos Mortales, ganado 15 EXP.`;
            },
            canUse: () => true,
          },
          "Fragmentos de Jade": {
            description: "Jade imbuido de energía. Otorga 20 EXP.",
            effect: (ps, gex) => {
              gex(20);
              return `Absorbido Fragmentos de Jade, ganado 20 EXP.`;
            },
            canUse: () => true,
          },
          "Esencia Oscura": {
            description: "Energía de sombras. Otorga 30 EXP.",
            effect: (ps, gex) => {
              gex(30);
              return `Absorbido Esencia Oscura, ganado 30 EXP.`;
            },
            canUse: () => true,
          },
          "Almas Condenadas": {
            description: "Ecos de almas. Otorga 40 EXP.",
            effect: (ps, gex) => {
              gex(40);
              return `Liberado Almas Condenadas, ganado 40 EXP.`;
            },
            canUse: () => true,
          },
          "Núcleo de Vórtice": {
            description: "Energía caótica. Otorga 50 EXP.",
            effect: (ps, gex) => {
              gex(50);
              return `Absorbido Núcleo de Vórtice, ganado 50 EXP.`;
            },
            canUse: () => true,
          },
          "Rocío Celestial": {
            description: "Gotas de energía celestial. Otorga 35 EXP.",
            effect: (ps, gex) => {
              gex(35);
              return `Bebido Rocío Celestial, ganado 35 EXP.`;
            },
            canUse: () => true,
          },
          "Cristales Psíquicos": {
            description: "Resuenan con poder mental. Otorga 45 EXP.",
            effect: (ps, gex) => {
              gex(45);
              return `Meditado con Cristales Psíquicos, ganado 45 EXP.`;
            },
            canUse: () => true,
          },
          "Mineral de Hierro Espiritual": {
            description: "Hierro imbuido con Qi. Otorga 25 EXP.",
            effect: (ps, gex) => {
              gex(25);
              return `Refinado Mineral, ganado 25 EXP.`;
            },
            canUse: () => true,
          },
          "Plumas de Fénix": {
            description: "Imbuidas con esencia de renovación. Otorga 60 EXP.",
            effect: (ps, gex) => {
              gex(60);
              return `Meditado con Plumas de Fénix, ganado 60 EXP.`;
            },
            canUse: () => true,
          },
          "Semillas Ancestrales": {
            description: "Llenas de vitalidad. Otorga 30 EXP.",
            effect: (ps, gex) => {
              gex(30);
              return `Plantado Semillas en dantian, ganado 30 EXP.`;
            },
            canUse: () => true,
          },
          "Escamas de Dragón": {
            description: "Imbuidas con poder dracónico. Otorga 70 EXP.",
            effect: (ps, gex) => {
              gex(70);
              return `Estudiado Escamas de Dragón, ganado 70 EXP.`;
            },
            canUse: () => true,
          },
          "Espejos Astrales": {
            description: "Reflejan otros planos. Otorga 40 EXP.",
            effect: (ps, gex) => {
              gex(40);
              return `Meditado con Espejos Astrales, ganado 40 EXP.`;
            },
            canUse: () => true,
          },
          "Relojes de Arena": {
            description: "Manipulan flujo del tiempo. Otorga 50 EXP.",
            effect: (ps, gex) => {
              gex(50);
              return `Estudiado Relojes de Arena, ganado 50 EXP.`;
            },
            canUse: () => true,
          },
          "Sangre de Demonio": {
            description: "Sangre corrupta pero potente. Otorga 35 EXP.",
            effect: (ps, gex) => {
              gex(35);
              return `Analizado Sangre de Demonio, ganado 35 EXP.`;
            },
            canUse: () => true,
          },
          "Lágrimas de Unicornio": {
            description:
              "Purificadoras con propiedades curativas. Otorga 45 EXP.",
            effect: (ps, gex) => {
              gex(45);
              return `Usado Lágrimas para purificar Qi, ganado 45 EXP.`;
            },
            canUse: () => true,
          },
          "Núcleo Elemental": {
            description: "Esencia de poder elemental. Otorga 65 EXP.",
            effect: (ps, gex) => {
              gex(65);
              return `Absorbido Núcleo Elemental, ganado 65 EXP.`;
            },
            canUse: () => true,
          },
          "Polvo de Arcano": {
            description: "Brillante con propiedades mágicas. Otorga 40 EXP.",
            effect: (ps, gex) => {
              gex(40);
              return `Utilizado Polvo de Arcano en ritual, ganado 40 EXP.`;
            },
            canUse: () => true,
          },
        };

  
        // --- FUNCIONES HELPER PARA UI MÓVIL ---
        function isMobileView() {
          return (
            window.matchMedia("(max-width: 768px)").matches ||
            window.matchMedia("(hover: none) and (pointer: coarse)").matches
          );
        }

        /// <!-- CAMBIO TAMAÑO MAPA MÓVIL -->
        //TAMAÑO TILE
        function calculateAndSetTileSize() {
          const mapContainerElement = document.querySelector(".map-container");
          if (!mapContainerElement) {
            console.warn(
              "calculateAndSetTileSize: mapContainerElement no encontrado, usando G_TILE_SIZE por defecto."
            );
            currentTileSize = G_TILE_SIZE;
            return G_TILE_SIZE;
          }

          if (isMobileView()) {
            const availableWidth = mapContainerElement.clientWidth;
            const availableHeight = mapContainerElement.clientHeight;

            // --- INICIO DE LA LÓGICA DE ORIENTACIÓN ---

            // Determina si estamos en modo horizontal (landscape) o vertical (portrait)
            const isLandscape = availableWidth > availableHeight;

            // Define cuántos tiles queremos ver en cada orientación.
            // Estos valores son la clave. ¡Puedes ajustarlos a tu gusto!
            const TILES_VISIBLE_X_PORTRAIT = 7;  // Menos tiles de ancho en vertical
            const TILES_VISIBLE_Y_PORTRAIT = 5;  // Más tiles de alto en vertical
            
            const TILES_VISIBLE_X_LANDSCAPE = 8; // Más tiles de ancho en horizontal
            const TILES_VISIBLE_Y_LANDSCAPE = 6;  // Menos tiles de alto en horizontal

            let tileSizeBasedOnWidth;
            let tileSizeBasedOnHeight;

            if (isLandscape) {
              // Si la pantalla es más ancha que alta
              console.log("Orientación: Horizontal (Landscape)");
              tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_LANDSCAPE;
              tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_LANDSCAPE;
            } else {
              // Si la pantalla es más alta que ancha
              console.log("Orientación: Vertical (Portrait)");
              tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_PORTRAIT;
              tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_PORTRAIT;
            }

            // --- FIN DE LA LÓGICA DE ORIENTACIÓN ---

            // El tamaño del tile será el menor de los dos cálculos para asegurar que todo quepa
            currentTileSize = Math.floor(
              Math.min(tileSizeBasedOnWidth, tileSizeBasedOnHeight)
            );
            currentTileSize = Math.max(20, currentTileSize); // Asegurar un tamaño mínimo razonable

            console.log(
              `Mobile View: Container W: ${availableWidth}, H: ${availableHeight}. Calculated Tile Size: ${currentTileSize}`
            );
          } else {
            currentTileSize = G_TILE_SIZE; // Usar el tamaño fijo para escritorio
            console.log(`Desktop View: Using G_TILE_SIZE: ${currentTileSize}`);
          }
          return currentTileSize;
        }
        // <!-- FIN CAMBIO TAMAÑO MAPA MÓVIL -->

        function isAnyModalOpen() {
          const modals = [
            "interactionModal",
            "activeCultivationModal",
            "shopModal",
            "sectHallModal",
            "cultivationChoiceModal",
            "techniqueModal",
          ];
          for (const modalId of modals) {
            const modalElement = document.getElementById(modalId);
            if (modalElement && modalElement.style.display === "flex") {
              return true;
            }
          }
          return false;
        }

        // NUEVA FUNCIÓN para controlar la visibilidad de la barra inferior
        function updateTopNavVisibility() { // Renombramos la función para claridad
          if (!topNavBar) return;

          if (gameState.battle.active || isAnyModalOpen()) {
              topNavBar.classList.add("hidden");
          } else {
              topNavBar.classList.remove("hidden");
          }
      }
        function openMissionsModal() {
          const container = document.getElementById("missionsContainer");
          container.innerHTML = "";
          const player = gameState.player;

          if (player.secta.misionesActivas.length === 0) {
              container.innerHTML = "<p style='text-align: center;'>No tienes misiones activas en este momento.</p>";
          } else {
              player.secta.misionesActivas.forEach((misionActiva) => {
                  const misionData = MISIONES_DATA[misionActiva.id];
                  if (!misionData) return;

                  // Reutilizamos la lógica de la UI de la secta para mostrar el progreso
                  let progresoTexto = "";
                  const objetivo = misionActiva.objetivoOriginal;
                  if (objetivo) {
                      const npcEntregaNombre = SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre || "el NPC correspondiente";
                      if (objetivo.tipo === "eliminar_enemigo") {
                          progresoTexto = `Progreso: ${misionActiva.progreso || 0}/${objetivo.cantidad} ${objetivo.nombreDisplay || "objetivos"}`;
                          if ((misionActiva.progreso || 0) >= objetivo.cantidad) progresoTexto += ` <strong>(¡Listo para entregar a ${npcEntregaNombre}!)</strong>`;
                      } else if (objetivo.tipo === "entregar_item") {
                          progresoTexto = `Reunir: ${gameState.inventory[objetivo.item] || 0}/${objetivo.cantidad} ${objetivo.item}`;
                          if ((gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad) progresoTexto += ` <strong>(¡Listo para entregar a ${npcEntregaNombre}!)</strong>`;
                      }
                      // Puedes añadir más casos para otros tipos de misiones
                  }
                  
                  const div = document.createElement("div");
                  div.style.border = "1px solid #d4af37";
                  div.style.borderRadius = "8px";
                  div.style.padding = "10px";
                  div.style.marginBottom = "10px";
                  div.style.background = "rgba(0,0,0,0.2)";

                  div.innerHTML = `
                      <h4>${misionData.titulo}</h4>
                      <p style="font-size: 0.9em; margin-top: 5px;">${misionData.descripcion}</p>
                      <p style="font-size: 0.8em; color: #f4d03f; margin-top: 8px;">${progresoTexto}</p>
                  `;
                  container.appendChild(div);
              });
          }

          document.getElementById("missionsModal").style.display = "flex";
          hideTouchControls();
      }

      function closeMissionsModal() {
          document.getElementById("missionsModal").style.display = "none";
          showTouchControls();
      }
        function showTouchControls() {
          const joystick = document.getElementById("joystick-container");
          const actionBtn = document.getElementById("action-button-touch");

          if (
            isMobileView() &&
            !mapControlsManuallyHidden &&
            !gameState.battle.active &&
            !isAnyModalOpen()
          ) {
            if (joystick) joystick.style.display = "block";
            if (actionBtn) actionBtn.style.display = "block";
          } else {
            if (joystick) joystick.style.display = "none";
            if (actionBtn) actionBtn.style.display = "none";
          }
        }

        function hideTouchControls() {
          const joystick = document.getElementById("joystick-container");
          const actionBtn = document.getElementById("action-button-touch");
          if (joystick) joystick.style.display = "none";
          if (actionBtn) actionBtn.style.display = "none";
        }

        function toggleMapControlsVisibility() {
          mapControlsManuallyHidden = !mapControlsManuallyHidden;
          const btn = document.getElementById("toggleMapControlsBtn");
          if (mapControlsManuallyHidden) {
            hideTouchControls();
            btn.textContent = "Mostrar Controles";
          } else {
            showTouchControls();
            btn.textContent = "Ocultar Controles";
          }
        }

        // --- FUNCIONES DEL JUEGO (MODIFICADAS Y EXISTENTES) ---

        function learnTechniqueFromRoll(playerState, techId) {
          if (!techniqueData[techId]) return "Error: Técnica desconocida.";
          if (playerState.learnedTechniques[techId]) {
            return `Ya conoces esta técnica: ${techniqueData[techId].name}.`;
          }
          const techCultivationSettings =
            techniqueData[techId].cultivationSettings;
          playerState.learnedTechniques[techId] = {
            level: 0,
            currentCultivationProgress: 0,
            cultivationTimeToNextLevel: techCultivationSettings
              ? techCultivationSettings.baseTimeToLevelUp
              : 60,
          };
          if (techId === "qi_to_hp_conversion_1") {
            playerState.canUseQiConversion = true;
            updateToggleQiConversionButtonVisibility();
          }
          return `Has aprendido '${techniqueData[techId].name}'. Puedes cultivarla para mejorarla.`;
        }

        function showModal(title, text, nonInteractive = false) {
          document.querySelector('.stats-panel').style.display = 'none';
          const modalElement = document.getElementById("interactionModal");
          const modalTitleEl = document.getElementById("modalTitle");
          const modalTextEl = document.getElementById("modalText");

          if (!modalElement || !modalTitleEl || !modalTextEl) {
            console.error(
              "CRITICAL: Modal o sus elementos internos no encontrados."
            );
            alert(`Error UI: Modal no encontrado.\nMensaje: ${title} - ${text}`);
            return;
          }

          modalTitleEl.textContent = title;
          modalTextEl.innerHTML = text.replace(/\n/g, "<br>");

          const closeButton = modalElement.querySelector(
            "button.close-modal-btn"
          ); // Busca por clase

          if (closeButton) {
            if (nonInteractive) {
              closeButton.style.display = "none"; // Ocultar si es no interactivo
            } else {
              closeButton.style.display = "block"; // Asegurar que sea visible si es interactivo
              // El onclick="closeModal()" ya está en el HTML, por lo que no necesitamos reasignarlo.
            }
          } else if (!nonInteractive) {
            console.warn(
              "#interactionModal no tiene un botón de cierre con clase .close-modal-btn y no es nonInteractive."
            );
          }

          modalElement.style.display = "flex";
          hideTouchControls();
          updateTopNavVisibility();
        }

        function closeModal() {
          const modalElement = document.getElementById("interactionModal");
          if (modalElement) {
          modalElement.style.display = "none";
          }

          
          if (!gameState.battle.active) {
              document.querySelector('.stats-panel').style.display = 'block';
          }
          
          
          updatePlayerBarsOnMap();
          showTouchControls();
          updateTopNavVisibility();
      }
//ENEMIGOS Y NPC FIJOS
        function ensureFixedEntities() {
          const player = gameState.player;
          let entities = gameState.map.entities;

          let idsParaProcesar = [
            "shop",
            "secta_entrada_principal",
            "npc_secta_guia",
            "npc_secta_admin",
      
            "jabali_colmilludo_alfa",
            "boss_ancient_golem",
            "transition_ruins_entrance",
            "transition_ruins_exit",
            "jabali_alfa_1",
            "jabali_alfa_2",
            "jabali_alfa_3",
            "jabali_alfa_4",
             "jabali_alfa_5",
            "jabali_alfa_6",
            "jabali_alfa_7",
            "jabali_alfa_8",
            "jabali_alfa_9",
            "jabali_alfa_10",
            "jabali_alfa_11",
            "jabali_alfa_12",
            
            // Puedes añadir otros IDs de entidades fijas aquí directamente
          ];

          // Lógica para jefes principales (actuales)
          if (
            player.worldState.currentBossToSpawn &&
            entityTypes[player.worldState.currentBossToSpawn]
          ) {
            const bossDef = entityTypes[player.worldState.currentBossToSpawn];
            if (
              bossDef.fixedLocation &&
              !player.worldState.defeatedBosses[
                player.worldState.currentBossToSpawn
              ]
            ) {
              if (
                !idsParaProcesar.includes(player.worldState.currentBossToSpawn)
              ) {
                idsParaProcesar.push(player.worldState.currentBossToSpawn);
              }
            }
          }

          // Lógica para rivales de desafío de secta (actuales)
          player.secta.misionesActivas.forEach((misionActiva) => {
            const misionData = MISIONES_DATA[misionActiva.id];
            if (
              misionData?.objetivo?.tipo === "derrotar_npc_especifico" &&
              misionData.objetivo.npcId
            ) {
              const rivalId = misionData.objetivo.npcId;
              if (
                entityTypes[rivalId]?.fixedLocation &&
                !player.secta.misionesCompletadas[misionActiva.id]
              ) {
                if (!idsParaProcesar.includes(rivalId)) {
                  idsParaProcesar.push(rivalId);
                }
              }
            }
          });

          // Nueva lógica: Añadir entidades fijas que podrían estar ligadas a misiones activas
          // (si implementas `missionRequirementId`)
          player.secta.misionesActivas.forEach((misionActiva) => {
            // Ejemplo: Si la misión "mision_cazar_bestia_especifica_1" está activa
            // y el jabalí tiene un `missionRequirementId: "mision_cazar_bestia_especifica_1"`
            // y aún no está en idsParaProcesar, lo añadirías.
            // Este es un ejemplo, necesitarías iterar sobre `entityTypes` para encontrar tales entidades.
            // Por ahora, como lo añadiste directamente a `idsParaProcesar`, esto es más simple.
          });

          console.log(
            "[EnsureFixed] IDs a procesar:",
            JSON.parse(JSON.stringify(idsParaProcesar))
          );

          idsParaProcesar.forEach((entityTypeId) => {
            const definition = entityTypes[entityTypeId];
            if (!definition) {
              console.warn(
                `[EnsureFixed] Definición no encontrada para ${entityTypeId}`
              );
              return;
            }

            if (!definition.fixedLocation) {
              // Si una entidad en idsParaProcesar no tiene fixedLocation, no podemos colocarla así.
              // Esto es un error de configuración o la entidad no debería estar en esta lista.
              console.warn(
                `[EnsureFixed] La entidad ${entityTypeId} está en idsParaProcesar pero no tiene 'fixedLocation' en su definición.`
              );
              return;
            }

            const fixedX = definition.fixedLocation.x;
            const fixedY = definition.fixedLocation.y;

            const existingEntityInstance = entities.find(
              (e) =>
                (e.x === fixedX &&
                  e.y === fixedY &&
                  (e.type === (definition.typeOverride || entityTypeId) ||
                    e.originalEntityTypeId === entityTypeId)) ||
                (definition.npcId && e.npcId === definition.npcId) // Para NPCs
            );

            let debeExistir = true;

            // Lógica de si debe existir (para jefes, rivales, o entidades ligadas a misiones)
            if (definition.isSectChallengeRival && definition.npcId) {
              const desafioMision = Object.values(MISIONES_DATA).find(
                (m) =>
                  m.objetivo?.tipo === "derrotar_npc_especifico" &&
                  m.objetivo?.npcId === definition.npcId
              );
              const misionId = desafioMision
                ? Object.keys(MISIONES_DATA).find(
                    (key) => MISIONES_DATA[key] === desafioMision
                  )
                : null;
              if (misionId) {
                if (player.secta.misionesCompletadas[misionId])
                  debeExistir = false;
                else if (
                  !player.secta.misionesActivas.some((m) => m.id === misionId)
                )
                  debeExistir = false;
              } else debeExistir = false;
            } else if (definition.isBoss || definition.isMiniBoss) {
              // Tratar MiniBoss de forma similar a Boss para 'defeated'
              // Usaremos una nueva propiedad en player.worldState para rastrear minibosses fijos derrotados
              // si no quieres que reaparezcan inmediatamente.
              if (
                player.worldState.defeatedFixedEntities &&
                player.worldState.defeatedFixedEntities[entityTypeId]
              ) {
                // Si tiene un tiempo de respawn, podría reaparecer
                const lastDefeatedTime =
                  player.worldState.defeatedFixedEntities[entityTypeId].time;
                const respawnTimeSeconds = definition.respawnTime; // ej. 300 segundos
                if (
                  respawnTimeSeconds &&
                  (Date.now() - lastDefeatedTime) / 1000 < respawnTimeSeconds
                ) {
                  debeExistir = false; // Aún no es tiempo de reaparecer
                } else if (respawnTimeSeconds) {
                  debeExistir = true; // Tiempo de respawn cumplido
                  // Opcional: remover de defeatedFixedEntities para que no se re-evalue el tiempo hasta la próxima derrota
                  // delete player.worldState.defeatedFixedEntities[entityTypeId];
                } else {
                  debeExistir = false; // No tiene respawnTime, así que si está derrotado, no reaparece.
                }
              }
            } else if (definition.missionRequirementId) {
              // Lógica para entidades que dependen de una misión activa
              if (
                !player.secta.misionesActivas.some(
                  (m) => m.id === definition.missionRequirementId
                )
              ) {
                debeExistir = false; // La misión requerida no está activa
              }
              // Podrías añadir una comprobación de si la misión ya fue completada y la entidad debe desaparecer.
              if (
                player.secta.misionesCompletadas[
                  definition.missionRequirementId
                ] &&
                !definition.respawnTime
              ) {
                // Si la misión está completada y la entidad no tiene respawn, no debe existir.
                debeExistir = false;
              }
            }

            if (debeExistir) {
              if (!existingEntityInstance) {
                console.log(
                  `[EnsureFixed] CREANDO nueva instancia para ${entityTypeId} en (${fixedX}, ${fixedY}).`
                );
                const newEntityData = {
                  ...definition,
                  x: fixedX,
                  y: fixedY,
                  type: definition.typeOverride || entityTypeId,
                  symbol: definition.symbol,
                  name: definition.name,
                  interaction: definition.interaction,
                  npcId: definition.npcId,
                  discovered:
                    definition.discovered === true ||
                    definition.isBoss ||
                    definition.isMiniBoss, // Los jefes/minibosses suelen estar descubiertos
                  isFixed: true,
                  id: `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                    .toString(16)
                    .slice(2)}`,
                  originalEntityTypeId: entityTypeId,
                  // Copiar stats de combate y loot
                
                
                };
                if (newEntityData.hp && !newEntityData.maxHp)
                  newEntityData.maxHp = newEntityData.hp;

                // No necesitamos `...definition` aquí porque ya estamos copiando explícitamente y de entityTypes
                const finalEntity = { ...newEntityData };
                // delete finalEntity.fixedLocation; // No es necesario porque newEntityData no lo incluye

                entities.push(finalEntity);
              } else {
                // Actualizar propiedades de la instancia existente si es necesario
                existingEntityInstance.isFixed = true;
                if (
                  definition.discovered === true ||
                  definition.isBoss ||
                  definition.isMiniBoss
                ) {
                  existingEntityInstance.discovered = true;
                }
                if (!existingEntityInstance.id) {
                  existingEntityInstance.id = `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                    .toString(16)
                    .slice(2)}`;
                }
                if (!existingEntityInstance.originalEntityTypeId) {
                  existingEntityInstance.originalEntityTypeId = entityTypeId;
                }
                // Asegurar que las stats estén actualizadas si se recarga el juego
                // (esto puede ser importante si las definiciones cambian entre versiones)
                if (definition.hp) existingEntityInstance.hp = definition.hp;
                if (definition.maxHp)
                  existingEntityInstance.maxHp = definition.maxHp;
                else if (definition.hp && !existingEntityInstance.maxHp)
                  existingEntityInstance.maxHp = definition.hp;
                // ... podrías actualizar otras stats aquí si es necesario ...
              }
            } else {
              // No debe existir
              if (existingEntityInstance) {
                console.log(
                  `[EnsureFixed] ELIMINANDO instancia existente de ${entityTypeId} en (${fixedX}, ${fixedY}) porque 'debeExistir' es false.`
                );
                entities = entities.filter(
                  (e) => e.id !== existingEntityInstance.id
                );
              }
            }
          });
          gameState.map.entities = entities; // Reasignar por si se filtraron entidades
        }
        //GENERAR MAPA!
        function generateMap(isFullReset = true) {
              calculateAndSetTileSize();

              if (isFullReset) {
                  // Limpiar entidades que no son fijas
                  gameState.map.entities = gameState.map.entities.filter(e => e.isFixed && !e.isDecorative); // Quitamos también las decoraciones viejas
                  
                  // Resetear contadores de spawn
                  gameState.map.terrainZones.forEach((zone) => {
                      if (zone.spawnSettings && zone.spawnSettings.targetEntities) {
                          zone.spawnSettings.targetEntities.forEach((target) => {
                              target.currentCount = 0;
                          });
                          zone.spawnSettings.respawnTimer = 0;
                          zone.spawnSettings.lastSpawnCheck = 0;
                      }
                  });

                  // Poblar cada zona con monstruos/recursos y luego con decoraciones
                  gameState.map.terrainZones.forEach((zone) => {
                      if (zone.spawnSettings) {
                          console.log(`generateMap: Poblando spawns para la zona "${zone.name}".`);
                          populateZoneWithObjects(zone, true);
                      }
                      // === LÓGICA MODIFICADA ===
                      if (zone.decorations) {
                          console.log(`generateMap: Poblando decoraciones para la zona "${zone.name}".`);
                          populateZoneWithDecorations(zone); // Llamamos a la nueva función
                      }
                      // === FIN DE LA MODIFICACIÓN ===
                  });
                  
                  // Ya no necesitamos la función global y aleatoria de decoraciones.
                  // populateDecorativeElements(50); // <-- ELIMINA O COMENTA ESTA LÍNEA
                  
              } else {
                  gameState.map.entities = gameState.map.entities.filter(
                      (e) => e.isFixed || e.isDecorative || (!e.zoneOrigin && !e.isFixed)
                  );
              }
              
              updatePlayerPosition();
              showTouchControls();
              ensureFixedEntities();
          }

        function populateZoneWithDecorations(zone) {
          if (!zone.decorations || zone.decorations.length === 0) {
              return; // No hay nada que decorar en esta zona
          }

          console.log(`[Decor] Poblando decoraciones para la zona: ${zone.name}`);

          // Recorremos cada celda de la zona
          for (let y = zone.y1; y <= zone.y2; y++) {
              for (let x = zone.x1; x <= zone.x2; x++) {
                  // Verificamos si la celda ya está ocupada por algo importante
                  const isOccupied = gameState.map.entities.some(e => e.x === x && e.y === y);
                  if (isOccupied) {
                      continue; // Si ya hay un monstruo o recurso, no ponemos decoración encima
                  }

                  // Iteramos sobre los tipos de decoración definidos para la zona
                  for (const deco of zone.decorations) {
                      // Usamos Math.random() para decidir si colocar esta decoración
                      if (Math.random() < deco.density) {
                          const decoDefinition = entityTypes[deco.entityTypeId];
                          if (decoDefinition) {
                              const newDeco = {
                                  ...decoDefinition,
                                  x: x,
                                  y: y,
                                  type: deco.entityTypeId,
                                  id: `${deco.entityTypeId}_${x}_${y}_${Math.random()}`,
                                  discovered: true,
                                  isFixed: true,
                                  isDecorative: true,
                              };
                              gameState.map.entities.push(newDeco);
                              // IMPORTANTE: Una vez que ponemos una decoración, salimos del bucle
                              // para no poner múltiples decoraciones (ej. un árbol y una roca) en la misma celda.
                              break; 
                          }
                      }
                  }
              }
          }
      }

        function populateDecorativeElements(numberOfElements = 3000) {
          const decorativeKeys = Object.keys(entityTypes).filter(
            (key) => entityTypes[key].isDecorative
          );
          if (decorativeKeys.length === 0) {
            console.log("[Decor] No decorative entity types found."); // LOG
            return;
          }
          // MODIFICACIÓN: Añadir las claves encontradas al log
          console.log(
            `[Decor] Attempting to populate ${numberOfElements} decorative elements. Found ${decorativeKeys.length} types:`,
            decorativeKeys.join(", ")
          );

          let addedCount = 0;
          for (let i = 0; i < numberOfElements; i++) {
            let spawnX,
              spawnY,
              attempts = 0;
            let positionFound = false;
            const randomDecoKey =
              decorativeKeys[Math.floor(Math.random() * decorativeKeys.length)];

            while (attempts < 20 && !positionFound) {
              // Intentos para encontrar posición
              spawnX = Math.floor(Math.random() * gameState.map.width);
              spawnY = Math.floor(Math.random() * gameState.map.height);

              // Para decorativos, la condición de "caminable" puede ser menos estricta
              // Lo importante es que la celda no esté ya ocupada.
              const isOccupied = gameState.map.entities.some(
                (e) => e.x === spawnX && e.y === spawnY
              );
              const isPlayerPos =
                spawnX === gameState.player.x && spawnY === gameState.player.y;

              if (!isOccupied && !isPlayerPos) {
                positionFound = true;
              }
              attempts++;
            }

            if (positionFound) {
              const decoDefinition = entityTypes[randomDecoKey];
              if (!decoDefinition || !decoDefinition.symbol) {
                console.warn(
                  `[Decor] Definition or symbol missing for deco key: ${randomDecoKey}`
                );
                continue;
              }
              const newDeco = {
                ...decoDefinition, // Copia todas las propiedades de la definición
                x: spawnX,
                y: spawnY,
                type: randomDecoKey, // El tipo ES la clave original de entityTypes
                id: `${randomDecoKey}_${Date.now()}_${i}_${Math.random()
                  .toString(16)
                  .slice(2)}`,
                discovered: true, // Importante: los decorativos suelen estar descubiertos
                isFixed: true, // Importante: para que no se limpien fácilmente
                isDecorative: true, // Asegura que sea true, incluso si la definición lo omite
              };

              gameState.map.entities.push(newDeco);
              addedCount++;
              // MODIFICACIÓN: Log más detallado, incluyendo si isDecorative es true en la instancia
              console.log(
                `[Decor] Added: ${newDeco.name} (Symbol: ${newDeco.symbol}, Type: ${newDeco.type}, IsDecorative: ${newDeco.isDecorative}) at ${spawnX},${spawnY}. ID: ${newDeco.id}`
              );
            } else {
              // console.log(`[Decor] Could not find position for a decorative element of type ${randomDecoKey} after 20 attempts.`);
            }
          }
          console.log(
            `[Decor] Finished populating. Added ${addedCount} decorative elements out of ${numberOfElements} attempts.`
          );
        }

        function populateZoneWithObjects(zone, initialPopulation = false) {
          if (!zone.spawnSettings) {
            console.log(
              `populateZoneWithObjects: Zone "${zone.name}" has no spawnSettings. Skipping.`
            );
            return;
          }

          console.log(
            `populateZoneWithObjects: Called for zone "${zone.name}". InitialPopulation: ${initialPopulation}`
          );

          zone.spawnSettings.targetEntities.forEach((targetSpawnInfo) => {
            console.log(
              `  Zone "${zone.name}": Processing target spawn info for entityTypeId "${targetSpawnInfo.entityTypeId}", count: ${targetSpawnInfo.count}, currentCount: ${targetSpawnInfo.currentCount}`
            );

            const entityTypeDefinition =
              entityTypes[targetSpawnInfo.entityTypeId];
            if (!entityTypeDefinition) {
              console.warn(
                `  Zone "${zone.name}": Definition for entityTypeId "${targetSpawnInfo.entityTypeId}" NOT FOUND in entityTypes.`
              );
              return;
            }

            let attemptSpawns =
              targetSpawnInfo.count - targetSpawnInfo.currentCount;
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Need to spawn ${attemptSpawns} (target: ${targetSpawnInfo.count}, current: ${targetSpawnInfo.currentCount})`
            );

            if (!initialPopulation && zone.spawnSettings.respawnTimer > 0) {
              console.log(
                `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Zone in cooldown (timer: ${zone.spawnSettings.respawnTimer}). Skipping spawn.`
              );
              return;
            }

            if (attemptSpawns <= 0 && !initialPopulation) {
              console.log(
                `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": No spawns needed and not initial population. Skipping.`
              );
              return;
            }
            if (
              attemptSpawns <= 0 &&
              initialPopulation &&
              targetSpawnInfo.currentCount >= targetSpawnInfo.count
            ) {
              console.log(
                `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Initial population, but already at target count. Skipping.`
              );
              return;
            }

            let spawnedThisCycle = 0;
            for (let i = 0; i < attemptSpawns; i++) {
              if (targetSpawnInfo.currentCount >= targetSpawnInfo.count) {
                console.log(
                  `    Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Reached target count (${targetSpawnInfo.currentCount}/${targetSpawnInfo.count}). Stopping spawns for this type.`
                );
                break;
              }

              let spawnX,
                spawnY,
                attempts = 0;
              let positionFound = false;
              while (attempts < 20 && !positionFound) {
                spawnX =
                  zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1 + 1));
                spawnY =
                  zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1 + 1));

                const targetTerrainId = getTerrainTypeAt(spawnX, spawnY);
                const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
                const terrainWalkable =
                  !targetTerrainData || targetTerrainData.walkable !== false;

                const isOccupied = gameState.map.entities.some(
                  (e) => e.x === spawnX && e.y === spawnY
                );
                const isPlayerPos =
                  spawnX === gameState.player.x && spawnY === gameState.player.y;

                if (terrainWalkable && !isOccupied && !isPlayerPos) {
                  positionFound = true;
                }
                attempts++;
              }

              if (positionFound) {
                let newEntity;
                newEntity = {
                  ...entityTypeDefinition, // <--- COPIAR TODAS LAS PROPIEDADES DE LA DEFINICIÓN PRIMERO
                  x: spawnX,
                  y: spawnY,
                  type:
                    entityTypeDefinition.typeOverride ||
                    targetSpawnInfo.entityTypeId,
                  id: `${
                    targetSpawnInfo.entityTypeId
                  }_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                  zoneOrigin: zone.name,
                  originalEntityTypeId: targetSpawnInfo.entityTypeId,
                  discovered: false,
                  //name: entityTypeDefinition.name,
                  //symbol: entityTypeDefinition.symbol,
                  //interaction: entityTypeDefinition.interaction,
                  //reward: entityTypeDefinition.reward,
                };
                // Asegurar HP/MaxHP para entidades de combate y limpiar para no combatientes
                if (
                  G_COMBAT_ENTITY_TYPES.includes(newEntity.type) ||
                  newEntity.isBoss ||
                  newEntity.isSectChallengeRival
                ) {
                  // Si entityTypeDefinition ya tiene hp/maxHp, el spread ya los copió.
                  // Este bloque es más para asegurar que existan o para poner valores por defecto.
                  newEntity.hp = newEntity.hp ?? entityTypeDefinition.hp ?? 50;
                  newEntity.maxHp = newEntity.maxHp ?? newEntity.hp;
                  // Aquí 'attack', 'defense', 'exp', 'lootTable' ya deberían estar copiados por el spread de entityTypeDefinition
                } else {
                  // Para recursos u otras entidades no combativas
                  delete newEntity.hp;
                  delete newEntity.maxHp;
                  delete newEntity.attack; // Asegurarse de que no tengan stats de combate
                  delete newEntity.defense;
                  delete newEntity.exp;
                  // lootTable podría ser relevante para recursos si lo usaras para definir múltiples items de un nodo.
                }

                // Corrección específica si es un recurso, para que su 'type' en el mapa sea solo 'resource' si así lo deseas
                // para la lógica de interacción, o mantener el tipo específico si prefieres.
                // La lógica actual en handleEntityInteraction ya maneja bien `targetSpawnInfo.entityTypeId` como type.
                // if (entityTypeDefinition.type === "resource") newEntity.type = "resource";

                gameState.map.entities.push(newEntity);
                targetSpawnInfo.currentCount++;
                spawnedThisCycle++;
                console.log(
                  `    SUCCESS: Spawned "${newEntity.name}" (Attack: ${newEntity.attack}, Final Type: ${newEntity.type}, OrigTypeID: ${newEntity.originalEntityTypeId}) in zone "${zone.name}" at (${spawnX},${spawnY}).`
                );
              } else {
                // console.log(`    FAILED: Could not find position for "${targetSpawnInfo.entityTypeId}" ...`);
                break;
              }
            }
            if (spawnedThisCycle > 0 && !initialPopulation) {
              zone.spawnSettings.respawnTimer =
                zone.spawnSettings.respawnCooldown;
              console.log(
                `  Zone "${zone.name}": Spawned ${spawnedThisCycle} of "${targetSpawnInfo.entityTypeId}". Setting respawn timer to ${zone.spawnSettings.respawnCooldown}s.`
              );
            }
          });
        }

        // Función para llamar en el bucle principal del juego o con setInterval
        function gameTickUpdater() {
          const now = Date.now();
          const deltaTime = (now - gameState.lastGameTimeUpdate) / 1000;
          gameState.gameTime += deltaTime;
          gameState.lastGameTimeUpdate = now;
          // === NUEVA LÓGICA DE REGENERACIÓN PASIVA ===
        if (player.passiveHpRegen > 0 && player.hp < player.maxHp) {
            player.hp = Math.min(player.maxHp, player.hp + (player.passiveHpRegen * deltaTime));
            updateUI(); // Actualizar la UI para ver la regeneración
        }
        // === FIN DE LA NUEVA LÓGICA ===

          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings) {
              if (zone.spawnSettings.respawnTimer > 0) {
                zone.spawnSettings.respawnTimer -= deltaTime;
                if (zone.spawnSettings.respawnTimer < 0)
                  zone.spawnSettings.respawnTimer = 0;
              }

              // Comprobar si CUALQUIER tipo de entidad en la zona necesita reaparecer
              let needsRespawn = false;
              for (const target of zone.spawnSettings.targetEntities) {
                if (target.currentCount < target.count) {
                  needsRespawn = true;
                  break;
                }
              }
              // Ajustado el cooldown del chequeo de respawn para ser más frecuente (e.g. 5-10s)
              const SPAWN_CHECK_COOLDOWN = 10; // Segundos
              if (
                needsRespawn &&
                zone.spawnSettings.respawnTimer <= 0 &&
                gameState.gameTime - (zone.spawnSettings.lastSpawnCheck || 0) >
                  SPAWN_CHECK_COOLDOWN
              ) {
                console.log(
                  `gameTickUpdater: Zone "${zone.name}" needs respawn and timer is 0. Calling populateZoneWithObjects.`
                ); // LOG
                zone.spawnSettings.lastSpawnCheck = gameState.gameTime; // Actualizar ANTES de llamar para evitar bucles rápidos
                populateZoneWithObjects(zone, false); // false porque no es población inicial
              }
            }
          });
          // ...
        }
        // movePlayer() no necesita grandes cambios, ya que updatePlayerPosition()
        // se encarga ahora del scroll.
        let animationFrameIndex = 0; // Para ciclar a través de PLAYER_WALK_CYCLE
        let lastPlayerMoveTime = 0; // Para controlar el tiempo de la animación

        function movePlayer(dx, dy) {
          movePlayerCallCount++;
          const callId = movePlayerCallCount;
          console.log(`[MovePlayer CALL #${callId}] Intento de mover dx:${dx}, dy:${dy}. Posición actual: (${gameState.player.x}, ${gameState.player.y})`);

          // Cooldown
          const now = Date.now();
          if (now - lastSuccessfulMoveTime < PLAYER_MOVE_COOLDOWN) {
              // console.log(`[MovePlayer CALL #${callId}] Cooldown activo. Movimiento ignorado.`); // Descomentar si quieres ver esto
              return; 
          }

          const playerState = gameState.player;
          if (playerState.isCultivating || gameState.battle.active) {
              console.log(`[MovePlayer CALL #${callId}] Acción bloqueada por cultivo/batalla.`);
              return;
          }

          const newX = playerState.x + dx;
          const newY = playerState.y + dy;
          console.log(`[MovePlayer CALL #${callId}] Posición de destino calculada: (${newX}, ${newY}).`);
          let canMove = true; 

          // 1. Límites del mapa
          if (newX < 0 || newX >= gameState.map.width || newY < 0 || newY >= gameState.map.height) {
              canMove = false;
              console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Límites del mapa.`);
          }

          // 2. Terreno
          if (canMove) {
              const targetTerrainId = getTerrainTypeAt(newX, newY);
              const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
              if (targetTerrainData && targetTerrainData.walkable === false) {
                  canMove = false;
                  console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Terreno no caminable ('${targetTerrainId}').`);
              }
          }
          
          // 3. Entidades
          if (canMove) {
              const entityAtNewPosition = gameState.map.entities.find(e => e.x === newX && e.y === newY);
              
              if (entityAtNewPosition) {
                  console.log(`[MovePlayer CALL #${callId}] Entidad encontrada en destino:`, JSON.parse(JSON.stringify(entityAtNewPosition)));
                  const entityTypeToCheck = entityAtNewPosition.originalEntityTypeId || entityAtNewPosition.type;
                  console.log(`[MovePlayer CALL #${callId}] Tipo de entidad a verificar: '${entityTypeToCheck}'`);
                  
                  if (G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) || entityAtNewPosition.isBoss || entityAtNewPosition.isSectChallengeRival) {
                      console.log(`[MovePlayer CALL #${callId}] La entidad es hostil. Iniciando batalla...`);
                      startBattle(entityAtNewPosition);
                      return; 
                  }
                  
                  const isBlocking = G_BLOCKING_ENTITY_TYPES.includes(entityTypeToCheck);
                  console.log(`[MovePlayer CALL #${callId}] ¿Está en la lista de bloqueo (G_BLOCKING_ENTITY_TYPES)? -> ${isBlocking}`);
                  
                  if (isBlocking) {
                      canMove = false;
                      console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Entidad Bloqueadora.`);
                  }
              } else {
                  console.log(`[MovePlayer CALL #${callId}] Celda de destino vacía.`);
              }
          }

          console.log(`[MovePlayer CALL #${callId}] Decisión final. canMove: ${canMove}`);

          if (canMove) {
              console.log(`[MovePlayer CALL #${callId}] RESULTADO: Movimiento a (${newX}, ${newY}) PERMITIDO.`);
              playerState.x = newX;
              playerState.y = newY;
              updatePlayerPosition(`movePlayer_success_call_${callId}`);
              updateUI();
              lastSuccessfulMoveTime = now;
              
          } else {
              console.log(`[MovePlayer CALL #${callId}] RESULTADO: Movimiento a (${newX}, ${newY}) BLOQUEADO.`);
          }
          console.log(`--- Fin de la llamada a movePlayer #${callId} ---`);
        }

        //FIN FUNCION MOVE PLAYER
        function checkForAggressiveEnemies() {
        if (gameState.battle.active || isAnyModalOpen()) {
            return; // No iniciar combate si ya estamos en uno o en un modal.
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;

        // Comprobamos las 8 casillas adyacentes y la casilla actual
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue; // No comprobar la propia casilla del jugador

                const checkX = playerX + dx;
                const checkY = playerY + dy;

                const entity = gameState.map.entities.find(e => e.x === checkX && e.y === checkY);

                if (entity) {
                    const isHostile = G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss || entity.isMiniBoss;
                    
                    // Si la entidad es hostil, iniciamos la batalla
                    if (isHostile) {
                        showModal("¡Emboscada!", `¡Un ${entity.name} te ataca al acercarte demasiado!`, true);
                        setTimeout(() => {
                            closeModal();
                            startBattle(entity);
                        }, 1500);
                        return; // Detenemos la función para no iniciar múltiples combates
                    }
                }
            }
        }
      }

        function getEnemyNameColor(playerLevel, enemyLevel) {
          const levelDiff = enemyLevel - playerLevel;

          if (levelDiff >= 5) {
              return { color: '#ff4d4d', fontWeight: 'bold' }; // Rojo (Muy Peligroso)
          } else if (levelDiff >= 3) {
              return { color: '#ff9b57', fontWeight: 'normal' }; // Naranja (Peligroso)
          } else if (levelDiff >= 1) {
              return { color: '#f4d03f', fontWeight: 'normal' }; // Amarillo (Más fuerte)
          } else if (levelDiff <= -5) {
              return { color: '#a0a0a0', fontWeight: 'normal' }; // Gris (Trivial)
          } else {
              return { color: '#f4e4bc', fontWeight: 'normal' }; // Blanco (Normal)
          }
        }

        function gameLoop() {
          if (isAnyModalOpen() || gameState.battle.active || gameState.player.isCultivating) {
              gameState.player.isMoving = false; // Detener animación si el juego está pausado
              return;
          }

          handleMovement(); // Maneja la lógica de movimiento
          checkForAggressiveEnemies();
          // Actualiza el frame de la animación basado en el estado
          if (gameState.player.isMoving) {
              // Cicla entre los frames 1, 2, 3...
              const frameCount = gameState.player.animationFrames - 1; // e.g., si hay 4 frames, cicla entre 1,2,3
              gameState.player.currentFrame = (gameState.player.currentFrame % frameCount) + 1;
          } else {
              gameState.player.currentFrame = 0; // Frame 0 es quieto
          }
          
          updatePlayerSpriteVisual(); // Actualiza el sprite visualmente
        }

        // Ajuste menor en window.addEventListener('resize')
        window.addEventListener("resize", () => {
          calculateAndSetTileSize();
          // renderMap(); // updatePlayerPosition se encarga de esto
          updatePlayerPosition();
        });

        function getTerrainTypeAt(x, y) {
          if (
            x < 0 ||
            x >= gameState.map.width ||
            y < 0 ||
            y >= gameState.map.height
          ) {
            return null; // Fuera de los límites del mapa
          }

          // Opción A: Si usas terrainGrid directamente
          if (
            gameState.map.terrainGrid &&
            gameState.map.terrainGrid[y] &&
            gameState.map.terrainGrid[y][x]
          ) {
            return gameState.map.terrainGrid[y][x];
          }

          // Opción B: Usando terrainZones
          for (const zone of gameState.map.terrainZones) {
            if (x >= zone.x1 && x <= zone.x2 && y >= zone.y1 && y <= zone.y2) {
              return zone.type;
            }
          }
          return gameState.map.defaultTerrain; // Devuelve el terreno por defecto
        }

        function renderMap(callerId = "unknown") {
          const mapElement = document.getElementById("gameMap");
          const mapContainerElement = document.querySelector(".map-container");

          if (!mapElement || !mapContainerElement) {
              return;
          }
          // --- INICIO DE LA LÓGICA DE AISLAMIENTO DE ZONA ---
        const currentZone = getPlayerCurrentZone();
        let currentAmbientColor = '#1a3d2e'; // Color por defecto del mundo principal
        
        if (currentZone && currentZone.isIsolated) {
            // Si estamos en una zona aislada, cambiamos el fondo a un color de "vacío"
            mapContainerElement.style.backgroundColor = currentZone.ambientColor || '#000';
        } else {
            // Si estamos en el mundo principal, el fondo es el definido en el CSS
            mapContainerElement.style.backgroundColor = '#1a3d2e'; // O el color original de tu .map-container
        }
        // --- FIN DE LA LÓGICA DE AISLAMIENTO DE ZONA ---
          const currentContainerWidth = mapContainerElement.clientWidth;
          const currentContainerHeight = mapContainerElement.clientHeight;

          const playerScreenX = currentContainerWidth / 2 - currentTileSize / 2;
          const playerScreenY = currentContainerHeight / 2 - currentTileSize / 2;
          const mapExpectedScrollX =
              -(gameState.player.x * currentTileSize) + playerScreenX;
          const mapExpectedScrollY =
              -(gameState.player.y * currentTileSize) + playerScreenY;

          const viewWorldXStart = Math.floor(
              -mapExpectedScrollX / currentTileSize
          );
          const viewWorldYStart = Math.floor(
              -mapExpectedScrollY / currentTileSize
          );
          const tilesInViewX =
              Math.ceil(currentContainerWidth / currentTileSize) + 2;
          const tilesInViewY =
              Math.ceil(currentContainerHeight / currentTileSize) + 2;
          const viewWorldXEnd = viewWorldXStart + tilesInViewX;
          const viewWorldYEnd = viewWorldYStart + tilesInViewY;

          mapElement.innerHTML = "";

          // 1. Renderizar TERRENO BASE
        for (let y = viewWorldYStart; y < viewWorldYEnd; y++) {
            for (let x = viewWorldXStart; x < viewWorldXEnd; x++) {
              let shouldDrawVoid = false;

                if (currentZone && currentZone.isIsolated) {
                    if (x < currentZone.x1 || x > currentZone.x2 || y < currentZone.y1 || y > currentZone.y2) {
                        shouldDrawVoid = true;
                    }
                } else {
                    // Si no estamos en una zona aislada, el "vacío" es cualquier cosa fuera de los límites del mapa.
                    if (x < 0 || x >= gameState.map.width || y < 0 || y >= gameState.map.height) {
                        shouldDrawVoid = true;
                    }
                }
                if (shouldDrawVoid) {
                    const voidTile = document.createElement("div");
                    voidTile.className = "tile void-tile";
                    voidTile.style.left = `${x * currentTileSize}px`;
                    voidTile.style.top = `${y * currentTileSize}px`;
                    voidTile.style.width = `${currentTileSize}px`;
                    voidTile.style.height = `${currentTileSize}px`;
                    voidTile.style.backgroundColor = currentAmbientColor; // Rellena con el color de ambiente
                    voidTile.style.zIndex = "0";
                    const voidTerrainData = G_TERRAIN_TYPES.VOID;
                    if (voidTerrainData && voidTerrainData.textureUrl) {
                        voidTile.style.backgroundImage = `url('${voidTerrainData.textureUrl}')`;
                        voidTile.style.backgroundSize = 'cover';
                    } else {
                        // Si la textura del vacío no se encuentra, vuelve a usar el color ambiental
                        voidTile.style.backgroundColor = currentAmbientColor;
                    }
                    mapElement.appendChild(voidTile);
                    continue; // Pasa al siguiente tile del bucle
                }
                const terrainId = getTerrainTypeAt(x, y);
                const terrainData = G_TERRAIN_TYPES[terrainId];
                if (terrainData) {
                    const terrainTile = document.createElement("div");
                    terrainTile.className = "tile terrain-tile";
                    terrainTile.style.left = `${x * currentTileSize}px`;
                    terrainTile.style.top = `${y * currentTileSize}px`;
                    terrainTile.style.width = `${currentTileSize}px`;
                    terrainTile.style.height = `${currentTileSize}px`;
                    terrainTile.style.zIndex = "1";

                    if (terrainData.textureUrl) {
                        terrainTile.style.backgroundImage = `url('${terrainData.textureUrl}')`;
                        terrainTile.style.backgroundSize = 'cover';
                    } else {
                        terrainTile.style.backgroundColor = terrainData.color;
                    }

                    mapElement.appendChild(terrainTile);
                }
            }
        }
          
          // 2. Renderizar ENTIDADES
          gameState.map.entities.forEach((entity) => {
              if (entity.discovered) {
                  if (
                      entity.x >= viewWorldXStart &&
                      entity.x < viewWorldXEnd &&
                      entity.y >= viewWorldYStart &&
                      entity.y < viewWorldYEnd
                  ) {
                      const entityContainer = document.createElement("div");
                      entityContainer.style.position = 'absolute';
                      entityContainer.style.left = `${entity.x * currentTileSize}px`;
                      entityContainer.style.top = `${entity.y * currentTileSize}px`;
                      entityContainer.style.width = `${currentTileSize}px`;
                      entityContainer.style.height = `${currentTileSize}px`;
                      entityContainer.style.display = 'flex';
                      entityContainer.style.alignItems = 'center';
                      entityContainer.style.justifyContent = 'center';
                      entityContainer.style.zIndex = '5';

                      const definition = entityTypes[entity.originalEntityTypeId] || entityTypes[entity.type];
                      const spriteUrl = entity.spriteUrl || (definition ? definition.spriteUrl : null);

                      if (spriteUrl) {
                          entityContainer.style.backgroundImage = `url('${spriteUrl}')`;
                          
                          if (entity.originalEntityTypeId === 'secta_entrada_principal') {
                              entityContainer.style.backgroundSize = '120%';
                              entityContainer.style.top = `${(entity.y - 1.5) * currentTileSize}px`;
                              entityContainer.style.height = `${currentTileSize * 3}px`;
                              // 1. Aumentamos el ancho del contenedor para que quepa el sprite
                              entityContainer.style.width = `${currentTileSize * 3}px`;

                          // 2. Ajustamos la posición izquierda para centrar el nuevo contenedor ancho
                          // Posición original: entity.x * currentTileSize
                          // Nuevo ancho: currentTileSize * 2.5
                          // Para centrarlo, debemos desplazarlo a la izquierda la mitad de su ancho extra.
                          // Ancho extra = (2.5 - 1) = 1.5. Mitad del ancho extra = 0.75.
                          entityContainer.style.left = `${(entity.x - 0.75) * currentTileSize}px`;
                          } else if (entity.originalEntityTypeId === 'shop') {
                              entityContainer.style.backgroundSize = '120%';
                              entityContainer.style.top = `${(entity.y - 1.2) * currentTileSize}px`;
                              entityContainer.style.height = `${currentTileSize * 2}px`;
                              entityContainer.style.width = `${currentTileSize * 2}px`;
                              entityContainer.style.left = `${(entity.x - 0.75) * currentTileSize}px`;
                          } else if (entity.originalEntityTypeId === 'deco_arbol_grande') {
                              entityContainer.style.backgroundSize = '120%';
                              entityContainer.style.top = `${(entity.y - 0.2) * currentTileSize}px`;
                              entityContainer.style.height = `${currentTileSize * 1.2}px`;
                              
                          } 
                          else if (entity.originalEntityTypeId === 'boss_dem') {
                              entityContainer.style.backgroundSize = '100%';
                              entityContainer.style.top = `${(entity.y - 1.5) * currentTileSize}px`;
                              entityContainer.style.width = `${currentTileSize * 3}px`;
                              entityContainer.style.height = `${currentTileSize * 3}px`;
                              
                          }
                          else {
                              entityContainer.style.backgroundSize = '80%';
                          }
                          
                          entityContainer.style.backgroundPosition = 'center bottom';
                          entityContainer.style.backgroundRepeat = 'no-repeat';
                      } else {
                          entityContainer.textContent = entity.symbol || (definition ? definition.symbol : "?");
                          entityContainer.style.fontSize = `${currentTileSize * (entity.isDecorative ? 0.5 : 0.6)}px`;
                      }

                      if (entity.isDecorative) {
                          entityContainer.style.opacity = "0.7";
                          entityContainer.style.zIndex = "3";
                      }

                      mapElement.appendChild(entityContainer);

                      const isHostile = G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss || entity.isMiniBoss;
                      const isImportantNPC = entity.npcId && !isHostile;

                      if (isHostile || isImportantNPC) {
                          const namePlate = document.createElement('div');
                          namePlate.className = 'entity-name-plate';
                          
                          let displayText = entity.name;

                          if (isHostile) {
                            // 1. Añadir etiqueta de estatus si existe
                            if (entity.isBoss) {
                                displayText += ` (Jefe)`;
                            } else if (entity.isMiniBoss) {
                                displayText += ` (Élite)`;
                            }

                            // 2. Añadir SIEMPRE el nivel si la entidad lo tiene
                            if (entity.level) {
                                displayText += ` (Nv. ${entity.level})`;
                            }

                            // 3. Aplicar color
                            if (entity.isBoss) {
                                namePlate.style.color = '#ff4d4d'; // Rojo para Jefes
                                namePlate.style.fontWeight = 'bold';
                            } else {
                                // Para todos los demás enemigos (miniboss y comunes), usar la escala de color
                                const nameStyle = getEnemyNameColor(gameState.player.level, entity.level || 1);
                                namePlate.style.color = nameStyle.color;
                                namePlate.style.fontWeight = nameStyle.fontWeight;
                            }
                        }
                          
                          namePlate.textContent = displayText;
                          entityContainer.appendChild(namePlate);
                      }
                  }
              }
          });

          updatePlayerVisualSize();
      }

        function updatePlayerSpriteVisual() {
          // Asegúrate que el nombre sea este
          const player = gameState.player;
          const playerElement = document.getElementById("player");
          if (!playerElement) return;

          // Verificación para depurar el error de la línea 2263
          if (
            !player.directionRowMap ||
            typeof player.currentDirection === "undefined"
          ) {
            console.error(
              "CRITICAL: player.directionRowMap o player.currentDirection no están definidos en updatePlayerSpriteVisual.",
              player
            );
            // Podrías establecer valores por defecto aquí como un parche temporal,
            // pero lo ideal es que estén bien inicializados en gameState.
            // player.currentDirection = player.currentDirection || 'down';
            // player.directionRowMap = player.directionRowMap || { 'down': 0, 'left': 1, 'right': 2, 'up': 3 };
            // player.currentFrame = player.currentFrame || 0;
            // player.frameWidth = player.frameWidth || 64;
            // player.frameHeight = player.frameHeight || 64;
            return; // Salir si faltan datos cruciales para evitar más errores
          }

          const row = player.directionRowMap[player.currentDirection];
          const col = player.currentFrame;

          // Otra verificación
          if (typeof row === "undefined" || typeof col === "undefined") {
            console.error(
              "CRITICAL: 'row' o 'col' son undefined en updatePlayerSpriteVisual.",
              {
                playerDir: player.currentDirection,
                playerFrame: player.currentFrame,
                map: player.directionRowMap,
              }
            );
            return;
          }

          const offsetX = col * player.frameWidth;
          const offsetY = row * player.frameHeight;

          playerElement.style.backgroundPosition = `-${offsetX}px -${offsetY}px`;

          if (gameState.battle.active) {
            const battlePlayerSprite = document.querySelector(
              ".battle-area .character-sprite"
            );
            if (battlePlayerSprite) {
              const battleRow = player.directionRowMap["down"];
              const battleFrame = 0;
              const battleOffsetX = battleFrame * player.frameWidth;
              const battleOffsetY = battleRow * player.frameHeight;
              battlePlayerSprite.style.backgroundPosition = `-${battleOffsetX}px -${battleOffsetY}px`;
            }
          }
        }

        // Asegúrate que G_TILE_SIZE sea igual a las dimensiones de tu frame de sprite
        // Si no, tendrás que ajustar cómo se define el tamaño del jugador.
        // En calculateAndSetTileSize, si currentTileSize se calcula dinámicamente,
        // y quieres que el jugador SIEMPRE tenga el tamaño del sprite:
        function updatePlayerVisualSize() {
          const playerElement = document.getElementById("player");
          if (playerElement) {
            // ESTO ES CRUCIAL: El tamaño del div del jugador DEBE ser el tamaño de UN FRAME
            // Si currentTileSize representa el tamaño deseado del jugador en pantalla,
            // y tus frames en la hoja de sprites son de un tamaño fijo (ej. 64x64),
            // entonces el div del jugador también debe ser de ese tamaño fijo para que background-position funcione.
            // O, si quieres que el jugador se reescale con currentTileSize, entonces frameWidth/Height
            // deben ser iguales a currentTileSize, y background-size debe escalar la hoja completa.

            // Opción A: El jugador mantiene el tamaño del frame original, y currentTileSize es solo para el mapa.
            playerElement.style.width = `${gameState.player.frameWidth}px`;
            playerElement.style.height = `${gameState.player.frameHeight}px`;
            // En este caso, .player y .character-sprite NO deberían cambiar su width/height en @media queries
            // basados en currentTileSize, sino mantener el tamaño del frame.

            // Opción B: El jugador se reescala con los tiles del mapa (más complejo con spritesheets).
            // Si eliges esto, frameWidth y frameHeight en gameState.player deberían ser actualizados
            // por calculateAndSetTileSize() para ser igual a currentTileSize.
            // Y el background-size del spritesheet necesitaría ajustarse para que un "frame virtual"
            // dentro de la hoja escalada coincida con currentTileSize.
            // Ejemplo para Opción B:
            //playerElement.style.width = `${currentTileSize}px`;
            //playerElement.style.height = `${currentTileSize}px`;
            // Y en updatePlayerSpriteVisual, los cálculos de offsetX/Y necesitarían
            // usar este currentTileSize en lugar de player.frameWidth/Height si la hoja
            // también se está escalando.
            // Por ahora, mantengamos la Opción A (tamaño de frame fijo) que es más simple
            // si tu CSS para .player no está siendo sobrescrito por las @media queries.
          }
        }

        function updatePlayerPosition(callerId = "unknown") {
          const playerElement = document.getElementById("player");
          const mapElement = document.getElementById("gameMap");
          const mapContainerElement = document.querySelector(".map-container");

          if (!playerElement || !mapElement || !mapContainerElement) {
            console.error(
              "UpdatePlayerPosition: Elemento(s) clave no encontrado(s)."
            );
            return;
          }

          const playerVisualWidth = gameState.player.frameWidth; // Usar el tamaño real del frame del sprite
          const playerVisualHeight = gameState.player.frameHeight;

          const playerScreenX =
            mapContainerElement.clientWidth / 2 - playerVisualWidth / 2;
          const playerScreenY =
            mapContainerElement.clientHeight / 2 - playerVisualHeight / 2;

          playerElement.style.left = `${playerScreenX}px`;
          playerElement.style.top = `${playerScreenY}px`;

          const mapScrollX =
            -(gameState.player.x * currentTileSize) + playerScreenX;
          const mapScrollY =
            -(gameState.player.y * currentTileSize) + playerScreenY;

          mapElement.style.transform = `translate(${mapScrollX}px, ${mapScrollY}px)`;

          gameState.map.entities.forEach((entity) => {
            const distance =
              Math.abs(entity.x - gameState.player.x) +
              Math.abs(entity.y - gameState.player.y);
            if (distance <= G_PLAYER_DISCOVERY_RANGE) {
              if (!entity.discovered) entity.discovered = true;
            }
          });

          renderMap(callerId);
          updatePlayerSpriteVisual();
          updatePlayerVisualSize();
          updatePlayerBarsOnMap(); 
          updateExtraStatsUI();
        }

        // ... (el resto de tus funciones JS, como updateUI, movePlayer, interact, etc. SIN CAMBIOS IMPORTANTES aquí,
        //      ya que los cambios principales son en el renderizado y tamaño de tiles)
        function updateUI() {
          const player = gameState.player;
          document.getElementById("playerLevel").textContent = player.level;
          document.getElementById("playerRealm").textContent = player.realm;
          document.getElementById("hpText").textContent = `${Math.floor(
            player.hp
          )}/${player.maxHp}`;
          document.getElementById("manaText").textContent = `${Math.floor(
            player.mana
          )}/${player.maxMana}`;
          document.getElementById("expText").textContent = `${Math.floor(
            player.exp
          )}/${player.expToNext}`;

          // Barras del Sidebar
          const hpBarSidebar = document.getElementById("hpBar");
          const manaBarSidebar = document.getElementById("manaBar");
          const expBarSidebar = document.getElementById("expBar");

          if (hpBarSidebar)
            hpBarSidebar.style.width = `${(player.hp / player.maxHp) * 100}%`;
          if (manaBarSidebar)
            manaBarSidebar.style.width = `${
              (player.mana / player.maxMana) * 100
            }%`;
          if (expBarSidebar)
            expBarSidebar.style.width = `${
              (player.exp / player.expToNext) * 100
            }%`;

          document.getElementById(
            "playerCoords"
          ).textContent = `X: ${player.x}, Y: ${player.y}`;

          updateExtraStatsUI();
          updateInventoryUI(); // Asumo que esta función existe y es correcta
          updateSectUI(); // Asumo que esta función existe y es correcta

          updatePlayerBarsOnMap(); // <--- LLAMADA AÑADIDA para las barras sobre el jugador
        }

        function updateInventoryUI() {
          const inventoryDisplay = document.getElementById("inventory");
          inventoryDisplay.innerHTML = "";
          Object.entries(gameState.inventory).forEach(([itemName, count]) => {
            if (count <= 0 && itemName !== "Piedras Espirituales") return;

            const itemDiv = document.createElement("div");
            itemDiv.className = "inventory-item";

            const itemInfo = itemData[itemName];
            const description = itemInfo
              ? itemInfo.description
              : "Un objeto misterioso.";
            itemDiv.innerHTML = `<strong>${itemName}: ${count}</strong><br><small><em>${description}</em></small>`;

            if (count > 0 && itemInfo && itemInfo.effect) {
              const canBeUsedNow = itemInfo.canUse
                ? itemInfo.canUse(gameState.player)
                : true;
              itemDiv.style.cursor = canBeUsedNow ? "pointer" : "not-allowed";
              itemDiv.style.opacity = canBeUsedNow ? 1 : 0.6;
              itemDiv.title = canBeUsedNow
                ? `Usar ${itemName}`
                : `No puedes usar ${itemName} ahora.`;
              if (canBeUsedNow) {
                itemDiv.onclick = () => useItem(itemName);
              }
            } else {
              itemDiv.style.opacity = 0.8;
              itemDiv.style.cursor = "default";
            }
            inventoryDisplay.appendChild(itemDiv);
          });
        }
       
      function updateRefinementUI() {}

        let lastPlayerAnimationUpdateTime = 0; // Renombrado para claridad

        function movePlayer(dx, dy) {
          movePlayerCallCount++;
          const callId = movePlayerCallCount;
          console.log(`[MovePlayer CALL #${callId}] Intento de mover dx:${dx}, dy:${dy}. Posición actual: (${gameState.player.x}, ${gameState.player.y})`);

          // Cooldown
          const now = Date.now();
          if (now - lastSuccessfulMoveTime < PLAYER_MOVE_COOLDOWN) {
              // console.log(`[MovePlayer CALL #${callId}] Cooldown activo. Movimiento ignorado.`);
              return; 
          }

          const newX = gameState.player.x + dx;
          const newY = gameState.player.y + dy;
          console.log(`[MovePlayer CALL #${callId}] Posición de destino calculada: (${newX}, ${newY}).`);
          let canMove = true; 

          // 1. Límites del mapa
          if (newX < 0 || newX >= gameState.map.width || newY < 0 || newY >= gameState.map.height) {
              canMove = false;
              console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Límites del mapa.`);
          }

          // 2. Terreno
          if (canMove) {
              const targetTerrainId = getTerrainTypeAt(newX, newY);
              if (G_TERRAIN_TYPES[targetTerrainId]?.walkable === false) {
                  canMove = false;
                  console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Terreno no caminable ('${targetTerrainId}').`);
              }
          }
          
          // 3. Entidades
          if (canMove) {
              const entityAtNewPosition = gameState.map.entities.find(e => e.x === newX && e.y === newY);
              
              if (entityAtNewPosition) {
                  console.log(`[MovePlayer CALL #${callId}] Entidad encontrada en destino:`, JSON.parse(JSON.stringify(entityAtNewPosition)));
                  const entityTypeToCheck = entityAtNewPosition.originalEntityTypeId || entityAtNewPosition.type;
                  console.log(`[MovePlayer CALL #${callId}] Tipo de entidad a verificar: '${entityTypeToCheck}'`);
                  
                  if (G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) || entityAtNewPosition.isBoss || entityAtNewPosition.isSectChallengeRival) {
                      console.log(`[MovePlayer CALL #${callId}] La entidad es hostil. Iniciando batalla...`);
                      startBattle(entityAtNewPosition);
                      return; 
                  }
                  
                  const isBlocking = G_BLOCKING_ENTITY_TYPES.includes(entityTypeToCheck);
                  console.log(`[MovePlayer CALL #${callId}] ¿Está en la lista de bloqueo (G_BLOCKING_ENTITY_TYPES)? -> ${isBlocking}`);
                  
                  if (isBlocking) {
                      canMove = false;
                      console.log(`[MovePlayer CALL #${callId}] BLOQUEADO por: Entidad Bloqueadora.`);
                  }
              } else {
                  console.log(`[MovePlayer CALL #${callId}] Celda de destino vacía.`);
              }
          }

          console.log(`[MovePlayer CALL #${callId}] Decisión final. canMove: ${canMove}`);

          if (canMove) {
              console.log(`[MovePlayer CALL #${callId}] RESULTADO: Movimiento a (${newX}, ${newY}) PERMITIDO.`);
              gameState.player.x = newX;
              gameState.player.y = newY;
              updatePlayerPosition(`movePlayer_success_call_${callId}`);
              updateUI();
              lastSuccessfulMoveTime = now;
          } else {
              console.log(`[MovePlayer CALL #${callId}] RESULTADO: Movimiento a (${newX}, ${newY}) BLOQUEADO.`);
          }
          console.log(`--- Fin de la llamada a movePlayer #${callId} ---`);
        }
        //FIN MOVE PLAYER

        let playerMovementKeysDown = {
          // Para rastrear qué teclas de movimiento están presionadas
          up: false,
          down: false,
          left: false,
          right: false,
        };
        function handleMovement() {
          let dx = 0;
          let dy = 0;
          let newDirection = null;

          // Determina la dirección del movimiento
          if (playerMovementKeysDown.up) { dy = -1; newDirection = 'up'; }
          else if (playerMovementKeysDown.down) { dy = 1; newDirection = 'down'; }
          else if (playerMovementKeysDown.left) { dx = -1; newDirection = 'left'; }
          else if (playerMovementKeysDown.right) { dx = 1; newDirection = 'right'; }

          // Si hay una dirección presionada, intenta mover al jugador
          if (newDirection) {
              gameState.player.currentDirection = newDirection;
              movePlayer(dx, dy); // La lógica de cooldown y colisión está dentro
          }

          // Lógica de animación visual (separada de la lógica de movimiento)
          const isActuallyMoving = playerMovementKeysDown.up || playerMovementKeysDown.down || playerMovementKeysDown.left || playerMovementKeysDown.right;
          gameState.player.isMoving = isActuallyMoving;
        }

        function interact() {
          if (gameState.player.isCultivating) {
            showModal(
              "Acción no permitida",
              "Detén tu cultivo antes de interactuar."
            );
            return;
          }
          if (gameState.battle.active) {
            showModal(
              "Acción no permitida",
              "No puedes interactuar durante el combate."
            );
            return;
          }

          const playerX = gameState.player.x;
          const playerY = gameState.player.y;
          const offsets = [
            { dx: 0, dy: 0 },
            { dx: 0, dy: -1 },
            { dx: 1, dy: 0 },
            { dx: 0, dy: 1 },
            { dx: -1, dy: 0 },
          ];

          for (const offset of offsets) {
            const targetX = playerX + offset.dx;
            const targetY = playerY + offset.dy;
            const entity = gameState.map.entities.find(
              (e) => e.x === targetX && e.y === targetY
            );

            if (entity) {
              if (
                G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
                entity.isBoss ||
                entity.isSectChallengeRival
              ) {
                const desafioMision = gameState.player.secta.misionesActivas.find(
                  (m) =>
                    MISIONES_DATA[m.id]?.objetivo?.tipo ===
                      "derrotar_npc_especifico" &&
                    MISIONES_DATA[m.id]?.objetivo?.npcId === entity.npcId
                );
                if (entity.isSectChallengeRival) {
                  if (desafioMision) {
                    showModal(
                      "¡Desafío Aceptado!",
                      `Te preparas para enfrentar a ${entity.name}.`,
                      true
                    );
                    setTimeout(() => {
                      closeModal();
                      startBattle(entity);
                    }, 1500);
                  } else {
                    showModal(
                      "Paz, por ahora...",
                      `${entity.name} te observa, pero no hay razón para luchar.`
                    );
                  }
                } else {
                  showModal(
                    "¡A la Batalla!",
                    `Decides enfrentar a ${entity.name}.`,
                    true
                  );
                  setTimeout(() => {
                    closeModal();
                    startBattle(entity);
                  }, 1000);
                }
                return;
              } else if (
                entity.interaction ||
                entityTypes[entity.type]?.interaction ||
                [
                  "resource",
                  "master",
                  "cultivation",
                  "shop",
                  "secta_entrada_principal",
                ].includes(entity.type)
              ) {
                handleEntityInteraction(entity);
                return;
              }
            }
          }
        }

        function handleEntityInteraction(entity) {
          if (!entity) return;

          let interactionType = entity.interaction; // Priorizar la interacción de la instancia

          // Si no hay interacción en la instancia, buscar en la definición de entityTypes
          // usando entity.originalEntityTypeId si está disponible, sino entity.type
          const definitionKey = entity.originalEntityTypeId || entity.type;
          if (!interactionType && entityTypes[definitionKey]) {
            interactionType = entityTypes[definitionKey].interaction;
          }
          // === INICIO DE LA NUEVA LÓGICA DE TRANSICIÓN ===
          if (interactionType === "transition") {
              const definition = entityTypes[definitionKey];
              if (definition && typeof definition.targetX === 'number' && typeof definition.targetY === 'number') {
                  
                  // Función que se ejecutará si el jugador confirma
                  const doTransition = () => {
                      gameState.player.x = definition.targetX;
                      gameState.player.y = definition.targetY;
                      updatePlayerPosition(`transition_to_${definitionKey}`); // ¡Muy importante!
                      showModal("Transición Completa", `Has llegado a ${definition.name}.`);
                  };

                  // Mostramos el modal de confirmación
                  showConfirmationModal(
                      `Entrar a ${entity.name}`,
                      "¿Deseas pasar a la siguiente zona?",
                      doTransition // Pasamos la función como callback
                  );

              } else {
                  console.warn(`La entidad de transición ${definitionKey} no tiene coordenadas de destino (targetX, targetY).`);
              }
              return; // Detenemos la ejecución para no procesar otros switches
          }
          if (interactionType) {
            switch (interactionType) {
              case "browse":
                if (entity.type === "shop") {
                  openShop();
                  return;
                }
                break;
              case "talk_secta_npc":
                if (entity.npcId) {
                  interactWithSectNPC(entity.npcId);
                  return;
                }
                break;
              case "access_sect_hall":
                if (entity.type === "secta_entrada_principal") {
                  openSectHallInterface();
                  return;
                }
                break;
              case "collect_resource":
                const rewardItem =
                  entity.reward ||
                  (entityTypes[entity.originalEntityTypeId]
                    ? entityTypes[entity.originalEntityTypeId].reward
                    : null) ||
                  "Piedras Espirituales"; // Último fallback

                const itemNameDisplay =
                  entity.name ||
                  (entityTypes[entity.originalEntityTypeId]
                    ? entityTypes[entity.originalEntityTypeId].name
                    : entity.type);

                gameState.inventory[rewardItem] =
                  (gameState.inventory[rewardItem] || 0) + 1;
                showModal(
                  "Recurso Encontrado",
                  `Has obtenido: 1 ${rewardItem}! (de ${itemNameDisplay})`
                );
                removeEntity(entity);
                updateInventoryUI();
                return;
              case "learn_from_master":
                const expGain =
                  entity.expGain || entityTypes[entity.type]?.expGain || 50;
                gainExperience(expGain);
                showModal(
                  "Encuentro con Maestro",
                  `El ${entity.name} te ha enseñado sabiduría. Ganas ${expGain} EXP!`
                );
                removeEntity(entity);
                return;
              case "meditate_spot":
                const manaGain =
                  entity.manaGain || entityTypes[entity.type]?.manaGain || 20;
                gameState.player.mana = Math.min(
                  gameState.player.maxMana,
                  gameState.player.mana + manaGain
                );
                showModal(
                  "Lugar de Cultivo",
                  `Has meditado en '${entity.name}'. Recuperas ${manaGain} Maná.`
                );
                removeEntity(entity);
                updateUI();
                return;
              default:
                console.warn(
                  `Interacción '${interactionType}' desconocida para ${entity.name} (Tipo: ${entity.type}, ID: ${entity.id}).`
                );
                break;
            }
          } else {
            console.log(
              `No hay acción definida para tipo '${entity.type}' (Entidad: ${entity.name}, ID: ${entity.id}, OrigTypeID: ${entity.originalEntityTypeId}).`
            );
          }
        }

        function interactWithSectNPC(npcId) {
          const npcData = SECTA_DATA.npcs[npcId];
          const player = gameState.player;
          if (!npcData) {
            console.error(
              `[interactWithSectNPC] NPC Data no encontrada para npcId: ${npcId}`
            );
            return;
          }

          console.log(
            `[NPC Interaction] Starting interaction with NPC: ${npcData.nombre} (ID: ${npcId})`
          );
          console.log(
            `[NPC Interaction] Player Active Missions (Raw):`,
            JSON.parse(JSON.stringify(player.secta.misionesActivas))
          );
          console.log(
            `[NPC Interaction] Player Inventory:`,
            JSON.parse(JSON.stringify(gameState.inventory))
          );

          let modalContentHTML = `<h3>${npcData.nombre} (${npcData.rol})</h3>`;
          modalContentHTML += `<p><em>"${npcData.dialogoInicial}"</em></p><hr>`;

          const elementsToProcess = [];

          // --- SECCIÓN: MISIONES PARA COMPLETAR ---
          modalContentHTML += `<h4>Misiones para Entregar/Reportar:</h4>`;
          let algunaMisionParaCompletar = false;

          player.secta.misionesActivas.forEach((misionActiva) => {
            const misionDef = MISIONES_DATA[misionActiva.id];

            // Log básico para cada misión activa
            console.log(
              `[NPC Interaction] Evaluating Active Mission: "${misionDef?.titulo}" (ID: ${misionActiva.id})`
            );

            // Comprobaciones cruciales: misionDef, objetivo, y objetivoOriginal deben existir.
            if (
              !misionDef ||
              !misionDef.objetivo ||
              !misionActiva.objetivoOriginal
            ) {
              console.warn(
                `[NPC Interaction] Skipping mission ID ${misionActiva.id}: Missing misionDef, misionDef.objetivo, or misionActiva.objetivoOriginal.`
              );
              return; // Saltar esta misión si los datos esenciales faltan
            }

            const objetivo = misionActiva.objetivoOriginal; // Usar el objetivo original guardado

            console.log(
              `[NPC Interaction] Mission "${
                misionDef.titulo
              }": Target NPC for delivery/report is "${
                objetivo.npcEntrega
              }". Current NPC is "${npcId}". Match: ${
                objetivo.npcEntrega === npcId
              }`
            );

            // Solo procesar si el NPC actual es el NPC de entrega/reporte de la misión
            if (objetivo.npcEntrega === npcId) {
              let listaParaEntregar = false;
              let objetivoStatus = "";

              console.log(
                `[NPC Interaction] Mission "${misionDef.titulo}" IS for this NPC. Original objective type: ${objetivo.tipo}`
              );

              switch (objetivo.tipo) {
                case "entregar_item":
                  const playerHasItem = gameState.inventory[objetivo.item] || 0;
                  const needsItem = objetivo.cantidad;
                  console.log(
                    `  - Type 'entregar_item'. Item: "${objetivo.item}", Needs: ${needsItem}, Player Has: ${playerHasItem}`
                  );
                  if (playerHasItem >= needsItem) {
                    listaParaEntregar = true;
                    objetivoStatus = `(Tienes ${playerHasItem}/${needsItem} ${objetivo.item})`;
                  } else {
                    objetivoStatus = `(Necesitas ${
                      needsItem - playerHasItem
                    } más ${objetivo.item})`;
                  }
                  break;

                case "eliminar_enemigo":
                  const currentProgressElim = misionActiva.progreso || 0;
                  const needsElim = objetivo.cantidad;
                  console.log(
                    `  - Type 'eliminar_enemigo'. Target: "${objetivo.nombreDisplay}", Needs: ${needsElim}, Progress: ${currentProgressElim}`
                  );
                  if (currentProgressElim >= needsElim) {
                    listaParaEntregar = true; // Significa que los enemigos fueron eliminados, lista para 'reportar'
                    objetivoStatus = `(${currentProgressElim}/${needsElim} ${objetivo.nombreDisplay} eliminados)`;
                  } else {
                    objetivoStatus = `(Elimina ${
                      needsElim - currentProgressElim
                    } más ${objetivo.nombreDisplay})`;
                  }
                  break;

                case "recolectar_multiples_items":
                  let todosRecolectados = true;
                  let itemsStatusArray = [];
                  console.log(
                    `  - Type 'recolectar_multiples_items'. Items required:`,
                    objetivo.items
                  );
                  for (const itemReq of objetivo.items) {
                    const playerHasMulti =
                      gameState.inventory[itemReq.nombre] || 0;
                    const needsMulti = itemReq.cantidad;
                    console.log(
                      `    - Item: "${itemReq.nombre}", Needs: ${needsMulti}, Player Has: ${playerHasMulti}`
                    );
                    if (playerHasMulti < needsMulti) {
                      todosRecolectados = false;
                    }
                    itemsStatusArray.push(
                      `${playerHasMulti}/${needsMulti} ${itemReq.nombre}`
                    );
                  }
                  if (todosRecolectados) {
                    listaParaEntregar = true;
                  }
                  objetivoStatus = `(${itemsStatusArray.join(", ")})`;
                  break;
                case "derrotar_npc_especifico":
                      // El progreso es 1 si el rival fue derrotado.
                      if (misionActiva.progreso === 1) {
                          listaParaEntregar = true;
                          const rivalName = entityTypes[objetivo.npcId]?.name || "el guardián";
                          objetivoStatus = `(Has derrotado a ${rivalName})`;
                      } else {
                          const rivalName = entityTypes[objetivo.npcId]?.name || "el guardián";
                          objetivoStatus = `(Debes derrotar a ${rivalName} en la arena)`;
                      }
                  break;

                case "cazar_y_recuperar_item_de_loot":
                  const playerHasLootItem =
                    (gameState.inventory[objetivo.itemPrueba] || 0) >=
                    objetivo.cantidadItemPrueba;
                  // El progreso a 1 indica que el tipo de enemigo que suelta el item fue derrotado.
                  const killedCorrectEnemyType = misionActiva.progreso === 1;
                  console.log(
                    `  - Type 'cazar_y_recuperar_item_de_loot'. Item: "${
                      objetivo.itemPrueba
                    }", Needs Qty: ${
                      objetivo.cantidadItemPrueba
                    }, Player Has Qty: ${
                      gameState.inventory[objetivo.itemPrueba] || 0
                    }. Killed enemy type: ${killedCorrectEnemyType}`
                  );
                  if (killedCorrectEnemyType && playerHasLootItem) {
                    // Debe haber matado al enemigo Y tener el ítem
                    listaParaEntregar = true;
                    objetivoStatus = `(Tienes ${objetivo.itemPrueba})`;
                  } else if (!killedCorrectEnemyType) {
                    objetivoStatus = `(Caza al ${
                      entityTypes[objetivo.enemigoTipo]?.name ||
                      objetivo.enemigoTipo
                    } y consigue ${objetivo.itemPrueba})`;
                  } else {
                    // Killed enemy, but doesn't have item (sold it? used it? or it never dropped - handle this in loot drop if needed)
                    objetivoStatus = `(Necesitas ${objetivo.itemPrueba}. ¿Lo perdiste o no lo obtuviste?)`;
                  }
                  break;

                // Añadir más casos aquí para otros tipos de misión que se completan con este NPC
                default:
                  console.warn(
                    `[NPC Interaction] Unhandled objective type "${objetivo.tipo}" for mission "${misionDef.titulo}" completion check with NPC.`
                  );
                  objetivoStatus = `(Objetivo: ${objetivo.tipo} - estado no verificado aquí)`;
                  break;
              }

              console.log(
                `[NPC Interaction] Mission "${misionDef.titulo}": listaParaEntregar = ${listaParaEntregar}. Objetivo status display: ${objetivoStatus}`
              );

              // Solo mostrar el botón de completar si listaParaEntregar es true
              if (listaParaEntregar) {
                const buttonId = `complete-mission-btn-${misionActiva.id.replace(
                  /\W/g,
                  "_"
                )}`;
                modalContentHTML += `<div style="padding: 5px; border: 1px solid #55cc55; margin-bottom: 5px; background-color: rgba(85,204,85,0.1);">
                                              <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                              <button id="${buttonId}">Completar Misión</button>
                                          </div>`;
                elementsToProcess.push({
                  buttonId: buttonId,
                  action: () => {
                    console.log(
                      `[NPC Interaction] Clicked "Completar Misión" button for ${misionActiva.id}`
                    );
                    // Pasar npcId como npcIdEntregaManual a completeMission
                    if (completeMission(misionActiva.id, npcId)) {
                      // Si la misión se completó con éxito, el modal del NPC se refrescará
                      // porque completeMission llama a showModal y al cerrarlo se actualiza el UI
                      // o, como alternativa, podemos forzar el refresco aquí.
                      // closeModal(); // Cierra el modal de interacción actual
                      interactWithSectNPC(npcId); // Vuelve a abrir el modal del NPC con el estado actualizado
                    }
                    // Si completeMission devuelve false, generalmente ya muestra un modal de error/info.
                  },
                });
                algunaMisionParaCompletar = true;
                console.log(
                  `[NPC Interaction] SUCCESS: Added "Completar Misión" button for ${misionDef.titulo}`
                );
              } else {
                // Opcional: Mostrar la misión pero sin el botón de completar si no está lista
                modalContentHTML += `<div style="padding: 5px; border: 1px solid #777; margin-bottom: 5px; background-color: rgba(100,100,100,0.1);">
                                              <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                              <small><em>(Aún no cumples todos los requisitos para entregar/reportar esta misión)</em></small>
                                          </div>`;
                console.log(
                  `[NPC Interaction] INFO: Mission "${misionDef.titulo}" is for this NPC but not ready for completion. Displaying status.`
                );
              }
            } else {
              // Log si la misión no es para este NPC
              // console.log(`[NPC Interaction] Mission "${misionDef.titulo}" is not designated for this NPC (Delivery NPC: ${objetivo.npcEntrega}).`);
            }
          });

          if (
            !algunaMisionParaCompletar &&
            !player.secta.misionesActivas.some(
              (m) => MISIONES_DATA[m.id]?.objetivo?.npcEntrega === npcId
            )
          ) {
            // Si no hay misiones para completar con ESTE NPC, y tampoco hay misiones activas que SEAN para este NPC (incluso si no están listas)
            modalContentHTML +=
              "<p>No tienes misiones para entregarme o reportarme en este momento.</p>";
            console.log(
              `[NPC Interaction] No missions found that are completable OR assignable to this NPC for completion.`
            );
          } else if (!algunaMisionParaCompletar) {
            // Hay misiones asignadas a este NPC, pero ninguna está lista para completarse.
            modalContentHTML +=
              "<p>Revisa los objetivos de tus misiones activas. Parece que aún no están listas para entregar/reportar.</p>";
            console.log(
              `[NPC Interaction] Missions are assigned to this NPC, but none are ready for completion yet.`
            );
          }
          modalContentHTML += "<hr>";

          // --- SECCIÓN: MISIONES DISPONIBLES (CON FILTRO DE NIVEL Y RANGO) ---
          // (Esta sección parece estar bien, la mantengo como estaba en tu código anterior con la lógica de requisitos)
          if (npcData.misionesOfrecidas && npcData.misionesOfrecidas.length > 0) {
            modalContentHTML += "<h4>Misiones Disponibles:</h4>";
            modalContentHTML += `<div id="npc-dynamic-content-missions" style="max-height: 200px; overflow-y: auto; border: 1px solid #444; padding: 10px; margin-bottom:10px;">`;
            let algunaMisionDisponibleMostrada = false;
            npcData.misionesOfrecidas.forEach((misionId, index) => {
              const mision = MISIONES_DATA[misionId];
              if (
                mision &&
                !player.secta.misionesActivas.some((m) => m.id === misionId) &&
                !player.secta.misionesCompletadas[misionId]
              ) {
                const nivelRequerido = mision.requisitoNivel || 0;
                const rangoRequeridoNombre = mision.requisitoRango;
                let cumpleRequisitos = true;

                if (player.level < nivelRequerido) {
                  cumpleRequisitos = false;
                }
                if (rangoRequeridoNombre) {
                  const indiceRangoJugador = SECTA_DATA.rangos.findIndex(
                    (r) => r.nombre === player.secta.rango
                  );
                  const indiceRangoRequerido = SECTA_DATA.rangos.findIndex(
                    (r) => r.nombre === rangoRequeridoNombre
                  );
                  if (indiceRangoJugador < indiceRangoRequerido) {
                    cumpleRequisitos = false;
                  }
                }

                if (cumpleRequisitos) {
                  let recompensaTextoResumido = `Recompensa: ${
                    mision.recompensa.pcs || 0
                  } PCS, ${mision.recompensa.exp || 0} EXP`;
                  if (mision.recompensa.items)
                    recompensaTextoResumido += ", Objetos";
                  if (mision.recompensa.nuevoRango)
                    recompensaTextoResumido += `, Ascenso a ${mision.recompensa.nuevoRango}`;

                  const buttonId = `accept-mission-btn-${misionId.replace(
                    /\W/g,
                    "_"
                  )}-${index}`;
                  const botonHTML = `<button id="${buttonId}">Aceptar Misión</button>`;

                  modalContentHTML += `<div style="padding: 5px; border: 1px solid #555; margin-bottom: 5px;">
                                              <strong>${
                                                mision.titulo
                                              }</strong> (Req. Nv: ${
                    nivelRequerido > 0 ? nivelRequerido : "Ninguno"
                  }${
                    rangoRequeridoNombre ? ", Rango: " + rangoRequeridoNombre : ""
                  })<br><small>${mision.descripcion}</small><br>
                                              <small style="color: #aaa;"><em>${recompensaTextoResumido}</em></small><br>
                                              ${botonHTML} 
                                          </div>`;
                  elementsToProcess.push({
                    buttonId: buttonId,
                    missionIdToAccept: misionId,
                  });
                  algunaMisionDisponibleMostrada = true;
                }
              }
            });
            if (!algunaMisionDisponibleMostrada)
              modalContentHTML +=
                "<p>No hay nuevas misiones para ti en este momento que cumplan tus requisitos.</p>";
            modalContentHTML += `</div>`;
            modalContentHTML += "<hr>";
          } else {
            modalContentHTML +=
              "<p>No tengo misiones para ti en este momento.</p><hr>";
          }

          // --- SECCIÓN: ENTREGA DE RECURSOS ---
          // (Esta sección parece estar bien, la mantengo)
          if (npcData.aceptaRecursos && npcData.aceptaRecursos.length > 0) {
            modalContentHTML += `<h4>Entregar Recursos:</h4>`;
            modalContentHTML += `<div id="npc-dynamic-content-resources" style="max-height: 150px; overflow-y: auto;">`;
            let puedeEntregarAlgo = false;
            npcData.aceptaRecursos.forEach((itemName) => {
              const cantidadPlayer = gameState.inventory[itemName] || 0;
              if (cantidadPlayer > 0) {
                const pcsPorItem =
                  itemName === "Hierbas Medicinales"
                    ? 2
                    : itemName === "Cristales de Qi"
                    ? 5
                    : itemName === "Núcleo de Bestia Menor"
                    ? 10
                    : 1;
                const buttonIdEntregar1 = `entregar-1-${itemName.replace(
                  /\W/g,
                  "_"
                )}`;
                const buttonIdEntregarAll = `entregar-all-${itemName.replace(
                  /\W/g,
                  "_"
                )}`;
                modalContentHTML += `<p>${itemName} (Tienes: ${cantidadPlayer}): 
                                      <button id="${buttonIdEntregar1}">Entregar 1 (${pcsPorItem} PCS)</button>
                                      ${
                                        cantidadPlayer > 1
                                          ? `<button id="${buttonIdEntregarAll}">Entregar Todo (${
                                              pcsPorItem * cantidadPlayer
                                            } PCS)</button>`
                                          : ""
                                      }
                                  </p>`;
                elementsToProcess.push({
                  buttonId: buttonIdEntregar1,
                  action: () => {
                    entregarRecursoSecta(itemName, 1, pcsPorItem);
                    interactWithSectNPC(npcId);
                  },
                });
                if (cantidadPlayer > 1) {
                  elementsToProcess.push({
                    buttonId: buttonIdEntregarAll,
                    action: () => {
                      entregarRecursoSecta(
                        itemName,
                        cantidadPlayer,
                        pcsPorItem * cantidadPlayer
                      );
                      interactWithSectNPC(npcId);
                    },
                  });
                }
                puedeEntregarAlgo = true;
              }
            });
            if (!puedeEntregarAlgo)
              modalContentHTML +=
                "<p>No tienes recursos que pueda necesitar en este momento.</p>";
            modalContentHTML += `</div><hr>`;
          }

          showModal("Interacción con " + npcData.nombre, modalContentHTML);

          const modalTextEl = document.getElementById("modalText");
          if (modalTextEl) {
            elementsToProcess.forEach((item) => {
              const buttonElement = modalTextEl.querySelector(
                "#" + item.buttonId
              );
              if (buttonElement) {
                if (item.missionIdToAccept) {
                  buttonElement.addEventListener("click", () => {
                    acceptMission(item.missionIdToAccept);
                    interactWithSectNPC(npcId);
                  });
                } else if (item.action) {
                  buttonElement.addEventListener("click", item.action);
                }
              } else {
                console.warn(
                  "[NPC Interaction] Could not find button with ID:",
                  item.buttonId,
                  "in #modalText to attach listener."
                );
              }
            });
          } else {
            console.error(
              "[NPC Interaction] #modalText element not found for attaching listeners to dynamic buttons."
            );
          }
        }

        function entregarRecursoSecta(itemName, cantidad, pcsGanados) {
          if ((gameState.inventory[itemName] || 0) < cantidad) {
            showModal("Error", "No tienes suficientes objetos.");
            return;
          }
          gameState.inventory[itemName] -= cantidad;
          gameState.player.secta.puntosContribucion += pcsGanados;
          showModal(
            "Recurso Entregado",
            `Entregaste ${cantidad} ${itemName} y ganaste ${pcsGanados} PCS.`
          );
          updateSectUI();
          updateInventoryUI();
          checkAndActivateRankChallengeMissions();
          closeModal();
        }

        function acceptMission(misionId) {
          const misionData = MISIONES_DATA[misionId];
          const player = gameState.player;
          if (!misionData) {
            showModal("Error de Misión", "Datos no encontrados.");
            return;
          }
          if (
            player.secta.misionesActivas.some((m) => m.id === misionId) ||
            player.secta.misionesCompletadas[misionId]
          ) {
            showModal("Error de Misión", "Ya activa/completada.");
            return;
          }
          if (!misionData.objetivo) {
            showModal("Error de Misión", "Objetivo no definido.");
            return;
          }

          let nuevaMisionActiva;
          try {
            nuevaMisionActiva = {
              id: misionId,
              progreso: 0,
              objetivoOriginal: JSON.parse(JSON.stringify(misionData.objetivo)),
            };
          } catch (error) {
            showModal("Error de Misión", "Problema al procesar objetivo.");
            return;
          }

          player.secta.misionesActivas.push(nuevaMisionActiva);
          showModal("Misión Aceptada", `Has aceptado: ${misionData.titulo}`);
          updateSectUI();

          const npcInteractionModal = document.getElementById("interactionModal");
          const modalTitleElement = document.getElementById("modalTitle");
          if (
            npcInteractionModal.style.display === "flex" &&
            modalTitleElement &&
            modalTitleElement.textContent.includes("Interacción con Secta")
          ) {
            closeModal();
          }
        }

        function removeEntity(entityToRemove) {
          const index = gameState.map.entities.findIndex(
            (e) => e.id === entityToRemove.id
          ); // Usar ID único

          if (index > -1) {
            const removedEntity = gameState.map.entities.splice(index, 1)[0];

            // Si la entidad provenía de una zona de spawn, actualizar el contador de esa zona
            if (removedEntity.zoneOrigin) {
              const originZone = gameState.map.terrainZones.find(
                (z) => z.name === removedEntity.zoneOrigin && z.spawnSettings
              );
              if (originZone) {
                const targetSpawnInfo =
                  originZone.spawnSettings.targetEntities.find(
                    (t) => t.entityTypeId === removedEntity.originalEntityTypeId // <-- USAR ESTO
                  );
                if (targetSpawnInfo && targetSpawnInfo.currentCount > 0) {
                  targetSpawnInfo.currentCount--;
                  // console.log(`Entidad ${removedEntity.name} eliminada de zona ${originZone.name}. Restantes de tipo ${targetSpawnInfo.entityTypeId}: ${targetSpawnInfo.currentCount}`);

                  // Si el contador baja y el timer estaba en cooldown, podemos resetear el timer
                  // para que intente reaparecer antes si la zona está por debajo del objetivo.
                  // Opcional: Podrías querer que el cooldown siempre se cumpla.
                  // if (originZone.spawnSettings.respawnTimer > 10) { // Si estaba en cooldown largo
                  //    originZone.spawnSettings.respawnTimer = 10; // Poner un cooldown corto para el próximo chequeo
                  // }
                }
              }
            }
            renderMap(); // Actualizar visualización
          }
        }

        function isRespawnNeeded() {
          const player = gameState.player;
          const activeBoss = gameState.map.entities.find(
            (e) =>
              e.isBoss &&
              !player.worldState.defeatedBosses[e.id || e.type] &&
              Math.abs(e.x - player.x) <= 5 &&
              Math.abs(e.y - player.y) <= 5
          );
          return !activeBoss;
        }

        function toggleCultivation() {
          if (gameState.battle.active) {
            showModal("Acción no permitida", "No puedes cultivar en combate.");
            return;
          }
          if (gameState.player.isCultivating) {
            showActiveCultivationModal();
          } else {
            openCultivationChoiceModal();
          }
        }

        function openCultivationChoiceModal() {
          const player = gameState.player;
          const techniquesListDiv = document.getElementById("cultivableTechniquesList");
          
          // Comprobación de seguridad
          if (!techniquesListDiv) {
              console.error("Error: El contenedor 'cultivableTechniquesList' no se encontró en el HTML.");
              return;
          }
          
          techniquesListDiv.innerHTML = ""; // Limpiar contenido anterior
          let hasCultivableTechniques = false;

          for (const techId in player.learnedTechniques) {
              const playerTech = player.learnedTechniques[techId];
              const techData = techniqueData[techId];
              if (techData && techData.cultivationSettings && playerTech.level < techData.maxLevel) {
                  hasCultivableTechniques = true;
                  const techButton = document.createElement("button");
                  techButton.className = "cultivation-option-btn";
                  techButton.textContent = `${techData.name} (Nv. ${playerTech.level})`;
                  
                  // --- LA CORRECCIÓN CLAVE ESTÁ AQUÍ ---
                  techButton.onclick = () => {
                      // 1. Primero, cerramos el modal actual.
                      closeCultivationChoiceModal();
                      // 2. Después, iniciamos el nuevo modo de cultivo.
                      startCultivationMode("technique", techId);
                  };
                  // --- FIN DE LA CORRECCIÓN ---

                  techniquesListDiv.appendChild(techButton);
              }
          }

          if (!hasCultivableTechniques) {
              techniquesListDiv.innerHTML = "<p>No tienes técnicas que requieran más cultivo.</p>";
          }

          document.getElementById("cultivationChoiceModal").style.display = "flex";
          hideTouchControls();
      }

        function closeCultivationChoiceModal() {
          document.getElementById("cultivationChoiceModal").style.display =
            "none";
          updatePlayerBarsOnMap();
          showTouchControls();
        }

        function startCultivationMode(type, targetId = null) {
          console.log(`[Cultivo LOG] ==> INTENTO DE INICIAR CULTIVO (Tipo: '${type}', Técnica: '${targetId}')`);
          if (gameState.player.isCultivating || gameState.cultivationInterval) {
              stopCultivation();
          }
          
          gameState.player.isCultivating = true;
          gameState.player.cultivationMode = { type, targetId, startTime: Date.now(), isConversionCultivation: false };
          
          // El intervalo se crea, pero no hacemos nada más que podría fallar aquí.
          gameState.cultivationInterval = setInterval(processCultivationTick, 1000);
          console.log(`[Cultivo LOG] -> NUEVO INTERVALO CREADO. ID: ${gameState.cultivationInterval}`);
          
          // Llamamos a la actualización de la UI por separado.
          showActiveCultivationModal();
          renderQuickSlotBar();
      }

      function stopCultivation(showFeedbackModal = false, feedbackMessage = {}) {
        const player = gameState.player;
        console.log(`[Cultivo LOG] ==> INTENTO DE DETENER CULTIVO`);

        if (!gameState.cultivationInterval) {
            console.log(`[Cultivo LOG]   -> No hay intervalo que detener. El cultivo ya estaba parado.`);
            // Aún así, reseteamos el estado del jugador por si está desincronizado.
            player.isCultivating = false;
            player.cultivationMode = { type: null, targetId: null, startTime: 0, isConversionCultivation: false };
            console.log(`[Cultivo LOG]   -> Estado del jugador reseteado por seguridad.`);
            return;
        }

        const intervalToClear = gameState.cultivationInterval;
        console.log(`[Cultivo LOG]   -> Limpiando intervalo con ID: ${intervalToClear}`);
        clearInterval(intervalToClear);
        gameState.cultivationInterval = null;
        console.log(`[Cultivo LOG]   -> Intervalo limpiado. gameState.cultivationInterval ahora es: ${gameState.cultivationInterval}`);

        player.isCultivating = false;
        player.cultivationMode = { type: null, targetId: null, startTime: 0, isConversionCultivation: false };
        console.log(`[Cultivo LOG]   -> Estado del jugador reseteado: isCultivating = ${player.isCultivating}`);

        closeActiveCultivationModal();
        renderQuickSlotBar();
        updateUI();

        if (showFeedbackModal) {
            console.log(`[Cultivo LOG]   -> Mostrando modal de feedback: "${feedbackMessage.title}"`);
            showModal(feedbackMessage.title || "Cultivo Detenido", feedbackMessage.text || "Has dejado de cultivar.");
        }
    }
     
    function showActiveCultivationModal() {
      const player = gameState.player;
      const modal = document.getElementById("activeCultivationModal");
      if (!modal) return; // Salida temprana si el modal no existe.

      // Ocultar todas las secciones primero
      const techUI = document.getElementById("activeCultivationProgressUI");
      const recoveryUI = document.getElementById("recoveryCultivationProgressUI");
      const boostUI = document.getElementById("cultivationBoostSection");
      
      if (techUI) techUI.style.display = "none";
      if (recoveryUI) recoveryUI.style.display = "none";
      if (boostUI) boostUI.style.display = "none";
      
      if (!player.isCultivating) {
          modal.style.display = "none";
          return;
      }

      const mode = player.cultivationMode.type;
      const targetId = player.cultivationMode.targetId;

      const titleEl = document.getElementById("activeCultivationTitle");
      const descEl = document.getElementById("activeCultivationDescription");
      if (!titleEl || !descEl) return;
      
      if (mode === 'technique' && targetId) {
          const techData = techniqueData[targetId];
          const playerTech = player.learnedTechniques[targetId];

          if (techData && playerTech && techUI) {
              techUI.style.display = "block";
              if (boostUI) boostUI.style.display = "block";
              
              titleEl.textContent = `Cultivando: ${techData.name}`;
              descEl.textContent = techData.description;

              // Actualizar UI de la técnica
              const nameSpan = document.getElementById("activeCultivationTargetName");
              const levelSpan = document.getElementById("activeCultivationTargetLevel");
              if (nameSpan) nameSpan.textContent = techData.name;
              if (levelSpan) levelSpan.textContent = playerTech.level;

              // Lógica de la barra de progreso
              const progressBar = document.getElementById("activeCultivationProgressBar");
              const progressText = document.getElementById("activeCultivationProgressText");
              if (progressBar && progressText) {
                  const progress = playerTech.currentCultivationProgress || 0;
                  const timeToNext = playerTech.cultivationTimeToNextLevel || Infinity;
                  let percent = (timeToNext > 0 && timeToNext !== Infinity) ? (progress / timeToNext) * 100 : (playerTech.level >= techData.maxLevel ? 100 : 0);
                  
                  progressBar.style.width = `${Math.min(100, percent)}%`;
                  progressText.textContent = (timeToNext === Infinity) ? "Nivel Máximo" : `${Math.floor(progress)}s / ${timeToNext}s`;
              }

              // Actualizar sección de aceleración
              const stonesDisplay = document.getElementById("cultivationModalPlayerStones");
              const boostButton = document.getElementById("boostCultivationButton");
              if (stonesDisplay) stonesDisplay.textContent = gameState.inventory["Piedras Espirituales"] || 0;
              if (boostButton) boostButton.disabled = (gameState.inventory["Piedras Espirituales"] || 0) < 1 || playerTech.level >= techData.maxLevel;
          }
      } else if (mode === 'recovery') {
          if (recoveryUI) {
              recoveryUI.style.display = "block";
              titleEl.textContent = "Meditación Restauradora";
              descEl.textContent = "Recuperando energía...";
              
              // Actualizar barras de HP/Maná del modal
              const hpText = document.getElementById("modalHpText");
              const hpBar = document.getElementById("modalHpBar");
              const manaText = document.getElementById("modalManaText");
              const manaBar = document.getElementById("modalManaBar");
              if (hpText) hpText.textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
              if (hpBar) hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
              if (manaText) manaText.textContent = `${Math.floor(player.mana)}/${player.maxMana}`;
              if (manaBar) manaBar.style.width = `${(player.mana / player.maxMana) * 100}%`;
          }
      }
      
      modal.style.display = "flex";
      hideTouchControls();
  }
        
  function closeActiveCultivationModal() {
          document.getElementById("activeCultivationModal").style.display =
            "none";
          updatePlayerBarsOnMap();
          showTouchControls();
        }


      function processCultivationTick() {
        const player = gameState.player;

        // Medida de seguridad: si el tick se ejecuta cuando no debería, se detiene.
        if (!player.isCultivating || !gameState.cultivationInterval) {
            stopCultivation();
            return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        // --- CULTIVO DE TÉCNICA (sin cambios, ya funciona bien) ---
        if (mode === 'technique' && targetId) {
            const playerTech = player.learnedTechniques[targetId];
            const techData = techniqueData[targetId];
            if (playerTech && techData && playerTech.level < techData.maxLevel) {
                playerTech.currentCultivationProgress = (playerTech.currentCultivationProgress || 0) + 1;
                const progress = playerTech.currentCultivationProgress;
                const required = playerTech.cultivationTimeToNextLevel || Infinity;

                if (progress >= required) {
                    playerTech.level++;
                    playerTech.currentCultivationProgress = 0;
                    playerTech.cultivationTimeToNextLevel = playerTech.level < techData.maxLevel ? Math.floor(techData.cultivationSettings.baseTimeToLevelUp * Math.pow(techData.cultivationSettings.levelTimeMultiplier, playerTech.level)) : Infinity;
                    applyTechniqueEffect(targetId, playerTech.level);
                    recalculatePlayerStats();
                    stopCultivation(true, { title: "¡Técnica Mejorada!", text: `¡'${techData.name}' ha subido al Nivel ${playerTech.level}!` });
                    return;
                }
            } else {
                stopCultivation(true, { title: "Cultivo Detenido", text: "La técnica ha alcanzado su máximo potencial." });
                return;
            }

        // --- CULTIVO DE RECUPERACIÓN ---
        } else if (mode === 'recovery') {
            
            // =========================================================================
            // === CORRECCIÓN CLAVE: Lógica de Conversión de Qi (SI ESTÁ ACTIVA) ===
            // =========================================================================
            if (player.cultivationMode.isConversionCultivation) {
                const conversionTechInfo = techniqueData["qi_to_hp_conversion_1"];
                const playerConversionTech = player.learnedTechniques["qi_to_hp_conversion_1"];
                
                if (conversionTechInfo?.effect && playerConversionTech?.level > 0) {
                    const effectDef = conversionTechInfo.effect;
                    const techLevel = playerConversionTech.level;
                    
                    const manaCost = Math.max(0.1, effectDef.baseManaCostPerSecond - (effectDef.manaCostReductionPerLevel || 0) * (techLevel - 1));
                    const hpGain = effectDef.baseHpGainPerSecond + (effectDef.hpGainIncreasePerLevel || 0) * (techLevel - 1);
                    
                    // Si se puede convertir, se hace y se termina el tick.
                    if (player.mana >= manaCost && player.hp < player.maxHp) {
                        player.mana -= manaCost; // <-- Se resta el maná.
                        player.hp = Math.min(player.maxHp, player.hp + hpGain);
                        // IMPORTANTE: No se ejecuta nada más de recuperación en este tick.
                    } else {
                        // Si no se puede, se detiene el cultivo con un mensaje.
                        stopCultivation(true, { title: "Conversión Detenida", text: "Maná insuficiente o vida al máximo." });
                        return; // Salimos del tick para no hacer nada más.
                    }
                } else {
                    // Si por alguna razón falta la técnica, se detiene para evitar errores.
                    stopCultivation(true, { title: "Error de Técnica", text: "No se encontró la técnica de Conversión de Qi." });
                    return;
                }
            
            // ==================================================================================
            // === Lógica de Meditación Restauradora Normal (SOLO SI LA CONVERSIÓN NO ESTÁ ACTIVA) ===
            // ==================================================================================
            } else {
                if (player.hp < player.maxHp) {
                    player.hp = Math.min(player.maxHp, player.hp + player.hpPerSecondBase);
                }
                if (player.mana < player.maxMana) {
                    player.mana = Math.min(player.maxMana, player.mana + player.qiPerSecondBase);
                }
                gainExperience(player.expPerSecondBase);
            }
        }

        // Al final del tick, se actualiza la UI con los nuevos valores.
        updateUI();
        showActiveCultivationModal();
    }

     
      function boostCultivationProgress() {
          const player = gameState.player;
          const mode = player.cultivationMode;

          if (!player.isCultivating || mode.type !== 'technique' || !mode.targetId) return;
          if ((gameState.inventory["Piedras Espirituales"] || 0) < 1) {
              showModal("Piedras Insuficientes", "No tienes suficientes Piedras Espirituales.");
              return;
          }

          const techId = mode.targetId;
          const playerTech = player.learnedTechniques[techId];
          const techData = techniqueData[techId];

          if (!playerTech || !techData || !techData.cultivationSettings || playerTech.level >= techData.maxLevel) {
              showModal("Límite Alcanzado", "Esta técnica ya está en su nivel máximo.");
              return;
          }

          gameState.inventory["Piedras Espirituales"]--;
          playerTech.currentCultivationProgress = (playerTech.currentCultivationProgress || 0) + 10;
          
          let leveledUpThisBoost = false;
          let firstLevelUpMessage = "";

          while (
              playerTech.currentCultivationProgress >= playerTech.cultivationTimeToNextLevel &&
              playerTech.level < techData.maxLevel
          ) {
              leveledUpThisBoost = true;
              const progressNeeded = playerTech.cultivationTimeToNextLevel;
              playerTech.currentCultivationProgress -= progressNeeded;
              playerTech.level++;

              if (!firstLevelUpMessage) {
                  firstLevelUpMessage = `¡Aceleraste '${techData.name}' al Nivel ${playerTech.level}!`;
                  if (playerTech.level >= techData.maxLevel) {
                      firstLevelUpMessage += " (¡Nivel Máximo alcanzado!)";
                  }
              }

              if (playerTech.level < techData.maxLevel) {
                  playerTech.cultivationTimeToNextLevel = Math.floor(
                      techData.cultivationSettings.baseTimeToLevelUp *
                      Math.pow(techData.cultivationSettings.levelTimeMultiplier, playerTech.level)
                  );
              } else {
                  playerTech.cultivationTimeToNextLevel = Infinity;
                  playerTech.currentCultivationProgress = 0;
              }
              applyTechniqueEffect(techId, playerTech.level);
          }
          
          recalculatePlayerStats();
          updateUI();

          if (leveledUpThisBoost) {
              stopCultivation(); // Detener el cultivo
              showModal("¡Técnica Mejorada con Aceleración!", firstLevelUpMessage + "\n\nEl cultivo se ha detenido.");
              // ---- CORRECCIÓN CLAVE ----
              return; // Salir de la función para no ejecutar más código.
          }

          if (playerTech.level >= techData.maxLevel) {
              stopCultivation();
              showModal("Nivel Máximo Alcanzado", `La técnica ${techData.name} ya está en su máximo potencial.`);
              return;
          }

          if (document.getElementById("activeCultivationModal").style.display === "flex") {
              showActiveCultivationModal();
          }
          if (document.getElementById("techniqueModal").style.display === "flex") {
              showTechniquePanel();
          }
      }
       
      function toggleQiConversion() {
          const player = gameState.player;

          // Si ya hay un cultivo de CUALQUIER tipo activo...
          if (player.isCultivating) {
              // ...y ese cultivo es específicamente el de conversión...
              if (player.cultivationMode.isConversionCultivation) {
                  // ...entonces lo detenemos.
                  console.log("Deteniendo cultivo de conversión de Qi activo.");
                  stopCultivation(true, { title: "Conversión Detenida", text: "Has detenido la conversión de Maná a Vida."});
              } else {
                  // Si es otro tipo de cultivo (ej. de técnica), avisamos al jugador.
                  showModal("Acción no permitida", "Debes detener tu cultivo actual para iniciar la conversión de Qi.");
              }
              return;
          }

          // Si no hay ningún cultivo activo, iniciamos el de conversión.
          console.log("Iniciando cultivo con CONVERSIÓN DE QI.");
          
          // CORRECCIÓN CLAVE 1:
          // Iniciamos el modo de cultivo de recuperación, pero inmediatamente después,
          // marcamos que es un modo especial de conversión.
          startCultivationMode('recovery'); 
          player.cultivationMode.isConversionCultivation = true; // <-- Esta es la marca especial.

          // También actualizamos la UI para que el botón refleje el estado activo.
          renderQuickSlotBar();
      }

        

        function useItem(itemName) {
          if (gameState.battle.active) {
            showModal(
              "Acción no permitida",
              "No puedes usar objetos del inventario en combate desde aquí."
            );
            return;
          }
          if (
            !gameState.inventory[itemName] ||
            gameState.inventory[itemName] <= 0
          ) {
            showModal("Inventario Vacío", `No tienes ${itemName}.`);
            return;
          }
          const itemInfo = itemData[itemName];
          if (!itemInfo || !itemInfo.effect) {
            showModal(
              "Error",
              `${itemName} no tiene efecto o no se puede usar así.`
            );
            return;
          }
          if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
            let reason = "No puedes usar esto ahora.";
            if (
              itemName === "Hierbas Medicinales" &&
              gameState.player.hp >= gameState.player.maxHp
            )
              reason = "Vida al máximo.";
            if (
              itemName === "Cristales de Qi" &&
              gameState.player.mana >= gameState.player.maxMana
            )
              reason = "Maná al máximo.";
            showModal("No se puede usar", reason);
            return;
          }
          const message =
            itemName === "Piedras Espirituales" ||
            itemName === "Núcleo de Bestia Menor" ||
            (itemInfo.description &&
              (itemInfo.description.includes("Otorga") ||
                itemInfo.description.includes("otorga")))
              ? itemInfo.effect(gameState.player, gainExperience)
              : itemInfo.effect(gameState.player);

          // Solo decrementar si el mensaje no indica un error (por si el efecto mismo retorna un error)
          if (
            message &&
            !message.toLowerCase().includes("error") &&
            !message.toLowerCase().includes("al máximo")
          ) {
            gameState.inventory[itemName]--;
          }
          showModal("Objeto Usado", message);
          updateUI();
        }

        function gainExperience(amount) {
          if (amount <= 0) return;
          gameState.player.exp += amount;
          while (gameState.player.exp >= gameState.player.expToNext) {
            levelUp();
          }
        }

        function levelUp() {
          const player = gameState.player;
          player.exp -= player.expToNext;
          player.level++;

          const hpIncrease = 20 + Math.floor(player.level / 2);
          const manaIncrease = 10 + Math.floor(player.level / 3);
          const attackIncrease = 2 + Math.floor(player.level / 4);
          const defenseIncrease = 1 + Math.floor(player.level / 5);

          player.baseMaxHp += hpIncrease;
          player.baseMaxMana += manaIncrease;
          player.baseAttack += attackIncrease;
          player.baseDefense += defenseIncrease;

          player.hp = player.baseMaxHp; // Rellenar HP y Mana al subir de nivel
          player.mana = player.baseMaxMana;
          player.expToNext = Math.floor(
            player.expToNext * (1.3 + player.level * 0.02)
          );

          const oldRealm = player.realm;
          const realms = [
            "Mortal",
            "Forjado del Cuerpo",
            "Condensación de Qi",
            "Fundación",
            "Núcleo Dorado",
            "Alma Naciente",
            "Espíritu Primordial",
          ];
          const realmIndex = Math.min(
            Math.floor((player.level - 1) / 5),
            realms.length - 1
          );
          player.realm = realms[realmIndex];
          let realmChangeMessage = "";
          if (player.realm !== oldRealm) {
            realmChangeMessage = `\n\n¡Has avanzado al Reino de ${player.realm}! Sientes una profunda transformación...`;
            generateMap(true);
          }
          recalculatePlayerStats();

          showModal(
            "¡Nivel Aumentado!",
            `Nivel ${player.level}!\nReino: ${player.realm}\n+${hpIncrease} HP, +${manaIncrease} Maná\n+${attackIncrease} Atk, +${defenseIncrease} Def${realmChangeMessage}`
          );
        }

        function recalculatePlayerStats() {
          const player = gameState.player;
          // Reiniciar stats a base
          player.maxHp = player.baseMaxHp;
          player.maxMana = player.baseMaxMana;
          player.attack = player.baseAttack;
          player.defense = player.baseDefense;

          // Asegurar que HP y Mana actuales no excedan los máximos recalculados
          player.hp = Math.min(player.hp, player.maxHp);
          player.mana = Math.min(player.mana, player.maxMana);

          gameState.activeCombatAbilities = []; // Reiniciar lista de habilidades de combate activas

          // Procesar técnicas aprendidas para habilidades de combate activas y efectos pasivos directos
          for (const techId in player.learnedTechniques) {
            const playerTech = player.learnedTechniques[techId];
            if (playerTech.level > 0) {
              // Solo si la técnica ha sido cultivada al menos al nivel 1 (o 0 si así lo defines)
              const techInfo = techniqueData[techId];
              if (
                techInfo?.type === "active_ability" &&
                !gameState.activeCombatAbilities.find(
                  (ab) => ab.id === techInfo.abilityId
                )
              ) {
                gameState.activeCombatAbilities.push({
                  id: techInfo.abilityId,
                  name: techInfo.name,
                  source: "technique",
                  sourceTechniqueId: techId, // Guardar el ID de la técnica fuente es útil
                });
              }
              // Si tienes técnicas pasivas que modifican stats como "Fortificación Corporal Básica",
              // sus efectos ya se aplicaron al player.baseStat cuando se aprendieron/subieron de nivel en applyTechniqueEffect.
              // recalculatePlayerStats se encarga de que maxHp, attack, etc., se actualicen desde baseMaxHp, baseAttack.
            }
          }
          updateUI(); // Actualizar la UI con los stats recalculados
        }

        function startBattle(mapEntity) {
          battleLogHistory = []; 
          const toggleBtn = document.getElementById('toggleMapControlsBtn');
          if (toggleBtn) {
              toggleBtn.classList.add('hidden-during-battle');
          }
          const player = gameState.player;
          if (player.isCultivating) stopCultivation();
          hideTouchControls();

          // Detener animación de caminar al entrar en batalla
          player.isMoving = false;
          if (player.animationTimer) {
            clearInterval(player.animationTimer);
            player.animationTimer = null;
          }
          if (player.idleTimeout) {
            clearTimeout(player.idleTimeout);
            player.idleTimeout = null;
          }
          player.currentDirection = "down"; // O la dirección que quieras en batalla
          player.currentFrame = 0; // Frame idle
          updatePlayerSpriteVisual(); // Actualizar para mostrar el sprite de batalla

          gameState.battle.active = true;
          gameState.battle.enemy = {
            ...mapEntity,
            hp: mapEntity.hp,
            maxHp: mapEntity.maxHp || mapEntity.hp,
            entityRef: mapEntity,
            frozenTurns: 0,
            stunnedTurns: 0,
            burningTurns: 0,
            burnDamage: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            defenseReductionTurns: 0,
            defenseReductionAmount: 0,
            rootedTurns: 0,
            rootDamage: 0,
            attackReductionTurns: 0,
            attackReductionAmount: 0,
            // Nuevos estados para efectos de alto nivel
            silencedTurns: 0, // Turnos en que no puede usar habilidades especiales
            sealedTurns: 0, // Turnos en que no puede realizar ninguna acción
          };
          gameState.battle.playerTurn = true;

          document.getElementById("battleScreen").style.display = "flex";
          populateBattleActionButtons();
          updateBattleUI();
          logBattle(`¡Un ${gameState.battle.enemy.name} te enfrenta!`);
          updateTopNavVisibility();
          updatePlayerBarsOnMap();
        }

        function showFloatingText(targetElement, text, type) {
        if (!targetElement) return;

        const battleScreen = document.getElementById('battleScreen');
        
        const popup = document.createElement('div');
        popup.className = `damage-popup ${type}`;
        popup.textContent = text;
        
        // Lo añadimos al contenedor de la pantalla de batalla para que position:absolute funcione bien
        battleScreen.appendChild(popup);

        // Calculamos la posición inicial del popup
        const targetRect = targetElement.getBoundingClientRect();
        const battleRect = battleScreen.getBoundingClientRect();

        // Posición inicial en el centro-superior del objetivo
        const initialTop = targetRect.top - battleRect.top - 20;
        const initialLeft = targetRect.left - battleRect.left + (targetRect.width / 2) - (popup.offsetWidth / 2);

        popup.style.top = `${initialTop}px`;
        popup.style.left = `${initialLeft}px`;

        // Eliminar el elemento del DOM después de que termine la animación
        popup.addEventListener('animationend', () => {
            popup.remove();
        });
      }

        function populateBattleActionButtons() {
          const battleActionButtons = document.getElementById(
            "battleActionButtons"
          );
          battleActionButtons.innerHTML = `
              <button onclick="battleAction('attack')">⚔️ Atacar</button>
              <button onclick="battleAction('defend')">🛡️ Defender</button>
              <button onclick="battleAction('qi_fist')">🧘 Puño de Qi</button> 
              <button onclick="battleAction('escape')">🏃 Huir</button>
          `;
          gameState.activeCombatAbilities.forEach((ability) => {
            const abilityButton = document.createElement("button");
            let buttonText = `✨ ${ability.name}`;
            let canAfford = true;
            if (ability.source === "technique" && ability.sourceTechniqueId) {
              const techLevel =
                gameState.player.learnedTechniques[ability.sourceTechniqueId]
                  ?.level;
              if (techLevel > 0) buttonText += ` (Nv.${techLevel})`;
              else {
                abilityButton.disabled = true;
                abilityButton.title = "Requiere refinamiento";
              }
            }
            const techDetails =
              ability.source === "technique" && ability.sourceTechniqueId
                ? techniqueData[ability.sourceTechniqueId]
                : null;
            let manaCost = 0;
            if (
              techDetails &&
              techDetails.effect &&
              techDetails.effect.manaCost
            ) {
              manaCost = techDetails.effect.manaCost;
            } else if (ability.id === "qi_blast_minor") {
              manaCost = 15;
            } else if (techDetails && techDetails.manaCost) {
              manaCost = techDetails.manaCost;
            }
            if (manaCost > 0 && gameState.player.mana < manaCost) {
              canAfford = false;
            }

            abilityButton.textContent = buttonText;
            abilityButton.onclick = () => battleAction(ability.id, ability);
            abilityButton.disabled = abilityButton.disabled || !canAfford;
            if (!canAfford && !abilityButton.disabled)
              abilityButton.title = "Maná insuficiente";

            battleActionButtons.appendChild(abilityButton);
          });
        }
       
        function updateExtraStatsUI() {
        // Actualizar Zona
        const zoneEl = document.getElementById('playerZone');
        if (zoneEl) {
            const currentZone = getPlayerCurrentZone();
            zoneEl.textContent = currentZone ? currentZone.name : 'Tierra Salvaje';
        }

        // Actualizar Piedras Espirituales
        const stonesEl = document.getElementById('playerStonesHud');
        if (stonesEl) {
            stonesEl.textContent = gameState.inventory["Piedras Espirituales"] || 0;
        }
      }
       
      function updateBattleUI() {
          const player = gameState.player;
          const enemy = gameState.battle.enemy;
          const battleScreenActive = document.getElementById('battleScreen').style.display === 'flex';

          // --- Actualización del Jugador (Barras sobre el sprite) ---
          const playerBarsContainer = document.getElementById("playerInBattleSpriteBarsContainer");
          const playerSpriteInBattle = document.querySelector(".battle-area .character .character-sprite");

          if (playerBarsContainer && playerSpriteInBattle && battleScreenActive) {
              playerBarsContainer.style.display = 'flex';
              const spriteTop = playerSpriteInBattle.offsetTop;
              const spriteLeft = playerSpriteInBattle.offsetLeft;
              const spriteWidth = playerSpriteInBattle.offsetWidth;
              const barContainerHeight = playerBarsContainer.offsetHeight;

              playerBarsContainer.style.top = `${spriteTop - barContainerHeight - 3}px`;
              playerBarsContainer.style.left = `${spriteLeft + (spriteWidth / 2)}px`;

              const playerHpFill = document.getElementById("playerInBattleSpriteHpFill");
              const playerManaFill = document.getElementById("playerInBattleSpriteManaFill");
              if(playerHpFill) playerHpFill.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
              if(playerManaFill) playerManaFill.style.width = `${Math.max(0, (player.mana / player.maxMana) * 100)}%`;

          } else if (playerBarsContainer) {
              playerBarsContainer.style.display = 'none';
          }

          // --- Actualización del Enemigo (Info y barras sobre el sprite) ---
          const enemyInfoContainer = document.getElementById('enemyInBattleInfoContainer');
          const enemySpriteEl = document.getElementById('enemySprite');
          
          let enemyHpPercent = 0;
          if (enemy) {
              enemyHpPercent = Math.max(0, (enemy.hp / (enemy.maxHp || enemy.hp)) * 100);
          }

          if (enemy && enemyInfoContainer && enemySpriteEl && battleScreenActive) {
              enemyInfoContainer.style.display = 'flex';

              
              // Calculamos la posición del contenedor de la barra de vida del enemigo
              const spriteTop = enemySpriteEl.offsetTop;
              const spriteLeft = enemySpriteEl.offsetLeft;
              const spriteWidth = enemySpriteEl.offsetWidth;
              const infoContainerHeight = enemyInfoContainer.offsetHeight;

              // Posicionamos el contenedor encima del sprite del enemigo
              enemyInfoContainer.style.top = `${spriteTop - infoContainerHeight - 5}px`;
              enemyInfoContainer.style.left = `${spriteLeft + (spriteWidth / 2)}px`;
              

              const enemyNameLevelEl = document.getElementById('enemyBattleNameLevel');
              const enemySpriteHpFill = document.getElementById('enemyInBattleSpriteHpFill');

              if (enemyNameLevelEl) {
                let enemyDisplayName = enemy.name;
                
                // Priorizamos la etiqueta de estatus (Jefe/Élite)
                if (enemy.isBoss) {
                    enemyDisplayName += ` (Jefe)`;
                } else if (enemy.isMiniBoss) {
                    enemyDisplayName += ` (Élite)`;
                }
                
                // Luego, añadimos el nivel si existe
                if (enemy.level) {
                    enemyDisplayName += ` - Nv. ${enemy.level}`;
                }

                enemyNameLevelEl.textContent = enemyDisplayName;
                // Coloreamos el nombre del jefe para que destaque
                if(enemy.isBoss) {
                    enemyNameLevelEl.style.color = '#ff4d4d'; // Rojo
                    enemyNameLevelEl.style.fontWeight = 'bold';
                } else {
                    // Si no es jefe, aplicamos la lógica de color por nivel
                    const nameStyle = getEnemyNameColor(player.level, enemy.level || 1);
                    enemyNameLevelEl.style.color = nameStyle.color;
                    enemyNameLevelEl.style.fontWeight = nameStyle.fontWeight;
                }
            }
              if (enemySpriteHpFill) enemySpriteHpFill.style.width = `${enemyHpPercent}%`;

          } else if (enemyInfoContainer) {
              enemyInfoContainer.style.display = 'none';
          }

          // --- Actualización del resto de la UI de batalla (paneles principales) ---
          if (battleScreenActive) {
              document.getElementById('playerBattleName').textContent = `Cultivador (Nv.${player.level})`;
              document.getElementById('playerBattleHp').textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
              document.getElementById('playerBattleHpBar').style.width = `${(player.hp / player.maxHp) * 100}%`;
              
              if (enemy && enemySpriteEl) {
                  if (enemy.spriteUrl) {
                      enemySpriteEl.style.backgroundImage = `url('${enemy.spriteUrl}')`;
                      enemySpriteEl.textContent = '';
                  } else {
                      enemySpriteEl.style.backgroundImage = 'none';
                      enemySpriteEl.textContent = enemy.symbol || '?';
                  }

                  document.getElementById('enemyName').textContent = enemy.name;
                  document.getElementById('enemyHp').textContent = `${Math.floor(enemy.hp)}/${enemy.maxHp || enemy.hp}`;
                  document.getElementById('enemyHpBar').style.width = `${enemyHpPercent}%`;
              }
          }
      }
        
      function battleAction(action, abilityDetails = null) {
             if (!gameState.battle.playerTurn || !gameState.battle.active) return;
              const player = gameState.player;
              const enemy = gameState.battle.enemy;
              let actionTaken = true;
        
        let playerTechLevel = 0;
        if (abilityDetails && abilityDetails.source === "technique" && abilityDetails.sourceTechniqueId) {
          playerTechLevel = player.learnedTechniques[abilityDetails.sourceTechniqueId]?.level || 0;
        }

          // --- Aplicar DoTs y HoTs al JUGADOR ---
          if (player.burningTurns > 0) {
            player.hp -= player.burnDamage;
            logBattle(`Sufres ${player.burnDamage} daño por quemadura.`);
            player.burningTurns--;
            if (player.burningTurns === 0) logBattle("Quemadura se extingue.");
          }
          if (player.poisonedTurns > 0) {
            player.hp -= player.poisonDamage;
            logBattle(`Sufres ${player.poisonDamage} de daño por veneno.`);
            player.poisonedTurns--;
            if (player.poisonedTurns === 0) {
                logBattle("El veneno se ha disipado.");
                player.poisonDamage = 0;
            }
        }
        // === NUEVA LÓGICA PARA PROCESAR DEBUFFS ===
        if (player.defenseReductionTurns > 0) {
            player.defenseReductionTurns--;
            if (player.defenseReductionTurns === 0) {
                player.defense += player.defenseReductionAmount; // Restaurar defensa
                logBattle(`Tu defensa vuelve a la normalidad. (Defensa: ${player.defense})`);
                player.defenseReductionAmount = 0;
            }
        }
        if (player.attackReductionTurns > 0) {
            player.attackReductionTurns--;
            if (player.attackReductionTurns === 0) {
                player.attack += player.attackReductionAmount; // Restaurar ataque
                logBattle(`Tu espíritu de lucha se recupera. (Ataque: ${player.attack})`);
                player.attackReductionAmount = 0;
            }
        }

          if (player.healingRainTurns > 0) {
            const heal = player.healingRainAmount;
            player.hp = Math.min(player.maxHp, player.hp + heal);
            logBattle(`Lluvia Curativa te sana ${heal} HP.`);
            player.healingRainTurns--;
            if (player.healingRainTurns === 0) logBattle("Lluvia Curativa cesa.");
          }

          // --- Revertir buffs/debuffs temporales del JUGADOR ---
          if (player.defenseBoostTurns > 0) {
            player.defenseBoostTurns--;
            if (player.defenseBoostTurns === 0) {
              player.defense -= player.defenseBoostAmount;
              logBattle(`Piel de Piedra termina. Defensa: ${player.defense}.`);
              player.defenseBoostAmount = 0;
            }
          }
          if (player.bloodRitualTurns > 0 && action !== "blood_ritual") {
            player.bloodRitualTurns--;
            if (player.bloodRitualTurns === 0) {
              player.attack -= player.bloodRitualAttackBoost;
              logBattle(`Ritual de Sangre termina. Ataque: ${player.attack}.`);
              player.bloodRitualAttackBoost = 0;
            }
          }
          if (player.immuneTurns > 0 && action !== "aura_of_purity") {
            player.immuneTurns--;
            if (player.immuneTurns === 0) {
              logBattle(`Inmunidad termina.`);
            }
          }
          if (
            player.cloneActive &&
            player.cloneTurns > 0 &&
            action !== "phantom_clone"
          ) {
            player.cloneTurns--;
            if (player.cloneTurns === 0) {
              player.cloneActive = false;
              logBattle("Clon Fantasma desaparece.");
            }
          }
          if (player.elementalTurns > 0 && action !== "summon_elemental") {
            player.elementalTurns--;
            if (player.elementalTurns === 0) {
              player.attack -= player.tempAttackBonus;
              player.defense -= player.tempDefenseBonus;
              logBattle("Elemental invocado desaparece.");
              player.tempAttackBonus = 0;
              player.tempDefenseBonus = 0;
            }
          }
          if (player.magicShieldTurns > 0 && action !== "mystic_barrier") {
            player.magicShieldTurns--;
            if (player.magicShieldTurns === 0 && player.magicShieldValue > 0) {
              logBattle("Barrera Mística se disipa.");
              player.magicShieldValue = 0;
            }
          }

          if (player.hp <= 0) {
            logBattle("Has sucumbido antes de actuar.");
            player.hp = 0;
            setTimeout(() => {
              player.hp = Math.floor(player.maxHp * 0.1);
              player.mana = Math.floor(player.maxMana * 0.1);
              const expLossPercentage = 0.1;
              const expToLose = Math.floor(player.exp * expLossPercentage);
              player.exp = Math.max(0, player.exp - expToLose);
              logBattle(`Pierdes ${expToLose} EXP.`);
              const safeRespawnCoords = findSafeRespawnLocation(
                G_SAFE_RESPAWN_X,
                G_SAFE_RESPAWN_Y
              );
              player.x = safeRespawnCoords.x;
              player.y = safeRespawnCoords.y;
              updatePlayerPosition();
              endBattle(false);
              showModal("Derrota", "Has sido derrotado...");
            }, 2000);
            return;
          }

          const techDetails = techniqueData[action]; // Obtener detalles de la técnica por su ID
        if (techDetails && techDetails.type === 'active_ability') {
            const manaCost = techDetails.manaCost || 0;
            if (player.mana >= manaCost) {
                player.mana -= manaCost;
                let damageDealt = 0;
                let logMessage = "";
                
                // --- Lógica Centralizada para Habilidades ---
                switch(action) {
                    case "sword_t1":
                      const swordTechDetails = techniqueData["sword_t1"];
                      const swordManaCost = swordTechDetails.manaCost || 10; 
                      if (player.mana >= swordManaCost) {
                          player.mana -= swordManaCost;
                          const damageMultiplier = swordTechDetails.effect.baseDamageMultiplier + ((playerTechLevel - 1) * 0.2);
                          const swordDamage = Math.max(1, Math.floor(player.attack * damageMultiplier) - (enemy.defense || 0));
                          enemy.hp -= swordDamage;
                          logBattle(`¡${swordTechDetails.name} (Nv.${playerTechLevel}) causa ${swordDamage} daño!`);
                          showFloatingText(document.querySelector('.character-sprite'), `Tajo Veloz`, 'ability');
                          showFloatingText(document.getElementById('enemySprite'), `-${swordDamage}`, 'damage');
                      } else { logBattle(`Maná insuficiente para ${swordTechDetails.name}.`); actionTaken = false; }
                      
                      break;
                      
                    case "sword_t3":
                    case "fire_t2":
                        damageDealt = Math.max(1, Math.floor(player.attack * (techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.2)) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} daño!`;
                        if (action === 'fire_t2') {
                             enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                             enemy.burnDamage = Math.max(enemy.burnDamage, techDetails.effect.burnDamagePerTurn + (playerTechLevel * 2));
                             logMessage += ` e inflige una quemadura intensa.`;
                        }
                        break;
                   
                 
                    case "fire_t1":
                        damageDealt = Math.max(1, Math.floor(player.attack * (techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.1)) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;
                        enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                        enemy.burnDamage = Math.max(enemy.burnDamage, techDetails.effect.burnDamagePerTurn + playerTechLevel);
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} daño y quema al enemigo!`;
                        break;

                    case "lightning_t1":
                    case "sword_t4":
                        damageDealt = Math.max(1, Math.floor(player.attack * (techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.15)) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) golpea con ${damageDealt} de daño!`;
                        if (Math.random() < (techDetails.effect.stunChance + (playerTechLevel * 0.02))) {
                            enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                            logMessage += " ¡El enemigo queda aturdido!";
                        }
                        break;
                    
                    case "sword_t2":
                        const defenseToIgnore = (enemy.defense || 0) * (techDetails.effect.defensePenetration + (playerTechLevel * 0.02));
                        damageDealt = Math.max(1, Math.floor(player.attack * (techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * 0.1)) - ((enemy.defense || 0) - defenseToIgnore));
                        enemy.hp -= damageDealt;
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) ignora parte de la defensa y causa ${damageDealt} daño!`;
                        break;

                    case "movement_t2":
                        player.dodgeNextAttack = true;
                        logMessage = `¡Usas ${techDetails.name} (Nv.${playerTechLevel}) y te preparas para esquivar!`;
                        break;

                    case "formation_t1":
                         player.magicShieldValue = (player.magicShieldValue || 0) + (techDetails.effect.shieldValue + (playerTechLevel * 5));
                         player.magicShieldTurns = Math.max(player.magicShieldTurns, techDetails.effect.duration);
                         logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) crea un escudo que absorbe ${techDetails.effect.shieldValue + (playerTechLevel * 5)} de daño!`;
                         break;
                    
                    case "formation_t2":
                         player.magicShieldValue = (player.magicShieldValue || 0) + (techDetails.effect.shieldValue + (playerTechLevel * 5));
                         player.magicShieldTurns = Math.max(player.magicShieldTurns, techDetails.effect.duration);
                         logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) crea un escudo que absorbe ${techDetails.effect.shieldValue + (playerTechLevel * 5)} de daño!`;
                         break;
                    case "formation_t3":
                         player.magicShieldValue = (player.magicShieldValue || 0) + (techDetails.effect.shieldValue + (playerTechLevel * 5));
                         player.magicShieldTurns = Math.max(player.magicShieldTurns, techDetails.effect.duration);
                         logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) crea un escudo que absorbe ${techDetails.effect.shieldValue + (playerTechLevel * 20)} de daño!`;
                         showFloatingText(document.getElementById('enemySprite'), 'Defensa ↓ / Ataque ↓', 'debuff');
                         break;
                    case "sword_t5": // Corte que Divide Cielos y Tierra
                        const baseDmg_t5 = player.attack * techDetails.effect.baseDamageMultiplier;
                        let finalDmg_t5 = baseDmg_t5;
                        logMessage = `¡${techDetails.name} desata un poder que ignora la defensa!`;
                        if (Math.random() < (techDetails.effect.criticalChance || 0)) {
                           finalDmg_t5 *= 1.5;
                           logMessage += " ¡Es un golpe crítico!";
                        }
                        enemy.hp -= Math.floor(finalDmg_t5);
                        logMessage += ` Causa ${Math.floor(finalDmg_t5)} daño verdadero.`;
                        break;

                    case "fire_t5": // Llama del Fénix Renaciente
                        const fireDmg_t5 = Math.floor(player.attack * techDetails.effect.baseDamageMultiplier);
                        enemy.hp -= fireDmg_t5;
                        player.canRevive = true; // Activa la bandera de resurrección
                        logMessage = `¡${techDetails.name} incinera al enemigo con ${fireDmg_t5} de daño y te imbuye con la esencia del Fénix!`;
                        break;
                    
                    case "formation_t5": // Matriz de Reversión del Cosmos
                        player.damageToHealingTurns = techDetails.effect.damageToHealingDuration;
                        logMessage = `¡Activaste ${techDetails.name}! Durante ${player.damageToHealingTurns} turnos, el daño recibido te curará.`;
                        break;

                    case "movement_t5": // Paso del Vacío Infinito
                         player.intangibleTurns = techDetails.effect.intangibleTurns;
                         const hits_t5 = techDetails.effect.multiHit;
                         let totalDmg_t5 = 0;
                         for(let i=0; i<hits_t5; i++){
                            const hitDmg = Math.max(1, Math.floor((player.attack * techDetails.effect.baseDamageMultiplier)/hits_t5) - enemy.defense);
                            enemy.hp -= hitDmg;
                            totalDmg_t5 += hitDmg;
                         }
                         logMessage = `¡Con ${techDetails.name} te vuelves intangible por ${player.intangibleTurns} turnos y golpeas ${hits_t5} veces, causando un total de ${totalDmg_t5} de daño!`;
                         break;

                    case "sword_t6": // Espada del Emperador Celestial
                         logMessage = `¡${techDetails.name} desata un poder absoluto!`;
                         if (enemy.hp / enemy.maxHp <= (techDetails.effect.executeThreshold || 0.2)) {
                            enemy.hp = 0;
                            logMessage += " ¡El enemigo es ejecutado por decreto celestial!";
                         } else {
                            const swordDmg_t6 = Math.floor(player.attack * techDetails.effect.baseDamageMultiplier);
                            enemy.hp -= swordDmg_t6;
                            logMessage += ` Causa ${swordDmg_t6} de daño que ignora toda protección.`;
                         }
                         break;
                    
                    case "formation_t6": // Matriz del Sello del Demonio
                        enemy.sealedTurns = techDetails.effect.sealDuration;
                        logMessage = `¡${techDetails.name} sella completamente al enemigo por ${enemy.sealedTurns} turnos!`;
                        break;
                    
                    default:
                        logBattle(`Técnica ${action} no implementada en batalla.`);
                        actionTaken = false;
                        break;
                }
                if(actionTaken) logBattle(logMessage);

            } else {
              logBattle(`Maná insuficiente para ${techDetails.name}.`);
              actionTaken = false;
            }
        } else {
            // Lógica para acciones básicas (attack, defend, escape)
            switch (action) {
                case "attack":
                    const damage = Math.max(1, player.attack - (enemy.defense || 0) + Math.floor(Math.random() * 5 - 2));
                    enemy.hp -= damage;
                    logBattle(`Atacas causando ${damage} daño.`);
                    showFloatingText(document.getElementById('enemySprite'), `-${damage}`, 'damage');
        
                    break;
                case 'qi_fist':
                  const qiFistCost = 10;
                    if (player.mana >= qiFistCost) {
                        player.mana -= qiFistCost;
                        const magicDamage = Math.max(1, Math.floor(player.attack * 0.8 + player.maxMana * 0.2) - (enemy.defense || 0));
                        enemy.hp -= magicDamage;
                        logBattle(`Puño de Qi causa ${magicDamage} daño mágico.`);
                        showFloatingText(document.querySelector('.character-sprite'), `Puño de QI`, 'ability');
                        showFloatingText(document.getElementById('enemySprite'), `-${magicDamage}`, 'damage');
                        
                    } else { logBattle('Maná insuficiente para Puño de Qi.'); actionTaken = false; }
                    
                  break;
                case "defend":
                    let healAmount = Math.floor(player.maxHp * 0.1);
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    showFloatingText(document.querySelector('.character-sprite'), `+${healAmount}`, 'heal');
                    logBattle(`Te defiendes y recuperas ${healAmount} HP.`);
                    break;
                case "escape":
                  if (enemy.isBoss) {
                    logBattle(`¡No puedes huir de un ${enemy.name}!`);
                    showFloatingText(document.querySelector('.character-sprite'), '¡Imposible!', 'debuff');
                    actionTaken = false; // La acción falló, no se consume el turno
                  } else if (Math.random() < 0.7) { // Probabilidad de éxito de huida
                      
                      const escapeTile = findEscapeTile(player, enemy);
                      
                      if (escapeTile) {
                          logBattle("¡Escapaste con éxito!");
                          showFloatingText(document.querySelector('.character-sprite'), '¡Huida!', 'ability');
                          
                          // Mover al jugador a la casilla segura ANTES de terminar la batalla
                          player.x = escapeTile.x;
                          player.y = escapeTile.y;
                          
                          // Esperar un breve momento para que el texto flotante se vea
                          setTimeout(() => {
                              endBattle(false); // false = no fue una victoria
                              updatePlayerPosition("escape_success"); // Actualizar la posición visual en el mapa
                          }, 500);

                      } else {
                          logBattle("¡Intentaste huir, pero no hay a dónde ir!");
                          showFloatingText(document.querySelector('.character-sprite'), '¡Atrapado!', 'debuff');
                          actionTaken = true; // El intento de huir consume el turno
                      }
                      
                      // Como la huida (exitosa o no) ya manejó el flujo, salimos de la función
                      return;

                  } else {
                    logBattle("¡No pudiste escapar!");
                    showFloatingText(document.querySelector('.character-sprite'), '¡Falló!', 'debuff');
                    actionTaken = true; // El intento fallido también consume el turno
                  }
                  break;
                default:
                    logBattle("Acción desconocida.");
                    actionTaken = false;
                    break;
            }
        }

        if (!actionTaken) {
          updateBattleUI();
          return;
        }

        gameState.battle.playerTurn = false;
        updateBattleUI();

        if (enemy.hp <= 0) {

          
            handleEnemyDefeat();
          } else {
            let enemyDiedToDot = false;
            if (enemy.burningTurns > 0) {
              enemy.hp -= enemy.burnDamage;
              logBattle(
                `${enemy.name} sufre ${
                  enemy.burnDamage
                } por quemadura. HP: ${Math.floor(enemy.hp)}`
              );
              if (enemy.hp <= 0) enemyDiedToDot = true;
            }
            if (!enemyDiedToDot && enemy.poisonedTurns > 0) {
              enemy.hp -= enemy.poisonDamage;
              logBattle(
                `${enemy.name} sufre ${
                  enemy.poisonDamage
                } por veneno. HP: ${Math.floor(enemy.hp)}`
              );
              if (enemy.hp <= 0) enemyDiedToDot = true;
            }
            if (!enemyDiedToDot && enemy.rootedTurns > 0) {
              enemy.hp -= enemy.rootDamage;
              logBattle(
                `${enemy.name} sufre ${
                  enemy.rootDamage
                } por enredo. HP: ${Math.floor(enemy.hp)}`
              );
              if (enemy.hp <= 0) enemyDiedToDot = true;
            }

            if (enemyDiedToDot) {
              handleEnemyDefeat();
            } else {
              setTimeout(enemyTurn, 1000);
            }
          }
        }

        function handleEnemyDefeat() {
          const enemy = gameState.battle.enemy;
          const player = gameState.player;

          logBattle(`¡Has derrotado al ${enemy.name}!`);
          gainExperience(enemy.exp);

          const misionesActivasDelJugador = [...player.secta.misionesActivas];
          
          misionesActivasDelJugador.forEach((misionActiva) => {
              const misionDataOriginal = MISIONES_DATA[misionActiva.id];
              if (!misionDataOriginal || !misionActiva.objetivoOriginal) return;
              
              const objetivo = misionActiva.objetivoOriginal;

              // Lógica para actualizar el progreso de la misión de desafío
              if (objetivo.tipo === "derrotar_npc_especifico" && enemy.isSectChallengeRival && enemy.npcId === objetivo.npcId) {
                  misionActiva.progreso = 1; // 1 significa "objetivo cumplido".
                  logBattle(`¡Has superado la prueba! Reporta tu éxito en la secta.`);
                  console.log(`[Misión Desafío] Progreso de la misión '${misionActiva.id}' actualizado a 1.`);
              } 
              // Lógica para otras misiones de eliminación
              else if (objetivo.tipo === "eliminar_enemigo" && (enemy.originalEntityTypeId === objetivo.enemigoTipo || enemy.name === objetivo.nombreDisplay)) {
                  misionActiva.progreso = (misionActiva.progreso || 0) + 1;
                  logBattle(`Progreso '${misionDataOriginal.titulo}': ${misionActiva.progreso}/${objetivo.cantidad}`);
              } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot" && enemy.originalEntityTypeId === objetivo.enemigoTipo) {
                  misionActiva.progreso = 1;
                  logBattle(`Has derrotado a un ${enemy.name}. Busca el ${objetivo.itemPrueba} entre el botín.`);
              }
          });
          
          updateSectUI();

          // El resto de la función (loot, etc.) no cambia...
          let lootObtenidoTexto = "Botín Obtenido: ";
          let algoObtenido = false;
          if (enemy.lootTable) {
              enemy.lootTable.forEach(loot => {
                  if (Math.random() < loot.chance) {
                      const cantidad = loot.quantity[0] + Math.floor(Math.random() * (loot.quantity[1] - loot.quantity[0] + 1));
                      gameState.inventory[loot.itemName] = (gameState.inventory[loot.itemName] || 0) + cantidad;
                      lootObtenidoTexto += `${cantidad} ${loot.itemName}, `;
                      algoObtenido = true;
                  }
              });
          }
          if (!algoObtenido) lootObtenidoTexto += "Nada.";
          else lootObtenidoTexto = lootObtenidoTexto.slice(0, -2) + ".";

          if (enemy.isBoss && enemy.originalEntityTypeId) {
              player.worldState.defeatedBosses[enemy.originalEntityTypeId] = true;
              if (enemy.nextBossId) {
                  player.worldState.currentBossToSpawn = enemy.nextBossId;
              } else {
                  player.worldState.currentBossToSpawn = null;
              }
          } else if (enemy.isMiniBoss && enemy.isFixed && enemy.originalEntityTypeId) {
              if (!player.worldState.defeatedFixedEntities) player.worldState.defeatedFixedEntities = {};
              player.worldState.defeatedFixedEntities[enemy.originalEntityTypeId] = { time: Date.now() };
          }

          setTimeout(() => {
              endBattle(true);
              showModal("¡Victoria!", `Has ganado el combate.\n\n${lootObtenidoTexto}\n\nRevisa tu diario de misiones para ver el progreso.`);
          }, 1500);
      }

        function completeMission(misionId, npcIdEntregaManual = null) {
          const player = gameState.player;
          const misionActiva = player.secta.misionesActivas.find((m) => m.id === misionId);
          const misionDataOriginal = MISIONES_DATA[misionId];

          if (!misionActiva || !misionDataOriginal) {
            showModal("Error de Misión", "Datos de la misión no encontrados.");
            return false;
          }

          const objetivo = misionActiva.objetivoOriginal;
          let objetivosCumplidos = false;

          switch (objetivo.tipo) {
            case "entregar_item":
              if ((gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad) {
                if (npcIdEntregaManual && npcIdEntregaManual === objetivo.npcEntrega) {
                  gameState.inventory[objetivo.item] -= objetivo.cantidad;
                  updateInventoryUI();
                  objetivosCumplidos = true;
                }
              } else {
                  showModal("Objetivo Incompleto", `Aún necesitas ${objetivo.cantidad - (gameState.inventory[objetivo.item] || 0)} ${objetivo.item}.`);
                  return false;
              }
              break;
            case "eliminar_enemigo":
              if (misionActiva.progreso >= objetivo.cantidad) {
                objetivosCumplidos = true;
              }
              break;
            case "derrotar_npc_especifico":
              if (misionActiva.progreso === 1) { 
                objetivosCumplidos = true;
              } else {
                showModal("Objetivo Incompleto", "Aún no has derrotado al oponente del desafío.");
                return false;
              }
              break;
            case "recolectar_multiples_items":
              let todosItemsRecolectados = true;
              for (const itemReq of objetivo.items) {
                if (
                  (gameState.inventory[itemReq.nombre] || 0) < itemReq.cantidad
                ) {
                  todosItemsRecolectados = false;
                  break;
                }
              }
              if (todosItemsRecolectados) {
                  if(npcIdEntregaManual === objetivo.npcEntrega) {
                      for (const itemReq of objetivo.items) {
                          gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                      }
                      updateInventoryUI();
                      objetivosCumplidos = true;
                  }
              }
              break;
            case "cazar_y_recuperar_item_de_loot":
                  if (misionActiva.progreso === 1 && (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba) {
                      if (npcIdEntregaManual === objetivo.npcEntrega) {
                          gameState.inventory[objetivo.itemPrueba] -= objetivo.cantidadItemPrueba;
                          updateInventoryUI();
                          objetivosCumplidos = true;
                      }
                  }
              break;
            default:
              showModal("Error de Misión", "Tipo de objetivo no reconocido.");
              return false;
          }

          if (!objetivosCumplidos) {
            console.log(`Objetivos no cumplidos para ${misionDataOriginal.titulo} al intentar completar.`);
            return false;
          }

          // --- Dar Recompensas ---
          player.secta.puntosContribucion += misionDataOriginal.recompensa.pcs || 0;
          gainExperience(misionDataOriginal.recompensa.exp || 0);
          let recompensaItemsTexto = "";
          if (misionDataOriginal.recompensa.items) {
            for (const itemName in misionDataOriginal.recompensa.items) {
              gameState.inventory[itemName] = (gameState.inventory[itemName] || 0) + misionDataOriginal.recompensa.items[itemName];
              recompensaItemsTexto += `${misionDataOriginal.recompensa.items[itemName]} ${itemName}, `;
            }
            updateInventoryUI();
            if (recompensaItemsTexto) recompensaItemsTexto = recompensaItemsTexto.slice(0, -2);
          }

          let recompensaTextoGlobal = `Recompensas: ${misionDataOriginal.recompensa.pcs || 0} PCS, ${misionDataOriginal.recompensa.exp || 0} EXP`;
          if (recompensaItemsTexto) recompensaTextoGlobal += `, ${recompensaItemsTexto}`;

          player.secta.misionesActivas = player.secta.misionesActivas.filter((m) => m.id !== misionId);
          player.secta.misionesCompletadas[misionId] = true;

          showModal("¡Misión Completada!", `Completaste: ${misionDataOriginal.titulo}.\n${recompensaTextoGlobal}`);

          if (misionDataOriginal.recompensa.nuevoRango) {
            const newRankName = misionDataOriginal.recompensa.nuevoRango;
            player.secta.rango = newRankName;
            
            setTimeout(() => showModal("¡Ascenso en la Secta!", `¡Felicidades! Ascendiste a ${player.secta.rango}.`), 2500);
            
            applyRankBenefits(player.secta.rango);

            // === INICIO DE LA MODIFICACIÓN CLAVE ===
            // Comprobamos si el nuevo rango tiene una elección de técnica como recompensa.
            const rankData = SECTA_DATA.rangos.find(r => r.nombre === newRankName);
            if (rankData && rankData.techniqueChoice) {
                // Esperamos un poco más para que no se solape con el modal de ascenso.
                setTimeout(() => {
                    openRankUpRewardModal(newRankName);
                }, 4500); 
            }
            // === FIN DE LA MODIFICACIÓN CLAVE ===
          }

          updateSectUI();
          checkAndActivateRankChallengeMissions();
          return true;
        }
       
        function openRankUpRewardModal(newRankName) {
          const modal = document.getElementById('rankUpRewardModal');
          const titleEl = document.getElementById('rankUpRewardTitle');
          const optionsContainer = document.getElementById('rankUpRewardOptionsContainer');

          if (!modal || !titleEl || !optionsContainer) {
              console.error("Elementos del modal de recompensa de rango no encontrados.");
              return;
          }

          const rankData = SECTA_DATA.rangos.find(r => r.nombre === newRankName);
          if (!rankData || !rankData.techniqueChoice || rankData.techniqueChoice.length === 0) {
              console.log(`No hay recompensas de técnica para el rango ${newRankName}.`);
              return;
          }

          titleEl.textContent = `Recompensa por ascender a ${newRankName}`;
          optionsContainer.innerHTML = ''; // Limpiar opciones anteriores

          rankData.techniqueChoice.forEach(techId => {
              const techInfo = techniqueData[techId];
              if (techInfo) {
                  const button = document.createElement('button');
                  button.className = 'cultivation-option-btn';
                  button.innerHTML = `
                      <strong>${techInfo.icon || '📜'} ${techInfo.name}</strong>
                      <br>
                      <small style="opacity: 0.8;">${techInfo.description}</small>
                  `;
                  button.onclick = () => claimRankUpReward(techId);
                  optionsContainer.appendChild(button);
              }
          });

          modal.style.display = 'flex';
          hideTouchControls();
        }

        function claimRankUpReward(techId) {
            // Buscamos el nombre del "Rollo" que enseña esta técnica
            let scrollItemName = null;
            const techDefinition = techniqueData[techId];

            // Este bucle asume que el nombre de la técnica en la definición y en el nombre del rollo coinciden.
            // Ej: techniqueData.sword_slash_1.name es "Corte de Espada Básico"
            // y el item se llama "Rollo: Corte de Espada Básico"
            if(techDefinition) {
                const expectedScrollName = `Rollo: ${techDefinition.name}`;
                if(itemData[expectedScrollName]) {
                    scrollItemName = expectedScrollName;
                }
            }
            
            if (scrollItemName) {
                gameState.inventory[scrollItemName] = (gameState.inventory[scrollItemName] || 0) + 1;
                updateInventoryUI();
                closeRankUpRewardModal();
                showModal("¡Recompensa Obtenida!", `Has recibido el "${scrollItemName}".\nRevisa tu inventario para aprender la técnica.`);
            } else {
                console.error(`No se pudo encontrar el objeto 'Rollo' para la técnica con ID: ${techId}`);
                showModal("Error de Recompensa", "No se pudo otorgar la recompensa. Contacta a un Anciano de la Secta (o al desarrollador).");
            }
        }

        function closeRankUpRewardModal() {
          const modal = document.getElementById('rankUpRewardModal');
          if(modal) modal.style.display = 'none';
          showTouchControls();
        }
        
        function updateSectUI() {
          const player = gameState.player;
          document.getElementById("sectaNombreDisplay").textContent =
            player.secta.nombre;
          document.getElementById("playerSectRank").textContent =
            player.secta.rango;
          document.getElementById("playerPCS").textContent =
            player.secta.puntosContribucion;

          const missionsListDiv = document.getElementById("activeMissionsList");
          missionsListDiv.innerHTML = "";

          if (player.secta.misionesActivas.length === 0) {
            missionsListDiv.innerHTML = "<p>Ninguna misión activa.</p>";
          } else {
            player.secta.misionesActivas.forEach((misionActiva) => {
              const misionDataOriginal = MISIONES_DATA[misionActiva.id];
              if (misionDataOriginal && misionActiva.objetivoOriginal) {
                // Asegurar que objetivoOriginal exista
                let progresoTexto = "";
                const objetivo = misionActiva.objetivoOriginal;
                const npcEntregaNombre =
                  SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre ||
                  "NPC correspondiente";

                if (objetivo.tipo === "eliminar_enemigo") {
                  progresoTexto = ` (${misionActiva.progreso || 0}/${
                    objetivo.cantidad
                  } ${objetivo.nombreDisplay || "objetivos"})`;
                  if ((misionActiva.progreso || 0) >= objetivo.cantidad) {
                    progresoTexto += ` <strong>¡Listo para entregar a ${npcEntregaNombre}!</strong>`;
                  }
                } else if (objetivo.tipo === "entregar_item") {
                  const tiene = gameState.inventory[objetivo.item] || 0;
                  const necesita = objetivo.cantidad;
                  progresoTexto = ` (Tienes ${tiene}/${necesita} ${objetivo.item})`;
                  if (tiene >= necesita) {
                    progresoTexto += ` <strong>¡Listo para entregar a ${npcEntregaNombre}!</strong>`;
                  }
                } else if (objetivo.tipo === "recolectar_multiples_items") {
                  let todosListos = true;
                  let itemsStatusArray = objetivo.items.map((itemReq) => {
                    const tiene = gameState.inventory[itemReq.nombre] || 0;
                    const necesita = itemReq.cantidad;
                    if (tiene < necesita) todosListos = false;
                    return `${tiene}/${necesita} ${itemReq.nombre}`;
                  });
                  progresoTexto = ` (${itemsStatusArray.join(", ")})`;
                  if (todosListos) {
                    progresoTexto += ` <strong>¡Listo para entregar a ${npcEntregaNombre}!</strong>`;
                  }
                } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot") {
                  const tieneItem =
                    (gameState.inventory[objetivo.itemPrueba] || 0) >=
                    objetivo.cantidadItemPrueba;
                  progresoTexto =
                    misionActiva.progreso === 1 && tieneItem
                      ? ` (Prueba '${objetivo.itemPrueba}' obtenida)`
                      : ` (Cazar ${objetivo.enemigoTipo} y obtener ${objetivo.itemPrueba})`;
                  if (misionActiva.progreso === 1 && tieneItem) {
                    progresoTexto += ` <strong>¡Listo para entregar a ${npcEntregaNombre}!</strong>`;
                  }
                } else if (objetivo.tipo === "derrotar_npc_especifico") {
                  // Estas se autocompletan, así que no aparecerán mucho aquí si se completan rápido
                  progresoTexto = ` (Derrotar a ${
                    entityTypes[objetivo.npcId]?.name || "objetivo"
                  })`;
                }
                const p = document.createElement("p");
                p.innerHTML = `<strong>${misionDataOriginal.titulo}</strong><small>${progresoTexto}</small>`;
                missionsListDiv.appendChild(p);
              }
            });
          }
        }

        function checkAndActivateRankChallengeMissions() {
          const player = gameState.player;
          const currentRankIndex = SECTA_DATA.rangos.findIndex(
            (r) => r.nombre === player.secta.rango
          );

          if (currentRankIndex === -1) {
            console.error(
              "Error: Rango actual del jugador no encontrado en SECTA_DATA.rangos"
            );
            return;
          }

          // Si ya está en el rango máximo, no hay más desafíos
          if (currentRankIndex + 1 >= SECTA_DATA.rangos.length) {
            // console.log("Jugador en el rango máximo o no hay más rangos definidos.");
            return;
          }

          const nextRankData = SECTA_DATA.rangos[currentRankIndex + 1];

          // Verificar si el jugador cumple los PCS para el siguiente rango
          if (player.secta.puntosContribucion >= nextRankData.pcsRequeridos) {
            // Verificar si hay un ID de rival para el desafío de este próximo rango
            if (nextRankData.desafioRivalId) {
              const desafioMisionId = Object.keys(MISIONES_DATA).find((mId) => {
                const mision = MISIONES_DATA[mId];
                return (
                  mision.objetivo?.tipo === "derrotar_npc_especifico" &&
                  mision.objetivo?.npcId === nextRankData.desafioRivalId &&
                  (mision.autoActivarAlCumplirRequisitos === true ||
                    mision.recompensa?.nuevoRango === nextRankData.nombre)
                ); // Condición para identificar la misión de desafío
              });

              if (desafioMisionId) {
                // Verificar si la misión de desafío NO está ya activa o completada
                const isMissionActive = player.secta.misionesActivas.some(
                  (m) => m.id === desafioMisionId
                );
                const isMissionCompleted =
                  player.secta.misionesCompletadas[desafioMisionId];

                if (!isMissionActive && !isMissionCompleted) {
                  acceptMission(desafioMisionId);
                  const misionData = MISIONES_DATA[desafioMisionId];
                  showModal(
                    "¡Nuevo Desafío de Rango!",
                    `Has alcanzado los requisitos de PCS para el rango de ${nextRankData.nombre}.\n` +
                      `Se ha activado la misión de desafío: "${misionData.titulo}".\n` +
                      `¡Prepárate y busca a tu oponente en la arena de la secta!`
                  );

                  // Asegurar que el NPC del desafío (el rival) aparezca en el mapa si tiene fixedLocation
                  // ensureFixedEntities() debería encargarse de esto si el rival está en la lista de entidades fijas
                  // y no ha sido derrotado (lo cual es el caso si la misión se acaba de activar).
                  // Si el rival no es una entidad fija por defecto, podrías añadirlo aquí dinámicamente,
                  // pero es más limpio manejarlo con ensureFixedEntities.
                  ensureFixedEntities();
                  renderMap(); // Para asegurar que el rival (si es nuevo) se muestre
                } else {
                  // console.log(`Misión de desafío ${desafioMisionId} para ${nextRankData.nombre} ya está activa o completada.`);
                }
              } else {
                console.warn(
                  `No se encontró una misión de desafío auto-activable para el rival ${nextRankData.desafioRivalId} del rango ${nextRankData.nombre}.`
                );
              }
            } else {
              // console.log(`El siguiente rango ${nextRankData.nombre} no tiene un desafioRivalId definido. Podría ser un rango sin desafío.`);
            }
          } else {
            // console.log(`Jugador no tiene suficientes PCS para el siguiente rango ${nextRankData.nombre}. Necesita: ${nextRankData.pcsRequeridos}, Tiene: ${player.secta.puntosContribucion}`);
          }
          updateSectUI(); // Actualizar la UI de la secta por si algo cambió
        }

        function applyRankBenefits(newRankName) {
          const rankData = SECTA_DATA.rangos.find(
            (r) => r.nombre === newRankName
          );
          if (rankData) {
            showModal(
              "Beneficios de Rango",
              `Has obtenido beneficios de ${newRankName}: ${rankData.beneficios}`
            );
          }
          updateUI();
        }

        function enemyTurn() {
        if (!gameState.battle.active || gameState.battle.playerTurn) return;
        
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const playerSprite = document.querySelector('.character-sprite');
        const enemySprite = document.getElementById('enemySprite');
        
        // 1. Procesar estados y DoTs del enemigo
        // (Esta parte no cambia, se mantiene como estaba)
        if (enemy.sealedTurns > 0 || enemy.frozenTurns > 0 || enemy.stunnedTurns > 0) {
            // ... (Lógica para saltar turno)
            const statusMessage = enemy.sealedTurns > 0 ? '¡Sellado!' : (enemy.frozenTurns > 0 ? '¡Congelado!' : '¡Aturdido!');
            showFloatingText(enemySprite, statusMessage, 'debuff');
            logBattle(`¡${enemy.name} está ${statusMessage.toLowerCase().replace('¡','')} y no puede actuar!`);
            
            if(enemy.sealedTurns > 0) enemy.sealedTurns--;
            if(enemy.frozenTurns > 0) enemy.frozenTurns--;
            if(enemy.stunnedTurns > 0) enemy.stunnedTurns--;
            
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
        }

        // 2. Decidir la acción del enemigo (Habilidad o Ataque Básico)
        let chosenAbilityData = null;
        let usedAbility = false;

        if (enemy.abilities && enemy.silencedTurns <= 0) {
            for (const ability of enemy.abilities) {
                if (Math.random() < ability.chance) {
                    chosenAbilityData = enemyAbilityData[ability.abilityId];
                    if (chosenAbilityData) {
                        usedAbility = true;
                        showFloatingText(enemySprite, chosenAbilityData.name, 'ability');
                        break;
                    }
                }
            }
        }

        let damageToDeal = 0;
        let effectsToApply = {};

        if (usedAbility && chosenAbilityData) {
            // Preparar el ataque de la habilidad
            damageToDeal = Math.floor(enemy.attack * (chosenAbilityData.effect.baseDamageMultiplier || 1.0));
            effectsToApply = chosenAbilityData.effect;
        } else {
            // Preparar un ataque básico
            damageToDeal = enemy.attack;
        }

        // 3. Comprobar las defensas del jugador ANTES de aplicar el daño
        if (player.intangibleTurns > 0) {
            logBattle(`¡Eres intangible! El ataque de ${enemy.name} te atraviesa sin causar daño.`);
            showFloatingText(playerSprite, 'Intangible', 'ability');
            player.intangibleTurns--;
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
        }
        if (player.dodgeNextAttack) {
            player.dodgeNextAttack = false;
            logBattle(`¡Esquivas el ataque de ${enemy.name}!`);
            showFloatingText(playerSprite, 'Esquivado', 'ability');
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
        }
        
        // 4. Aplicar el daño y los efectos si el ataque no fue anulado
        const finalDamage = Math.max(0, damageToDeal - player.defense);
        
        if (finalDamage > 0) {
            player.hp -= finalDamage;
            showFloatingText(playerSprite, `-${finalDamage}`, 'damage');
        } else {
            showFloatingText(playerSprite, 'Bloqueado', 'ability');
        }

        // Aplicar efectos de la habilidad (veneno, debuffs, etc.)
        if (usedAbility && effectsToApply) {
            if (effectsToApply.poison && !player.isImmuneToStatus) {
                player.poisonedTurns = Math.max(player.poisonedTurns, effectsToApply.poison.duration);
                player.poisonDamage = Math.max(player.poisonDamage, effectsToApply.poison.damagePerTurn);
                showFloatingText(playerSprite, 'Envenenado', 'debuff');
            }
            if (effectsToApply.debuff && !player.isImmuneToStatus) {
                const debuff = effectsToApply.debuff;
                if (debuff.stat === 'defense' && player.defenseReductionTurns === 0) {
                    player.defenseReductionAmount = debuff.amount;
                    player.defense -= debuff.amount;
                    player.defenseReductionTurns = debuff.duration;
                    showFloatingText(playerSprite, 'Defensa ↓', 'debuff');
                }
                // ... (añadir otros debuffs aquí)
            }
            if (effectsToApply.lifesteal) {
                const healAmount = Math.floor(finalDamage * effectsToApply.lifesteal);
                enemy.hp = Math.min(enemy.maxHp, enemy.hp + healAmount);
                showFloatingText(enemySprite, `+${healAmount}`, 'heal');
            }
            logBattle(chosenAbilityData.logMessage(enemy.name, finalDamage, effectsToApply.poison?.damagePerTurn || effectsToApply.debuff?.amount, effectsToApply.poison?.duration || effectsToApply.debuff?.duration));
        } else {
            // Log para el ataque básico
            if (finalDamage > 0) {
                logBattle(`${enemy.name} te ataca y te causa ${finalDamage} de daño.`);
            } else {
                logBattle(`${enemy.name} te ataca pero tu defensa absorbe todo el impacto.`);
            }
        }
        
        // 5. Comprobar si el jugador fue derrotado
        if (player.hp <= 0) {
            player.hp = 0;
            // ... (lógica de salvación por habilidades y derrota no cambia) ...
            let hasBeenSaved = false;
            if (player.canRevive) { // Simplificado para el ejemplo
                 player.hp = Math.floor(player.maxHp * 0.5);
                 player.canRevive = false;
                 logBattle("¡La Llama del Fénix te devuelve a la vida!");
                 showFloatingText(playerSprite, '¡Revivido!', 'heal');
                 hasBeenSaved = true;
            }
            
            if (!hasBeenSaved) {
                
               logBattle("¡Has sido derrotado!");
                const expLoss = Math.floor(gameState.player.exp * 0.1);
                setTimeout(() => {
                    gameState.player.hp = Math.floor(gameState.player.maxHp * 0.1);
                    gameState.player.mana = Math.floor(gameState.player.maxMana * 0.1);
                    gameState.player.exp = Math.max(0, gameState.player.exp - expLoss);
                    const safeCoords = findSafeRespawnLocation(G_SAFE_RESPAWN_X, G_SAFE_RESPAWN_Y);
                    gameState.player.x = safeCoords.x;
                    gameState.player.y = safeCoords.y;
                    updatePlayerPosition("player_defeat_respawn");
                    endBattle(false);
                    showModal("Derrota", `Regresas a un lugar seguro, mermado. Pierdes ${expLoss} EXP.`);
                }, 2000);
                return; // Fin de la función si el jugador es derrotado
                return;
            }
        }

        // 6. Finalizar el turno
        gameState.battle.playerTurn = true;
        populateBattleActionButtons();
        updateBattleUI();
        updateUI();
      }

          function showBattleReview() {
              const reviewLog = document.getElementById("battleReviewLog");
              reviewLog.innerHTML = ""; // Limpiar contenido anterior

              // Unimos todos los mensajes del historial con un salto de línea
              const formattedLog = battleLogHistory.join("<br>");
              reviewLog.innerHTML = formattedLog;

              document.getElementById("battleReviewModal").style.display = "flex";
          }

      function closeBattleReviewModal() {
          document.getElementById("battleReviewModal").style.display = "none";
      }

        function endBattle(victory) {
          const player = gameState.player;
          gameState.battle.active = false;
          document.getElementById("battleScreen").style.display = "none";
          document.getElementById("battleLog").innerHTML = "";
          // Ocultar las barras sobre el sprite en batalla explícitamente al finalizar
          const barsInBattleContainer = document.getElementById(
            "playerInBattleSpriteBarsContainer"
          );
          if (barsInBattleContainer) {
            barsInBattleContainer.style.display = "none";
          }
          if (victory && gameState.battle.enemy?.entityRef) {
            removeEntity(gameState.battle.enemy.entityRef);
          }
          gameState.battle.enemy = null;

          // Restaurar sprite a idle después de la batalla
          player.currentDirection = "down"; // O la última dirección antes de la batalla
          player.currentFrame = 0;
          player.isMoving = false; // Asegurarse de que no esté en estado de movimiento
          updatePlayerSpriteVisual();

          recalculatePlayerStats();
          updateUI();
          updateTopNavVisibility();
          showTouchControls();
          updatePlayerBarsOnMap();
        }

     
      function findEscapeTile(player, enemy) {
        const playerX = player.x;
        const playerY = player.y;
        
        // Calcular la dirección opuesta al enemigo
        const dx = playerX - enemy.x;
        const dy = playerY - enemy.y;

        // Normalizar la dirección para obtener un vector unitario (aproximado)
        let escapeX = playerX + Math.sign(dx);
        let escapeY = playerY + Math.sign(dy);

        const checkTile = (x, y) => {
            if (x < 0 || x >= gameState.map.width || y < 0 || y >= gameState.map.height) return false;
            const terrain = G_TERRAIN_TYPES[getTerrainTypeAt(x, y)];
            if (terrain && terrain.walkable === false) return false;
            const isOccupied = gameState.map.entities.some(e => e.x === x && e.y === y);
            return !isOccupied;
        };

        // 1. Intentar moverse a la casilla directamente opuesta
        if (checkTile(escapeX, escapeY)) {
            return { x: escapeX, y: escapeY };
        }

        // 2. Si no es posible, buscar en las 8 casillas adyacentes una que esté vacía
        const possibleMoves = [
            { x: playerX, y: playerY - 1 }, { x: playerX, y: playerY + 1 }, // Arriba, Abajo
            { x: playerX - 1, y: playerY }, { x: playerX + 1, y: playerY }, // Izquierda, Derecha
            { x: playerX - 1, y: playerY - 1 }, { x: playerX + 1, y: playerY - 1 }, // Diagonales
            { x: playerX - 1, y: playerY + 1 }, { x: playerX + 1, y: playerY + 1 },
        ];

        for (const move of possibleMoves) {
            if (checkTile(move.x, move.y)) {
                return move;
            }
        }
        
        return null; // No se encontró ninguna casilla segura para huir
      }

        function findSafeRespawnLocation(preferredX, preferredY) {
          const isHostile = (entity) =>
            G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss;
          let preferredSpotOccupiedByHostile = gameState.map.entities.some(
            (e) => e.x === preferredX && e.y === preferredY && isHostile(e)
          );
          if (!preferredSpotOccupiedByHostile)
            return { x: preferredX, y: preferredY };
          for (let r = 1; r <= G_SAFE_RESPAWN_SEARCH_RADIUS; r++) {
            for (let dy = -r; dy <= r; dy++) {
              for (let dx = -r; dx <= r; dx++) {
                if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
                const cx = preferredX + dx;
                const cy = preferredY + dy;
                if (
                  cx < 0 ||
                  cx >= gameState.map.width ||
                  cy < 0 ||
                  cy >= gameState.map.height
                )
                  continue;
                const isCompletelyEmpty = !gameState.map.entities.some(
                  (e) => e.x === cx && e.y === cy
                );
                if (isCompletelyEmpty) return { x: cx, y: cy };
              }
            }
          }
          return { x: preferredX, y: preferredY };
        }

        function logBattle(message) {
          battleLogHistory.push(message);
      }

        function showTechniquePanel() {
          const container = document.getElementById("learnedTechniquesContainer");
          container.innerHTML = "";
          const player = gameState.player;
          if (Object.keys(player.learnedTechniques).length === 0) {
            container.innerHTML = "<p>Aún no has aprendido ninguna técnica.</p>";
          }
          for (const techId in player.learnedTechniques) {
            const techInfo = techniqueData[techId];
            const playerTech = player.learnedTechniques[techId];
            if (!techInfo) continue;
            const div = document.createElement("div");
            div.className = "technique-item";
            let levelText =
              playerTech.level >= techInfo.maxLevel
                ? `Nivel: ${playerTech.level} (MAX)`
                : `Nivel: ${playerTech.level} / ${techInfo.maxLevel}`;
            let description = techInfo.description;
            // Podrías añadir lógica aquí para mostrar el efecto actual basado en el nivel
            // Ejemplo: if (techInfo.effect.baseDamageMultiplier) description += ` (Daño actual: ${...})`;
            div.innerHTML = `<strong>${techInfo.name} ${
              techInfo.icon || ""
            }</strong> (${levelText})<br><small>${description}</small><br>`;
            if (
              techInfo.cultivationSettings &&
              playerTech.level < techInfo.maxLevel
            ) {
              const progress = playerTech.currentCultivationProgress || 0;
              const timeToNext =
                playerTech.cultivationTimeToNextLevel ||
                (techInfo.cultivationSettings
                  ? techInfo.cultivationSettings.baseTimeToLevelUp
                  : Infinity);
              div.innerHTML += `<small>Progreso Cultivo: ${Math.floor(
                progress
              )}s / ${timeToNext}s para Nv. ${playerTech.level + 1}</small><br>`;
            }
            container.appendChild(div);
          }
          document.getElementById("techniqueModal").style.display = "flex";
          hideTouchControls();
        }

        function startTechniqueRefinement(techId) {}

        function stopTechniqueRefinement() {}

        function applyTechniqueEffect(techId, newLevel) {
          const techInfo = techniqueData[techId];
          const player = gameState.player;
          if (!techInfo) return;
          
          const effect = techInfo.effect;
          switch (techInfo.type) {
              case "passive_cultivation":
                  if (player.hasOwnProperty(effect.statToBoost)) {
                      // Asumimos que el efecto es por nivel, así que solo añadimos el valor del nuevo nivel
                      player[effect.statToBoost] += effect.value;
                  }
                  break;
              case "passive_stat":
                    if (effect.statToBoost === "passiveHpRegen") {
                        player.passiveHpRegen = (player.passiveHpRegen || 0) + effect.value;
                    } else if (effect.statToBoost === "statusImmunity" && effect.value === true) {
                        player.isImmuneToStatus = true;
                    } else if (effect.statToBoost === "deathSaveChance") {
                        player.deathSaveChance = (player.deathSaveChance || 0) + effect.value;
                    } else if (player.hasOwnProperty(effect.statToBoost)) {
                        player[effect.statToBoost] += effect.value;
                    }
              case "active_ability":
                  // Cuando una habilidad activa sube de nivel, solo necesitamos refrescar los stats
                  // por si acaso, y la UI de batalla se actualizará la próxima vez que empiece un combate.
                  recalculatePlayerStats(); 
                  break;
              case "active_refinement_effect":
                  if (techId === "qi_to_hp_conversion_1") {
                      if (newLevel >= 1) {
                          player.canUseQiConversion = true;
                          // ---- LA CORRECCIÓN ESTÁ AQUÍ ----
                          // La siguiente línea causaba el error y ha sido eliminada:
                          // updateToggleQiConversionButtonVisibility(); 
                          
                          // En su lugar, la visibilidad del botón se maneja correctamente
                          // por la función renderQuickSlotBar(), que se llama cuando
                          // se actualiza la UI general.
                      }
                  }
                  break;
                  recalculatePlayerStats(); 
        updateUI();
          }
          // No es necesario llamar a updateUI() aquí, ya que se llamará después
          // de que el cultivo se detenga o en el siguiente tick.
      }

        function closeTechniqueModal() {
          document.getElementById("techniqueModal").style.display = "none";
          updatePlayerBarsOnMap();
          showTouchControls();
        }

        let currentShopPage = 1;
        const shopItemsPerPage = 6;

        function openShop() {
          document.getElementById(
            "playerSpiritualStones"
          ).textContent = `Piedras Espirituales: ${
            gameState.inventory["Piedras Espirituales"] || 0
          }`;
          document.getElementById("shopModal").style.display = "flex";
          renderShopProducts();
          hideTouchControls();
        }

        function renderShopProducts() {
          const shopProductsEl = document.getElementById("shopProducts");
          shopProductsEl.innerHTML = "";
          const activeCategory =
            document.querySelector("#shopCategories .active")?.dataset.category ||
            "all";
          const searchTerm = document
            .getElementById("shopSearch")
            .value.toLowerCase();
          const priceVal = parseInt(document.getElementById("priceRange").value);
          document.getElementById(
            "priceRangeValue"
          ).textContent = `${priceVal} PS`;

          let filteredItems = shopData.inventory.filter((item) => {
            const itemNameLower = item.itemName.toLowerCase();
            const itemCategory = item.category || "other";
            const itemTypeForFilter =
              item.type ||
              (itemNameLower.includes("rollo:") ? "scroll" : "other");

            if (
              searchTerm &&
              !itemNameLower.includes(searchTerm) &&
              !(
                item.description &&
                item.description.toLowerCase().includes(searchTerm)
              )
            )
              return false;
            if (item.price > priceVal) return false;

            if (activeCategory !== "all") {
              if (activeCategory === "combat" && !techIsCombat(item.itemName))
                return false;
              if (
                activeCategory === "cultivation" &&
                !techIsCultivation(item.itemName)
              )
                return false;
              if (
                activeCategory === "scroll" &&
                !itemNameLower.startsWith("rollo: ")
              )
                return false;
              if (
                activeCategory === "consumable" &&
                itemTypeForFilter !== "consumable" &&
                ![
                  "Hierbas Medicinales",
                  "Cristales de Qi",
                  "Píldora de Recuperación Menor",
                ].includes(item.itemName)
              )
                return false;
              if (activeCategory === "weapon" && itemCategory !== "weapon")
                return false;
              if (activeCategory === "armor" && itemCategory !== "armor")
                return false;
              if (activeCategory === "material" && !isMaterial(item.itemName))
                return false;
            }
            return true;
          });

          const totalPages = Math.ceil(filteredItems.length / shopItemsPerPage);
          const startIndex = (currentShopPage - 1) * shopItemsPerPage;
          const pageItems = filteredItems.slice(
            startIndex,
            startIndex + shopItemsPerPage
          );

          pageItems.forEach((item) => {
            const itemInfo = itemData[item.itemName] || {};
            const productCard = document.createElement("div");
            productCard.className = "product-card";
            let itemIcon = getItemIcon(item.itemName, item.category);
            let itemType = getItemShopType(
              item.itemName,
              item.category,
              item.type
            );

            productCard.innerHTML = `
                  <div class="product-header">
                      <div>
                          <div class="product-name">${itemIcon} ${
              item.itemName
            }</div>
                          <span class="product-type">${itemType}</span>
                      </div>
                      <div class="product-price">${item.price} PS</div>
                  </div>
                  <div class="product-description">${
                    itemInfo.description ||
                    item.description ||
                    "Un objeto misterioso."
                  }</div>
                  ${
                    item.levelRequirement
                      ? `<div><strong>Req:</strong> Nv ${item.levelRequirement}</div>`
                      : ""
                  }
                  ${
                    typeof item.stock === "number"
                      ? `<div><strong>Disp:</strong> ${item.stock}</div>`
                      : ""
                  }
                  <div class="product-actions">
                      <button class="buy-btn" data-item="${
                        item.itemName
                      }" data-price="${item.price}">Comprar</button>
                  </div>`;
            const buyBtn = productCard.querySelector(".buy-btn");
            if (
              (gameState.inventory["Piedras Espirituales"] || 0) < item.price ||
              item.stock === 0
            ) {
              buyBtn.disabled = true;
              buyBtn.title =
                item.stock === 0 ? "Agotado" : "Piedras insuficientes";
            }
            buyBtn.addEventListener("click", () => buyFromShop(item.itemName));
            shopProductsEl.appendChild(productCard);
          });
          renderShopPagination(totalPages);
        }

        function techIsCombat(itemName) {
          if (!itemName.startsWith("Rollo: ")) return false;
          const techName = itemName.substring(7);
          const techId = Object.keys(techniqueData).find(
            (id) => techniqueData[id].name === techName
          );
          return (
            techId &&
            (techniqueData[techId].type === "active_ability" ||
              techniqueData[techId].abilityId)
          );
        }
        
        function techIsCultivation(itemName) {
          if (!itemName.startsWith("Rollo: ")) return false;
          const techName = itemName.substring(7);
          const techId = Object.keys(techniqueData).find(
            (id) => techniqueData[id].name === techName
          );
          return (
            techId &&
            (techniqueData[techId].type === "passive_cultivation" ||
              techniqueData[techId].type === "passive_stat" ||
              techniqueData[techId].type === "active_refinement_effect")
          );
        }
        
        function isMaterial(itemName) {
          const knownMaterials = [
            "Cristal de Hielo",
            "Esencia de Fuego",
            "Núcleo de Tormenta",
            "Venenos Mortales",
            "Fragmentos de Jade",
            "Esencia Oscura",
            "Almas Condenadas",
            "Núcleo de Vórtice",
            "Rocío Celestial",
            "Cristales Psíquicos",
            "Mineral de Hierro Espiritual",
            "Plumas de Fénix",
            "Semillas Ancestrales",
            "Escamas de Dragón",
            "Espejos Astrales",
            "Relojes de Arena",
            "Sangre de Demonio",
            "Lágrimas de Unicornio",
            "Núcleo Elemental",
            "Polvo de Arcano",
            "Piedras Espirituales",
            "Cristales de Qi",
            "Hierbas Medicinales",
          ];
          return knownMaterials.includes(itemName);
        }

        function getItemIcon(itemName, category) {
          if (itemName.includes("Espada") || category === "weapon") return "⚔️";
          if (itemName.includes("Armadura") || category === "armor") return "🛡️";
          if (itemName.includes("Hierba")) return "🌿";
          if (itemName.includes("Cristal")) return "💎";
          if (itemName.includes("Piedra")) return "💎";
          if (itemName.startsWith("Rollo:")) return "📜";
          return "📦";
        }

        function getItemShopType(itemName, category, type) {
          if (itemName.startsWith("Rollo: ")) return "Técnica";
          if (category === "weapon") return "Arma";
          if (category === "armor") return "Armadura";
          if (
            type === "consumable" ||
            [
              "Hierbas Medicinales",
              "Cristales de Qi",
              "Píldora de Recuperación Menor",
            ].includes(itemName)
          )
            return "Consumible";
          if (isMaterial(itemName)) return "Material";
          return "Objeto";
        }

        function renderShopPagination(totalPages) {
          const pagination = document.getElementById("shopPagination");
          pagination.innerHTML = "";
          if (totalPages <= 1) return;
          const prevBtn = document.createElement("button");
          prevBtn.className = "page-btn";
          prevBtn.textContent = "«";
          prevBtn.addEventListener("click", () => {
            if (currentShopPage > 1) {
              currentShopPage--;
              renderShopProducts();
            }
          });
          pagination.appendChild(prevBtn);
          const startPage = Math.max(1, currentShopPage - 1);
          const endPage = Math.min(totalPages, currentShopPage + 1);
          for (let i = startPage; i <= endPage; i++) {
            const pageBtn = document.createElement("button");
            pageBtn.className = `page-btn ${
              i === currentShopPage ? "active" : ""
            }`;
            pageBtn.textContent = i;
            pageBtn.addEventListener("click", () => {
              currentShopPage = i;
              renderShopProducts();
            });
            pagination.appendChild(pageBtn);
          }
          const nextBtn = document.createElement("button");
          nextBtn.className = "page-btn";
          nextBtn.textContent = "»";
          nextBtn.addEventListener("click", () => {
            if (currentShopPage < totalPages) {
              currentShopPage++;
              renderShopProducts();
            }
          });
          pagination.appendChild(nextBtn);
        }

        function closeShopModal() {
          document.getElementById("shopModal").style.display = "none";
          updatePlayerBarsOnMap();
          showTouchControls();
        }

        function buyFromShop(itemName) {
          const itemToBuy = shopData.inventory.find(
            (i) => i.itemName === itemName
          );
          const playerStones = gameState.inventory["Piedras Espirituales"] || 0;
          if (
            !itemToBuy ||
            itemToBuy.stock === 0 ||
            playerStones < itemToBuy.price
          ) {
            showModal(
              "Error Compra",
              "No se puede comprar (fondos insuficientes, agotado o no existe)."
            );
            return;
          }
          gameState.inventory["Piedras Espirituales"] -= itemToBuy.price;
          if (itemToBuy.type === "equipment" && itemToBuy.attackBonus) {
            gameState.player.baseAttack += itemToBuy.attackBonus;
            recalculatePlayerStats();
            showModal(
              "¡Equipo Comprado!",
              `Compraste ${itemName}. Ataque base +${itemToBuy.attackBonus}.`
            );
          } else {
            gameState.inventory[itemName] =
              (gameState.inventory[itemName] || 0) + 1;
            if (
              itemData[itemName] &&
              itemData[itemName].effect &&
              itemName.startsWith("Rollo: ")
            ) {
              showModal(
                "¡Rollo Comprado!",
                `Has comprado ${itemName}. Úsalo desde tu inventario para aprender la técnica.`
              );
            } else {
              showModal("¡Objeto Comprado!", `Has comprado ${itemName}.`);
            }
          }
          if (typeof itemToBuy.stock === "number" && itemToBuy.stock > 0)
            itemToBuy.stock--;
          openShop();
          updateUI();
        }

        function sellToShop(itemName, quantityToSell, totalStonesEarned) {}

        function saveGame() {
          try {
            const gameStateToSave = JSON.parse(JSON.stringify(gameState));
            const gameDataJson = JSON.stringify(gameStateToSave, null, 2);
            const blob = new Blob([gameDataJson], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "camino_del_cultivador_save.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showModal("Partida Guardada", "Progreso guardado como archivo JSON.");
          } catch (error) {
            showModal("Error al Guardar", `Hubo un problema: ${error.message}`);
          }
        }
        function triggerFileUpload() {
          document.getElementById("fileInput").click();
        }

        // --- CARGA DE PARTIDA ---

      function loadGameFromFile(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function(e) {
              try {
                  // Detener procesos activos antes de cargar
                  if (gameState.player.isCultivating) stopCultivation();
                  if (gameState.battle.active) endBattle(false);

                  const loadedGameState = JSON.parse(e.target.result);

                  if (!loadedGameState.player || !loadedGameState.map || !loadedGameState.inventory) {
                      throw new Error("Formato de guardado incorrecto o datos esenciales faltantes.");
                  }

                  // Copia profunda y segura de los datos principales
                  gameState.player = JSON.parse(JSON.stringify(loadedGameState.player));
                  gameState.inventory = JSON.parse(JSON.stringify(loadedGameState.inventory));
                  gameState.map.entities = loadedGameState.map.entities ? JSON.parse(JSON.stringify(loadedGameState.map.entities)) : [];

                  // --- INICIO DE LA REPARACIÓN DE MISIONES ACTIVAS ---
                  // Esta rutina asegura que las misiones cargadas de una partida antigua
                  // tengan la información de objetivo más reciente del código del juego.
                  if (gameState.player.secta && gameState.player.secta.misionesActivas) {
                      console.log("Ejecutando rutina de reparación de misiones en partida guardada...");
                      gameState.player.secta.misionesActivas.forEach(misionActiva => {
                          const masterMisionData = MISIONES_DATA[misionActiva.id];
                          if (masterMisionData && masterMisionData.objetivo) {
                              // Si el objetivo original guardado no existe, o si no tiene la propiedad npcEntrega
                              // mientras que la definición maestra sí la tiene, lo reparamos.
                              // La forma más segura es simplemente volver a clonar el objeto de objetivo maestro.
                              if (!misionActiva.objetivoOriginal || misionActiva.objetivoOriginal.npcEntrega !== masterMisionData.objetivo.npcEntrega) {
                                  console.log(`Reparando objetivo de la misión activa '${misionActiva.id}'. Se añadirá/actualizará la información del objetivo.`);
                                  misionActiva.objetivoOriginal = JSON.parse(JSON.stringify(masterMisionData.objetivo));
                              }
                          }
                      });
                  }
                  // --- FIN DE LA REPARACIÓN DE MISIONES ---

                  // --- INICIO DE LA REPARACIÓN DE TÉCNICAS (ya la tenías) ---
                  if (gameState.player.learnedTechniques) {
                      console.log("Ejecutando rutina de reparación de técnicas en partida guardada...");
                      for (const techId in gameState.player.learnedTechniques) {
                          const playerTech = gameState.player.learnedTechniques[techId];
                          const techDef = techniqueData[techId]; 

                          if (playerTech && techDef && techDef.cultivationSettings) {
                              if (playerTech.level < techDef.maxLevel) {
                                  const expectedTime = Math.floor(
                                      techDef.cultivationSettings.baseTimeToLevelUp *
                                      Math.pow(techDef.cultivationSettings.levelTimeMultiplier, playerTech.level)
                                  );
                                  if (playerTech.cultivationTimeToNextLevel !== expectedTime) {
                                      console.log(`Corrigiendo 'cultivationTimeToNextLevel' para la técnica '${techDef.name}' (Nivel ${playerTech.level}). Valor antiguo: ${playerTech.cultivationTimeToNextLevel}, Nuevo valor: ${expectedTime}`);
                                      playerTech.cultivationTimeToNextLevel = expectedTime;
                                  }
                              } else {
                                  if (playerTech.cultivationTimeToNextLevel !== Infinity) {
                                      playerTech.cultivationTimeToNextLevel = Infinity;
                                  }
                              }
                          }
                      }
                  }
                  // --- FIN DE LA REPARACIÓN DE TÉCNICAS ---

                  // Resetear estados transitorios que no deben guardarse
                  gameState.player.isCultivating = false;
                  if (gameState.cultivationInterval) {
                      clearInterval(gameState.cultivationInterval);
                      gameState.cultivationInterval = null;
                  }
                  
                  // Reconstruir y refrescar el juego
                  generateMap(true);
                  recalculatePlayerStats();
                  renderQuickSlotBar();
                  updatePlayerPosition("loadGameFromFile_end");
                  
                  showModal("Partida Cargada", "¡Partida restaurada con éxito! (Se aplicaron correcciones de compatibilidad)");

              } catch (error) {
                  showModal("Error al Cargar", `Hubo un problema: ${error.message}`);
                  console.error("Error loading game:", error);
              } finally {
                  event.target.value = null;
              }
          };
          reader.onerror = () => {
              showModal("Error de Lectura", "No se pudo leer el archivo de guardado.");
              event.target.value = null;
          };
          reader.readAsText(file);
      }
        
      function renderQuickSlotBar() {
          const bar = document.getElementById("quickSlotBar");
          if (!bar) return;
          bar.innerHTML = ""; // Limpiar la barra

          // Renderizar los 5 slots de ítems (sin cambios aquí)
          gameState.player.quickSlots.forEach((itemName, index) => {
              const slot = document.createElement("div");
              slot.className = "quick-slot";
              
              const keyHint = document.createElement("span");
              keyHint.className = "slot-key-hint";
              keyHint.textContent = index + 1;
              slot.appendChild(keyHint);

              if (itemName && itemData[itemName]) {
                  const itemCount = gameState.inventory[itemName] || 0;
                  slot.innerHTML += getItemIcon(itemName);
                  const countDisplay = document.createElement("span");
                  countDisplay.className = "slot-item-count";
                  countDisplay.textContent = itemCount;
                  slot.appendChild(countDisplay);

                  if (itemCount === 0) {
                      slot.style.opacity = 0.5;
                      slot.title = `${itemName} (Agotado)`;
                  } else {
                      slot.title = `Usar ${itemName} (x${itemCount})`;
                      slot.onclick = () => useQuickSlotItem(index);
                  }
              } else {
                  slot.classList.add("empty");
                  slot.title = "Haz clic para asignar un objeto";
                  slot.onclick = () => openItemAssignmentModal(index);
              }
              bar.appendChild(slot);
          });

          // Renderizar el botón de Cultivar (sin cambios aquí)
          const cultivateSlot = document.createElement("div");
          cultivateSlot.className = "quick-slot cultivate-slot";
          cultivateSlot.title = "Cultivar (🧘)";
          cultivateSlot.innerHTML = '🧘';
          cultivateSlot.onclick = () => toggleCultivation();
          if (gameState.player.isCultivating) {
              cultivateSlot.classList.add('active-cultivation');
              cultivateSlot.title = "Ver/Detener Cultivo";
          }
          bar.appendChild(cultivateSlot);

          // === INICIO DE LA NUEVA LÓGICA PARA EL BOTÓN DE CONVERSIÓN ===
          // Solo mostramos el botón si el jugador puede usar la conversión de Qi
          if (gameState.player.canUseQiConversion) {
              const conversionSlot = document.createElement("div");
              conversionSlot.className = "quick-slot conversion-slot";
              
              conversionSlot.innerHTML = '☯️';
              conversionSlot.onclick = () => toggleQiConversion();

              // La apariencia "activa" ahora depende de si el modo de cultivo es de conversión.
              if (gameState.player.isCultivating && gameState.player.cultivationMode.isConversionCultivation) {
                  conversionSlot.classList.add('active-conversion');
                  conversionSlot.title = "Conversión de Maná a Vida ACTIVA (clic para detener)";
              } else {
                  conversionSlot.title = "Iniciar Conversión de Maná a Vida";
              }

              bar.appendChild(conversionSlot);
          }
          // === FIN DE LA NUEVA LÓGICA ===
      }

      function useQuickSlotItem(slotIndex) {
          const itemName = gameState.player.quickSlots[slotIndex];
          if (!itemName) {
              console.log(`Slot ${slotIndex + 1} está vacío.`);
              // Si el slot está vacío, podríamos abrir el modal de asignación. ¡Es una buena mejora!
              openItemAssignmentModal(slotIndex);
              return;
          }

          const item = itemData[itemName];
          const itemCount = gameState.inventory[itemName] || 0;

          if (itemCount <= 0) {
              showModal("Agotado", `No te quedan más ${itemName}.`);
              // Si el inventario dice 0 pero el slot aún tiene el ítem, lo limpiamos por seguridad.
              gameState.player.quickSlots[slotIndex] = null;
              renderQuickSlotBar(); // Actualizar la UI
              return;
          }

          if (item && item.canUse && !item.canUse(gameState.player)) {
              showModal("No se puede usar", `No puedes usar ${itemName} ahora.`);
              return;
          }

          // Usar el objeto
          const message = (item.effect) ? item.effect(gameState.player, gainExperience) : `No se puede usar ${itemName}.`;
          
          if (message && !message.toLowerCase().includes("error") && !message.toLowerCase().includes("al máximo")) {
              gameState.inventory[itemName]--;
              showModal("Objeto Usado", message);
              updateUI(); 

              // === INICIO DE LA CORRECCIÓN CLAVE ===
              // Después de usar el ítem, verificamos si se agotó.
              const newCount = gameState.inventory[itemName] || 0;
              if (newCount <= 0) {
                  // Si la cantidad es 0, vaciamos el slot.
                  gameState.player.quickSlots[slotIndex] = null;
                  console.log(`Ítem ${itemName} agotado. Vaciando slot ${slotIndex + 1}.`);
              }
              // === FIN DE LA CORRECCIÓN CLAVE ===

              renderQuickSlotBar(); // Vuelve a renderizar la barra para actualizar la cantidad o mostrar el slot vacío.
          } else {
              showModal("Acción no posible", message);
          }
      }
        function showHelp() {
          showModal(
            "Ayuda - Camino del Cultivador",
            "Explora y conviértete en un cultivador poderoso.\n\n" +
              '🧘 Cultiva (Botón "Cultivar") para mejorar HP/Maná/EXP y tus Técnicas.\n' +
              "📖 Aprende y Refina Técnicas para obtener nuevas habilidades y mejoras pasivas.\n" +
              "⬆️ Sube de Nivel para aumentar tus estadísticas base.\n" + // Actualizado
              "👹 Combate demonios y rivales.\n" +
              "💎 Recolecta recursos y tesoros.\n" +
              "📜 Busca o compra rollos de técnicas para volverte más fuerte\n\n" + // Eliminada mención al árbol de habilidades
              "Controles (Teclado):\n" +
              "  WASD/Flechas: Moverse\n" +
              "  ESPACIO: Interactuar\n\n" +
              "Controles (Táctil):\n" +
              "  Joystick: Moverse\n" +
              '  Botón "Acción": Interactuar'
          );
        }
        //ACTUALIZAR BARRAS DEL JUGADOR
        function updatePlayerBarsOnMap() {
          const player = gameState.player;
          const barsContainer = document.getElementById(
            "playerOnMapBarsContainer"
          );
          const hpFill = document.getElementById("playerOnMapHpFill");
          const manaFill = document.getElementById("playerOnMapManaFill");
          const playerElement = document.getElementById("player"); // El sprite del jugador

          if (!barsContainer || !hpFill || !manaFill || !playerElement) {
            // console.warn("Elementos de barras sobre el jugador no encontrados en el DOM.");
            return;
          }

          // Ocultar barras si el jugador está en batalla o si algún modal principal está abierto.
          if (gameState.battle.active || isAnyModalOpen()) {
            barsContainer.style.display = "none";
            return;
          }
          barsContainer.style.display = "flex";

          // La posición del playerElement (sprite) ya está calculada y centrada en updatePlayerPosition.
          // Usamos su 'top' y 'left' (que son relativos al map-container) como referencia.
          const playerVisualTop = parseFloat(playerElement.style.top) || 0;
          const playerVisualLeft = parseFloat(playerElement.style.left) || 0;
          const playerVisualWidth = playerElement.offsetWidth;

          // Posicionar las barras ligeramente encima del sprite del jugador.
          const barHeightWithGap = barsContainer.offsetHeight || 13; // Alto total aprox. de las 2 barras + gap
          barsContainer.style.top = `${playerVisualTop - barHeightWithGap - 5}px`; // 5px de espacio sobre el sprite

          // Centrar horizontalmente con el sprite del jugador.
          // El 'transform: translateX(-50%)' en el CSS ayuda con esto si 'left' es el centro.
          barsContainer.style.left = `${
            playerVisualLeft + playerVisualWidth / 2
          }px`;

          // Actualizar el relleno de las barras.
          const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
          const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

          hpFill.style.width = `${hpPercent}%`;
          manaFill.style.width = `${manaPercent}%`;
        }

        function updatePlayerBarsInBattle() {
          const player = gameState.player;
          const barsContainer = document.getElementById(
            "playerInBattleSpriteBarsContainer"
          );
          const hpFill = document.getElementById("playerInBattleSpriteHpFill");
          const manaFill = document.getElementById(
            "playerInBattleSpriteManaFill"
          );
          const playerSpriteInBattle = document.querySelector(
            ".battle-area .character .character-sprite"
          );

          if (!barsContainer || !hpFill || !manaFill || !playerSpriteInBattle) {
            // console.warn("Elementos de barras sobre el sprite del jugador en batalla no encontrados.");
            if (barsContainer) barsContainer.style.display = "none"; // Ocultar si faltan elementos
            return;
          }

          // Solo mostrar si la pantalla de batalla está activa
          if (
            !gameState.battle.active ||
            document.getElementById("battleScreen").style.display !== "flex"
          ) {
            barsContainer.style.display = "none";
            return;
          }
          barsContainer.style.display = "flex";

          // Posicionar las barras ligeramente encima del sprite del jugador en batalla.
          // El sprite (.character-sprite) es un div, necesitamos su offsetTop y offsetLeft
          // relativo a su padre (.character) que ahora es 'position: relative'.

          const spriteTop = playerSpriteInBattle.offsetTop; // Distancia desde el borde superior del .character
          const spriteLeft = playerSpriteInBattle.offsetLeft; // Distancia desde el borde izquierdo del .character
          const spriteWidth = playerSpriteInBattle.offsetWidth;

          const barHeightWithGap = barsContainer.offsetHeight || 12; // Alto total aprox. de las 2 barras + gap

          // El 'top' de las barras será el 'top' del sprite menos la altura de las barras y un pequeño margen.
          barsContainer.style.top = `${spriteTop - barHeightWithGap - 3}px`; // 3px de espacio sobre el sprite

          // Centrar horizontalmente con el sprite del jugador.
          // 'left' será el 'left' del sprite más la mitad del ancho del sprite.
          // El 'transform: translateX(-50%)' en CSS centra el contenedor de barras.
          barsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

          // Actualizar el relleno de las barras.
          const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
          const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

          hpFill.style.width = `${hpPercent}%`;
          manaFill.style.width = `${manaPercent}%`;
        }

        const joystickContainer = document.getElementById("joystick-container");
        const joystickPad = document.getElementById("joystick-pad");
        const joystickHandle = document.getElementById("joystick-handle");
        const actionButtonTouch = document.getElementById("action-button-touch");
        let joystickActive = false;
        let joystickCurrentDx = 0; // Guardar la dirección actual del joystick
        let joystickCurrentDy = 0;

        const JOYSTICK_THRESHOLD = 15;
        const JOYSTICK_GAME_MOVE_INTERVAL = 300;
        let joystickGameMoveTimerId = null;
        let lastJoystickMoveTime = 0;
        let joystickLoopId = null;
        let joystickTouchIdentifier = null; // <!-- CAMBIO JOYSTICK: Para seguir el dedo correcto -->

        function initJoystick() {
          if (
            !joystickContainer ||
            !joystickPad ||
            !joystickHandle ||
            !actionButtonTouch
          ) {
            console.error(
              "Error inicializando joystick: Elementos no encontrados."
            );
            return;
          }
          resetJoystickHandle();

          joystickPad.addEventListener(
            "touchstart",
            (event) => {
              if (
                gameState.player.isCultivating ||
                gameState.battle.active ||
                joystickActive
              )
                return;
              const touch = event.changedTouches[0];
              if (!touch) return;
              const padRect = joystickPad.getBoundingClientRect();
              if (
                touch.clientX < padRect.left ||
                touch.clientX > padRect.right ||
                touch.clientY < padRect.top ||
                touch.clientY > padRect.bottom
              ) {
                return;
              }
              event.preventDefault();
              joystickActive = true;
              joystickTouchIdentifier = touch.identifier;
              document.addEventListener("touchmove", handleJoystickMove, {
                passive: false,
              });
              document.addEventListener("touchend", handleJoystickEnd, {
                passive: false,
              });
              document.addEventListener("touchcancel", handleJoystickEnd, {
                passive: false,
              });

              // No iniciar el gameMoveTimer aquí, la animación la maneja handlePlayerMovementInput
              // updateJoystickHandlePosition y determinar dirección inicial
              updateJoystickHandlePosition(touch, true); // true para indicar que es el inicio
            },
            { passive: false }
          );

          actionButtonTouch.addEventListener("click", () => {
            if (!gameState.player.isCultivating && !gameState.battle.active) {
              interact();
            }
          });
        }
        function resetJoystickHandle() {
          if (joystickHandle)
            joystickHandle.style.transform = "translate(0px, 0px)";
          joystickCurrentDx = 0;
          joystickCurrentDy = 0;
        }
        // <!-- CAMBIO JOYSTICK: Modificaciones en los manejadores -->
        function handleJoystickStart(event) {
          
          if (
            gameState.player.isCultivating ||
            gameState.battle.active ||
            joystickActive
          )
            return;

          // Solo procesar el primer toque en el pad
          const touch = event.changedTouches[0];
          if (!touch) return;

          // Comprobar si el toque está realmente dentro del joystickPad (opcional, pero bueno para evitar activaciones accidentales)
          const padRect = joystickPad.getBoundingClientRect();
          if (
            touch.clientX < padRect.left ||
            touch.clientX > padRect.right ||
            touch.clientY < padRect.top ||
            touch.clientY > padRect.bottom
          ) {
            return;
          }

          event.preventDefault(); // Prevenir scroll/zoom si el toque es para el joystick

          joystickActive = true;
          joystickTouchIdentifier = touch.identifier; // Guardar el ID del dedo

          // Añadir listeners de movimiento y fin al documento para seguir el dedo fuera del pad
          document.addEventListener("touchmove", handleJoystickMove, {
            passive: false,
          });
          document.addEventListener("touchend", handleJoystickEnd, {
            passive: false,
          });
          document.addEventListener("touchcancel", handleJoystickEnd, {
            passive: false,
          });

          // if (!joystickGameMoveTimerId) {
          //   joystickGameMoveTimerId = setInterval(
          //     processJoystickGameMove,
          //     JOYSTICK_GAME_MOVE_INTERVAL
          //   );
          // }
          updateJoystickHandlePosition(touch);
          // console.log("Joystick Start, ID:", joystickTouchIdentifier);
        }
        function handleJoystickMove(event) {
          if (!joystickActive) return;

          // Encontrar el toque correcto
          let touch = null;
          for (let i = 0; i < event.changedTouches.length; i++) {
            if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
              touch = event.changedTouches[i];
              break;
            }
          }

          if (touch) {
            event.preventDefault(); // Prevenir scroll si el movimiento es del dedo del joystick
            updateJoystickHandlePosition(touch);
            // console.log("Joystick Move");
          }
        }

        function updateJoystickHandlePosition(touch) {
          const padRect = joystickPad.getBoundingClientRect();
          if (padRect.width === 0) return;

          const joystickCenterX = padRect.left + padRect.width / 2;
          const joystickCenterY = padRect.top + padRect.height / 2;

          const currentX = touch.clientX - joystickCenterX;
          const currentY = touch.clientY - joystickCenterY;

          const angle = Math.atan2(currentY, currentX);
          const maxDistance = joystickPad.offsetWidth / 2 - joystickHandle.offsetWidth / 2;
          if (maxDistance <= 0) return;

          const distance = Math.min(maxDistance, Math.hypot(currentX, currentY));
          const limitedX = distance * Math.cos(angle);
          const limitedY = distance * Math.sin(angle);
          if (joystickHandle) {
              joystickHandle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
          }

          // --- LÓGICA DE CONTROL SIMPLIFICADA ---
          // Primero, reseteamos todas las direcciones del joystick.
          playerMovementKeysDown.up = false;
          playerMovementKeysDown.down = false;
          playerMovementKeysDown.left = false;
          playerMovementKeysDown.right = false;

          // Ahora, activamos la dirección correcta si el joystick está lo suficientemente inclinado.
          const magnitude = Math.hypot(currentX, currentY);
          if (magnitude > JOYSTICK_THRESHOLD) {
              if (Math.abs(currentX) > Math.abs(currentY)) {
                  // Movimiento horizontal (izquierda o derecha)
                  if (currentX > 0) {
                      playerMovementKeysDown.right = true;
                  } else {
                      playerMovementKeysDown.left = true;
                  }
              } else {
                  // Movimiento vertical (arriba o abajo)
                  if (currentY > 0) {
                      playerMovementKeysDown.down = true;
                  } else {
                      playerMovementKeysDown.up = true;
                  }
              }
          }
        }

        function handleJoystickEnd(event) {
          if (!joystickActive) return;
          
          let touchEndedIsOurs = false;
          for (let i = 0; i < event.changedTouches.length; i++) {
            if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
              touchEndedIsOurs = true;
              break;
            }
          }

          if (touchEndedIsOurs) {
            joystickActive = false;
            joystickTouchIdentifier = null;
            resetJoystickHandle();
            
            // --- LIMPIEZA DE BANDERAS ---
            // Al soltar el joystick, nos aseguramos de que ninguna tecla de movimiento quede "presionada"
            playerMovementKeysDown.up = false;
            playerMovementKeysDown.down = false;
            playerMovementKeysDown.left = false;
            playerMovementKeysDown.right = false;

            document.removeEventListener("touchmove", handleJoystickMove);
            document.removeEventListener("touchend", handleJoystickEnd);
            document.removeEventListener("touchcancel", handleJoystickEnd);
          }
        }
        // processJoystickGameMove se mantiene igual
        // <!-- FIN CAMBIO JOYSTICK -->
        function processJoystickGameMove() {
          // Esta función se llama cada JOYSTICK_GAME_MOVE_INTERVAL
          if (
            joystickActive &&
            (joystickCurrentDx !== 0 || joystickCurrentDy !== 0)
          ) {
            // console.log(`[processJoystickGameMove] Effective move: dx=${joystickCurrentDx}, dy=${joystickCurrentDy}. Calling movePlayer.`);
            movePlayer(joystickCurrentDx, joystickCurrentDy);
          }
        }
        function joystickLoop() {
          if (!joystickActive) {
            joystickLoopId = null;
            return;
          }
          const now = Date.now();
          if (now - lastJoystickMoveTime > JOYSTICK_MOVE_INTERVAL) {
            let dx = 0,
              dy = 0;
            const magnitude = Math.hypot(joystickCurrentX, joystickCurrentY);
            if (magnitude > JOYSTICK_THRESHOLD) {
              if (Math.abs(joystickCurrentX) > Math.abs(joystickCurrentY)) {
                dx = joystickCurrentX > 0 ? 1 : -1;
              } else {
                dy = joystickCurrentY > 0 ? 1 : -1;
              }
            }
            if (dx !== 0 || dy !== 0) {
              movePlayer(dx, dy);
              lastJoystickMoveTime = now;
            }
          }
          joystickLoopId = requestAnimationFrame(joystickLoop);
        }
        // --- NUEVAS FUNCIONES PARA LOS MODALES DE INVENTARIO Y PERSONAJE (EJEMPLOS) ---

        // Modal para Inventario Detallado (si decides usar un modal en lugar del sidebar)
        function openInventoryModal() {
          let inventoryContent = `
              <h2 style="text-align: center; margin-bottom: 20px;">Inventario</h2>
              <div id="inventory-modal-list" style="text-align: left;">
          `;

          // Filtrar para mostrar solo los ítems que el jugador posee
          const itemsToShow = Object.entries(gameState.inventory).filter(([itemName, count]) => count > 0);

          if (itemsToShow.length === 0) {
              inventoryContent += "<p style='text-align: center; opacity: 0.7;'>No tienes ningún objeto.</p>";
          } else {
              itemsToShow.forEach(([itemName, count]) => {
                  const itemInfo = itemData[itemName] || {};
                  const canBeUsed = itemInfo.canUse ? itemInfo.canUse(gameState.player) : false;
                  
                  inventoryContent += `
                      <div class="inventory-modal-item">
                          <div class="item-details">
                              <div class="item-name">${getItemIcon(itemName, '')} ${itemName} (x${count})</div>
                              <div class="item-description">${itemInfo.description || "Un objeto misterioso."}</div>
                          </div>
                          <div class="item-actions">
                              ${itemInfo.effect ? `<button class="use-item-btn" data-itemname="${itemName}" ${canBeUsed ? '' : 'disabled'} title="${canBeUsed ? 'Usar objeto' : 'No se puede usar ahora'}">Usar</button>` : ''}
                      
                          </div>
                      </div>
                  `;
              });
          }

          inventoryContent += '</div>';

          // Usamos el modal genérico para mostrar el contenido
          showModal("Detalles del Inventario", inventoryContent);
          // Ocultamos el título por defecto del modal genérico, ya que hemos puesto el nuestro.
          document.getElementById('modalTitle').style.display = 'none';

          // AÑADIMOS LOS LISTENERS DESPUÉS DE QUE EL MODAL ES VISIBLE
          document.querySelectorAll('.use-item-btn').forEach(button => {
              button.addEventListener('click', function() {
                  const itemName = this.dataset.itemname;
                  // Usamos la función de uso de ítem, que ya da feedback y actualiza la UI
                  useItem(itemName); 
                  // Cerramos y reabrimos el modal para reflejar los cambios (ej. item gastado)
                  closeModal();
                  openInventoryModal();
              });
          });

          document.querySelectorAll('.assign-slot-btn').forEach(button => {
              button.addEventListener('click', function() {
                  const itemName = this.dataset.itemname;
                  assignItemToQuickSlot(itemName);
              });
          });
      }

      function openItemAssignmentModal(slotIndex) {
          let assignmentContent = `
              <h2 style="text-align: center; margin-bottom: 20px;">Asignar al Slot ${slotIndex + 1}</h2>
              <p style="text-align: center; opacity: 0.8; margin-bottom: 15px;">Selecciona un objeto consumible para este acceso rápido.</p>
              <div id="assignment-modal-list" style="text-align: left;">
          `;

          // Filtrar para mostrar solo los ítems consumibles que el jugador posee
          const assignableItems = Object.entries(gameState.inventory).filter(([itemName, count]) => {
              const itemInfo = itemData[itemName];
              return count > 0 && itemInfo && itemInfo.canUse; // 'canUse' es nuestro indicador de consumible
          });

          if (assignableItems.length === 0) {
              assignmentContent += "<p style='text-align: center; opacity: 0.7;'>No tienes objetos consumibles para asignar.</p>";
          } else {
              assignableItems.forEach(([itemName, count]) => {
                  const itemInfo = itemData[itemName];
                  assignmentContent += `
                      <div class="inventory-modal-item assignable-item" data-itemname="${itemName}">
                          <div class="item-details">
                              <div class="item-name">${getItemIcon(itemName, '')} ${itemName} (x${count})</div>
                              <div class="item-description">${itemInfo.description}</div>
                          </div>
                      </div>
                  `;
              });
          }

          assignmentContent += `</div><button onclick="unassignQuickSlot(${slotIndex})" style="margin-top:20px; background-color: #883333;">Quitar Objeto del Slot</button>`;
          
          // Mostramos el modal
          showModal("Asignar Objeto", assignmentContent);
          document.getElementById('modalTitle').style.display = 'none';

          // Añadimos listeners a los ítems clicables
          document.querySelectorAll('.assignable-item').forEach(itemDiv => {
              itemDiv.addEventListener('click', function() {
                  const itemName = this.dataset.itemname;
                  // Asignar el ítem al slot correspondiente
                  gameState.player.quickSlots[slotIndex] = itemName;
                  // Cerrar el modal y actualizar la barra
                  closeModal();
                  renderQuickSlotBar();
              });
          });
      }
      function unassignQuickSlot(slotIndex) {
          gameState.player.quickSlots[slotIndex] = null;
          closeModal();
          renderQuickSlotBar();
      }

        // Modal para Personaje (Stats, Equipo, etc.)
        function openCharacterModal() {
          const player = gameState.player;
          let characterContent = `
                  <h2>${player.realm} - Nivel ${player.level}</h2>
                  <div style="text-align: left; margin-top: 15px;">
                  <p><strong>Vida:</strong> ${Math.floor(player.hp)} / ${
            player.maxHp
          }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill hp-fill" style="width: ${
                    (player.hp / player.maxHp) * 100
                  }%;"></div></div>
                  <p><strong>Maná:</strong> ${Math.floor(player.mana)} / ${
            player.maxMana
          }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill mana-fill" style="width: ${
                    (player.mana / player.maxMana) * 100
                  }%;"></div></div>
                  <p><strong>Experiencia:</strong> ${Math.floor(player.exp)} / ${
            player.expToNext
          }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill exp-fill" style="width: ${
                    (player.exp / player.expToNext) * 100
                  }%;"></div></div>
                  <hr style="margin: 15px 0;">
                  <p><strong>Ataque:</strong> ${player.attack}</p>
                  <p><strong>Defensa:</strong> ${player.defense}</p>
                  <p><strong>Piedras Espirituales:</strong> ${
                    gameState.inventory["Piedras Espirituales"] || 0
                  }</p>
                  <hr style="margin: 15px 0;">
                  <h4>Secta: ${player.secta.nombre}</h4>
                  <p><strong>Rango:</strong> ${player.secta.rango}</p>
                  <p><strong>Puntos de Contribución:</strong> ${
                    player.secta.puntosContribucion
                  } PCS</p>
                  </div>
                  `;
          // Aquí podrías añadir una sección para el equipo si lo implementas.
          showModal("Detalles del Personaje", characterContent);
        }

        // Placeholder para un futuro modal de menú principal
        function openMainMenuModal() {
          let menuContent = `
                  <h2>Menú Principal</h2>
                  <button class="cultivation-option-btn" onclick="saveGame(); closeModal();">💾 Guardar Partida</button>
                  <button class="cultivation-option-btn" onclick="triggerFileUpload(); closeModal();">📁 Cargar Partida</button>
                  <button class="cultivation-option-btn" onclick="showHelp();">❓ Ayuda</button>
                  <button class="cultivation-option-btn" onclick="closeModal();">↩️ Volver al Juego</button>
              `;
          // Usamos el showModal genérico pero sin el botón de cierre por defecto, ya que "Volver al Juego" hace esa función.
          // Para ello, tu showModal necesitaría una forma de ocultar su propio botón de cierre.
          // Si showModal no lo permite, necesitarías un modal específico para el menú.
          // Por ahora, asumiré que el showModal genérico tiene un botón de cierre que se ocultará
          // o que el usuario usará el botón "Volver al Juego".

          // Modificamos el modal genérico para que no muestre su propio botón "Cerrar" si se lo indicamos
          const modalElement = document.getElementById("interactionModal");
          const modalTitleEl = document.getElementById("modalTitle");
          const modalTextEl = document.getElementById("modalText");
          const closeButton = modalElement.querySelector(
            "button.close-modal-btn"
          );

          modalTitleEl.textContent = "Menú Principal"; // El H2 ya está en menuContent
          modalTextEl.innerHTML = menuContent.replace(
            "<h2>Menú Principal</h2>",
            ""
          ); // Quitar el H2 duplicado
          if (closeButton) closeButton.style.display = "none"; // Ocultar el botón de cierre por defecto del modal

          modalElement.style.display = "flex";
          hideTouchControls();
          updateTopNavVisibility();
        }

        function openSectHallInterface() {
          const player = gameState.player;
          const sectData = SECTA_DATA;
          console.log(
            "[SectHall] Abrir interfaz. Rango actual:",
            player.secta.rango,
            "PCS:",
            player.secta.puntosContribucion
          ); // LOG INICIAL

          document.getElementById(
            "sectHallModalTitle"
          ).textContent = `Salón ${player.secta.nombre}`;
          document.getElementById("sectHallPlayerRank").textContent =
            player.secta.rango;
          document.getElementById("sectHallPlayerPCS").textContent =
            player.secta.puntosContribucion;

          const availableMissionsDiv = document.getElementById(
            "sectHallAvailableMissions"
          );
          availableMissionsDiv.innerHTML =
            "<p>Habla con Guía Lin o Admin Yao para asignaciones generales.</p>";

          const rankChallengesDiv = document.getElementById(
            "sectHallRankChallenges"
          );
          rankChallengesDiv.innerHTML = "";

          const currentRankIndex = sectData.rangos.findIndex(
            (r) => r.nombre === player.secta.rango
          );
          console.log("[SectHall] currentRankIndex:", currentRankIndex); // LOG currentRankIndex

          let challengeButtonAdded = false;

          // Condición principal para mostrar el botón de consulta
          if (
            currentRankIndex !== -1 &&
            currentRankIndex + 1 < sectData.rangos.length
          ) {
            console.log(
              "[SectHall] Condición para mostrar botón CUMPLIDA. Hay un siguiente rango."
            ); // LOG
            const nextRankData = sectData.rangos[currentRankIndex + 1];
            console.log(
              "[SectHall] Siguiente rango:",
              nextRankData.nombre,
              "PCS Req:",
              nextRankData.pcsRequeridos
            ); // LOG nextRankData

            const challengeButton = document.createElement("button");
            challengeButton.textContent = `Consultar Desafío para ${nextRankData.nombre}`;
            challengeButton.className = "cultivation-option-btn";
            challengeButton.style.marginBottom = "10px";

            challengeButton.onclick = () => {
              // ... (lógica del onclick que ya tienes, puedes añadir logs internos aquí también si es necesario) ...
              console.log("[SectHall] Botón 'Consultar Desafío' CLICADO.");
              const pcsNecesarios = nextRankData.pcsRequeridos;
              const tieneSuficientesPCS =
                player.secta.puntosContribucion >= pcsNecesarios;
              const rivalIdParaDesafio = nextRankData.desafioRivalId;
              let mensajeDesafio = `<strong>Desafío para ascender a ${nextRankData.nombre}:</strong><br>`;
              let misionDesafioActiva = null;
              let misionDesafioDataObj = null;
              let idDeLaMisionAsociada = null;

              console.log(
                `[SectHall - OnClick] PCS Necesarios: ${pcsNecesarios}, Tiene PCS: ${tieneSuficientesPCS}, Rival ID: ${rivalIdParaDesafio}`
              );

              if (rivalIdParaDesafio) {
                const misionEntry = Object.entries(MISIONES_DATA).find(
                  ([mKey, mVal]) =>
                    mVal.objetivo?.tipo === "derrotar_npc_especifico" &&
                    mVal.objetivo?.npcId === rivalIdParaDesafio &&
                    mVal.recompensa?.nuevoRango === nextRankData.nombre
                );
                console.log(
                  "[SectHall - OnClick] Mision Entry encontrada:",
                  misionEntry
                );

                if (misionEntry) {
                  idDeLaMisionAsociada = misionEntry[0];
                  misionDesafioDataObj = misionEntry[1];
                  misionDesafioActiva = player.secta.misionesActivas.find(
                    (m) => m.id === idDeLaMisionAsociada
                  );
                  console.log(
                    "[SectHall - OnClick] ID Misión Asociada:",
                    idDeLaMisionAsociada,
                    "Misión Activa?:",
                    !!misionDesafioActiva
                  );

                  mensajeDesafio += `<em>"${misionDesafioDataObj.descripcion}"</em><br>`;
                  mensajeDesafio += `Oponente: <strong>${
                    entityTypes[rivalIdParaDesafio]?.name ||
                    "Guardián Desconocido"
                  }</strong>.<br>`;
                  mensajeDesafio += `Recompensas: ${
                    misionDesafioDataObj.recompensa.pcs || 0
                  } PCS, ${misionDesafioDataObj.recompensa.exp || 0} EXP, Rango ${
                    nextRankData.nombre
                  }.<br><hr>`;
                } else {
                  mensajeDesafio += `Información del desafío específico no encontrada (error de configuración o la misión no está definida correctamente).<br><hr>`;
                }
              } else {
                mensajeDesafio += `Este rango no parece requerir un desafío de combate para ascender.<br><hr>`;
              }

              mensajeDesafio += `<strong>Requisitos Actuales:</strong><br>`;
              mensajeDesafio += `Puntos de Contribución (PCS): ${player.secta.puntosContribucion} / ${pcsNecesarios} PCS. `;
              mensajeDesafio += tieneSuficientesPCS
                ? "<span style='color: #66ff66;'>(Cumplido)</span><br>"
                : `<span style='color: #ffcc66;'>(Faltan ${
                    pcsNecesarios - player.secta.puntosContribucion
                  } PCS)</span><br>`;

              if (misionDesafioActiva) {
                mensajeDesafio +=
                  "<br><strong style='color: #66ff66;'>¡El desafío está ACTIVO!</strong> Dirígete a la arena.";
              } else if (
                idDeLaMisionAsociada &&
                player.secta.misionesCompletadas[idDeLaMisionAsociada]
              ) {
                mensajeDesafio +=
                  "<br><strong style='color: #aaa;'>Ya has completado este desafío.</strong>";
              } else if (
                tieneSuficientesPCS &&
                rivalIdParaDesafio &&
                misionDesafioDataObj &&
                idDeLaMisionAsociada
              ) {
                const activarDesafioBtnId = "activar-desafio-btn-specific";
                mensajeDesafio += `<br><button id="${activarDesafioBtnId}">Activar Misión de Desafío Ahora</button>`;

                window.tempChallengeActivationInfo = {
                  misionId: idDeLaMisionAsociada,
                  nextRankName: nextRankData.nombre,
                };
              } else if (!tieneSuficientesPCS) {
                mensajeDesafio +=
                  "<br>Aún no cumples los requisitos de PCS para activar este desafío.";
              } else if (!rivalIdParaDesafio || !misionDesafioDataObj) {
                mensajeDesafio +=
                  "<br>No hay un desafío de combate claramente definido para este rango o falta información de la misión.";
              }

              showModal("Información del Desafío de Rango", mensajeDesafio);

              if (
                window.tempChallengeActivationInfo &&
                document.getElementById("activar-desafio-btn-specific")
              ) {
                document.getElementById("activar-desafio-btn-specific").onclick =
                  () => {
                    console.log(
                      "[SectHall - OnClick] Botón 'Activar Misión Ahora' CLICADO."
                    );
                    const info = window.tempChallengeActivationInfo;
                    const misionDataParaActivar = MISIONES_DATA[info.misionId];
                    const playerRef = gameState.player;
                    const nextRankDataRef = SECTA_DATA.rangos.find(
                      (r) => r.nombre === info.nextRankName
                    );

                    if (
                      misionDataParaActivar &&
                      nextRankDataRef &&
                      playerRef.secta.puntosContribucion >=
                        nextRankDataRef.pcsRequeridos
                    ) {
                      if (
                        !playerRef.secta.misionesActivas.some(
                          (m) => m.id === info.misionId
                        ) &&
                        !playerRef.secta.misionesCompletadas[info.misionId]
                      ) {
                        acceptMission(info.misionId);
                        closeModal();
                        openSectHallInterface();
                        ensureFixedEntities();
                        renderMap();
                      } else {
                        showModal(
                          "Desafío ya Gestionado",
                          "Este desafío ya está activo o ha sido completado."
                        );
                      }
                    } else {
                      showModal(
                        "Requisitos No Cumplidos",
                        "Ya no cumples los requisitos para activar este desafío."
                      );
                    }
                    delete window.tempChallengeActivationInfo;
                  };
              } else if (
                document.getElementById("activar-desafio-btn-specific")
              ) {
                console.warn(
                  "[SectHall - OnClick] Botón 'activar-desafio-btn-specific' existe, pero window.tempChallengeActivationInfo no está definido."
                );
              }
            };
            rankChallengesDiv.appendChild(challengeButton);
            challengeButtonAdded = true;
            console.log("[SectHall] Botón 'Consultar Desafío' AÑADIDO al DOM."); // LOG si se añade
          } else {
            // Este bloque se ejecuta si la condición if (currentRankIndex !== -1 && currentRankIndex + 1 < sectData.rangos.length) NO se cumple
            console.log("[SectHall] Condición para mostrar botón NO CUMPLIDA."); // LOG
            if (currentRankIndex === -1) {
              console.log(
                "[SectHall] Razón: currentRankIndex es -1 (rango del jugador no encontrado)."
              ); // LOG
            } else {
              console.log(
                "[SectHall] Razón: Jugador en rango máximo o no hay más rangos (currentRankIndex + 1 >= sectData.rangos.length)."
              ); // LOG
            }
          }

          // Mensajes de fallback si el botón no se añadió
          if (!challengeButtonAdded) {
            console.log(
              "[SectHall] challengeButtonAdded es FALSE. Mostrando mensaje de fallback."
            ); // LOG
            if (currentRankIndex === -1) {
              rankChallengesDiv.innerHTML =
                "<p>Error al determinar tu rango actual.</p>";
            } else if (currentRankIndex + 1 >= sectData.rangos.length) {
              rankChallengesDiv.innerHTML =
                "<p>¡Has alcanzado el rango más alto o no hay más desafíos definidos!</p>";
            } else {
              // Esta situación es menos común si la lógica anterior es correcta,
              // pero podría ocurrir si hay un `nextRankData` pero por alguna razón no se crea el botón.
              rankChallengesDiv.innerHTML =
                "<p>No hay información de desafío disponible en este momento (situación de fallback inesperada).</p>";
            }
          }

          document.getElementById("sectHallModal").style.display = "flex";
          hideTouchControls();
        }
        function acceptMissionFromSectHall(misionId) {
          acceptMission(misionId);
          if (document.getElementById("sectHallModal").style.display === "flex") {
            openSectHallInterface();
          }
        }
        function closeSectHallModal() {
          document.getElementById("sectHallModal").style.display = "none";
          showTouchControls();
          updatePlayerBarsOnMap();
          showTouchControls();
        }
        function openSectShop() {
          showModal("Tienda de Secta", "El Depósito aún está siendo abastecido.");
        }
        // Variable global para almacenar la acción a confirmar
      let onConfirmAction = null;
      

      function getPlayerCurrentZone() {
        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        for (const zone of gameState.map.terrainZones) {
          if (playerX >= zone.x1 && playerX <= zone.x2 && playerY >= zone.y1 && playerY <= zone.y2) {
            return zone;
          }
        }
        return null; // El jugador no está en ninguna zona definida (está en el "mundo abierto")
      }
      function showConfirmationModal(title, text, onConfirm) {
        document.getElementById('confirmationModalTitle').textContent = title;
        document.getElementById('confirmationModalText').innerHTML = text;
        
        onConfirmAction = onConfirm; // Guardamos la función que se ejecutará si se confirma

        const confirmButton = document.getElementById('confirmBtn');
        // Usamos .onclick para reemplazar cualquier listener anterior
        confirmButton.onclick = () => {
            if (typeof onConfirmAction === 'function') {
                onConfirmAction();
            }
            closeConfirmationModal();
        };

        document.getElementById('confirmationModal').style.display = 'flex';
        hideTouchControls();
      }

      function closeConfirmationModal() {
        document.getElementById('confirmationModal').style.display = 'none';
        onConfirmAction = null; // Limpiamos la acción
        showTouchControls();
      }
        // --- INICIALIZACIÓN ---
        document.addEventListener("DOMContentLoaded", () => {
          const mobileMenuButton = document.getElementById('mobileMenuBtn');
          const topNavBar = document.getElementById('topNavBar'); // Ya deberías tener esta variable
          if (mobileMenuButton && topNavBar) {
              mobileMenuButton.addEventListener('click', (e) => {
                  e.stopPropagation(); // Evita que otros clicks se disparen
                  topNavBar.classList.toggle('open');
              });
          }
          
          // Añadir un listener para cerrar el menú si se hace clic fuera de él
          document.addEventListener('click', (e) => {
              if (topNavBar.classList.contains('open') && !topNavBar.contains(e.target)) {
                  topNavBar.classList.remove('open');
              }
          });
          renderQuickSlotBar();
          const navBtnMissions = document.getElementById('navBtnMissions');
          if (navBtnMissions) {
              navBtnMissions.addEventListener('click', openMissionsModal);
          }
          const navBtnInventory = document.getElementById('navBtnInventory');
          console.log("Dentro de DOMContentLoaded, navBtnInventory:", navBtnInventory);
          if (navBtnInventory) {
            navBtnInventory.addEventListener("click", () => {
              openInventoryModal(); // Llama a nuestra nueva y mejorada función
              if(isMobileView() && topNavBar.classList.contains('open')) {
                  topNavBar.classList.remove('open');
              }
            });
          }

          if (navBtnCharacter) {
            navBtnCharacter.addEventListener("click", () => {
              // Necesitas una función para abrir un MODAL de personaje
              openCharacterModal(); // Tendrías que crear esta función y el modal
            });
          }

          if (navBtnCultivate) {
            navBtnCultivate.addEventListener("click", () => {
              toggleCultivation(); // Tu función existente para iniciar/detener cultivo
            });
          }

          if (navBtnTechniques) {
            navBtnTechniques.addEventListener("click", () => {
              showTechniquePanel(); // Tu función existente para mostrar el modal de técnicas
            });
          }

          if (navBtnMenu) {
              navBtnMenu.addEventListener("click", () => {
                  // Siempre abre el modal del menú principal.
                  openMainMenuModal(); 
                  
                  // Adicional: En móvil, cierra el menú desplegable después de hacer clic.
                  if (isMobileView() && topNavBar.classList.contains('open')) {
                      topNavBar.classList.remove('open');
                  }
              });
          }

          // Llamada inicial para asegurar el estado correcto de la barra
          updateTopNavVisibility();

          // --- INICIO DEL REEMPLAZO DE EVENT LISTENERS ---
          document.addEventListener("keydown", (e) => {
              if (isAnyModalOpen() || gameState.battle.active || gameState.player.isCultivating) {
                  Object.keys(playerMovementKeysDown).forEach(k => playerMovementKeysDown[k] = false);
                  return;
              }
              // --- INICIO DE LA MODIFICACIÓN PARA ACCESO RÁPIDO ---
              if (e.code.startsWith("Digit")) {
                  const slotIndex = parseInt(e.code.replace("Digit", ""), 10) - 1;
                  if (slotIndex >= 0 && slotIndex < 5) {
                      e.preventDefault();
                      useQuickSlotItem(slotIndex);
                      return; // Importante para que no procese el movimiento
                  }
              }
              // --- FIN DE LA MODIFICACIÓN ---
              let direction = null;
              switch (e.code) {
                  case "KeyW": case "ArrowUp":    direction = "up"; break;
                  case "KeyS": case "ArrowDown":  direction = "down"; break;
                  case "KeyA": case "ArrowLeft":  direction = "left"; break;
                  case "KeyD": case "ArrowRight": direction = "right"; break;
                  case "Space":
                      e.preventDefault();
                      interact();
                      return;
              }

              if (direction) {
                  e.preventDefault();
                  playerMovementKeysDown[direction] = true;
              }
          });

          document.addEventListener("keyup", (e) => {
              let direction = null;
              switch (e.code) {
                  case "KeyW": case "ArrowUp":    direction = "up"; break;
                  case "KeyS": case "ArrowDown":  direction = "down"; break;
                  case "KeyA": case "ArrowLeft":  direction = "left"; break;
                  case "KeyD": case "ArrowRight": direction = "right"; break;
              }

              if (direction) {
                  e.preventDefault();
                  playerMovementKeysDown[direction] = false;
              }
          });
          

          // Helper para convertir dirección a dx/dy para movePlayer
          function dxFromDirection(direction) {
            if (direction === "left") return -1;
            if (direction === "right") return 1;
            return 0;
          }

          function dyFromDirection(direction) {
            if (direction === "up") return -1;
            if (direction === "down") return 1;
            return 0;
          }

          const fileInput = document.getElementById("fileInput");
          if (fileInput) fileInput.addEventListener("change", loadGameFromFile);

          const toggleControlsBtn = document.getElementById(
            "toggleMapControlsBtn"
          );
          if (toggleControlsBtn)
            toggleControlsBtn.addEventListener(
              "click",
              toggleMapControlsVisibility
            );

          // Listener para redimensionar y recalcular el tamaño de los tiles
          window.addEventListener("resize", () => {
            calculateAndSetTileSize();
            renderMap(); // Vuelve a dibujar con el nuevo tamaño
            updatePlayerPosition(); // Asegura que el jugador esté bien posicionado
          });

          // Iniciar el bucle de actualización del juego
          setInterval(gameTickUpdater, 1000); // Llama cada segundo, ajusta según necesidad
          initJoystick();
          setInterval(gameLoop, 100);
          calculateAndSetTileSize();
          // generateMap() ahora es más simple, isRespawn = false para carga inicial completa
          gameState.lastGameTimeUpdate = Date.now(); // Inicializar antes del primer tick
         
          generateMap(true); // Usar true para la generación inicial completa, incluyendo decorativos
          
          recalculatePlayerStats();
          updatePlayerVisualSize(); // Asegura el tamaño correcto del div del jugador
          updatePlayerSpriteVisual(); // Establece el sprite inicial
          updatePlayerPosition("DOMContentLoaded_init"); // Llama después de sprite visual

          updatePlayerSpriteVisual(); // Llamar una vez para establecer el sprite inicial

          showTouchControls();

          showModal(
            "Despertar del Cultivador",
            "Has despertado en un mundo de cultivadores buscando poder supremo. " +
              "Te encuentras cerca de la <strong>Secta del Viento Azure</strong>. Quizás allí encuentres tu camino.\n\n" +
              "<strong>Objetivo:</strong> Asciende en la secta, domina técnicas, derrota enemigos y desvela secretos.\n\n" +
              "Busca al <strong>Guía Lin</strong> en la secta (⛩️) para comenzar.\n\n" +
              'Usa Controles (Teclado/Táctil) para moverte e interactuar. Presiona "?" para ayuda.'
          );
          document
            .querySelectorAll("#shopCategories .category-item")
            .forEach((item) => {
              item.addEventListener("click", function () {
                document
                  .querySelectorAll("#shopCategories .category-item")
                  .forEach((i) => i.classList.remove("active"));
                this.classList.add("active");
                currentShopPage = 1;
                renderShopProducts();
              });
            });
          document.getElementById("shopSearch").addEventListener("input", () => {
            currentShopPage = 1;
            renderShopProducts();
          });
          document.getElementById("priceRange").addEventListener("input", (e) => {
            document.getElementById(
              "priceRangeValue"
            ).textContent = `${e.target.value} PS`;
            currentShopPage = 1;
            renderShopProducts();
          });
        });
      </script>
      <!-- BARRA DE ACCESO RÁPIDO INFERIOR -->
      <div class="quick-slot-bar" id="quickSlotBar">
          <!-- Los slots se generarán con JavaScript -->
        </div>
  </body>
</html>
