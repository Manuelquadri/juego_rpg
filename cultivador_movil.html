<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Camino del Cultivador</title>
    <style>
      /****************************************
       * 1. ESTILOS GENERALES Y LAYOUT
       ****************************************/
       
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", monospace;
        background-color: #1a3d2e; 
        color: #f4e4bc;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Evita el scroll indeseado */
      }

      .game-container {
        display: flex;
        flex-grow: 1;
        /* El padding-top crea el espacio para la barra de navegación superior */
        padding-top: 55px; /* Ajusta este valor si cambia la altura de la barra */
        position: relative;
        z-index: 1;
      }

      .sidebar {
        display: none; /* La barra lateral ya no se usa, se oculta permanentemente */
      }

      button {
        background: linear-gradient(135deg, #d4af37, #b8941f);
        color: #2c1810;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      button:hover {
        background: linear-gradient(135deg, #f4d03f, #d4af37);
        transform: translateY(-2px);
      }

      button:disabled {
        background: #666;
        color: #999;
        cursor: not-allowed;
        transform: none;
      }
      /* Esta regla se aplicará a TODAS las barras de estadísticas del juego */
      .stat-bar {
        width: 100%;
        height: 18px; /* Una altura estándar y visible. Puedes ajustarla. */
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 9px;
        overflow: hidden; /* Asegura que el relleno no se salga */
        border: 1px solid rgba(212, 175, 55, 0.2);
        margin: 8px 0; /* Un poco de espacio vertical para que no se pegue a otros elementos */
      }

      /* El relleno de la barra */
      .stat-fill {
        height: 100%; /* Ahora esto funcionará, porque el padre (.stat-bar) tiene una altura fija */
        transition: width 0.3s linear;
      }
      #fullscreenIcon {
        margin-right: 8px;
        display: inline-block;
        /* Para el ícono de salir */
        font-family: 'Arial Unicode MS', 'Apple Symbols', 'sans-serif';
      }
      /* ESTILO PARA LA REJILLA DEL MAPA */
      .grid-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 2; 
          background-size: var(--tile-size, 100px) var(--tile-size, 100px);
          background-image:
              linear-gradient(to right, #ff00d94d 2px, transparent 1px),
              linear-gradient(to bottom, #ff00d94d 2px, transparent 1px);
          display: none;
      }
      .grid-overlay.active {
          display: block;
      }
      /* --- Estilos para los Indicadores de Misión sobre NPCs --- */
      .quest-indicator {
          position: absolute;
          top: -50px; /* Posiciona el indicador por encima de la cabeza del NPC */
          left: 50%;
          transform: translateX(-50%);
          font-size: 30px;
          font-weight: bold;
          text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
          pointer-events: none; /* Para que no interfiera con los clics */
          z-index: 7; /* Por encima de la placa de nombre */
          animation: bounce-indicator 1.5s infinite ease-in-out;
      }

      .indicator-available {
          color: #f4d03f; /* Amarillo para misiones disponibles */
      }

      .indicator-progress {
          color: #ffffff; /* Blanco para misiones en progreso/entrega */
      }

      @keyframes bounce-indicator {
          0%, 20%, 50%, 80%, 100% {
              transform: translateX(-50%) translateY(0);
          }
          40% {
              transform: translateX(-50%) translateY(-10px);
          }
          60% {
              transform: translateX(-50%) translateY(-5px);
          }
      }
      /* --- Estilos para el Diagrama de Formación en el Modal de Técnicas --- */
      .technique-section-title {
          margin-top: 20px;
          padding-top: 15px;
          border-top: 1px solid rgba(212, 175, 55, 0.3);
          color: #f4d03f;
      }

      .formation-diagram-grid {
          display: grid;
          width: 100px; /* Tamaño pequeño para el diagrama */
          height: 100px;
          margin: 10px 0 5px 0;
          border: 1px solid #555;
          background-color: rgba(0,0,0,0.1);
      }

      .formation-diagram-grid .grid-cell {
          border: 1px solid #333;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 0.9em;
      }

      .formation-diagram-grid .grid-cell.rune {
          color: #ff00ff;
          font-weight: bold;
      }

      .formation-diagram-grid .grid-cell.enemy {
          color: #ff4d4d;
      }
      /****************************************
       * 2. INTERFAZ PRINCIPAL (HUD, BARRAS, BOTONES)
       ****************************************/

      /* --- Barra de Navegación Superior --- */
      .top-nav-bar {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 55px; /* Altura fija para el cálculo de padding */
        background: linear-gradient(180deg, #2c1810, #1a1a1a);
        border-bottom: 2px solid #d4af37;
        display: flex;
        justify-content: space-around;
        align-items: center;
        z-index: 250;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease-in-out;
        transform: translateY(0);
      }

      .top-nav-bar.hidden {
        transform: translateY(-100%);
      }

      .nav-button {
        position: relative;
        background: transparent;
        border: none;
        color: #f4e4bc;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 8px 5px;
        cursor: pointer;
        font-family: "Courier New", monospace;
        font-size: 0.75rem;
        flex-grow: 1;
        max-width: 20%;
        transition: background-color 0.2s, color 0.2s;
      }

      .nav-button:hover,
      .nav-button.active {
        background-color: rgba(212, 175, 55, 0.15);
        color: #f4d03f;
      }

      .nav-icon {
        font-size: 1.5rem;
        margin-bottom: 3px;
      }

      /* --- HUD de Stats del Jugador (Esquina superior izquierda) --- */
      .stats-panel {
        position: fixed; /* FIJO en la ventana, no relativo al mapa */
        top: 70px; /* 55px de la barra + 15px de margen */
        left: 15px;
        z-index: 100;
        width: 180px;
        background: rgba(26, 26, 26, 0.75);
        backdrop-filter: blur(4px);
        border: 2px solid #d4af37;
        border-radius: 8px;
        padding: 10px;
        margin: 0;
      }

      .stats-panel .stat-bar {
        width: 100%;
        height: 12px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 7px;
        margin-top: 3px;
        margin-bottom: 8px;
        overflow: hidden;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      .stat-fill {
        height: 100%;
        transition: width 0.3s;
      }
      .stats-panel .stat-line,
      .stats-panel .stat-block {
        margin-bottom: 8px; /* Espaciado consistente */
      }

      .stats-panel .stat-stones {
        color: #f4d03f; /* Destacar las piedras espirituales */
        font-weight: bold;
        margin-top: 4px;
      }

      .stats-panel .stat-block span {
        display: block; /* Asegura que el texto esté en su propia línea */
        font-size: 0.9em;
        margin-bottom: 2px;
      }
      .hp-fill {
        background: linear-gradient(90deg, #ff4444, #ff6666);
      }
      .mana-fill {
        background: linear-gradient(90deg, #4444ff, #6666ff);
      }
      .exp-fill {
        background: linear-gradient(90deg, #44ff44, #66ff66);
      }
      .stats-panel.hidden {
        opacity: 0;
        pointer-events: none; /* Evita que se pueda hacer clic en el panel cuando está oculto */
        transform: translateX(
          -100%
        ); /* Opcional: lo desliza fuera de la pantalla */
        transition: opacity 0.3s ease, transform 0.3s ease;
      }
      /* --- Barra de Acceso Rápido Inferior --- */
      .quick-slot-bar {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        padding: 8px;
        background: rgba(26, 26, 26, 0.8);
        border: 2px solid #d4af37;
        border-radius: 12px;
        z-index: 150;
        box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
        backdrop-filter: blur(4px);
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      }
      .quick-slot-bar.hidden {
          opacity: 0;
          visibility: hidden;
          pointer-events: none; /* Importante para que no sea clickeable cuando está invisible */
      }

      .quick-slot {
        width: 55px;
        height: 55px;
        border: 2px solid rgba(212, 175, 55, 0.5);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        position: relative;
        transition: all 0.2s;
      }
      .quick-slot:hover {
        background-color: rgba(212, 175, 55, 0.2);
        border-color: #f4d03f;
      }
      .quick-slot.empty {
        border-style: dashed;
      }

      .slot-item-count {
        position: absolute;
        bottom: 2px;
        right: 4px;
        font-size: 14px;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px black;
      }

      .slot-key-hint {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 12px;
        color: #f4e4bc;
        opacity: 0.7;
      }
      .cultivate-slot {
        font-size: 28px; /* Hacemos el emoji un poco más grande */
        border-style: solid; /* Para que no se vea punteado como un slot vacío */
      }

      /* Estilo para cuando el cultivo está activo */
      .cultivate-slot.active-cultivation {
        background-color: rgba(
          139,
          69,
          19,
          0.5
        ); /* Un brillo sutil de color del tema */
        border-color: #f4d03f;
        box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
        animation: pulse-cultivation 2s infinite;
      }
      .conversion-slot {
        font-size: 28px;
        border-style: solid;
        color: #f4e4bc;
        opacity: 0.6; /* Un poco tenue cuando está inactivo */
        transition: all 0.3s;
      }

      .conversion-slot:hover {
        opacity: 1;
      }

      .conversion-slot.active-conversion {
        opacity: 1;
        background-color: rgba(68, 68, 255, 0.3); /* Brillo azulado */
        border-color: #6666ff;
        box-shadow: 0 0 10px rgba(102, 102, 255, 0.7);
        animation: pulse-conversion 2s infinite;
      }
      /* Estilo para que el enemigo se vea "seleccionable" al pasar el ratón */
      .selectable-enemy {
          cursor: pointer;
          transition: filter 0.2s ease-in-out;
      }
      .selectable-enemy:hover {
          filter: brightness(1.3) drop-shadow(0 0 5px #fff);
      }
      .player.channeling {
            filter: drop-shadow(0 0 8px #ff99ff) brightness(1.5);
            animation: pulse-channeling 1.5s infinite;
        }

        @keyframes pulse-channeling {
            0% { filter: drop-shadow(0 0 8px #ff99ff) brightness(1.5); }
            50% { filter: drop-shadow(0 0 16px #ffc0ff) brightness(1.8); }
            100% { filter: drop-shadow(0 0 8px #ff99ff) brightness(1.5); }
        }
      /* El estilo para el sombreado rojo del "área de peligro" */
      .danger-zone-tile {
          position: absolute;
          z-index: 2; /* Encima del terreno, debajo de las entidades */
          background-color: rgba(255, 50, 50, 0.25);
          border: 1px dashed rgba(255, 100, 100, 0.6);
          pointer-events: none; /* ¡Muy importante! Para que no bloquee otros clics */
          box-sizing: border-box;
      }
      .rune-slot {
          font-size: 28px;
          border-style: solid;
          color: #ff99ff; /* Un tono magenta/rosa para la magia rúnica */
          opacity: 0.6; /* Un poco tenue cuando no se usa activamente */
          transition: all 0.3s;
      }

      .rune-slot:hover {
          opacity: 1;
          color: #ffc0ff;
          border-color: #ff99ff;
      }

      /* (Opcional) Un estilo para cuando la habilidad se esté usando, aunque para plantar runas no es tan necesario */
      .rune-slot.active-scribing {
          opacity: 1;
          background-color: rgba(255, 100, 255, 0.2); /* Brillo magenta */
          border-color: #ff99ff;
          box-shadow: 0 0 10px rgba(255, 153, 255, 0.7);
          animation: pulse-rune-slot 1.5s infinite;
      }

      @keyframes pulse-rune-slot {
          0% { transform: scale(1); }
          50% { transform: scale(1.05); }
          100% { transform: scale(1); }
      }
      .rune-marker {
          background-color: rgba(255, 100, 255, 0.2);
          border: 2px solid #ff00ff;
          border-radius: 50%;
          box-shadow: 0 0 15px #ff00ff, inset 0 0 10px #ff00ff;
          animation: pulse-rune 2.5s infinite ease-in-out;
      }

      @keyframes pulse-rune {
          0% { transform: scale(0.8); opacity: 0.7; }
          50% { transform: scale(1.0); opacity: 1; }
          100% { transform: scale(0.8); opacity: 0.7; }
      }
      @keyframes pulse-conversion {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes pulse-cultivation {
        0% {
          transform: scale(1);
          box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 15px rgba(244, 208, 63, 0.8);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
        }
      }
      @keyframes pulse-mission-marker {
          0% {
              box-shadow: 0 0 5px rgba(255, 223, 0, 0.4), inset 0 0 5px rgba(255, 223, 0, 0.3);
              opacity: 0.7;
          }
          50% {
              box-shadow: 0 0 20px rgba(255, 223, 0, 0.8), inset 0 0 10px rgba(255, 223, 0, 0.5);
              opacity: 1;
          }
          100% {
              box-shadow: 0 0 5px rgba(255, 223, 0, 0.4), inset 0 0 5px rgba(255, 223, 0, 0.3);
              opacity: 0.7;
          }
      }

      /* --- Botones de Control Superpuestos (Móvil) --- */
      #mobileMenuBtn {
        display: none;
        position: fixed;
        top: 10px;
        right: 10px; /* <--- CORREGIDO */
        z-index: 1000;
        width: 45px;
        height: 45px;
        font-size: 24px;
        padding: 0;
      }

      #toggleMapControlsBtn {
          display: none; /* Se controla por JS y media queries */
          position: fixed;
          top: 60px; /* Posición respecto a la ventana */
          right: 10px;
          z-index: 200; /* Aseguramos que esté al mismo nivel que los otros controles */
          padding: 8px 12px;
          font-size: 14px;
      }

      #toggleMapControlsBtn.hidden-during-battle {
        display: none !important;
      }

      /****************************************
       * 3. MAPA Y ELEMENTOS DEL MAPA
       ****************************************/
      .map-container {
        flex: 1;
        position: relative;
        background: #1a3d2e;
        border: 3px solid #d4af37;
        overflow: hidden;
      }

      .map {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .tile {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .player {
        z-index: 10;
        color: transparent; /* Oculta el emoji de fallback */
        font-size: 0;
        background-image: url("img/tu_sprite_sheet.png"); /* Asegúrate que la ruta sea correcta */
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: 256px 256px; /* Ajusta al tamaño total de tu spritesheet */
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }

      /* Barras de stats sobre el jugador en el mapa */
      #playerOnMapBarsContainer {
        position: absolute;
        width: 48px;
        display: none; /* JS lo controla */
        flex-direction: column;
        gap: 1px;
        z-index: 15;
        pointer-events: none;
        transform: translateX(-50%);
      }

      .on-map-stat-bar {
        width: 100%;
        height: 6px;
        background-color: rgba(50, 50, 50, 0.7);
        border: 1px solid rgba(0, 0, 0, 0.5);
        border-radius: 2px;
        overflow: hidden;
      }

      .on-map-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerOnMapHpFill {
        background-color: #f44336;
      }
      #playerOnMapManaFill {
        background-color: #2196f3;
      }
      .entity-name-plate {
        position: absolute; /* Para posicionarlo relativo al mapa */
        bottom: 100%; /* Lo coloca justo encima del 'top' del sprite */
        left: 50%;
        transform: translateX(-50%); /* Lo centra horizontalmente */
        background-color: rgba(10, 10, 10, 0.7);
        color: #f4e4bc;
        padding: 2px 5px;
        border-radius: 4px;
        font-size: 10px; /* Un tamaño de fuente pequeño y legible */
        font-weight: bold;
        white-space: nowrap; /* Evita que el nombre se parta en dos líneas */
        z-index: 6; /* Asegura que esté por encima de la entidad */
        pointer-events: none; /* Evita que la etiqueta intercepte clics del ratón */
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      /****************************************
       * 4. PANTALLA DE BATALLA
       ****************************************/

      .battle-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        display: none;
        flex-direction: column;
        z-index: 300;
        overflow: hidden;
        max-height: 100dvh; 
      }

      .battle-area {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: space-around;
        padding: 20px 10px;
        gap: 10px;
        overflow-y: auto;
      }

      .character,
      .enemy {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-basis: 45%;
        max-width: 280px;
        min-width: 120px;
        padding: 60px 0;
      }

      .character-sprite,
      .enemy-sprite {
        width: 80px;
        height: 80px;
        font-size: 60px;
        margin-bottom: 10px;
      }
      .enemy-sprite {
        background-size: contain; /* Asegura que la imagen quepa completa en el div */
        background-repeat: no-repeat;
        background-position: center; /* Centra la imagen del sprite */
        image-rendering: pixelated; /* Mantiene la estética pixel-art si la tienes */
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }

      .character-sprite {
        background-image: url("img/tu_sprite_sheet.png");
        background-repeat: no-repeat;
        background-position: 0 0;
        background-size: auto;
        color: transparent;
      }

      .battle-actions {
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-top: 2px solid #d4af37;
        flex-shrink: 0;
      }

      .action-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 5px;
        margin-bottom: 10px;
      }

      .battle-actions button {
        padding: 8px 10px;
        font-size: 0.8em;
      }

      .log {
        display: none;
      }

      /* Barras sobre sprites en batalla */
      #playerInBattleSpriteBarsContainer,
      #enemyInBattleInfoContainer {
        position: absolute;
        display: none;
        flex-direction: column;
        gap: 2px;
        z-index: 5;
        pointer-events: none;
        transform: translateX(-50%);
      }

      #playerInBattleSpriteBarsContainer {
        width: 60px;
      }
      #enemyInBattleInfoContainer {
        min-width: 70px;
        max-width: 300px;
        align-items: center;
        padding: 2px 4px;
        background-color: rgba(10, 10, 10, 0.6);
        border-radius: 3px;
        border: 1px solid rgba(212, 175, 55, 0.3);
      }

      .in-battle-sprite-stat-bar {
        width: 100%;
        height: 5px;
        background-color: rgba(50, 50, 50, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.6);
        border-radius: 2px;
        overflow: hidden;
      }
      .in-battle-sprite-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerInBattleSpriteHpFill {
        background-color: #e53935;
      }
      #playerInBattleSpriteManaFill {
        background-color: #1e88e5;
      }
      #enemyInBattleSpriteHpFill {
        background-color: #c62828;
      }

      .enemy-battle-name-level {
        font-size: 0.8em;
        color: #f4e4bc;
        font-weight: bold;
        white-space: nowrap;
      }

      /****************************************
       * 5. MODALES Y ELEMENTOS DE UI
       ****************************************/
      /* === NUEVO: ESTILOS PARA EL VELO OSCURECEDOR === */
      /* Estilos para la cuadrícula del tutorial de formaciones */
      #formation-pattern-grid {
          display: grid;
          grid-template-columns: repeat(5, 1fr);
          grid-template-rows: repeat(5, 1fr);
          width: 150px; /* Tamaño de la cuadrícula de ejemplo */
          height: 150px;
          margin: 15px auto;
          border: 2px solid #555;
          background-color: rgba(0,0,0,0.2);
      }

      .grid-cell {
          border: 1px solid #444;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 1.2em;
      }

      .grid-cell.rune {
          color: #ff00ff; /* Color de la runa de ejemplo */
          font-weight: bold;
      }

      .grid-cell.enemy {
          color: #ff4d4d; /* Color del enemigo de ejemplo */
      }
      .game-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6); /* Color negro semitransparente */
        backdrop-filter: blur(
          3px
        ); /* Efecto de desenfoque para el fondo (opcional, muy vistoso) */
        z-index: 290; /* Clave: Por encima del juego (z-index < 290) pero por debajo de la batalla/modales (z-index >= 300) */
        opacity: 0;
        pointer-events: none; /* No debe ser clickeable cuando está invisible */
        transition: opacity 0.4s ease-in-out;
      }

      .game-overlay.active {
        opacity: 1;
        pointer-events: auto; /* Se vuelve "sólido" para evitar clics en el juego de fondo */
      }
      /* === FIN DE ESTILOS PARA EL VELO === */

      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 500; /* Más alto que la batalla */
        padding: 10px;
      }

      .modal-content {
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        border: 3px solid #d4af37;
        border-radius: 15px;
        padding: 20px;
        max-width: 95%;
        width: 500px;
        text-align: center;
        max-height: 90vh;
        overflow-y: auto;
      }
      .inventory-modal-item .item-description {
          font-size: 0.9em;
          opacity: 0.8;
          margin-top: 4px;
          margin-bottom: 8px; /* <-- Añade este margen inferior */
      }

      .cultivation-option-btn {
        display: block;
        width: 100%;
        padding: 10px;
        margin-bottom: 8px;
        text-align: left;
      }

      /* Controles táctiles del mapa (Joystick, Botón Acción) */
      #joystick-container {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
        z-index: 200;
        /* display: none;  SE MUESTRA/OCULTA CON EL OVERLAY PADRE */
        opacity: 0.7;
      }
      #joystick-pad {
        z-index: 1;
        width: 100%;
        height: 100%;
        background-color: rgba(128, 128, 128, 0.5);
        border-radius: 50%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid rgba(255, 255, 255, 0.7);
      }
      #joystick-handle {
        width: 50px;
        height: 50px;
        background-color: rgba(80, 80, 80, 0.8);
        border-radius: 50%;
        position: absolute;
        border: 2px solid rgba(200, 200, 200, 0.9);
      }
      #action-button-touch {
        position: fixed;
        bottom: 60px;
        right: 60px;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        z-index: 200;
        /* display: none; SE MUESTRA/OCULTA CON EL OVERLAY PADRE */
        font-size: 0.8em;
      }
      #touch-controls-overlay {
          /* Este contenedor no tiene tamaño, solo sirve para agrupar 
            y asegurar que sus hijos 'fixed' se muestren correctamente */
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none; /* Clave: Permite que los clics "atraviesen" el overlay y lleguen al mapa */
          z-index: 199; /* Justo debajo de los controles individuales */
          display: none; /* Por defecto, oculto. JS lo controla. */
      }

      /* Cualquier elemento clickeable DENTRO del overlay debe reactivar los pointer-events */
      #touch-controls-overlay > * {
          pointer-events: auto;
      }
      /* --- Estilos para Modal de Inventario --- */
      .inventory-modal-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 15px;
        padding: 10px;
        margin-bottom: 8px;
        border: 1px solid rgba(212, 175, 55, 0.2);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.15);
      }

      .inventory-modal-item .item-details {
        flex-grow: 1;
      }

      .inventory-modal-item .item-name {
        font-weight: bold;
        color: #f4d03f;
        font-size: 1.1em;
      }

      .inventory-modal-item .item-description {
        font-size: 0.9em;
        opacity: 0.8;
        margin-top: 4px;
      }

      .inventory-modal-item .item-actions {
        display: flex;
        gap: 8px;
        flex-shrink: 0;
      }

      .inventory-modal-item .item-actions button {
        padding: 6px 10px;
        font-size: 0.8em;
      }
      .assignable-item {
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .assignable-item:hover {
        background-color: rgba(212, 175, 55, 0.1);
        border-color: rgba(212, 175, 55, 0.4);
      }
      /* --- Fin Estilos Modal Inventario --- */

      /* === ESTILOS PARA NOTIFICACIÓN DE ZONA === */
      .zone-notification {
        position: absolute;
        top: 20%; /* Posición vertical */
        left: 50%;
        transform: translateX(-50%); /* Centrado horizontal */
        background-color: rgba(10, 10, 10, 0.8);
        color: #f4d03f;
        font-size: 1.5em; /* Tamaño de fuente grande */
        font-weight: bold;
        padding: 15px 30px;
        border-radius: 10px;
        border: 2px solid #d4af37;
        z-index: 200; /* Por encima del mapa pero debajo de otros modales */
        pointer-events: none; /* Para que no intercepte clics */
        opacity: 0; /* Empieza invisible */
        transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out;
        text-shadow: 1px 1px 3px black;
        white-space: nowrap; /* Evita que el texto se rompa */
      }

      .zone-notification.show {
        opacity: 1;
        top: 25%; /* Se mueve un poco hacia abajo al aparecer */
      }

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
      @media (max-width: 768px),
        (max-height: 500px),
        (hover: none) and (pointer: coarse) {
        .game-container {
          padding-top: 0; /* En móvil, no hay espacio arriba, el menú es un overlay */
          /* --- CORRECCIÓN CLAVE --- */
          /* Hacemos que el contenedor del juego pueda estar detrás de la barra */
        
        }

        .map-container {
          max-height: 100dvh; 
        }

        #mobileMenuBtn,
        #toggleMapControlsBtn {
          display: block;
        }

        .top-nav-bar {
        flex-direction: column;
        justify-content: flex-start;
        align-items: stretch;
        height: auto; /* <-- Correcto */
        padding-top: 60px; /* <-- Correcto */
        z-index: 200;
        transform: translateY(-100%);
        transition: transform 0.4s ease-in-out;

        /* 1. Establecemos una altura máxima. No puede ser más alto que la pantalla. */
        max-height: 100dvh; 
        
        /* 2. LA CLAVE: Si el contenido se desborda, creamos un scroll vertical. */
        overflow-y: auto; 

        /* 3. (Opcional pero recomendado) Mejoramos la estética de la barra de scroll en navegadores Webkit (Chrome, Safari) */
        scrollbar-width: thin;
        scrollbar-color: #d4af37 rgba(0, 0, 0, 0.3);
        }
        /* Para navegadores Webkit (Chrome, Safari, Edge) */
        .top-nav-bar::-webkit-scrollbar {
            width: 8px;
        }
        .top-nav-bar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        .top-nav-bar::-webkit-scrollbar-thumb {
            background-color: #b8941f;
            border-radius: 4px;
            border: 2px solid transparent;
            background-clip: content-box;
        }
        .top-nav-bar.open {
          transform: translateY(0);
        }

        .top-nav-bar .nav-button {
          justify-content: flex-start;
          padding: 15px 20px;
          max-width: 100%;
        }

        .stats-panel .desktop-only {
          display: none;
        }

        .stats-panel {
          /* Ajustes existentes para móvil */
          width: 180px; /* Un poco más ancho para la nueva info */
          padding: 8px;
          font-size: 0.8em; /* Un poco más grande para legibilidad */
          top: 10px;
          left: 10px;
          backdrop-filter: blur(2px);
        }

        #toggleMapControlsBtn {
          top: 60px; /* Vuelve a su posición original en móvil */
        }

        .character-sprite,
        .enemy-sprite {
          width: 60px;
          height: 60px;
          font-size: 55px;
        }
      }

      @media (max-width: 480px) {
        .nav-text {
          display: none;
        }
        .nav-icon {
          font-size: 1.8rem;
          margin-bottom: 0;
        }
        .nav-button {
          padding: 10px 5px;
        }

        .stats-panel {
          width: 160px;
          font-size: 0.8em;
        }
        .stats-panel h3 {
          font-size: 1.1em;
        }

        .character-sprite,
        .enemy-sprite {
          width: 50px;
          height: 50px;
          font-size: 50px;
        }
        .battle-actions button {
          padding: 6px 8px;
          font-size: 0.75em;
        }
      }
      @media (max-height: 500px) and (min-width: 600px), (orientation: landscape) {

        /* --- Acciones de Batalla más Compactas (LÓGICA MEJORADA) --- */
        .battle-actions {
            padding: 5px; 
        }

        .action-buttons {
            /* Clave: Forzamos la cuadrícula a tener más columnas para que se expanda horizontalmente */
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 5px; 
            margin-bottom: 5px;
            /* Opcional: Para centrar los botones si no llenan todo el espacio */
            justify-content: center; 
        }

        .battle-actions button {
            /* Hacemos los botones más anchos pero menos altos */
            padding: 8px 12px;     /* Más padding horizontal, menos vertical */
            min-height: 36px;      /* Establecemos una altura mínima/máxima para controlar su altura */
            max-height: 38px;
            font-size: 0.70rem;    /* Un tamaño de fuente legible pero compacto */
            line-height: 1.2;      /* Ayuda a centrar el texto verticalmente en la nueva altura */
            
            /* Aseguramos que el contenido dentro del botón se centre */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        /* --- Ajustes al resto de la UI en modo horizontal --- */
        .stats-panel {
            top: 60px;
            left: 10px;
            padding: 6px;
            font-size: 0.75rem;
        }

        .stats-panel h3 {
            font-size: 1rem;
            margin-bottom: 2px;
        }

        .quick-slot-bar {
            bottom: 5px;
            padding: 6px;
            gap: 6px;
        }
        .quick-slot {
            width: 48px;
            height: 48px;
            font-size: 22px;
        }
        .slot-item-count {
            font-size: 12px;
        }
        .slot-key-hint {
            font-size: 10px;
        }
        
       

        /* 2. Ajustamos los sprites y nombres para que ocupen el espacio liberado */
        .character,
        .enemy {
            padding: 10px 0; /* Reducimos drásticamente el padding vertical */
            justify-content: center; /* Centramos el contenido restante (sprite y nombre) */
        }

        .character-sprite,
        .enemy-sprite {
            margin-bottom: 8px; /* Un pequeño margen entre el sprite y el nombre */
        }

        /* 3. Aseguramos que la información sobre el sprite del enemigo sea visible */
        #enemyInBattleInfoContainer {
            /* Es posible que necesitemos ajustar su posición si se descuadra */
            transform: translate(-50%, 5px); /* Empuja la barra un poco hacia abajo para que no se pegue al borde */
        }
        

        }
      /****************************************
       * NUEVO: 7. ESTILOS DE LA TIENDA
       ****************************************/

      #shopModal .modal-content {
        max-width: 90%;
        width: 1000px; /* Un ancho mayor para la tienda */
        height: 90vh;
        display: flex;
        flex-direction: column;
      }

      .shop-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        flex-shrink: 0;
      }

      .shop-stats {
        font-size: 1.1em;
        color: #f4d03f;
      }

      .shop-container {
        display: flex;
        gap: 20px;
        flex-grow: 1;
        overflow: hidden; /* Evita que el contenedor principal scrollee */
      }

      .shop-filters {
        flex: 0 0 220px; /* No crece, no se encoge, base de 220px */
        padding-right: 15px;
        border-right: 1px solid rgba(212, 175, 55, 0.2);
        overflow-y: auto;
      }

      .shop-products {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .products-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 15px;
        overflow-y: auto; /* El scroll ahora está aquí */
        padding: 5px;
        flex-grow: 1;
      }

      .section-title {
        color: #f4d03f;
        margin-bottom: 10px;
        border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        padding-bottom: 5px;
      }

      .search-box {
        width: 100%;
        padding: 8px;
        background-color: rgba(0, 0, 0, 0.3);
        border: 1px solid #555;
        border-radius: 5px;
        color: #f4e4bc;
        margin-bottom: 15px;
      }

      .filter-group {
        margin-bottom: 20px;
      }
      .filter-title {
        font-weight: bold;
        margin-bottom: 8px;
        font-size: 0.9em;
        opacity: 0.8;
      }

      .category-list {
        list-style: none;
      }
      .category-item {
        padding: 8px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .category-item:hover {
        background-color: rgba(212, 175, 55, 0.1);
      }
      .category-item.active {
        background-color: rgba(212, 175, 55, 0.2);
        color: #f4d03f;
        font-weight: bold;
      }

      .product-card {
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(212, 175, 55, 0.3);
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
      }

      .product-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 10px;
      }

      .product-name {
        font-weight: bold;
        color: #f4d03f;
      }
      .product-type {
        font-size: 0.8em;
        opacity: 0.7;
      }
      .product-price {
        font-weight: bold;
        white-space: nowrap;
      }

      .product-description {
        font-size: 0.9em;
        margin: 10px 0;
        opacity: 0.9;
        flex-grow: 1; /* Hace que la descripción empuje el botón hacia abajo */
      }

      .product-actions {
        margin-top: auto; /* Empuja el botón al final de la tarjeta */
      }
      .buy-btn {
        width: 100%;
      }

      /****************************************
       * 6. MEDIA QUERIES (RESPONSIVIDAD)
       ****************************************/
      @media (max-width: 768px) {
        /* ... (tus otras media queries) ... */

        /* AÑADE ESTAS REGLAS DENTRO DE LA MEDIA QUERY DE 768px */
        #shopModal .modal-content {
          width: 95%; /* Ocupa más ancho en móvil */
          /* Quitamos la altura fija para que se adapte al contenido en móvil */
          height: auto;
          max-height: 85vh; /* Ponemos una altura máxima para que no ocupe toda la pantalla */
        }

        .shop-container {
          flex-direction: column; /* Apila los filtros encima de los productos */
          /* Hacemos que el scroll sea manejado por el .modal-content general en móvil */
          overflow: visible;
        }

        .shop-filters {
          flex: 0 0 auto; /* No debe crecer, su tamaño será determinado por su contenido */
          border-right: none;
          border-bottom: 1px solid rgba(212, 175, 55, 0.2);
          padding-bottom: 15px;
          margin-bottom: 15px;
          overflow-y: visible; /* Correcto, no queremos scroll aquí */
        }

        .shop-products {
          /* Quitamos el overflow: hidden que podría estar ocultando el contenido */
          overflow: visible;
        }

        .products-grid {
          grid-template-columns: 1fr; /* Una sola columna para los productos en móvil */
          overflow-y: visible; /* El scroll lo maneja el padre */
          /* Quitamos el flex-grow para evitar conflictos */
        }
      }
      /****************************************
       * NUEVO: 8. ESTILOS DE COMBATE FLOTANTES
       ****************************************/
      .damage-popup {
        position: absolute;
        z-index: 310; /* Encima de todo en la batalla */
        font-family: "Courier New", monospace;
        font-weight: bold;
        pointer-events: none; /* Para que no intercepte clics */
        text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.7);
        animation: floatUpAndFade 1.5s ease-out forwards;
      }

      /* Estilos específicos */
      .damage-popup.damage {
        color: #ff4d4d;
        font-size: 1.2em;
      }
      .damage-popup.heal {
        color: #66ff66;
        font-size: 1.8em;
      }
      .damage-popup.mana {
        color: #87cefa;
        font-size: 1.5em;
      }
      .damage-popup.ability {
        color: #f4d03f;
        font-size: 1.2em;
      }
      .damage-popup.debuff {
        color: #dda0dd;
        font-size: 1.2em;
      }

      @keyframes floatUpAndFade {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        100% {
          transform: translateY(-80px) scale(1.2);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <!-- ======================================================================= -->
    <!-- 1. CAPAS GLOBALES Y ELEMENTOS FIJOS (Velo, Stats, Botones) -->
    <!-- Estos elementos están en la capa superior y no se mueven con el mapa. -->
    <!-- ======================================================================= -->
    <div id="game-overlay" class="game-overlay"></div>
    <button id="mobileMenuBtn">☰</button>

    <div class="stats-panel">
      <p class="stat-line stat-coords">
        Coords: <span id="playerCoords">X: 0, Y: 0</span>
      </p>
      <p class="stat-line stat-zone">
        Zona: <span id="playerZone">Desconocida</span>
      </p>
      <p class="stat-line stat-level desktop-only">
        Nivel: <span id="playerLevel">1</span>
      </p>
      <p class="stat-line stat-realm desktop-only">
        Reino: <span id="playerRealm">Mortal</span>
      </p>
      <div class="stat-block desktop-only">
        <span>Vida: <span id="hpText">100/100</span></span>
        <div class="stat-bar">
          <div class="stat-fill hp-fill" id="hpBar" style="width: 100%"></div>
        </div>
      </div>
      <div class="stat-block desktop-only">
        <span>Maná: <span id="manaText">50/50</span></span>
        <div class="stat-bar">
          <div
            class="stat-fill mana-fill"
            id="manaBar"
            style="width: 100%"
          ></div>
        </div>
      </div>
      <div class="stat-block">
        <span>Experiencia: <span id="expText">0/100</span></span>
        <div class="stat-bar">
          <div class="stat-fill exp-fill" id="expBar" style="width: 0%"></div>
        </div>
      </div>
      <p class="stat-line stat-stones">
        P. Espirituales: <span id="playerStonesHud">0</span>
      </p>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display: none" />
   

    <!-- ======================================================================= -->
    <!-- 2. CONTENEDOR PRINCIPAL DEL JUEGO (El mundo que se mueve) -->
    <!-- Solo contiene el mapa, el jugador y los elementos que están DENTRO del mundo del juego. -->
    <!-- ======================================================================= -->
    <div class="game-container">
      <div class="map-container">
        <div class="map" id="gameMap"></div>
        
        <div class="grid-overlay"></div>
        
        <div class="tile player" id="player">🧘</div>
        <div id="zone-notification" class="zone-notification"></div>

        <div id="playerOnMapBarsContainer">
          <div class="on-map-stat-bar">
            <div class="on-map-stat-fill" id="playerOnMapHpFill"></div>
          </div>
          <div class="on-map-stat-bar">
            <div class="on-map-stat-fill" id="playerOnMapManaFill"></div>
          </div>
        </div>

        

        <!-- El sidebar es parte del layout del juego, por lo que se queda aquí. -->
        <div class="sidebar">
          <div class="inventory-panel">
            <h3>Inventario</h3>
            <div class="inventory-grid" id="inventory"></div>
          </div>
          <div class="controls-panel">
            <h3>Controles</h3>
            <p><strong>Escritorio:</strong></p>
            <p>WASD/Flechas: Moverse</p>
            <p>ESPACIO: Interactuar</p>
            <p style="margin-top: 5px"><strong>Móvil:</strong></p>
            <p>Joystick: Moverse</p>
            <p>Botón Acción: Interactuar</p>
            <p>
              "Ocultar/Mostrar Controles": Alterna visibilidad de controles
              táctiles.
            </p>
            <button id="cultivateButton" onclick="toggleCultivation()">
              🧘‍♀️ Cultivar
            </button>
            <button onclick="showTechniquePanel()">📖 Técnicas</button>
            <button onclick="saveGame()">💾 Guardar Partida</button>
            <button onclick="triggerFileUpload()">📁 Cargar Partida</button>
            <button onclick="showHelp()">❓ Ayuda</button>
          </div>
          <div class="secta-panel">
            <h3><span id="sectaNombreDisplay">Secta</span></h3>
            <p>Rango: <span id="playerSectRank">Discípulo Externo</span></p>
            <p>Puntos de Contribución: <span id="playerPCS">0</span> PCS</p>
            <h4>Misiones Activas:</h4>
            <div
              id="activeMissionsList"
              style="font-size: 0.9em; max-height: 150px; overflow-y: auto"
            >
              <p>Ninguna misión activa.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- <<--- FIN DEL CONTENEDOR PRINCIPAL DEL JUEGO -->
      
    <!-- === INICIO DE LA NUEVA SECCIÓN DE CONTROLES TÁCTILES === -->
    <!-- Este es el contenedor correcto que el JavaScript mostrará u ocultará -->
    <div id="touch-controls-overlay">
      <div id="joystick-container">
          <div id="joystick-pad">
              <div id="joystick-handle"></div>
          </div>
      </div>
      <button id="action-button-touch">Acción</button>
    </div>
    <button id="toggleMapControlsBtn">Ocultar Controles</button>
    <button id="toggleGridBtn" style="position: fixed; top: 100px; right: 10px; z-index: 200; padding: 8px 12px; font-size: 14px;">Mostrar Rejilla</button>

    <!-- ======================================================================= -->
    <!-- 3. TODAS LAS PANTALLAS Y MODALES SUPERPUESTOS -->
    <!-- Al estar fuera del game-container, no se verán borrosos en móvil. -->
    <!-- ======================================================================= -->

    <!-- Pantalla de Combate -->
    <div class="battle-screen" id="battleScreen">
      <div class="battle-area">
        <div class="character">
          <div id="playerInBattleSpriteBarsContainer">
            <div class="in-battle-sprite-stat-bar">
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteHpFill"
              ></div>
            </div>
            <div class="in-battle-sprite-stat-bar">
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteManaFill"
              ></div>
            </div>
          </div>
          <div class="character-sprite">🧘</div>
          <h3 id="playerBattleName">Cultivador</h3>
          <div>Vida: <span id="playerBattleHp">100/100</span></div>
          <div class="stat-bar"style="display: none;">
            <div
              class="stat-fill hp-fill"
              id="playerBattleHpBar"
              style="display:none"
            ></div>
          </div>
        </div>
        <div class="enemy">
          <div id="enemyInBattleInfoContainer">
            <div class="enemy-battle-name-level" id="enemyBattleNameLevel">
              Enemigo (Nv. X)
            </div>
            <div class="in-battle-sprite-stat-bar enemy-hp-bar">
              <div
                class="in-battle-sprite-stat-fill"
                id="enemyInBattleSpriteHpFill"
              ></div>
            </div>
          </div>
          <div class="enemy-sprite" id="enemySprite"></div>
          <h3 id="enemyName">Demonio</h3>
          <div>Vida: <span id="enemyHp">80/80</span></div>
          <div class="stat-bar"style="display: none;">
            <div
              class="stat-fill hp-fill"
              id="enemyHpBar"
              
            ></div>
          </div>
        </div>
      </div>
      <div class="battle-actions">
        <div class="action-buttons" id="battleActionButtons"></div>
        <div class="log" id="battleLog"></div>
      </div>
    </div>

    <!-- Modal para Cultivo Activo -->
    <div class="modal" id="activeCultivationModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="activeCultivationTitle">Cultivando...</h3>
        <p id="activeCultivationDescription">Concentrando tu energía...</p>
        <div id="activeCultivationProgressUI" style="display: none">
          <p>
            Progreso:
            <span id="activeCultivationTargetName">Técnica X</span> (Nv.
            <span id="activeCultivationTargetLevel">Y</span>)
          </p>
          <div class="stat-bar" style="background: #444; margin: 10px 0">
            <div
              class="stat-fill"
              id="activeCultivationProgressBar"
              style="
                width: 0%;
                background: linear-gradient(90deg, #ffd700, #ffae42);
              "
            ></div>
          </div>
          <p
            id="activeCultivationProgressText"
            style="text-align: center; font-size: 0.9em"
          >
            0s / 0s
          </p>
        </div>
        <div
          id="recoveryCultivationProgressUI"
          style="display: none; margin-top: 15px"
        >
          <p>Absorbiendo Qi del entorno...</p>
          <div style="margin-top: 15px; font-size: 0.9em">
            <div>Vida: <span id="modalHpText">100/100</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill hp-fill"
                id="modalHpBar"
                style="width: 100%"
              ></div>
            </div>
            <div>Maná: <span id="modalManaText">50/50</span></div>
            <div class="stat-bar">
              <div
                class="stat-fill mana-fill"
                id="modalManaBar"
                style="width: 100%"
              ></div>
            </div>
          </div>
        </div>
        <div id="cultivationBoostSection" style="display: none; margin-top: 15px; padding-top: 10px; border-top: 1px solid #555;">
          <p>Piedras Espirituales: <span id="cultivationModalPlayerStones">0</span></p>
          
          <!-- Contenedor para los botones de aceleración -->
          <div style="display: flex; gap: 10px; margin-top: 8px;">
              
              <!-- Botón para usar 1 piedra -->
              <button id="boostCultivationButton1" onclick="boostCultivationProgress(1)" style="flex-grow: 1;">
                  ⚡ Usar 1 PS (+10s)
              </button>
              
              <!-- NUEVO Botón para usar 10 piedras -->
              <button id="boostCultivationButton10" onclick="boostCultivationProgress(10)" style="flex-grow: 1; background: linear-gradient(135deg, #e8c34f, #c9a82e);">
                  ⚡⚡ Usar 10 PS (+100s)
              </button>
              <button id="boostCultivationButtonAll" style="flex-grow: 1; background: linear-gradient(135deg, #ff5733, #c70039); color: white;">
                ⚡⚡⚡ Usar Todas
            </button>
      
          </div>
      </div>
        <button onclick="stopCultivation(true)" style="margin-top: 20px">
          🚫 Detener Cultivo
        </button>
      </div>
    </div>

    <!-- Modal para tienda -->
    <div class="modal" id="shopModal">
      <div class="modal-content">
        <div class="shop-header">
          <h2 id="shopName">Pabellón de Tesoros del Dragón Oculto</h2>
          <div class="shop-stats">
            <span id="playerSpiritualStones">Piedras Espirituales: 0</span>
          </div>
        </div>
        <div class="shop-container">
          <div class="shop-filters">
            <h3 class="section-title">Filtros</h3>
            <input
              type="text"
              class="search-box"
              id="shopSearch"
              placeholder="Buscar..."
            />
            <div class="filter-group">
              <div class="filter-title">Categorías</div>
              <ul class="category-list" id="shopCategories">
                <li class="category-item active" data-category="all">Todas</li>
                <li class="category-item" data-category="combat">T. Combate</li>
                <li class="category-item" data-category="cultivation">
                  T. Cultivo
                </li>
                <li class="category-item" data-category="weapon">Armas</li>
                <li class="category-item" data-category="armor">Armaduras</li>
                <li class="category-item" data-category="consumable">
                  Consumibles
                </li>
                <li class="category-item" data-category="material">
                  Materiales
                </li>
                <li class="category-item" data-category="scroll">Rollos</li>
              </ul>
            </div>
            <div class="filter-group">
              <div class="filter-title">Rango de Precio</div>
              <div>
                <input
                  type="range"
                  id="priceRange"
                  min="0"
                  max="10000"
                  value="10000"
                  style="width: 100%"
                />
              </div>
              <div
                style="
                  display: flex;
                  justify-content: space-between;
                  font-size: 0.8em;
                "
              >
                <span>0 PS</span><span id="priceRangeValue">1000 PS</span>
              </div>
            </div>
          </div>
          <div class="shop-products">
            <h3 class="section-title">Técnicas y Objetos</h3>
            <div class="products-grid" id="shopProducts"></div>
            <div class="pagination" id="shopPagination"></div>
          </div>
        </div>
        <div>
          <button onclick="closeShopModal()" style="margin-top: 20px">
            Salir de la Tienda
          </button>
        </div>
      </div>
    </div>

    <!-- Modal para Secta -->
    <div class="modal" id="sectHallModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 id="sectHallModalTitle">Salón de la Secta del Viento Azure</h3>
        <div id="sectHallOptions">
          <p>
            Bienvenido, Discípulo <span id="sectHallPlayerRank">Externo</span>.
          </p>
          <p>Puntos de Contribución: <span id="sectHallPlayerPCS">0</span></p>
          <hr />
          <h4>Tablón de Misiones</h4>
          <div
            id="sectHallAvailableMissions"
            style="
              max-height: 150px;
              overflow-y: auto;
              margin-bottom: 10px;
              border: 1px solid #444;
              padding: 5px;
            "
          >
            <p>Habla con el Guía Lin para nuevas asignaciones.</p>
          </div>
          <h4>Contribuciones a la Secta</h4>
          <div id="sectHallContributions" style="margin-bottom: 10px">
            <p>Visita al Administrador Yao para entregar recursos.</p>
          </div>
          <h4>Desafíos de Rango</h4>
          <div id="sectHallRankChallenges" style="margin-bottom: 10px">
            <p id="sectHallChallengeStatus">
              Consulta con el Maestro de la Arena.
            </p>
          </div>
          <h4>Tienda de la Secta</h4>
          <button onclick="openSectShop()">Visitar Depósito de la Secta</button>
          <hr />
        </div>
        <button
          onclick="closeSectHallModal()"
          style="display: block; margin: 20px auto 0"
        >
          Salir del Salón
        </button>
      </div>
    </div>

    <!-- Modal genérico para confirmaciones (Sí/No) -->
    <div class="modal" id="confirmationModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="confirmationModalTitle">Confirmar Acción</h3>
        <p id="confirmationModalText" style="margin: 15px 0; line-height: 1.5">
          ¿Estás seguro?
        </p>
        <div
          style="display: flex; justify-content: space-around; margin-top: 20px"
        >
          <button id="confirmBtn" style="background-color: #4caf50">
            Confirmar
          </button>
          <button
            id="cancelBtn"
            onclick="closeConfirmationModal()"
            style="background-color: #f44336"
          >
            Cancelar
          </button>
        </div>
      </div>
    </div>

    <!-- Modal para Misiones -->
    <div class="modal" id="missionsModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">Diario de Misiones</h3>
        <div
          id="missionsContainer"
          style="
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
          "
        ></div>
        <button
          onclick="closeMissionsModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Modal para Revisión de Batalla -->
    <div class="modal" id="battleReviewModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">Resumen del Combate</h3>
        <div
          id="battleReviewLog"
          style="
            margin-top: 15px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.5;
          "
        ></div>
        <button
          onclick="closeBattleReviewModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Modal para Selección de Cultivo -->
    <div class="modal" id="cultivationChoiceModal">
      <div class="modal-content" style="max-width: 500px; text-align: left">
        <h3>¿Qué deseas cultivar?</h3>
        <div id="cultivationOptionsContainer">
          <button
            class="cultivation-option-btn"
            onclick="startCultivationMode('recovery')"
          >
            🧘 Meditación Restauradora
          </button>
          <hr />
          <h4>Cultivar Técnica:</h4>
          <div
            id="cultivableTechniquesList"
            style="max-height: 200px; overflow-y: auto"
          ></div>
        </div>
        <button
          onclick="closeCultivationChoiceModal()"
          style="margin-top: 20px"
        >
          Cancelar
        </button>
      </div>
    </div>

    <!-- Modal genérico para interacciones y notificaciones -->
    <div class="modal" id="interactionModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="modalTitle">Título del Modal</h3>
        <p
          id="modalText"
          style="margin-top: 15px; margin-bottom: 20px; line-height: 1.5"
        >
          Texto.
        </p>
        <button onclick="closeModal()" class="close-modal-btn">Cerrar</button>
      </div>
    </div>
    <!-- Modal para Gestión de Técnicas -->
    <div class="modal" id="manageTechniquesModal">
      <div class="modal-content" style="max-width: 800px; text-align: left;">
          <h3 style="text-align: center;">Gestionar Técnicas de Combate</h3>
          <div id="technique-management-container" style="display: flex; gap: 20px; margin-top: 20px;">
              
              <!-- Columna de Técnicas Equipadas -->
              <div id="equipped-techniques-panel" style="flex: 1; border-right: 1px solid #555; padding-right: 20px;">
                  <h4>Equipadas (3 máx.)</h4>
                  <div id="equipped-techniques-list">
                      <!-- Los slots equipados se generarán aquí -->
                  </div>
              </div>

              <!-- Columna de Técnicas Aprendidas (disponibles para equipar) -->
              <div id="available-techniques-panel" style="flex: 2;">
                  <h4>Técnicas Aprendidas</h4>
                  <div id="available-techniques-list" style="max-height: 400px; overflow-y: auto;">
                      <!-- La lista de técnicas disponibles se generará aquí -->
                  </div>
              </div>

          </div>
          <button onclick="closeManageTechniquesModal()" style="display: block; margin: 20px auto 0;">Cerrar</button>
      </div>
  </div>
  <!-- Modal para el Tutorial de Formaciones -->
  <div class="modal" id="formationTutorialModal">
    <div class="modal-content" style="max-width: 550px; text-align: left;">
        <h3 id="formationTutorialTitle" style="text-align: center;">El Arte de las Matrices Rúnicas</h3>
        <p id="formationTutorialText" style="margin-top: 15px; line-height: 1.6;">
            Este antiguo mural detalla el arte perdido de las formaciones de combate. Al inscribir runas en un patrón preciso alrededor de un enemigo, puedes canalizar el Qi del entorno para crear efectos devastadores antes de que comience la batalla.
        </p>
        <hr style="margin: 15px 0;">
        
        <h4>Cómo Inscribir una Formación:</h4>
        <ol style="margin-left: 20px;">
            <li>Aprende y equipa la técnica <strong>"Inscripción Rúnica"</strong>.</li>
            <li>Asegúrate de tener <strong>"Tinta Rúnica"</strong> en tu inventario.</li>
            <li>Párate en una casilla <strong>adyacente</strong> a un enemigo.</li>
            <li>Usa la habilidad "Inscripción Rúnica" para trazar una runa en tu posición actual.</li>
            <li>Repite el proceso en diferentes casillas para formar un patrón.</li>
        </ol>

        <h4 style="margin-top: 20px;">Ejemplo: El Hexagrama Devastador</h4>
        <p style="font-size: 0.9em; opacity: 0.8;">Este patrón debilita las defensas del objetivo.</p>
        
        <!-- Contenedor de la cuadrícula del patrón -->
        <div id="formation-pattern-grid" style="margin-top: 10px;">
            <!-- La cuadrícula se generará con JavaScript -->
        </div>

        <button onclick="closeFormationTutorial()" style="display: block; margin: 20px auto 0;">Entendido</button>
    </div>
  </div>
    <!-- Modal para Técnicas -->
    <div class="modal" id="techniqueModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">Técnicas Aprendidas</h3>
        <div
          id="learnedTechniquesContainer"
          style="
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
          "
        ></div>
        <button onclick="openManageTechniquesModal()" style="display: block; margin: 20px auto 10px; background-color: #3a7c6a;">
          ⚔️ Gestionar Técnicas de Combate
      </button>
        <button
          onclick="closeTechniqueModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>

    <!-- Modal para Recompensa de Ascenso de Rango -->
    <div class="modal" id="rankUpRewardModal">
      <div class="modal-content" style="max-width: 550px; text-align: left">
        <h3 id="rankUpRewardTitle">Recompensa por Ascenso</h3>
        <p>
          Como reconocimiento a tu progreso, la secta te otorga un manual de
          técnica. Elige sabiamente, pues este conocimiento definirá tu camino.
        </p>
        <div id="rankUpRewardOptionsContainer" style="margin-top: 15px"></div>
        <button onclick="closeRankUpRewardModal()" style="margin-top: 20px">
          Decidiré más tarde
        </button>
      </div>
    </div>

    <!-- Modal para Teletransporte -->
    <div class="modal" id="teleportModal">
      <div class="modal-content" style="max-width: 500px; text-align: left">
        <h3 id="teleportModalTitle">Red de Matrices Espirituales</h3>
        <p>Selecciona un destino sintonizado:</p>
        <div id="teleportOptionsContainer" style="margin-top: 15px"></div>
        <button onclick="closeTeleportModal()" style="margin-top: 20px">
          Cancelar
        </button>
      </div>
    </div>

    <!-- ======================================================================= -->
    <!-- 4. BARRAS DE NAVEGACIÓN SUPERPUESTAS -->
    <!-- También van fuera para garantizar su posición fija y renderizado nítido. -->
    <!-- ======================================================================= -->

    <nav class="top-nav-bar" id="topNavBar">
      <button id="navBtnCharacter" class="nav-button">
        <div class="nav-icon">👤</div>
        <span class="nav-text">Personaje</span>
      </button>
      <button id="navBtnMissions" class="nav-button">
        <div class="nav-icon">📖</div>
        <span class="nav-text">Misiones</span>
      </button>
      <button id="navBtnInventory" class="nav-button">
        <div class="nav-icon">🎒</div>
        <span class="nav-text">Inventario</span>
      </button>
      <button id="navBtnCultivate" class="nav-button">
        <div class="nav-icon">🧘</div>
        <span class="nav-text">Cultivar</span>
      </button>
      <button id="navBtnTechniques" class="nav-button">
        <div class="nav-icon">📜</div>
        <span class="nav-text">Técnicas</span>
      </button>
      <button id="navBtnMenu" class="nav-button">
        <div class="nav-icon">⚙️</div>
        <span class="nav-text">Menú</span>
      </button>
    </nav>
    <!-- ================================================================= -->
    <script>
      let lastSuccessfulMoveTime = 0;
      const PLAYER_MOVE_COOLDOWN = 250; // <-- ¡ESTE ES EL NÚMERO QUE AJUSTARÁS! (en milisegundos)
      let playerMovementKeysDown = {
        // Para rastrear qué teclas de movimiento están presionadas
        up: false,
        down: false,
        left: false,
        right: false,
      };
      let isGridVisible = false;

      const topNavBar = document.getElementById("topNavBar");
      const navBtnInventory = document.getElementById("navBtnInventory");
      console.log("Botón de Inventario (navBtnInventory):", navBtnInventory);
      const navBtnCharacter = document.getElementById("navBtnCharacter");
      const navBtnCultivate = document.getElementById("navBtnCultivate");
      const navBtnTechniques = document.getElementById("navBtnTechniques");
      const navBtnMenu = document.getElementById("navBtnMenu");
      let movePlayerCallCount = 0;
      // --- ESTADO DEL JUEGO ---
      let gameState = {
        /* ... (tu gameState existente sin cambios) ... */
      };
      // Estado del juego y datos principales
      gameState = {
        player: {
          isChannelingRune: false,     // true si está en modo seguro para plantar runas
          channelingTimeout: null,
          discoveredFormationPatterns: {},
          x: 11,
          y: 15,
          level: 1,
          baseMaxHp: 100,
          baseMaxMana: 50,
          baseAttack: 15,
          baseDefense: 5,
          hp: 100,
          maxHp: 100,
          mana: 50,
          maxMana: 50,
          attack: 15,
          defense: 5,
          exp: 0,
          expToNext: 100,
          realm: "Mortal",
          quickSlots: [null, null, null, null, null], // 5 slots, inicialmente vacíos
          equippedTechniques: [null, null, null],
          isCultivating: false,
          cultivationMode: {
            type: null,
            targetId: null,
            startTime: 0,
          },
          cultivationStartTime: 0,
          qiPerSecondBase: 1,
          expPerSecondBase: 0.5,
          hpPerSecondBase: 1,
          learnedTechniques: {},
          activeRefiningTechniqueId: null,
          canUseQiConversion: false,
          isQiConversionActive: false,
          worldState: {
            defeatedBosses: {},
            currentBossToSpawn: "boss_dem",
            defeatedFixedEntities: {},
            storyFlags: {
              metAncianaSu: false,          // Hito 1: Conocer a la archivista.
              knowsAboutCalamity: false,    // Hito 2: Aprender sobre el desastre pasado.
              knowsAboutSoberano: false,    // Hito 3: El Maestro revela el secreto del Soberano.
              knowsFullTruth: false,        // Hito 4: El Santuario revela la verdad completa.
          },
          subplotFlags: {
                rivalryProgress: 0,      // 0: No iniciado, 1: Primer encuentro, 2: Derrotado una vez, etc.
                alchemistTrust: 0,       // Nivel de confianza con el Viejo Mo.
                renegadeContact: 0,      // Progreso en la trama de los renegados.
                foundAlchemistNote: false, // Para iniciar la misión del alquimista.
                fengQuestProgress: 0, // 0: No conocido, 1: Encontrado, 2: Prueba completada, 3: Lección completada, 4: Tesis completada
                hasPlacedSondeoRune: false // Para la última misión
            },
          
          },
          secta: {
            nombre: "Secta del Viento Azure",
            rango: "Discípulo Externo",
            puntosContribucion: 0,
            misionesActivas: [],
            misionesCompletadas: {},
            rivalesDerrotadosClave: {},
          },
          // ---- PROPIEDADES DE ANIMACIÓN DEL SPRITE - ASEGÚRATE QUE ESTÉN AQUÍ Y CORRECTAS ----
          spriteSheetUrl: "img/personaje_cultivador_spritesheet.png",
          frameWidth: 64, // Ancho de un solo frame del sprite
          frameHeight: 64, // Alto de un solo frame del sprite
          directionRowMap: {
            // Mapeo de dirección a la fila Y en la hoja de sprites (0-indexed)
            down: 0, // Fila 0 para mirar/caminar hacia abajo
            left: 1, // Fila 1 para mirar/caminar hacia la izquierda
            right: 2, // Fila 2 para mirar/caminar hacia la derecha
            up: 3, // Fila 3 para mirar/caminar hacia arriba
          },
          animationFrames: 4, // Número de frames por dirección en la hoja
          currentFrame: 0, // Frame actual de la animación (0 a animationFrames - 1)
          currentDirection: "down", // Dirección inicial: 'up', 'down', 'left', 'right'
          currentZoneName: null,
          isMoving: false,
          unlockedTeleporters: {
            tp_sect_hub: true, // El teletransportador de la secta empieza activado
          },
          animationTimer: null, // Para el intervalo de la animación de caminar
          idleTimeout: null, // Para volver al estado idle después de moverse
          animationSpeed: 150, // Milisegundos entre frames de animación
          // ---- FIN PROPIEDADES DE ANIMACIÓN ----
          // NUEVO: Para animación de sprites
          sprites: {
            idle: "img/personaje_cultivador_idle.png", // O 'img/personaje_cultivador_down.png' si es tu frontal
            up: "img/personaje_cultivador_up.png",
            down: "img/personaje_cultivador_down.png",
            left: "img/personaje_cultivador_left.png",
            right: "img/personaje_cultivador_right.png",
          },
          currentSpriteKey: "idle", // 'idle', 'up', 'down', 'left', 'right'
          movementAnimationTimeout: null,
          //BUFF
          defenseBoostTurns: 0,
          defenseBoostAmount: 0,
          abilityCooldowns: {},
          // ===  DEBUFFS ===
          defenseReductionTurns: 0,
          defenseReductionAmount: 0,
          attackReductionTurns: 0,
          attackReductionAmount: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          burningTurns: 0,
          burnDamage: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          stunnedTurns: 0,
          manaDrainTurns: 0,
          manaDrainAmount: 0,
          // ===================================
          dodgeNextAttack: false,
          healingRainTurns: 0,

          defenseBoostTurns: 0,
          defenseBoostAmount: 0,
          dodgeNextAttack: false,
          healingRainTurns: 0,
          healingRainAmount: 0,
          manaRegenPerTurn: 0,
          // Para Ritual de Sangre
          bloodRitualTurns: 0,
          bloodRitualAttackBoost: 0,
          magicShieldValue: 0, // Valor actual del escudo de absorción
          magicShieldTurns: 0,

          activeChanneledAbility: {
            // Para habilidades con coste por turno
            id: null,
            hp: 0, // "Vida" de la habilidad (para los grilletes)
          },
          tempDefenseBoostTurns: 0,
          tempDefenseBoostAmount: 0,
          // Nuevos estados para técnicas de alto nivel
          isImmuneToStatus: false, // Inmunidad a quemaduras, veneno, stun, etc.
          passiveHpRegen: 0, // Cantidad de HP a regenerar por segundo pasivamente
          reviveChance: 0, // Probabilidad de resucitar al morir
          deathSaveChance: 0, // Probabilidad de sobrevivir con 1 HP
          damageToHealingTurns: 0, // Turnos para convertir daño en curación
          intangibleTurns: 0, // Turnos de ser intangible (inmune a daño directo)
          canRevive: false, // Flag activado por Llama del Fénix
         
          immuneTurns: 0,
          silencedTurns: 0, // Turnos en que no puede usar habilidades especiales
          sealedTurns: 0,   // Turnos en que no puede realizar ninguna acción
        },
        utilityRunes: {},
        cultivationInterval: null,
        inventory: {
          "Piedras Espirituales": 0,
          "Hierbas Medicinales": 0,
          "Cristales de Qi": 0,
        },
        selectedEnemyId: null,
        map: {
          width: 600, // Más pequeño para pruebas iniciales
          height: 600,
          defaultTerrain: "GRASSLAND",
          terrainZones: [
            //ZONAS
            //LÍMITES DE MAPA
            // ... otras zonas (montañas, ruinas, agua sin spawns de monstruos terrestres)

            {
              x1: 91,
              y1: 28,
              x2: 110,
              y2: 29,
              type: "SWAMP",
              name: "Camino a Tierra salvaje",
              decorations: [
          
              ],
           
            },
            {
              x1: 2,
              y1: 9,
              x2: 600,
              y2: 9,
              type: "MOUNTAIN_FRENTE",
              name: "límite norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 0,
              y1: 0,
              x2: 600,
              y2: 8,
              type: "MOUNTAIN_SUP",
              name: "Montañas Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: -20,
              y1: 0,
              x2: 0,
              y2: 600,
              type: "MOUNTAIN_SUP",
              name: "Montañas del Oeste",
            }, // Sin spawnSettings = no spawns
            {
              x1: 92,
              y1: 0,
              x2: 110,
              y2: 27,
              type: "MOUNTAIN_SUP",
              name: "Limite mapa este con desfiladero",
            }, 
            {//Limite con Valle del Dragón
              x1: 145,
              y1: 0,
              x2: 145,
              y2: 600,
              type: "MOUNTAIN_SUP",
              name: "Limite mapa este con desfiladero",
            }, // Sin spawnSettings = no spawns
            {
              x1: 92,
              y1: 30,
              x2: 110,
              y2: 600,
              type: "MOUNTAIN_SUP",
              name: "Limite mapa este con desfiladero",
            }, // Sin spawnSettings = no spawns
            {
              x1: 91,
              y1: 9,
              x2: 91,
              y2: 9,
              type: "MOUNTAIN_SUP_DER",
              name: "Montañas del Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 9,
              x2: 1,
              y2: 9,
              type: "MOUNTAIN_SUP_IZQ",
              name: "Montañas del Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 40,
              x2: 1,
              y2: 40,
              type: "MOUNTAIN_INF_IZQ",
              name: "Montañas del Norte",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 69,
              x2: 1,
              y2: 69,
              type: "MOUNTAIN_INF_IZQ",
              name: "borde desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 2,
              y1: 40,
              x2: 23,
              y2: 40,
              type: "MOUNTAIN_ABAJO_SUP",
              name: "frontera pradera-desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 26,
              y1: 40,
              x2: 89,
              y2: 40,
              type: "MOUNTAIN_ABAJO_SUP",
              name: "frontera pradera-desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 70,
              x2: 89,
              y2: 70,
              type: "MOUNTAIN_ABAJO_SUP_DES",
              name: "límite inferior desierto",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 71,
              x2: 89,
              y2: 90,
              type: "MOUNTAIN_SUP",
              name: "límite inferior desierto",
            }, // Sin spawnSettings = no spawns

           

            {
              x1: 91,
              y1: 10,
              x2: 91,
              y2: 27,
              type: "MOUNTAIN_DER",
              name: "Límite este con desfiladero",
            }, // Sin spawnSettings = no spawns
            {
              x1: 144,
              y1: 10,
              x2: 144,
              y2: 600,
              type: "MOUNTAIN_DER",
              name: "Límite este con Valle del Dragón",
            }, // Sin spawnSettings = no spawns
            {
              x1: 91,
              y1: 30,
              x2: 91,
              y2: 600,
              type: "MOUNTAIN_DER",
              name: "Límite este",
            }, // Sin spawnSettings = no spawns
            {
              x1: 1,
              y1: 10,
              x2: 1,
              y2: 39,
              type: "MOUNTAIN_IZQ",
              name: "límite oeste pradera",
            }, // Sin spawnSettings = no spawns
            {
              x1: 146,
              y1: 10,
              x2: 146,
              y2: 600,
              type: "MOUNTAIN_IZQ",
              name: "límite este con Valle del Dragón",
            }, // Sin spawnSettings = no spawns
            // ...FIN DE LOS LIMITES

            // ARENA DE LA SECTA
            {
              x1: 4,
              y1: 12,
              x2: 8,
              y2: 16, // Ejemplo de coordenadas (ajusta según tu mapa)
              type: "ARENA", // Puedes usar 'DESERT' o crear un G_TERRAIN_TYPES.ARENA
              name: "Arena de la Secta",
              // No necesita spawnSettings por ahora, a menos que quieras pequeños mobs decorativos allí.
            },

            ///ZONA SEGURA DE LA SECTA

            {
              x1: 2,
              y1: 10,
              x2: 29,
              y2: 24,

              type: "GRASSLAND",
              name: "Terreno de la Secta (Seguro)",
            },
            {
              x1: 2,
              y1: 25,
              x2: 29,
              y2: 39,

              type: "GRASSLAND",
              name: "Praderas de la Secta",
              spawnSettings: {
                targetEntities: [
                  // Lista de objetivos de spawn para esta zona
                  {
                    entityTypeId: "monster_secta_debil",
                    count: 10,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster", count: 10, currentCount: 0 },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "cristal_qi", count: 3, currentCount: 0 },
                  {
                    entityTypeId: "cultivator_rival_low",
                    count: 10,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0, // Cuando llegue a 0, puede reaparecer
                respawnCooldown: 300, // Segundos para reaparecer después de vaciarse o parcialmente
                lastSpawnCheck: 0, // Timestamp del último intento de spawn
              },
            },
            // Bosque Esmeralda Profundo
            {
              x1: 54,
              y1: 10,
              x2: 65,
              y2: 39,
              type: "GRASSLAND", //
              name: "Bosque Esmeralda Profundo",
              decorations: [
                { entityTypeId: "deco_arbol_grande", density: 0.1 }, // 10% de las celdas tendrán un árbol grande
                { entityTypeId: "deco_arbol_normal", density: 0.3 }, // 30% tendrán un árbol normal
                { entityTypeId: "deco_roca_musgosa", density: 0.05 }, // 5% tendrán una roca
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "osa_mayor_esmeralda",
                    count: 2,
                    currentCount: 0,
                  }, // Un enemigo más raro y fuerte
                  { entityTypeId: "treant_anciano", count: 1, currentCount: 0 }, // Un mini-jefe de zon
                ],
                respawnTimer: 0,
                respawnCooldown: 450,
                lastSpawnCheck: 0,
              },
            },
            // Bosque Esmeralda
            {
              x1: 30,
              y1: 10,
              x2: 59,
              y2: 39,
              type: "GRASSLAND", // <-- El terreno base ahora es hierba
              name: "Bosque Esmeralda",
              decorations: [
                { entityTypeId: "deco_arbol_grande", density: 0.1 }, // 10% de las celdas tendrán un árbol grande
                { entityTypeId: "deco_arbol_normal", density: 0.3 }, // 30% tendrán un árbol normal
                { entityTypeId: "deco_roca_musgosa", density: 0.05 }, // 5% tendrán una roca
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_bosque_lobo",
                    count: 8,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_bosque_arana",
                    count: 5,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster_alpha", count: 5, currentCount: 0 },
                ],
                respawnTimer: 0,
                respawnCooldown: 450,
                lastSpawnCheck: 0,
              },
            },
            // Desierto Abrasador profundo
            {
              x1: 69,
              y1: 50,
              x2: 90,
              y2: 69,
              type: "DESERT",
              name: "Desierto Abrasador profundo",
              decorations: [
                { entityTypeId: "deco_desierto", density: 0.05 }, // 5% de las celdas tendrán un árbol grande
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "djinn_arenas",
                    count: 20,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "gusano_dunas_colosal",
                    count: 20,
                    currentCount: 0,
                    isElite: true,
                  }, // Golem como elite
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },
            // Desierto Abrasador
            {
              x1: 1,
              y1: 41,
              x2: 90,
              y2: 69,
              type: "DESERT",
              name: "Desierto Abrasador",
              decorations: [
                { entityTypeId: "deco_desierto", density: 0.05 }, // 5% de las celdas tendrán un árbol grande
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_desierto_escorpion",
                    count: 70,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_desierto_golem_arena",
                    count: 20,
                    currentCount: 0,
                    isElite: true,
                  }, // Golem como elite
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },
            // RUINAS
            {
              x1: 500,
              y1: 500,
              x2: 550,
              y2: 550,
              type: "RUINS",
              name: "Corazón de las Ruinas Olvidadas",
              decorations: [
                { entityTypeId: "deco_ruina_pilar", density: 0.02 },
              ],
              isIsolated: true, // Marca esta zona como un "mapa" separado
              ambientColor: "#1a1a1a", // Color del "vacío" alrededor de la zona
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "esqueleto_podrido",
                    count: 25,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "guardian_terracota",
                    count: 25,
                    currentCount: 0,
                  },
                  
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // Ciénaga Sombría
            {
              x1: 66,
              y1: 10,
              x2: 90,
              y2: 39,
              type: "SWAMP",
              name: "Ciénaga Sombría",
              decorations: [
                // <-- NUEVA PROPIEDAD
                { entityTypeId: "deco_arbol_pantano", density: 0.1 }, // 10% de las celdas tendrán un árbol grande
                { entityTypeId: "deco_agua_estancada", density: 0.05 },
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_cienaga_serpiente",
                    count: 10,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "espectro_pantano",
                    count: 4,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "cultivador_renegado",
                    count: 5,
                    currentCount: 0,
                  },
                  
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // ===============================================
            // === ZONAS DE ALTO NIVEL (NUEVAS) ===
            // ===============================================

            // Zona para Misiones de Diácono
            {
              x1: 111,
              y1: 10,
              x2: 143,
              y2: 50,
              type: "GRASSLAND", // Usaremos un terreno rocoso y hostil
              name: "Desfiladero de los Lamentos",
              isIsolated: false, // Es como un mapa separado
              ambientColor: "#3c2f2f", // Un tono rojizo oscuro
              decorations: [
               
             
                { entityTypeId: "deco_montaña", density: 0.3 }, // 30% tendrán un árbol normal
                { entityTypeId: "deco_montaña_large", density: 0.05 },
    
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "cultivador_secta_rival",
                    count: 15,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "murcielago_cristal_sangriento",
                    count: 10,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "bandido_desfiladero",
                    count: 20,
                    currentCount: 0,
                  },
                  
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },

            // Zona para Misiones de Anciano
            {
              x1: 147,
              y1: 10,
              x2: 225,
              y2: 70,
              type: "SWAMP", // Un terreno antiguo y corrupto
              name: "Valle del Dragón Caído",
              isIsolated: true,
              ambientColor: "#2a3b2a", // Un verde enfermizo
              decorations: [
                { entityTypeId: "deco_arbol_pantano", density: 0.2 },
                { entityTypeId: "deco_huesos_gigantes", density: 0.05 }, // Necesitaremos definir esto
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "draco_hueso_antiguo",
                    count: 50,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "espectro_tifonico",
                    count: 80,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "draco_hueso_antiguo_boss",
                    count: 1,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 900,
                lastSpawnCheck: 0,
              },
            },

            // Zona para Misiones de Gran Anciano
            {
              x1: 400,
              y1: 10,
              x2: 450,
              y2: 60,
              type: "RUINS", // Terreno de otro mundo
              name: "La Fisura Demoníaca",
              isIsolated: true,
              ambientColor: "#4d194d", // Un púrpura corrupto
              decorations: [
                { entityTypeId: "deco_cristal_corrupto", density: 0.15 }, // Necesitaremos definir esto
              ],
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "demonio_de_la_fisura",
                    count: 20,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "guardian_celestial_caido",
                    count: 5,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 1200,
                lastSpawnCheck: 0,
              },
            },

            ///=========  FIN ZONAS ==========
          ],
          terrainGrid: null,
          entities: [],
        },
        battle: {
          active: false,
          enemy: {
            frozenTurns: 0,
            stunnedTurns: 0,
            burningTurns: 0,
            burnDamage: 0,
            poisonedTurns: 0,
            poisonDamage: 0,
            defenseReductionTurns: 0,
            defenseReductionAmount: 0,
            attackReductionTurns: 0,
            attackReductionAmount: 0,

            // --- AÑADE ESTAS LÍNEAS AQUÍ ---
            rootedTurns: 0, // Turnos que permanecerá atrapado
            rootDamage: 0, // Daño que sufrirá cada turno mientras esté atrapado
            // --- FIN DE LAS LÍNEAS A AÑADIR ---

            // Nuevos estados para efectos de alto nivel
            silencedTurns: 0,
            sealedTurns: 0,
            reflectDamageTurns: 0, // Para el aura de espinas
            reflectDamageMultiplier: 0,
            stunChance:0,
          },

          playerTurn: true,
        },
        gameTime: 0, // Un simple contador de segundos del juego para los temporizadores
        lastGameTimeUpdate: Date.now(),
        activeCombatAbilities: [],
      }; //FIN GAMESTATE

      let battleLogHistory = [];

      // --- CONSTANTES Y DATOS DEL JUEGO --- (sin cambios, deben estar aquí)
      let G_TILE_SIZE = 100; // Valor por defecto para escritorio
      const G_PLAYER_DISCOVERY_RANGE = 3;
      // --- VARIABLES GLOBALES ADICIONALES PARA CONTROL UI MÓVIL ---
      let mapControlsManuallyHidden = false;
      let currentTileSize = G_TILE_SIZE; // Usaremos este para los cálculos de renderizado
      let recoveryProgress = 0;
      let recoveryDirection = 1; // 1 para aumentar, -1 para disminuir
      const RECOVERY_CYCLE_DURATION = 2;

      const G_COMBAT_ENTITY_TYPES = [
        "monster",
        "guardian_terracota",
        "mission_boss",
        "esqueleto_podrido",
        "bandido_desfiladero",
        "monster_desierto_escorpion",
        "monster_secta_debil",
        "monster_alpha",
        "cultivator_rival_low",
        "cultivator_adept_hostile",
        "boss_dem",
        "boss_ancient_golem",
        "monster_cienaga_serpiente",
        "monster_bosque_lobo",
        "monster_bosque_arana",
        "monster_desierto_golem_arena",
        "jabali_colmilludo_alfa",
        "jabali_alfa_1",
        "jabali_alfa_2",
        "jabali_alfa_3",
        "jabali_alfa_4",
        "jabali_alfa_5",
        "jabali_alfa_6",
        "jabali_alfa_7",
        "jabali_alfa_8",
        "jabali_alfa_9",
        "jabali_alfa_10",
        "jabali_alfa_11",
        "jabali_alfa_12",
        "osa_mayor_esmeralda",
        "treant_anciano",
        "basilisco_cienaga",
        "espectro_pantano",
        "djinn_arenas",
        "gusano_dunas_colosal",
        "guardian_terracota",
        "murcielago_cristal_sangriento",
        "mercenario_acorazado",
        "bandido_desfiladero",
        "cultivador_secta_rival",
        "diacono_renegado_jin",
        "cultivador_renegado",
        "draco_hueso_antiguo",
        "espectro_tifonico",
        "demonio_de_la_fisura",
        "guardian_celestial_caido",
        "draco_hueso_antiguo_boss",
        "emperador_lich_del_valle",
        "lider_renegado_kai",
      ];
      const G_MAX_MAP_ENTITIES = 30;
      const G_RESPAWN_THRESHOLD = 15;
      const G_SAFE_RESPAWN_X = 10;
      const G_SAFE_RESPAWN_Y = 10;
      const G_SAFE_RESPAWN_SEARCH_RADIUS = 3;
      // TELETRANSPORTE
      const TELEPORTER_DATA = {
        tp_sect_hub: {
          name: "Matriz Central de la Secta",
          x: 15, // <-- Coordenadas al lado de la secta
          y: 11,
          isHub: true, // Marca este como el punto de partida principal
        },
        tp_forest_shrine: {
          name: "Santuario del Bosque Esmeralda",
          x: 45, // <-- Coordenadas en medio del bosque
          y: 25,
          isHub: false,
        },
        tp_desert_oasis: {
          name: "Oasis del Desierto Abrasador",
          x: 40, // <-- Coordenadas en una zona segura del desierto
          y: 60,
          isHub: false,
        },
        tp_swamp_ruin: {
          name: "Ruina Hundida de la Ciénaga",
          x: 75, // <-- Coordenadas en la ciénaga
          y: 30,
          isHub: false,
        },
        tp_desfiladero: {
          name: "Desfiladero",
          x: 135, // 
          y: 30,
          isHub: false,
        },
        tp_dragon_valley: {
        name: "Corazón del Valle del Dragón",
        x: 150, // Coordenada segura DENTRO del valle
        y: 15,  // Puedes ajustar esto a donde quieras que aparezca el jugador
        isHub: false,
    },
        // Puedes añadir más teletransportadores aquí en el futuro
      };
      const G_TERRAIN_TYPES = {
        VOID: {
          textureUrl: "img/mont_sup.png", // ¡Asegúrate de que esta imagen exista!
          name: "Vacío",
        },
        ARENA: {
          symbol: "🏟️",
          textureUrl: "img/b_arena.png",
          color: "#D2B48C",
          name: "Arena",
        },

        GRASSLAND: {
          symbol: "🟩",
          textureUrl: "img/grassland.png",
          color: "#34A853",
          name: "Pradera",
        }, // Verde para pastizales
        FOREST: {
          symbol: "🌲",
          textureUrl: "img/grassland.png",
          color: "#1E824C",
          name: "Bosque",
        }, // Verde oscuro para bosques
        MOUNTAIN_FRENTE: {
          symbol: "⛰️",
          textureUrl: "img/mont_frente.png",
          color: "#A9A9A9",
          name: "Montaña",
        }, // Gris para montañas
        MOUNTAIN_SUP: {
          symbol: "⛰️",
          textureUrl: "img/mont_sup.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_SUP_DER: {
          symbol: "⛰️",
          textureUrl: "img/mont_sup_der.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_SUP_IZQ: {
          symbol: "⛰️",
          textureUrl: "img/mont_sup_izq.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_DER: {
          symbol: "⛰️",
          textureUrl: "img/mont_der.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_IZQ: {
          symbol: "⛰️",
          textureUrl: "img/mont_izq.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_INF_IZQ: {
          symbol: "⛰️",
          textureUrl: "img/mont_int_inf_izq.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_ABAJO_SUP: {
          symbol: "⛰️",
          textureUrl: "img/mont_abajo_sup.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        MOUNTAIN_ABAJO_SUP_DES: {
          symbol: "⛰️",
          textureUrl: "img/mont_abajo_sup_des.png",
          color: "#A9A9A9",
          name: "Montaña",
        },
        WATER: {
          symbol: "🟦",
          color: "#4A86E8",
          name: "Agua",
        }, // Azul para agua (intransitable)
        RUINS: {
          symbol: "🏛️",
          textureUrl: "img/suelo_ruinas.png",
          color: "#706050",
          name: "Ruinas",
        }, // Marrón/Gris para ruinas
        TERRENO_MONT: {
          symbol: "🏛️",
          textureUrl: "img/terreno_mont.png",
          color: "#706050",
          name: "Ruinas",
        },
        DESERT: {
          symbol: "🟨",
          textureUrl: "img/arena.png",
          color: "#F9E79F",
          name: "Desierto",
        }, // Amarillo claro para desierto
        SWAMP: {
          symbol: "🟪",
          textureUrl: "img/pantano.png",
          color: "#5D3A9A",
          name: "Pantano",
        }, // Púrpura/Verde oscuro para pantano

        // Añade más según necesites
      };

      const PLAYER_SPRITE_FRAME_WIDTH = 64; // <--- ¡AJUSTA ESTO AL ANCHO DE UN FRAME DE TU SPRITE!
      const PLAYER_SPRITE_FRAME_HEIGHT = 64; // <--- ¡AJUSTA ESTO AL ALTO DE UN FRAME DE TU SPRITE!
      const PLAYER_ANIMATION_SPEED = 150; // Milisegundos entre frames de caminata (ajusta a gusto)
      const PLAYER_WALK_CYCLE = [0, 1, 0, 2]; // Los frames de columna a ciclar para caminar.
      // Si tu animación es 0-1-2-1, sería [0,1,2,1]
      // Si es 0-1-0-2 sería [0,1,0,2] (para un efecto de pie y luego paso)
      // Para tu sprite de 4 frames por dirección: [0, 1, 2, 3] y el frame 0 es el de "quieto"
      // o puedes usar [1,2,3,0] si el 0 es un frame de paso
      // Una animación común es "quieto" -> paso1 -> "quieto" -> paso2
      // O para ciclo continuo: paso1 -> paso2 -> paso3 -> paso4 -> paso1 ...
      // Para el sprite que mostraste, parece ser:
      // Frame 0: Quieto
      // Frame 1: Paso A
      // Frame 2: Quieto (o un frame intermedio)
      // Frame 3: Paso B
      // Entonces un ciclo podría ser [0, 1, 0, 3] o [1,0,3,0] para animación mientras se mueve
      // O si todos son frames de paso: [0,1,2,3]
      // VAMOS A USAR UN CICLO [1,0,3,0] (asumiendo frame 0 es el base/quieto y 1,3 son pasos)
      // Si el frame 0 es un paso y el personaje se "desliza" al estar quieto, cambia esto.
      // Definir las posiciones Y del sprite sheet para cada dirección
      const PLAYER_SPRITE_DIRECTIONS_Y = {
        down: 0 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 1 (índice 0) para caminar hacia abajo
        left: 1 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 2 (índice 1) para caminar hacia la izquierda
        right: 2 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 3 (índice 2) para caminar hacia la derecha
        up: 3 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 4 (índice 3) para caminar hacia arriba
      };
      // Podríamos añadir una propiedad 'walkable' a cada tipo de terreno
      G_TERRAIN_TYPES.MOUNTAIN_FRENTE.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_SUP.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_SUP_DER.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_DER.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_IZQ.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP.walkable = false; // Ejemplo, montañas podrían ser no transitables
      G_TERRAIN_TYPES.MOUNTAIN_ABAJO_SUP_DES.walkable = false;
      G_TERRAIN_TYPES.WATER.walkable = false;
      // Por defecto, asumimos que son transitables si no se especifica 'walkable: false'
      const G_BLOCKING_ENTITY_TYPES = [
        "shop",
        "secta_entrada_principal",
        "secta_entrada_principal_2",
        "secta_entrada_principal_3",
        "secta_entrada_principal_4",
        "npc_secta_guia",
        "npc_secta_admin",
        "npc_anciana_su",
        "npc_maestro_jian",
        "santuario_del_eco",
      ];
      //SECTA
      const SECTA_DATA = {
        nombre: "Secta del Viento Azure",
        rangos: [
          {
            nombre: "Discípulo Externo",
            pcsRequeridos: 0,
            beneficios: "Acceso básico a la secta.",
          },
          {
            nombre: "Discípulo Interno", // GRADO 1
            pcsRequeridos: 50,
            desafioRivalId: "rival_interno_1",
            beneficios:
              "Acceso al Patio Interno, misiones de mayor nivel, +5% ganancia de Qi al cultivar en la secta.",
            techniqueChoice: [
              "sword_t1",
              "body_t1",
              "formation_t1",
              "fire_t1",
              "lightning_t1",
            ],
          },
          {
            nombre: "Discípulo Principal", // GRADO 2
            pcsRequeridos: 200,
            desafioRivalId: "rival_principal_1",
            beneficios:
              "Acceso a la Biblioteca de Técnicas (nuevas técnicas), +10% ganancia de EXP en misiones de secta.",
            techniqueChoice: [
              "sword_t2",
              "body_t2",
              "formation_t2",
              "movement_t2",
              "fire_t2",
            ],
          },
          {
            nombre: "Diácono", // GRADO 3
            pcsRequeridos: 500,
            desafioRivalId: "guardian_diacono_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir pequeños grupos de discípulos (mecánica futura).",
            techniqueChoice: [
              "sword_t3",
              "body_t3",
              "formation_t3",
              "lightning_t3",
              "movement_t3",
            ],
          },
          {
            nombre: "Anciano", // GRADO 4
            pcsRequeridos: 1500,
            desafioRivalId: "guardian_anciano_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir medianos grupos de discípulos (mecánica futura).",
            techniqueChoice: [
              "sword_t4",
              "body_t4",
              "fire_t4",
              "lightning_t4",
              "formation_t4",
              "movement_t4",
            ],
          },
          {
            nombre: "Gran Anciano", // GRADO 5
            pcsRequeridos: 2500,
            desafioRivalId: "guardian_gran_anciano_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir grandes grupos de discípulos (mecánica futura).",
            techniqueChoice: [
              "sword_t5",
              "body_t5",
              "fire_t5",
              "lightning_t5",
              "formation_t5",
              "movement_t5",
            ],
          },
          {
            nombre: "Maestro de Secta", // GRADO 6
            pcsRequeridos: 5000,
            desafioRivalId: "guardian_maestro_1",
            beneficios:
              "Asignación semanal de Piedras Espirituales, puede dirigir la secta completa (mecánica futura).",
            techniqueChoice: [
              "sword_t6",
              "body_t6",
              "fire_t6",
              "lightning_t6",
              "formation_t6",
              "movement_t6",
            ],
          },
          // === NUEVOS RANGOS AÑADIDOS ===
          {
            nombre: "Patriarca", // GRADO 7
            pcsRequeridos: 10000,
            desafioRivalId: "guardian_patriarca_1", // Necesitarías definir este rival
            beneficios:
              "Tu influencia trasciende la secta. Obtienes acceso a dominios secretos.",
            techniqueChoice: [
              "sword_t7",
              "body_t7",
              "fire_t7",
              "lightning_t7",
              "formation_t7",
              "movement_t7",
            ],
          },
          {
            nombre: "Soberano Inmortal", // GRADO 8
            pcsRequeridos: 25000,
            desafioRivalId: "guardian_soberano_1", // Necesitarías definir este rival
            beneficios:
              "Tu nombre es leyenda. El mundo mortal ya no puede contenerte.",
            techniqueChoice: [
              "sword_t8",
              "body_t8",
              "fire_t8",
              "lightning_t8",
              "formation_t8",
              "movement_t8",
            ],
          },
          {
            nombre: "Soberano del Dao", // GRADO 9
            pcsRequeridos: 50000,
            desafioRivalId: "guardian_dao_1", // Necesitarías definir este rival
            beneficios:
              "Te has fusionado con el Gran Dao. Eres uno con la creación.",
            techniqueChoice: ["sword_t9"], // Ejemplo con una sola técnica definitiva
          },
        ],
        npcs: {
          guia_lin: {
            nombre: "Guía Lin",
            rol: "Maestro de Reclutas",
            dialogoInicial:
              "Bienvenido, joven aspirante... ¿Estás listo para empezar? Compra Items con Piedras espirituales,aprende técnicas, completa misiones y sube de rango en la secta",

            misionesOfrecidas: [
              "mision_recolectar_hierbas_1", // Aunque la entrega sea a Yao, Lin puede ofrecerla
              "mision_eliminar_demonios_1",
              "mision_lobos_bosque_1", // Nueva misión ofrecida por Lin
              "mision_cultivador_hostil_1", // Nueva misión ofrecida por Lin
              "mision_componentes_alquimia_1",
              "mision_recuperar_artefacto_1",
              // --- NUEVAS MISIONES ASIGNADAS ---
              // Rango: Discípulo Externo
              "mision_ext_1",
              "mision_ext_3",
              "mision_ext_4",
              // Rango: Discípulo Interno
              "mision_int_1",
              "mision_int_2",
              "mision_int_4",
              "mision_cazar_renegado_kai",
              // Rango: Discípulo Principal
              "mision_prin_4",
              // Misiones de Rango Diácono
              "mision_diac_1",
            
              "mision_diac_3",
              "mision_diac_4",

              // Misiones de Rango Anciano
              "mision_anc_1",
              "mision_anc_3",
              "mision_anc_4",

              // Misiones de Rango Gran Anciano
              "mision_gran_anc_1",
              "mision_gran_anc_2",
              "mision_gran_anc_3",

              // Misión Final de Maestro de Secta
              "mision_maestro_1",
            ],
          },
          admin_yao: {
            nombre: "Administrador Yao",
            rol: "Intendente de la Secta",
            dialogoInicial:
              "Entrega recursos valiosos o completa encargos para ganar Puntos de Contribución. También puedes adquirir algunos suministros aquí.",
            aceptaRecursos: [
              "Hierbas Medicinales",
              "Cristales de Qi",
              "Núcleo de Bestia Menor",
            ], // ...etc.
            tiendaSectaId: "tienda_secta_basica",
            misionesOfrecidas: [
              "mision_escorpiones_desierto_1", // Nueva misión ofrecida por Yao
              // --- NUEVAS MISIONES ASIGNADAS ---
              // Rango: Discípulo Externo
              "mision_ext_2",
              // Rango: Discípulo Interno
              "mision_int_3",
              // Rango: Discípulo Principal
              "mision_prin_1",
              "mision_prin_2",
              "mision_prin_3",
              // Misiones de Rango Diácono
              "mision_diac_2",

              // Misiones de Rango Anciano
              "mision_anc_2",

              // Misiones de Rango Gran Anciano
              "mision_gran_anc_4",
              // ... añade más ID de misiones que Yao ofrezca
            ],
          },
          npc_anciana_su: {
            symbol: "👵",
            name: "Anciana Su, la Archivista",
            spriteUrl: "img/anciana_su.png", // Necesitarás una imagen para ella
            interaction: "talk_story_npc",
            npcId: "anciana_su",
            fixedLocation: { x: 18, y: 14 }, // Por ejemplo, en un edificio tipo biblioteca de la secta
            discovered: true,
          },
          npc_maestro_jian: {
            symbol: "👑",
            name: "Maestro de Secta Jian",
            spriteUrl: "img/maestro_jian.png", // Necesitarás una imagen para él
            interaction: "talk_story_npc",
            npcId: "maestro_jian",
            fixedLocation: { x: 15, y: 18 }, // En la parte más profunda del salón principal
            discovered: true,
          },
          santuario_del_eco: {
            symbol: "⛩️",
            name: "Santuario del Eco",
            spriteUrl: "img/santuario_eco.png", // Necesitarás una imagen (puede ser un altar brillante)
            interaction: "interact_shrine",
            type: "story_shrine",
            fixedLocation: { x: 330, y: 15 }, // Oculto en el Valle del Dragón Caído
            discovered: false, // El jugador debe descubrirlo
          },
        },
      };

      const MISIONES_DATA = {

        // ==========================================================
        // ===            MISIONES DE HISTORIA PRINCIPAL          ===
        // ==========================================================
        mision_historia_1_demonio: {
            titulo: "El General Demonio de la Pradera",
            descripcion: "La Anciana Su te ha revelado que una poderosa presencia demoníaca se ha manifestado al sur de las praderas de la secta. Este 'General Demonio' es una amenaza directa y su derrota es crucial para la seguridad de todos. Encuéntralo y elimínalo.",
            objetivo: {
                tipo: "derrotar_npc_especifico",
                npcId: "boss_dem", // ID del jefe que debe ser derrotado
                npcEntrega: "anciana_su", // Reportar a la Anciana Su
            },
            recompensa: {
                pcs: 300,
                exp: 1500,
                items: { "Núcleo Demoníaco Mayor": 1, "Piedras Espirituales": 150 },
            },
            // Esta misión no es ofrecida por un NPC, se activa por evento.
            isStoryMission: true, 
        },
        // === MISIONES: DISCÍPULO EXTERNO ===

        mision_ext_1: {
          titulo: "Control de Plagas en la Pradera",
          descripcion:
            "Unas Bestias Menores de Pradera se están acercando demasiado a los terrenos de la secta. Demuestra tu valía eliminando 5 de ellas.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_secta_debil",
            cantidad: 5,
            nombreDisplay: "Bestia Menor",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 30,
            exp: 50,
            items: { "Piedras Espirituales": 5 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
        },
        mision_ext_2: {
          titulo: "Suministro de Energía",
          descripcion:
            "El Administrador Yao necesita reponer las reservas de energía de la secta. Recolecta 3 Cristales de Qi y entrégaselos.",
          objetivo: {
            tipo: "entregar_item",
            item: "Cristales de Qi",
            cantidad: 3,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 40,
            exp: 60,
            items: { "Piedras Espirituales": 10 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Externo",
        },
        mision_ext_3: {
          titulo: "Una Lección de Humildad",
          descripcion:
            "Algunos cultivadores novatos se han vuelto arrogantes y están causando problemas. El Guía Lin quiere que derrotes a 3 de ellos para que recuerden su lugar.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivator_rival_low",
            cantidad: 3,
            nombreDisplay: "Cultivador Novato Hostil",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 50,
            exp: 120,
            items: { "Píldora de Recuperación Menor": 1 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
        },
        mision_ext_4: {
          titulo: "Primera Incursión al Bosque",
          descripcion:
            "Los lobos del Bosque Esmeralda están mostrando una agresividad inusual. Adéntrate con cuidado y elimina 2 Lobos del Bosque para investigar.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_bosque_lobo",
            cantidad: 2,
            nombreDisplay: "Lobo del Bosque",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 60, exp: 150, items: { "Colmillo de Lobo": 1 } },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
          requisitoNivel: 3, // Un pequeño requisito de nivel para guiar al jugador.
        },

        mision_cultivador_hostil_1: {
          titulo: "Rivalidad Temprana",
          descripcion:
            "Un grupo de cultivadores están causando alboroto en la secta. El Guía Lin quiere que les des una lección. Derrótalos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivator_rival_low",
            cantidad: 10,
            nombreDisplay: "Cultivador Novato Hostil",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 200,
            exp: 400,
            items: {
              "Píldora de Recuperación Menor": 1,
              "Piedras Espirituales": 12,
            },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 8,
        },
        //MISIONES FORMACIONES
        mision_feng_0_encontrar_maestro: {
            titulo: "Un Eco en el Compás",
            descripcion: "El compás gira violentamente y apunta hacia una zona escondida en los campos de la secta. La ubicación de una extraña anomalía ha sido marcada en tu percepción espiritual. Dirígete a las coordenadas x:2, y:23.",
            objetivo: {
                tipo: "llegar_a_punto",
                x: 2,
                y: 23,
                nombreArea: "Anomalía Espiritual",
                npcEntrega: "npc_maestro_feng" // Al llegar y hablar con él, la misión se completará.
            },
            recompensa: {
                pcs: 0,
                exp: 100
            },
            isStoryMission: true, // Indica que no la ofrece un NPC directamente, sino que se activa por evento.
        },
        mision_feng_1_tutorial: {
            titulo: "El Arte de la Inscripción",
            descripcion: "El Maestro Feng quiere que demuestres tu aptitud. Te ha pedido que traces una simple formación de tres puntos en cualquier lugar del mapa para probar tu control.",
            objetivo: {
                tipo: "trazar_patron",
                patternId: "fengs_initiation_seal",
                npcEntrega: "npc_maestro_feng"
            },
            recompensa: {
                pcs: 100, exp: 1000,
                learnPattern: "verdant_life_circle", // Recompensa: aprender el siguiente patrón
                items: { "Tinta Rúnica": 20 }
            },
            npcInicio: "npc_maestro_feng"
        },
        mision_feng_2_prueba_vital: {
            titulo: "Una Prueba de Vitalidad",
            descripcion: "Feng te ha enseñado el 'Círculo de Vida Frondoso'. Ahora quiere que lo pongas a prueba. Derrota a un poderoso Treant Anciano en el Bosque Esmeralda Profundo. Su poder de desgaste pondrá a prueba tu capacidad de supervivencia.",
            objetivo: {
                tipo: "eliminar_enemigo",
                enemigoTipo: "treant_anciano", // Un enemigo que ya tienes definido
                cantidad: 1,
                npcEntrega: "npc_maestro_feng"
            },
            recompensa: {
                pcs: 300, exp: 2500,
                learnPattern: "arcane_vortex_array" // Recompensa: aprender el siguiente
            },
            npcInicio: "npc_maestro_feng"
        },
        mision_feng_3_romper_sello: {
            titulo: "Rompiendo el Sello Ancestral",
            
            descripcion: "Tu siguiente gran prueba. El Golem Geo en el Desierto Profundo está protegido por un sello mágico que lo hace invulnerable. La 'Matriz del Vórtice Arcano' que te enseñé no funcionará contra la magia de la tierra. Necesitarás un poder diferente, uno que 'quiebre el caparazón' desde fuera. Investiga los diagramas que has encontrado en tus viajes y usa la formación correcta para destruir su barrera mágica antes de poder derrotarlo.",
            
            objetivo: {
                tipo: "derrotar_npc_especifico",
                npcId: "boss_ancient_golem",
                npcEntrega: "npc_maestro_feng"
            },
            recompensa: {
                pcs: 1000,
                exp: 8000,
                learnPattern: "aegis_of_the_mountain"
            },
            npcInicio: "npc_maestro_feng"
        },
        mision_feng_4_la_egida: {
            titulo: "La Prueba de la Montaña",
            descripcion: "Feng te ha enseñado la 'Égida de la Montaña Inamovible', una formación defensiva formidable. Para dominarla, debes enfrentar y derrotar a un Djinn de las Arenas, cuya ofensiva implacable pondrá a prueba tu nueva defensa.",
            objetivo: {
                tipo: "eliminar_enemigo",
                enemigoTipo: "djinn_arenas", // Un enemigo que golpea duro
                cantidad: 1,
                npcEntrega: "npc_maestro_feng"
            },
            recompensa: {
                pcs: 2000,
                exp: 10000,
                items: { "Rollo: Matriz de Reversión del Cosmos (Trascendente)": 1 } // La recompensa final
            },
            npcInicio: "npc_maestro_feng"
        },
        // Asegúrate de que las misiones que quieres que se entreguen a un NPC tengan `npcEntrega` en su `objetivo`.
        mision_componentes_alquimia_1: {
          titulo: "Medicina Urgente",
          descripcion:
            "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Raíces de Fuego Terrenal' para una píldora vital. Se dice que crecen en zonas con fluctuaciones elementales. Entrégalas al Administrador Yao.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "Flor de Luna Escarchada", cantidad: 3 },
              { nombre: "Raíz de Fuego Terrenal", cantidad: 2 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 250,
            items: {
              "Píldora de Recuperación Menor": 2,
              "Piedras Espirituales": 10,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Externo",
        },

        // === MISIONES: DISCÍPULO INTERNO ===
        // (Se desbloquean al alcanzar este rango)

        mision_int_1: {
          titulo: "La Plaga Arácnida",
          descripcion:
            "Las Arañas Tejesombras están infestando el Bosque Esmeralda, haciendo peligrosa la recolección de hierbas. Extermina a 8 de ellas.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_bosque_arana",
            cantidad: 8,
            nombreDisplay: "Araña Tejesombras",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 80, exp: 250, items: { "Seda de Araña": 3 } },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
        },
        mision_int_2: {
          titulo: "Limpieza en la Ciénaga",
          descripcion:
            "La Ciénaga Sombría es un lugar peligroso. Para mantener a raya a sus habitantes, elimina 4 Serpientes de Ciénaga.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_cienaga_serpiente",
            cantidad: 4,
            nombreDisplay: "Serpiente de Ciénaga",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 100,
            exp: 300,
            items: { "Piedras Espirituales": 25 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
        },
        mision_int_3: {
          titulo: "La Petición del Herrero",
          descripcion:
            "El herrero de la secta necesita Quitina Resistente para forjar armaduras ligeras. Caza Escorpiones de las Dunas hasta obtener 3 unidades de Quitina y entrégaselas a Yao.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "monster_desierto_escorpion",
            itemPrueba: "Quitina Resistente",
            cantidadItemPrueba: 3,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 400,
            items: { "Piedras Espirituales": 30 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Interno",
        },
        mision_int_4: {
          titulo: "La Bestia Alfa",
          descripcion:
            "Un Lobo Alfa ha sido avistado en el corazón del bosque, liderando a las manadas. Cazarlo será una prueba de tu creciente poder.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_alpha",
            cantidad: 1,
            nombreDisplay: "Lobo Alfa",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 500,
            items: { "Núcleo de Bestia Menor": 1, "Piedras Espirituales": 50 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
          requisitoNivel: 8,
        },
        mision_cazar_renegado_kai: {
          titulo: "El Renegado Erudito",
          descripcion: "El Guía Lin está preocupado por Kai, un ex-discípulo talentoso que abandonó la secta en busca de 'conocimientos prohibidos'. Ha sido visto liderando a un grupo de renegados en el Bosque Esmeralda Profundo. Su influencia es una amenaza. Encuéntralo y pon fin a sus actividades.",
          objetivo: {
              tipo: "derrotar_npc_especifico",
              // --- CAMBIO CLAVE ---
              // Ahora usamos el ID de la entidad, que es el correcto para un jefe de misión
              npcId: "lider_renegado_kai", 
              npcEntrega: "guia_lin" 
          },
          recompensa: {
              pcs: 250,
              exp: 1500,
              items: { "Píldora de Recuperación Menor": 3 }
          },
          npcInicio: "guia_lin", 
          requisitoRango: "Discípulo Interno"
      },
        mision_cazar_bestia_especifica_1: {
          titulo: "La Amenaza del Jabalí Colmilludo",
          descripcion:
            "Un Jabalí Colmilludo particularmente agresivo ha estado atacando a los recolectores de la secta en lo profundo del bosque. Caza a esta bestia y trae su 'Colmillo intacto' como prueba al Guía Lin.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "jabali_colmilludo_alfa",
            itemPrueba: "Colmillo de Jabalí Alfa",
            cantidadItemPrueba: 1,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 300,
            items: { "Piedras Espirituales": 20, "Carne de Bestia Exótica": 3 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Interno",
          requisitoNivel: 10,
        },
        

        // === MISIONES: DISCÍPULO PRINCIPAL ===
        // (Se desbloquean al alcanzar este rango)

        mision_prin_1: {
          titulo: "Arena y Aguijón",
          descripcion:
            "Las caravanas que comercian con la secta reportan ataques de Escorpiones de las Dunas. Reduce su número eliminando a 10 de ellos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_desierto_escorpion",
            cantidad: 10,
            nombreDisplay: "Escorpión de las Dunas",
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 180,
            exp: 600,
            items: { "Piedras Espirituales": 70 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Principal",
        },
        mision_prin_2: {
          titulo: "Corazones de Arena",
          descripcion:
            "Los Golems de Tormenta de Arena son una amenaza mayor en el desierto. Destruye 5 y trae sus Núcleos de Arena como prueba.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "monster_desierto_golem_arena",
            itemPrueba: "Núcleo de Arena",
            cantidadItemPrueba: 5,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 250,
            exp: 800,
            items: { "Fragmento Desértico": 2, "Piedras Espirituales": 100 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Principal",
          requisitoNivel: 12,
        },
        mision_prin_3: {
          titulo: "Ecos Espectrales",
          descripcion:
            "Los alquimistas de la secta pagan bien por Esencias Espectrales. Se dice que los Espectros del Pantano las dejan al ser derrotados. Consigue 2 esencias.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "espectro_pantano",
            itemPrueba: "Esencia Espectral",
            cantidadItemPrueba: 2,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 300,
            exp: 900,
            items: { "Talismán de Percepción": 1 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Discípulo Principal",
        },
        mision_prin_4: {
          titulo: "Renegados Peligrosos",
          descripcion:
            "Un grupo de Cultivadores Renegados ha establecido un campamento en el bosque profundo, desafiando la autoridad de la secta. Disuélvelos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivador_renegado",
            cantidad: 4,
            nombreDisplay: "Cultivador Renegado",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 280,
            exp: 1000,
            items: {
              "Rollo: Técnica Aleatoria Menor": 1,
              "Piedras Espirituales": 80,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Discípulo Principal",
          requisitoNivel: 15,
        },
        // === MISIONES: DIÁCONO ===
        mision_diac_1: {
          titulo: "Contención de Rivales",
          descripcion:
            "La Secta de la Llama Negra se está expandiendo a nuestro territorio. Ve al Desfiladero de los Lamentos y derrota a 10 de sus cultivadores para enviar un mensaje.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivador_secta_rival",
            cantidad: 10,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 400,
            exp: 2500,
            items: { "Piedras Espirituales": 200 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Diácono",
        },
        mision_diac_2: {
          titulo: "Recolección Peligrosa",
          descripcion:
            "Nuestros alquimistas necesitan Cristales de Sangre Puros, que solo se encuentran en la Caverna de Cristal de Sangre, dentro del Desfiladero. Ten cuidado con sus guardianes. Necesitamos 3 cristales.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "murcielago_cristal_sangriento",
            itemPrueba: "Cristal de Sangre Puro",
            cantidadItemPrueba: 3,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 500,
            exp: 3000,
            items: { "Píldora de Recuperación Mayor": 2 },
          }, // Necesitarías definir este item
          npcInicio: "admin_yao",
          requisitoRango: "Diácono",
        },
        mision_diac_3: {
            titulo: "Limpieza en el Desfiladero",
            descripcion: "Un grupo de bandidos bien armados se ha asentado en el Desfiladero de los Lamentos, interrumpiendo las rutas de la secta. Elimínalos.",
            // CORREGIDO: El objeto 'objetivo' ahora es el correcto para una misión de eliminación.
            objetivo: {
                tipo: "eliminar_enemigo",
                enemigoTipo: "bandido_desfiladero",
                nombreDisplay: "Bandido del Desfiladero",
                cantidad: 10,
                npcEntrega: "guia_lin"
            },
            recompensa: {
                pcs: 800,
                exp: 4000,
                items: { "Piedras Espirituales": 150 }
            },
            npcInicio: "guia_lin",
            requisitoRango: "Diácono",
        },
        mision_diac_4: {
            titulo: "La Traición de Jin",
            descripcion: "Es hora de acabar con la amenaza del Diácono Renegado Jin. Derrótalo y restaura el honor de la secta.",
            objetivo: {
                tipo: "derrotar_npc_especifico", // <-- TIPO CORRECTO
                npcId: "diacono_renegado_jin",   // <-- PROPIEDAD CORRECTA
                npcEntrega: "guia_lin"
            },
            recompensa: {
                pcs: 1000,
                exp: 5000,
                items: { "Rollo: Técnica de Absorción de Qi Celestial": 1 }
            },
            npcInicio: "guia_lin",
            requisitoRango: "Diácono", 
        },

        // === MISIONES: ANCIANO ===
        mision_anc_1: {
          titulo: "El Resentimiento del Dragón",
          descripcion:
            "La energía Yin en el Valle del Dragón Caído ha reanimado a los antiguos dracos. Pacifica a 8 de estas criaturas esqueléticas.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "draco_hueso_antiguo",
            cantidad: 8,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 1200,
            exp: 8000,
            items: { "Piedras Espirituales": 500 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Anciano",
        },
        mision_anc_2: {
          titulo: "El Corazón de la Tormenta",
          descripcion:
            "Para forjar un artefacto celestial, necesitamos un Corazón de Tifón. Caza a los Espectros Tifónicos en el Valle hasta que obtengas uno.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "espectro_tifonico",
            itemPrueba: "Corazón de Tifón",
            cantidadItemPrueba: 1,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 1500,
            exp: 10000,
            items: { "Piedras Espirituales": 700 },
          },
          npcInicio: "admin_yao",
          requisitoRango: "Anciano",
        },
        mision_anc_3: {
          titulo: "La Fuente de la Corrupción",
          descripcion:
            "Creemos que un poderoso no-muerto es la causa de la corrupción en el Valle. Encuentra su guarida y prepárate para enfrentarlo.",
          objetivo: {
            tipo: "llegar_a_punto",
            x: 200,
            y: 48,
            nombreArea: "Trono del Lich",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 500, exp: 3000 },
          npcInicio: "guia_lin",
          requisitoRango: "Anciano",
        },
        mision_anc_4: {
          titulo: "Sellar al Emperador Lich",
          descripcion:
            "El Emperador Lich amenaza con extender su plaga no-muerta. Destrúyelo y reclama su filacteria como prueba.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "emperador_lich_del_valle",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 2500,
            exp: 15000,
            items: {
              "Filacteria del Lich": 1,
              "Rollo: Técnica de Anciano Aleatoria": 1,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Anciano",
        },

        // === MISIONES: GRAN ANCIANO ===
        mision_gran_anc_1: {
          titulo: "Defensa de la Realidad",
          descripcion:
            "Una Fisura Demoníaca se ha abierto, y sus habitantes se derraman en nuestro mundo. Repele la primera oleada eliminando a 15 Demonios de la Fisura.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "demonio_de_la_fisura",
            cantidad: 15,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 3000,
            exp: 20000,
            items: { "Fragmento de la Fisura": 5 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Gran Anciano",
        },
        mision_gran_anc_2: {
          titulo: "Luz Caída",
          descripcion:
            "Los Guardianes Celestiales que protegían el sello de la fisura han sido corrompidos. Libera a 3 de ellos de su tormento.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "guardian_celestial_caido",
            cantidad: 3,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 4000,
            exp: 25000,
            items: { "Lágrima Celestial": 1 },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Gran Anciano",
        },
        mision_gran_anc_3: {
          titulo: "El General del Abismo",
          descripcion:
            "El General Demoníaco Abismal comanda las fuerzas de la Fisura. Adéntrate en su corazón y derrótalo para sellar la amenaza... por ahora.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "general_demoniaco_abismal",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 5000,
            exp: 40000,
            items: {
              "Corazón del Abismo": 1,
              "Rollo: Técnica de Gran Anciano Aleatoria": 1,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Gran Anciano",
        },
        mision_gran_anc_4: {
          titulo: "Preparativos para la Ascensión",
          descripcion:
            "Has llegado al pináculo. Para trascender, necesitas forjar un Sello del Dao. Reúne 3 Lágrimas Celestiales, 5 Fragmentos de la Fisura y 10 Escamas de Dragón Espectral.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "Lágrima Celestial", cantidad: 3 },
              { nombre: "Fragmento de la Fisura", cantidad: 5 },
              { nombre: "Escama de Dragón Espectral", cantidad: 10 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: { pcs: 10000, exp: 50000 },
          npcInicio: "admin_yao",
          requisitoRango: "Gran Anciano",
        },

        // === MISIÓN FINAL: MAESTRO DE SECTA ===
        mision_maestro_1: {
          titulo: "El Duelo del Destino",
          descripcion:
            "El equilibrio del mundo se ha roto. Un Avatar del Dao Corrupto ha despertado para consumir toda la existencia. Como Maestro de Secta, es tu deber enfrentarlo y proteger este mundo.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "avatar_del_dao_corrupto",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 0,
            exp: 100000,
            items: { "Semilla del Dao Verdadero": 1 },
            nuevoRango: "Soberano Inmortal",
          }, // Rango final honorífico
          npcInicio: "guia_lin",
          requisitoRango: "Maestro de Secta",
        },

        //MISIONES DE DESAFÍO
        mision_desafio_interno_1: {
          titulo: "Prueba de Discípulo Interno",
          descripcion:
            "Para ser reconocido como Discípulo Interno, debes demostrar tu fuerza venciendo al Guardián de la Prueba, Han Li. Encuéntralo en la arena de desafíos de la secta.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_interno_1",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 200, exp: 300, nuevoRango: "Discípulo Interno" },
          autoActivarAlCumplirRequisitos: true,
        },
        mision_desafio_principal_1: {
          titulo: "Prueba de Discípulo Principal",
          descripcion:
            "La Anciana Shui espera en la arena. Demuestra que eres digno del rango de Discípulo Principal.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_principal_1",
            npcEntrega: "guia_lin",
          },
          recompensa: { pcs: 500, exp: 800, nuevoRango: "Discípulo Principal" },
          autoActivarAlCumplirRequisitos: true,
        },
        mision_desafio_diacono_1: {
          titulo: "Prueba de Diácono",
          descripcion:
            "Has demostrado tu valía a través de tus contribuciones. Para ser reconocido como Diácono, debes derrotar al Guardián de la Arena, Feng, en un duelo honorable.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_diacono_1",
            npcEntrega: "guia_lin", // El Guía Lin confirmará tu ascenso
          },
          recompensa: {
            pcs: 500,
            exp: 2000,
            nuevoRango: "Diácono",
            // La elección de técnica ya está manejada por tu lógica de ascenso
          },
          autoActivarAlCumplirRequisitos: true, // Esto es clave para la automatización
        },

        mision_desafio_anciano_1: {
          titulo: "Prueba de Anciano",
          descripcion:
            "Solo los más fuertes pueden guiar a la secta. El Anciano Guardián Lei te espera en la arena para probar si eres digno del título de Anciano.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_anciano_1",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 1000,
            exp: 5000,
            nuevoRango: "Anciano",
          },
          autoActivarAlCumplirRequisitos: true,
        },

        mision_desafio_gran_anciano_1: {
          titulo: "Prueba de Gran Anciano",
          descripcion:
            "La Gran Anciana de la Hoja, Yue, pondrá a prueba no solo tu fuerza, sino tu ingenio en combate. Véncela para obtener el respeto de todo el consejo de ancianos.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_gran_anciano_1",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 2000,
            exp: 10000,
            nuevoRango: "Gran Anciano",
          },
          autoActivarAlCumplirRequisitos: true,
        },

        mision_desafio_maestro_1: {
          titulo: "La Prueba Final: El Legado del Maestro",
          descripcion:
            "El camino hacia la cima llega a su fin. El Maestro de Secta anterior te espera para una última prueba. Demuestra que estás listo para heredar su voluntad y liderar la secta hacia la gloria.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "guardian_maestro_1",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 5000,
            exp: 20000,
            nuevoRango: "Maestro de Secta",
          },
          autoActivarAlCumplirRequisitos: true,
        },
      };

      const shopData = {
        name: "Pabellón de Tesoros del Dragón Oculto",
        inventory: [
        { 
              itemName: "Tinta Rúnica",
              type: "material", 
              category: "material",
              price: 1, 
              stock: 50000000, 
              description: "Tinta imbuida de Qi, necesaria para trazar formaciones rúnicas en el suelo."
          },
          { itemName: "Hierbas Medicinales", price: 1, stock: 100 },
          { itemName: "Cristales de Qi", price: 1, stock: 100 },
          {
            itemName: "Espada de Hierro",
            type: "equipment",
            category: "weapon",
            attackBonus: 5,
            price: 50,
            stock: 1,
            description: "Una espada básica pero fiable. (+5 Ataque)",
          },
          //nivel 0
          { itemName: "Rollo: Absorción de Qi Menor", price: 15, stock: 1 },
          { itemName: "Rollo: Inscripción Rúnica", price: 150, stock: 1 },
          { itemName: "Rollo: Conversión de Qi", price: 25, stock: 10 },
          //nivel inferior
          { itemName: "Rollo: Tajo del Viento Veloz (Inferior)", price: 150, stock: 1 },
          { itemName: "Rollo: Físico de Buey de Piedra (Inferior)", price: 200, stock: 1 },
          { itemName: "Rollo: Matriz de Escudo de Qi (Inferior)", price: 180, stock: 1 },
          { itemName: "Rollo: Chispa Ígnea (Inferior)", price: 170, stock: 1 },
          { itemName: "Rollo: Dedo de Relámpago (Inferior)", price: 220, stock: 1 },
          //nivel terrenal

          {
            itemName: "Rollo: Estocada Perfora-Armadura (Terrenal)",
            price: 300,
            stock: 1,
          },
          { itemName: "Rollo: Piel de Acero Fundido (Terrenal)", price: 300, stock: 1 },
          {
            itemName: "Rollo: Matriz de Grilletes de Qi (Terrenal)",
            price: 300,
            stock: 1,
          },
          { itemName: "Rollo: Paso Etéreo (Terrenal)", price: 300, stock: 5 },
          { itemName: "Rollo: Aliento de Dragón Menor (Terrenal)", price: 300, stock: 1 },
          //nivel marcial
          {
            itemName: "Rollo: Danza de Espada Ciclónica (Marcial)",
            price: 600,
            stock: 1,
          },
          {
            itemName: "Rollo: Corazón de Voluntad Indomable (Marcial)",
            price: 600,
            stock: 1,
          },
          {
            itemName: "Rollo: Matriz de Supresión Espiritual (Marcial)",
            price: 600,
            stock: 1,
          },
          { itemName: "Rollo: Jaula de Rayos (Marcial)", price: 600, stock: 1 },
          { itemName: "Rollo: Parpadeo de Sombra (Marcial)", price: 600, stock: 1 },
          //Nivel soberano
          {
            itemName: "Rollo: Intenteción de Espada del Tirano (Soberano)",
            price: 1200,
            stock: 1,
          },
          { itemName: "Rollo: Cuerpo Dorado Inmortal (Soberano)", price: 1200, stock: 1 },
          { itemName: "Rollo: Sol Abrasador (Soberano)", price: 1200, stock: 1 },
          {
            itemName: "Rollo: Llamada del Juicio del Trueno (Soberano)",
            price: 1200,
            stock: 1,
          },
          {
            itemName: "Rollo: Santuario Dorado Protector (Soberano)",
            price: 1200,
            stock: 1,
          },
          //nivel trascendente
          {
            itemName: "Rollo: Corte que Divide Cielos y Tierra (Trascendente)",
            price: 2400,
            stock: 1,
          },
          {
            itemName: "Rollo: Constitución de Dragón Ancestral (Trascendente)",
            price: 2400,
            stock: 1,
          },
          {
            itemName: "Rollo: Llama del Fénix Renaciente (Trascendente)",
            price: 2400,
            stock: 1,
          },
          {
            itemName: "Rollo: Tribulación de los Nueve Cielos (Trascendente)",
            price: 2400,
            stock: 1,
          },
          {
            itemName: "Rollo: Matriz de Reversión del Cosmos (Trascendente)",
            price: 2400,
            stock: 1,
          },
          { itemName: "Rollo: Paso del Vacío Infinito (Trascendente)", price: 2400, stock: 1 },
//nivel celestial
          { itemName: "Rollo: Espada del Emperador (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Cuerpo Inmortal de Jade (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Incineración del Mundo Mortal (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Decreto del Señor del Trueno (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Matriz del Sello del Demonio (Celestial)", price: 5000, stock: 1 },
          { itemName: "Rollo: Omnipresencia Divina (Celestial)", price: 5000, stock: 1 },

       
          
        ],
      };

      //ROLLOS DE TECNICAS
      const techniqueData = {
        // =================================================================
        // == GRADO 1 (Rango: Discípulo Externo)
        // =================================================================
        formation_scribing_1: {
          id: "formation_scribing_1",
          name: "Inscripción Rúnica",
          icon: "✍️",
          description: "Te permite usar 'Tinta Rúnica' para trazar runas. Cultivar esta técnica mejora la potencia de todas tus formaciones completadas.",
          type: "active_ability",
          abilityId: "plant_rune",
          manaCost: 10,
          // --- CAMBIOS CLAVE ---
          maxLevel: 10, // Ahora se puede subir de nivel
          cultivationSettings: {
              baseTimeToLevelUp: 300, // Requiere tiempo para dominarla
              levelTimeMultiplier: 2,
          },
          // Este efecto no se aplica directamente, lo leeremos en otra función
          effect: {
              // +10% de potencia por cada nivel después del primero.
              amplificationPerLevel: 0.10 
          }
      },
      
        qi_to_hp_conversion_1: {
          id: "qi_to_hp_conversion_1",
          name: "Conversión de Qi",
          description:
            "Permite activar/desactivar la conversión de Maná en HP al cultivar. Mejora la tasa de conversión y eficiencia con cada nivel de refinamiento.",
          type: "active_refinement_effect",
          effect: {
            baseManaCostPerSecond: 2.0, // Mantenemos un coste base razonable
            baseHpGainPerSecond: 3.0, // <-- ¡VALOR CORREGIDO! Ahora es más eficiente.
            hpGainIncreasePerLevel: 1, // Hacemos que la mejora por nivel sea más gradual pero sostenida
            manaCostReductionPerLevel: 0.02, // Reducimos la mejora de eficiencia para balancear
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Cristales de Qi": 5, "Piedras Espirituales": 10 },
            levelRequirement: 1,
          },
          icon: "☯️",
        },
        qi_absorption_boost_1: {
          id: "qi_absorption_boost_1",
          name: "Absorción de Qi Menor",
          description:
            "Aumenta la cantidad de Qi ganado por segundo al cultivar en 0.5.",
          type: "passive_cultivation",
          effect: { statToBoost: "qiPerSecondBase", value: 0.5 },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 60,
            levelTimeMultiplier: 1.5,
          },
          refinementCost: {
            baseTime: 30,
            materials: { "Piedras Espirituales": 20 },
            levelRequirement: 1,
          },
          icon: "📜",
        },

        qi_absorption_celestial_1: {
          id: "qi_absorption_celestial_1",
          name: "Técnica de Absorción de Qi Celestial",
          description: "Una técnica de cultivo superior que alinea tu espíritu con los cielos, aumentando drásticamente la cantidad de Qi ganado por segundo al cultivar (+2.0 Qi/s).",
          type: "passive_cultivation",
          effect: { statToBoost: "qiPerSecondBase", value: 2.0 },
          maxLevel: 10, // Se puede mejorar para aumentar aún más el beneficio
          cultivationSettings: {
            baseTimeToLevelUp: 300, // Requiere más tiempo para subir de nivel que las básicas
            levelTimeMultiplier: 1.8,
          },
          icon: "🌌",
        },

        // =================================================================
        // == GRADO 1 (Rango: Discípulo Interno) - Nivel Mortal
        // =================================================================
        sword_t1: {
          id: "sword_t1",
          requiredRank: "Discípulo Interno",
          name: "Tajo del Viento Veloz (Inferior)",
          icon: "💨",
          description:
            "Un corte de espada rápido y eficiente. Un pilar del combate básico.",
          type: "active_ability",
          abilityId: "sword_t1",
          // --- INICIO DE LA MODIFICACIÓN ---
          effect: { 
            baseDamageMultiplier: 1.2,
            multiplierIncreasePerLevel: 0.2 // Aumenta el multiplicador en 0.2 por cada nivel.
          },
          // --- FIN DE LA MODIFICACIÓN ---
          manaCost: 10,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          cooldown: 1,
        },
        body_t1: {
          requiredRank: "Discípulo Interno",
          id: "body_t1",
          name: "Físico de Buey de Piedra (Inferior)",
          icon: "🐂",
          description:
            "Fortalece pasivamente tu cuerpo, aumentando tu Vida Máxima base.",
          type: "passive_stat",
          effect: { 
            statToBoost: "baseMaxHp", 
            value: 25 },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 120,
            levelTimeMultiplier: 1.7,
          },
        },
        formation_t1: {
          requiredRank: "Discípulo Interno",
          id: "formation_t1",
          name: "Matriz de Escudo de Qi (Inferior)",
          icon: "💠",
          description: "Crea un escudo temporal que absorbe daño. A niveles más altos, el escudo es más resistente e incluso restaura una pequeña cantidad de vida al ser invocado.",
          type: "active_ability",
          abilityId: "formation_t1",
          effect: {
              // --- VALORES MEJORADOS ---
              shieldValue: 50,                // Aumentado desde 40. Un mejor punto de partida.
              shieldIncreasePerLevel: 15,     // Aumentado. +15 de escudo por nivel es muy notable.
              duration: 3,
              // --- NUEVO EFECTO SECUNDARIO ---
              healOnCastLevelReq: 5,          // Requiere nivel 5 de la técnica para empezar a curar.
              healOnCastAmount: 20            // Cantidad base de la curación.
          },
          manaCost: 20,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 100, levelTimeMultiplier: 1.8 },
      },
      fire_t1: {
        requiredRank: "Discípulo Interno",
          id: "fire_t1",
          name: "Chispa Ígnea (Inferior)",
          icon: "🔥",
          description:
            "Lanza una pequeña bola de fuego que causa daño y puede aplicar una quemadura menor.",
          type: "active_ability",
          abilityId: "fire_t1",
          effect: {
            baseDamageMultiplier: 0.8,
            multiplierIncreasePerLevel: 0.1, // <-- MODIFICACIÓN AÑADIDA
            burnDamagePerTurn: 5,
            burnDamageIncreasePerLevel: 1, // <-- MODIFICACIÓN AÑADIDA
            burnDuration: 2,
          },
          manaCost: 15,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 110,
            levelTimeMultiplier: 1.7,
          },
        },
        lightning_t1: {
          requiredRank: "Discípulo Interno",
          id: "lightning_t1",
          name: "Dedo de Relámpago (Inferior)",
          icon: "⚡",
          description:
            "Un rápido chispazo de relámpago que puede aturdir brevemente al enemigo.",
          type: "active_ability",
          abilityId: "lightning_t1",
          effect: { 
            baseDamageMultiplier: 0.9,
            multiplierIncreasePerLevel: 0.1, // <-- MODIFICACIÓN AÑADIDA
            stunChance: 0.2,
            stunChanceIncreasePerLevel: 0.03, // <-- MODIFICACIÓN AÑADIDA
          },
          manaCost: 18,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 130,
            levelTimeMultiplier: 1.8,
          },
        },
        movement_t1: {
          requiredRank: "Discípulo Interno",
          id: "movement_t1",
          name: "Paso Veloz (Inferior)",
          icon: "👟",
          description: "Un movimiento rápido que te reposiciona, aumentando temporalmente tu defensa para el siguiente turno.",
          type: "active_ability",
          abilityId: "movement_t1",
          effect: { 
              tempDefenseBuff: 10, // Un bono fijo y simple para una técnica inicial
              buffDuration: 2,     // Dura tu turno actual y el siguiente del enemigo
              buffIncreasePerLevel: 2 // Aumenta el bono en 2 por cada nivel
          },
          manaCost: 15,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 100, levelTimeMultiplier: 1.7 }
      },

        // =================================================================
        // == GRADO 2 (Rango: Discípulo Principal) - Nivel Terrenal
        // =================================================================
        sword_t2: {
            id: "sword_t2",
            requiredRank: "Discípulo Principal", 
            name: "Estocada Perfora-Armadura (Terrenal)",
            icon: "🗡️",
            description: "Un ataque preciso que ignora una porción de la defensa enemiga y puede causar una herida sangrante.",
            type: "active_ability",
            abilityId: "sword_t2",
            effect: {
                // --- VALORES MEJORADOS ---
                baseDamageMultiplier: 1.8,      // Aumentado desde 1.1. Ahora es claramente más fuerte.
                defensePenetration: 0.3,        // Aumentado desde 0.25. Ignora más defensa.
                bleedChance: 0.3,               // NUEVO: 30% de probabilidad de causar hemorragia.
                bleedDamagePerTurn: 15,         // NUEVO: Daño de la hemorragia.
                bleedDuration: 2                // NUEVO: Duración de la hemorragia.
            },
            manaCost: 25,
            cooldown: 2,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 180, levelTimeMultiplier: 1.6 },
        },
        body_t2: {
          
          id: "body_t2",
          requiredRank: "Discípulo Principal", 
          name: "Piel de Acero Fundido (Terrenal)",
          icon: "🦾",
          description:
            "Aumenta pasivamente tu Defensa base, haciéndote más resistente.",
          type: "passive_stat",
          effect: { statToBoost: "baseDefense", value: 0.1 },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 200,
            levelTimeMultiplier: 1.7,
          },
        },
        formation_t2: {
          id: "formation_t2",
          requiredRank: "Discípulo Principal", 
          name: "Matriz de Grilletes de Qi (Terrenal)",
          icon: "🔗",
          description:
            "Una formación que intenta enraizar al enemigo. Consume maná cada turno y puede romperse si el enemigo ataca con fuerza.",
          type: "active_ability",
          abilityId: "formation_t2",
          effect: {
            rootDuration: 2,
            damagePerTurn: 10,
            damagePerTurnIncreasePerLevel: 2, // <-- MODIFICACIÓN AÑADIDA
            rootChance: 0.7,
            shacklesHP: 100, 
            shacklesHPIncreasePerLevel: 20, // <-- MODIFICACIÓN AÑADIDA
            manaUpkeep: 5,
          },
          manaCost: 30,
          cooldown: 3,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 190,
            levelTimeMultiplier: 1.8,
          },
        },
        movement_t2: {
          id: "movement_t2",
          requiredRank: "Discípulo Principal", 
          name: "Paso Etéreo (Terrenal)",
          icon: "👟",
          description: "Esquivas el próximo ataque. El movimiento fluido también aumenta tu defensa temporalmente. El bono de defensa aumenta con el nivel.",
          type: "active_ability",
          abilityId: "movement_t2",
          effect: {
              dodgeNextAttack: true,
              // --- NUEVAS PROPIEDADES ---
              tempDefenseBuff: 5,      // Defensa extra que otorga
              buffDuration: 2,         // Duración del buff en turnos
              buffIncreasePerLevel: 2  // Cuánto aumenta el buff de defensa por nivel
          },
          manaCost: 40,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 220, levelTimeMultiplier: 1.9 },
      },
      fire_t2: {
          id: "fire_t2",
          requiredRank: "Discípulo Principal", 
          name: "Aliento de Dragón Menor (Terrenal)",
          icon: "🐲",
          description:
            "Exhalas un cono de fuego que quema con mayor intensidad.",
          type: "active_ability",
          abilityId: "fire_t2",
          effect: {
            baseDamageMultiplier: 1.0,
            multiplierIncreasePerLevel: 0.2, // <-- MODIFICACIÓN AÑADIDA
            burnDamagePerTurn: 15,
            burnDamageIncreasePerLevel: 2, // <-- MODIFICACIÓN AÑADIDA
            burnDuration: 3,
          },
          manaCost: 35,
          cooldown: 3,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 200,
            levelTimeMultiplier: 1.7,
          },
        },
        lightning_t2: {
          id: "lightning_t2",
          requiredRank: "Discípulo Principal", 
          name: "Látigo de Trueno (Terrenal)",
          icon: "⚡️",
          description: "Un chasquido de energía eléctrica que golpea al enemigo, reduciendo su defensa temporalmente.",
          type: "active_ability",
          abilityId: "lightning_t2",
          effect: { 
              baseDamageMultiplier: 1.4,
              multiplierIncreasePerLevel: 0.15, // <-- MODIFICACIÓN AÑADIDA
              defenseReduction: 10,
              defenseReductionIncreasePerLevel: 1, // <-- MODIFICACIÓN AÑADIDA
              duration: 2
          },
          manaCost: 28,
          cooldown: 2,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 190, levelTimeMultiplier: 1.8 }
      },

        // =================================================================
        // == GRADO 3 (Rango: Diácono) - Nivel Marcial
        // =================================================================
        sword_t3: {
            id: "sword_t3",
            requiredRank: "Diácono",
            name: "Danza de Espada Ciclónica (Marcial)",
            icon: "🌪️",
            description: "Giras como un ciclón, golpeando al enemigo múltiples veces. El número de golpes aumenta con el nivel.",
            type: "active_ability",
            abilityId: "sword_t3",
            effect: {
                baseDamageMultiplier: 1.5,
                baseHits: 3, // <-- Nuevo: Golpes base
                hitsIncreasePerLevel: 0.5 // <-- Nuevo: Medio golpe por nivel (se redondeará)
            },
            manaCost: 50,
            cooldown: 2,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 300, levelTimeMultiplier: 1.6 },
        },
        body_t3: {
          id: "body_t3",
          requiredRank: "Diácono",
          name: "Corazón de Voluntad Indomable (Marcial)",
          icon: "❤️‍🔥",
          description:
            "Pasivamente, tu voluntad de hierro reduce una porción de todo el daño recibido.",
          type: "passive_stat",
          effect: { statToBoost: "damageReduction", value: 0.01 }, // Esto necesitará lógica en el cálculo de daño
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 350,
            levelTimeMultiplier: 1.7,
          },
        },
        formation_t3: {
            id: "formation_t3",
            requiredRank: "Diácono",
            name: "Matriz de Supresión Espiritual (Marcial)",
            icon: "🕸️",
            description: "Crea un campo que debilita al enemigo, reduciendo su ataque y defensa. El efecto es más potente con el nivel.",
            type: "active_ability",
            abilityId: "formation_t3",
            effect: { 
                baseReduction: 15, // <-- Nuevo
                reductionIncreasePerLevel: 3, // <-- Nuevo
                duration: 4 
            },
            manaCost: 45,
            cooldown: 5,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 320, levelTimeMultiplier: 1.8 },
        },
        lightning_t3: {
            id: "lightning_t3",
            requiredRank: "Diácono",
            name: "Jaula de Rayos (Marcial)",
            icon: "⛓️",
            description: "Encierra al enemigo en una jaula eléctrica, causando daño y con alta probabilidad de aturdir, ambos mejoran con el nivel.",
            type: "active_ability",
            abilityId: "lightning_t3",
            effect: {
                baseDamageMultiplier: 1.2,
                damageMultiplierIncreasePerLevel: 0.1, // <-- Nuevo
                baseStunChance: 0.5, // <-- Nuevo
                stunChanceIncreasePerLevel: 0.03, // <-- Nuevo
                duration: 2
            },
            manaCost: 60,
            cooldown: 4,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 380, levelTimeMultiplier: 1.8 },
        },
        movement_t3: {
          id: "movement_t3",
          requiredRank: "Diácono",
          name: "Parpadeo de Sombra (Marcial)",
          icon: "👻",
          description: "Te teletransportas instantáneamente detrás del enemigo para un golpe crítico garantizado. Su potencia aumenta con el nivel.", // Descripción mejorada
          type: "active_ability",
          abilityId: "movement_t3",
          effect: { 
              baseDamageMultiplier: 2.0, 
              multiplierIncreasePerLevel: 0.2, // <-- NUEVA PROPIEDAD DE ESCALADO
              isCritical: true 
          },
          manaCost: 55,
          cooldown: 3,
          maxLevel: 10,
          cultivationSettings: {
              baseTimeToLevelUp: 400,
              levelTimeMultiplier: 1.9,
          },
      },

        // =================================================================
        // == GRADO 4 (Rango: Anciano) - Nivel Soberano
        // =================================================================
        sword_t4: {
            id: "sword_t4",
            requiredRank: "Anciano",
            name: "Intención de Espada del Tirano (Soberano)",
            icon: "👑",
            description: "Canalizas tu Qi para una onda de energía que daña y puede aturdir. Su poder aumenta con el nivel.",
            type: "active_ability",
            abilityId: "sword_t4",
            effect: { 
                baseDamageMultiplier: 2.8,
                multiplierIncreasePerLevel: 0.25, // <-- Nuevo
                baseStunChance: 0.4, // <-- Nuevo
                stunChanceIncreasePerLevel: 0.02, // <-- Nuevo
            },
            manaCost: 70,
            cooldown: 1,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 500, levelTimeMultiplier: 1.5 },
        },
        body_t4: {
          id: "body_t4",
          requiredRank: "Anciano",
          name: "Cuerpo Dorado Inmortal (Soberano)",
          icon: "🌟",
          description:
            "Tu cuerpo se vuelve tan duro que regenera vida pasivamente incluso fuera del cultivo.",
          type: "passive_stat",
          effect: { statToBoost: "passiveHpRegen", value: 0.5 }, // Necesitará lógica en el game tick
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 600,
            levelTimeMultiplier: 1.6,
          },
        },
        fire_t4: {
            id: "fire_t4",
            requiredRank: "Anciano",
            name: "Sol Abrasador (Soberano)",
            icon: "☀️",
            description: "Creas un sol en miniatura que explota, causando daño masivo y dejando una quemadura intensa que escala con el nivel.", // Descripción actualizada
            type: "active_ability",
            abilityId: "fire_t4",
            effect: { 
                baseDamageMultiplier: 2.5,
                multiplierIncreasePerLevel: 0.3, 
                aoe: true,
                // --- INICIO DE LA MODIFICACIÓN ---
                burnDamagePerTurn: 30,       // Daño de quemadura base.
                burnDuration: 3,           // Duración de la quemadura en turnos.
                burnIncreasePerLevel: 5    // El daño de la quemadura aumenta en 5 por cada nivel.
                // --- FIN DE LA MODIFICACIÓN ---
            },
            manaCost: 80,
            cooldown: 4,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 550, levelTimeMultiplier: 1.6 },
        },
        lightning_t4: {
            id: "lightning_t4",
            requiredRank: "Anciano",
            name: "Llamada del Juicio del Trueno (Soberano)",
            icon: "🌩️",
            description: "Invocas un rayo celestial que ignora la defensa. Su daño base aumenta con el nivel.",
            type: "active_ability",
            abilityId: "lightning_t4",
            effect: { 
                baseDamageMultiplier: 2.0,
                multiplierIncreasePerLevel: 0.25, // <-- Nuevo
                ignoreDefense: true 
            },
            manaCost: 75,
            cooldown: 4,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 580, levelTimeMultiplier: 1.7 },
        },
        formation_t4: {
            id: "formation_t4",
            requiredRank: "Anciano",
            name: "Santuario Dorado Protector (Soberano)",
            icon: "🏰",
            description: "Una matriz defensiva definitiva que te hace inmune al daño. A niveles altos, dura un turno más.",
            type: "active_ability",
            abilityId: "formation_t4",
            effect: { 
                baseDuration: 2, // <-- Nuevo
                levelForExtraTurn: 7 // <-- Nuevo: A nivel 7, dura un turno extra
            },
            manaCost: 100,
            cooldown: 8,
            maxLevel: 10,
            cultivationSettings: { baseTimeToLevelUp: 620, levelTimeMultiplier: 1.8 },
        },
        movement_t4: {
          id: "movement_t4",
          requiredRank: "Anciano",
          name: "Danza del Viento Espectral (Soberano)",
          icon: "💃",
          description: "Un ataque veloz que confunde al enemigo, permitiéndote esquivar con certeza el siguiente golpe recibido.",
          type: "active_ability",
          abilityId: "movement_t4",
          effect: { 
              baseDamageMultiplier: 1.8, 
              multiplierIncreasePerLevel: 0.2, // <-- MODIFICACIÓN AÑADIDA
              dodgeNextAttack: true
          },
          manaCost: 65,
          cooldown: 1,
          maxLevel: 10,
          cultivationSettings: { baseTimeToLevelUp: 600, levelTimeMultiplier: 1.8 }
      },

        // =================================================================
        // == GRADO 5 (Rango: Gran Anciano) - Nivel Transcendente
        // =================================================================
        sword_t5: {
          id: "sword_t5",
          requiredRank: "Gran Anciano",
          name: "Corte que Divide Cielos y Tierra (Transcendente)",
          icon: "⚔️",
          description:
            "Una técnica legendaria que corta a través de cualquier defensa y causa daño verdadero.",
          type: "active_ability",
          abilityId: "sword_t5",
          effect: {
            baseDamageMultiplier: 4.0,
            multiplierIncreasePerLevel: 0.5, // <-- MODIFICACIÓN AÑADIDA
            trueDamage: true,
            criticalChance: 0.3,
            criticalChanceIncreasePerLevel: 0.02 // <-- MODIFICACIÓN AÑADIDA (2% más por nivel)
          },
          manaCost: 120,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 800,
            levelTimeMultiplier: 1.4,
          },
        },
        body_t5: {
            id: "body_t5",
            requiredRank: "Gran Anciano",
            name: "Constitución de Dragón Ancestral (Trascendente)",
            icon: "🐉",
            description: "Tu cuerpo alcanza la perfección dracónica, aumentando tu resistencia a efectos de estado y regenerando vida poderosamente.",
            type: "passive_stat",
            effect: {
                // === NUEVO SISTEMA DE RESISTENCIA ===
                statusResistChanceBase: 0.10,      // 10% de resistencia base al nivel 1
                statusResistChancePerLevel: 0.04,  // +4% de resistencia por cada nivel adicional
                // ===================================
                passiveHpRegen: 2.0,
            },
            maxLevel: 10,
            cultivationSettings: {
                baseTimeToLevelUp: 900,
                levelTimeMultiplier: 1.5,
            },
        },
        fire_t5: {
          id: "fire_t5",
          requiredRank: "Gran Anciano",
          name: "Llama del Fénix Renaciente (Transcendente)",
          icon: "🔥",
          description:
            "Invocas el fuego sagrado del fénix que causa daño masivo y puede resucitarte al morir.",
          type: "active_ability",
          abilityId: "fire_t5",
          effect: { 
            baseDamageMultiplier: 3.5, 
            aoe: true, 
            reviveChance: 0.25,
            reviveChanceIncreasePerLevel: 0.025 // <-- MODIFICACIÓN AÑADIDA (2.5% más por nivel)
          },
          manaCost: 150,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 850,
            levelTimeMultiplier: 1.5,
          },
        },
        lightning_t5: {
          id: "lightning_t5",
          requiredRank: "Gran Anciano",
          name: "Tribulación de los Nueve Cielos (Transcendente)",
          icon: "🌩️",
          description:
            "Canalizas el poder de la tribulación celestial para devastar a todos los enemigos.",
          type: "active_ability",
          abilityId: "lightning_t5",
          effect: {
            baseDamageMultiplier: 3.0,
            multiplierIncreasePerLevel: 0.4, // <-- MODIFICACIÓN AÑADIDA
            aoe: true,
            paralyzeChance: 0.6,
            paralyzeChanceIncreasePerLevel: 0.04, // <-- MODIFICACIÓN AÑADIDA
            duration: 2,
          },
          manaCost: 140,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 880,
            levelTimeMultiplier: 1.6,
          },
        },
        formation_t5: {
          id: "formation_t5",
          requiredRank: "Gran Anciano",
          name: "Matriz de Reversión del Cosmos (Transcendente)",
          icon: "🌌",
          description:
            "Una formación que invierte el daño recibido, convirtiéndolo en curación.",
          type: "active_ability",
          abilityId: "formation_t5",
          effect: { damageToHealingDuration: 3, reflectDamage: 0.5 },
          manaCost: 180,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 950,
            levelTimeMultiplier: 1.7,
          },
        },
        movement_t5: {
          id: "movement_t5",
          requiredRank: "Gran Anciano",
          name: "Paso del Vacío Infinito (Transcendente)",
          icon: "🌀",
          description:
            "Te mueves entre dimensiones, volviéndote intangible y atacando desde múltiples ángulos.",
          type: "active_ability",
          abilityId: "movement_t5",
          effect: {
            baseDamageMultiplier: 2.5,
            intangibleTurns: 2,
            multiHit: 3,
          },
          manaCost: 130,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 820,
            levelTimeMultiplier: 1.8,
          },
        },

        // =================================================================
        // == GRADO 6 (Rango: Patriarca) - Nivel Celestial
        // =================================================================
        sword_t6: {
          id: "sword_t6",
          requiredRank: "Maestro de Secta",
          name: "Espada del Emperador (Celestial)",
          icon: "👑",
          description:
            "El arte supremo de la espada que puede cortar a través del destino mismo.",
          type: "active_ability",
          abilityId: "sword_t6",
          effect: {
            baseDamageMultiplier: 6.0,
            multiplierIncreasePerLevel: 0.5, // <-- MODIFICACIÓN AÑADIDA
            ignoreAllEffects: true,
            executeThreshold: 0.2,
            executeThresholdIncreasePerLevel: 0.01 // <-- MODIFICACIÓN AÑADIDA (1% más de umbral por nivel)
          },
          manaCost: 200,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1200,
            levelTimeMultiplier: 1.3,
          },
        },
        body_t6: {
          id: "body_t6",
          requiredRank: "Maestro de Secta",
          name: "Cuerpo Inmortal de Jade (Celestial)",
          icon: "💎",
          description:
            "Tu cuerpo trasciende la mortalidad, volviéndose prácticamente indestructible.",
          type: "passive_stat",
          effect: {
            statToBoost: "damageReduction",
            value: 0.01,
            deathSaveChance: 0.2,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1400,
            levelTimeMultiplier: 1.4,
          },
        },
        fire_t6: {
          id: "fire_t6",
          requiredRank: "Maestro de Secta",
          name: "Incineración del Mundo Mortal (Celestial)",
          icon: "🌋",
          description:
            "Reduces todo a cenizas con el fuego que arde desde el núcleo de la creación.",
          type: "active_ability",
          abilityId: "fire_t6",
          effect: {
            baseDamageMultiplier: 5.0,
            aoe: true,
            burnDamagePerTurn: 100,
            burnDuration: 5,
          },
          manaCost: 250,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1300,
            levelTimeMultiplier: 1.4,
          },
        },
        lightning_t6: {
          id: "lightning_t6",
          requiredRank: "Maestro de Secta",
          name: "Decreto del Señor del Trueno (Celestial)",
          icon: "⚡",
          description:
            "Como señor de las tormentas, tu palabra se convierte en ley absoluta.",
          type: "active_ability",
          abilityId: "lightning_t6",
          effect: {
            baseDamageMultiplier: 4.5,
            aoe: true,
            silenceDuration: 3,
            stunChance: 0.8,
          },
          manaCost: 220,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1350,
            levelTimeMultiplier: 1.5,
          },
        },
        formation_t6: {
          id: "formation_t6",
          requiredRank: "Maestro de Secta",
          name: "Matriz del Sello del Demonio (Celestial)",
          icon: "🔒",
          description:
            "Sella completamente al enemigo, impidiendo todas sus acciones por varios turnos.",
          type: "active_ability",
          abilityId: "formation_t6",
          effect: { sealDuration: 4, damagePerTurn: 50 },
          manaCost: 300,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1500,
            levelTimeMultiplier: 1.6,
          },
        },
        movement_t6: {
          id: "movement_t6",
          requiredRank: "Maestro de Secta",
          name: "Omnipresencia Divina (Celestial)",
          icon: "👁️",
          description:
            "Existes en múltiples lugares simultáneamente, atacando desde todas partes.",
          type: "active_ability",
          abilityId: "movement_t6",
          effect: { baseDamageMultiplier: 3.0, unavoidable: true, multiHit: 5 },
          manaCost: 280,
          cooldown: 6,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 1250,
            levelTimeMultiplier: 1.7,
          },
        },

        // =================================================================
        // == GRADO 7 (Rango: Soberano Supremo) - Nivel Legendario
        // =================================================================
        sword_t7: {
          id: "sword_t7",
          requiredRank: "Maestro de Secta",
          name: "Lamento del Fin del Mundo",
          icon: "🗡️",
          description:
            "Una técnica que lleva la esencia de la destrucción apocalíptica.",
          type: "active_ability",
          abilityId: "sword_t7",
          effect: {
            baseDamageMultiplier: 8.0,
            aoe: true,
            ignoreAllDefenses: true,
            lifeSteal: 0.5,
          },
          manaCost: 350,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2000,
            levelTimeMultiplier: 1.2,
          },
        },
        body_t7: {
          id: "body_t7",
          requiredRank: "Maestro de Secta",
          name: "Forma del Ancestro Primordial",
          icon: "🌟",
          description:
            "Tu cuerpo alcanza la forma perfecta de los antiguos dioses creadores.",
          type: "passive_stat",
          effect: {
            statToBoost: "allStats",
            multiplier: 2.0,
            regenAllPerTurn: true,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2500,
            levelTimeMultiplier: 1.3,
          },
        },
        fire_t7: {
          id: "fire_t7",
          requiredRank: "Maestro de Secta",
          name: "Génesis Ígneo",
          icon: "🔥",
          description:
            "El fuego que creó el universo, capaz de destruir y recrear la realidad.",
          type: "active_ability",
          abilityId: "fire_t7",
          effect: {
            baseDamageMultiplier: 7.0,
            aoe: true,
            resetEnemyBuffs: true,
            burnDamagePerTurn: 200,
          },
          manaCost: 400,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2200,
            levelTimeMultiplier: 1.3,
          },
        },
        lightning_t7: {
          id: "lightning_t7",
          requiredRank: "Maestro de Secta",
          name: "Cólera del Emperador Celestial",
          icon: "⚡",
          description:
            "La ira divina se manifiesta como rayos que juzgan a todos los seres.",
          type: "active_ability",
          abilityId: "lightning_t7",
          effect: {
            baseDamageMultiplier: 6.5,
            aoe: true,
            judgmentEffect: true,
            chainLightning: 10,
          },
          manaCost: 380,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2300,
            levelTimeMultiplier: 1.4,
          },
        },
        formation_t7: {
          id: "formation_t7",
          requiredRank: "Maestro de Secta",
          name: "Matriz del Caos Primordial",
          icon: "🌀",
          description:
            "Invocas el caos que existía antes de la creación para deshacer a tus enemigos.",
          type: "active_ability",
          abilityId: "formation_t7",
          effect: { randomCatastrophicEffects: true, reality_distortion: 5 },
          manaCost: 450,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2800,
            levelTimeMultiplier: 1.5,
          },
        },
        movement_t7: {
          id: "movement_t7",
          requiredRank: "Maestro de Secta",
          name: "Danza del Tejido Espacio-Tiempo",
          icon: "🌌",
          description:
            "Manipulas el espacio y el tiempo para existir en múltiples momentos simultáneamente.",
          type: "active_ability",
          abilityId: "movement_t7",
          effect: {
            baseDamageMultiplier: 4.0,
            timeLoop: 3,
            spacialDistortion: true,
          },
          manaCost: 420,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 2400,
            levelTimeMultiplier: 1.6,
          },
        },

        // =================================================================
        // == GRADO 8 (Rango: Emperador Inmortal) - Nivel Épico
        // =================================================================
        sword_t8: {
          id: "sword_t8",
          requiredRank: "Maestro de Secta",
          name: "Decreto Imperial: Extinción",
          icon: "👑",
          description:
            "Como emperador, tu palabra es ley absoluta. Decretas la extinción de tus enemigos.",
          type: "active_ability",
          abilityId: "sword_t8",
          effect: {
            baseDamageMultiplier: 12.0,
            instantKillChance: 0.3,
            ignoreAllProtections: true,
          },
          manaCost: 500,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 3500,
            levelTimeMultiplier: 1.1,
          },
        },
        body_t8: {
          id: "body_t8",
          requiredRank: "Maestro de Secta",
          name: "Avatar del Dao Eterno",
          icon: "☯️",
          description:
            "Te conviertes en la manifestación física del Dao, trascendiendo todas las limitaciones.",
          type: "passive_stat",
          effect: {
            statToBoost: "transcendence",
            value: true,
            immuneToAll: true,
          },
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 4000,
            levelTimeMultiplier: 1.2,
          },
        },
        fire_t8: {
          id: "fire_t8",
          requiredRank: "Maestro de Secta",
          name: "Apocalipsis de Llamas Divinas",
          icon: "🔥",
          description:
            "El fuego que consume universos enteros, purificando la existencia misma.",
          type: "active_ability",
          abilityId: "fire_t8",
          effect: {
            baseDamageMultiplier: 10.0,
            aoe: true,
            purificationEffect: true,
            universeScaleDamage: true,
          },
          manaCost: 600,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 3800,
            levelTimeMultiplier: 1.2,
          },
        },
        lightning_t8: {
          id: "lightning_t8",
          requiredRank: "Maestro de Secta",
          name: "Tribulación del Fin de los Tiempos",
          icon: "⚡",
          description:
            "Invocas la tribulación final que marcará el fin de una era.",
          type: "active_ability",
          abilityId: "lightning_t8",
          effect: {
            baseDamageMultiplier: 9.0,
            aoe: true,
            eraEndingEffect: true,
            temporalDamage: true,
          },
          manaCost: 550,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 3600,
            levelTimeMultiplier: 1.3,
          },
        },
        formation_t8: {
          id: "formation_t8",
          requiredRank: "Maestro de Secta",
          name: "Matriz de Reescritura de la Realidad",
          icon: "📜",
          description:
            "Reescribes las leyes fundamentales de la realidad a tu favor.",
          type: "active_ability",
          abilityId: "formation_t8",
          effect: {
            realityRewrite: true,
            lawManipulation: true,
            existenceControl: 7,
          },
          manaCost: 700,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 4500,
            levelTimeMultiplier: 1.4,
          },
        },
        movement_t8: {
          id: "movement_t8",
          requiredRank: "Maestro de Secta",
          name: "Trascendencia Dimensional",
          icon: "🌀",
          description:
            "Trasciendes las limitaciones dimensionales, existiendo en todas las dimensiones.",
          type: "active_ability",
          abilityId: "movement_t8",
          effect: {
            baseDamageMultiplier: 6.0,
            dimensionalTravel: true,
            omnipresence: true,
          },
          manaCost: 650,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 4200,
            levelTimeMultiplier: 1.5,
          },
        },

        // =================================================================
        // == GRADO 9 (Rango: Soberano del Dao) - Nivel Mítico Supremo
        // =================================================================
        sword_t9: {
          id: "sword_t9",
          requiredRank: "Maestro de Secta",
          name: "Corte del Origen Absoluto",
          icon: "⚔️",
          description:
            "Cortas a través del origen mismo de la existencia, negando la realidad de tus enemigos.",
          type: "active_ability",
          abilityId: "sword_t9",
          effect: {
            baseDamageMultiplier: 20.0,
            existenceNegation: true,
            conceptualDamage: true,
          },
          manaCost: 800,
          cooldown: 8,
          maxLevel: 10,
          cultivationSettings: {
            baseTimeToLevelUp: 6000,
            levelTimeMultiplier: 1.0,
          },
        },
      };

      // ===  DICCIONARIO DE HABILIDADES DE ENEMIGOS ===
      const enemyAbilityData = {
        // --- BUFFS (Mejoras al enemigo) ---

        stone_skin_1: {
          name: "Piel de Piedra",
          type: "buff_stat",
          logMessage: (enemyName, defenseBoost, duration) =>
            `${enemyName} usa Piel de Piedra. ¡Su defensa aumenta en ${defenseBoost} por ${duration} turnos!`,
          effect: {
            stat: "defense", // La estadística a mejorar
            amount: 15, // Cuánto aumenta
            duration: 3, // Cuántos turnos dura
          },
        },
        // --- DEBUFFS (Perjuicios al jugador) ---
        armor_break: {
          name: "Golpe Rompe-Armadura",
          type: "debuff_stat",
          logMessage: (enemyName, damage, reduction, duration) =>
            `¡${enemyName} usa un Golpe Rompe-Armadura! Recibes ${damage} de daño y tu defensa se reduce en ${reduction} por ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 1.2,
            debuff: {
              stat: "defense",
              amount: 10,
              duration: 3,
            },
          },
        },
        thorns_aura: {
          name: "Aura de Espinas",
          type: "buff_reflect",
          logMessage: (enemyName, reflectPercent, duration) =>
            `${enemyName} se rodea de un Aura de Espinas. ¡Reflejará un ${reflectPercent}% del daño durante ${duration} turnos!`,
          effect: {
            reflectChance: 1.0, // 100% de probabilidad de reflejar
            reflectMultiplier: 0.25, // Refleja el 25% del daño
            duration: 2,
          },
        },
        armor_piercing_strike: {
          name: "Golpe Perforante",
          type: "piercing_damage",
          logMessage: (enemyName, damage) =>
            `${enemyName} utiliza un Golpe Perforante que ignora parte de tu armadura, ¡causando ${damage} de daño!`,
          effect: {
            baseDamageMultiplier: 1.1,
            armorPenetration: 0.3, // 30% de la defensa del jugador será ignorada
          },
        },
        intimidating_roar: {
          name: "Rugido Intimidante",
          type: "debuff_stat_no_damage", // Un debuff que no hace daño directo
          logMessage: (enemyName, reduction, duration) =>
            `¡${enemyName} suelta un Rugido Intimidante! Tu ataque se reduce en ${reduction} por ${duration} turnos.`,
          effect: {
            debuff: {
              stat: "attack",
              amount: 8,
              duration: 3,
            },
          },
        },

        // --- ATAQUES CON DAÑO EN EL TIEMPO (DoT) ---
        fire_breath: {
          name: "Aliento de Fuego",
          type: "dot_damage",
          logMessage: (enemyName, damage, burnDmg, duration) =>
            `¡${enemyName} te envuelve en su Aliento de Fuego! Recibes ${damage} de daño y quedas quemado por ${burnDmg} de daño durante ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 0.8,
            dot: {
              type: "burn", // 'burn', 'poison', 'curse', etc.
              damagePerTurn: 8,
              duration: 3,
            },
          },
        },

        poison_sting: {
          name: "Picadura Venenosa",
          type: "dot_damage",
          logMessage: (enemyName, damage, poisonDmg, duration) =>
            `¡${enemyName} te clava su Aguijón Venenoso! Recibes ${damage} de daño y quedas envenenado por ${poisonDmg} de daño durante ${duration} turnos.`,
          effect: {
            baseDamageMultiplier: 0.5, // El golpe inicial no es tan fuerte
            poison: {
              damagePerTurn: 10, // Daño base del veneno
              duration: 3,
            },
          },
        },
        // Una maldición que drena el maná del jugador cada turno
        mana_curse: {
          name: "Maldición de Maná",
          type: "dot_resource", // <--- TIPO NUEVO (DoT que afecta un recurso)
          logMessage: (enemyName, manaDrain, duration) =>
            `${enemyName} te maldice, ¡drenando ${manaDrain} de tu maná cada turno durante ${duration} turnos!`,
          effect: {
            dot: {
              resource: "mana", // El recurso a drenar
              drainPerTurn: 15,
              duration: 3,
            },
          },
        },
        shattering_curse: {
          name: "Maldición Quebrantadora",
          type: "debuff_stat_percent", // Nuevo tipo de habilidad
          logMessage: (enemyName, percent, duration) => `${enemyName} lanza una Maldición Quebrantadora. ¡Tu defensa se reduce en un ${percent}% por ${duration} turnos!`,
          effect: {
              debuff: {
                  stat: "defense",
                  percentage: 0.3, // Reduce la defensa en un 30%
                  duration: 3,
              }
          }
      },

        // Habilidad que causa daño basado en el % de vida máxima del jugador
        abyssal_drain: {
            name: "Drenaje Abismal",
            type: "percent_hp_damage", // Nuevo tipo
            logMessage: (enemyName, damage) => `${enemyName} usa Drenaje Abismal, arrancando un trozo de tu fuerza vital y causándote ${damage} de daño!`,
            effect: {
                percentage: 0.25 // Causa un 25% de la vida máxima del jugador como daño
            }
        },

        // Habilidad de daño verdadero que ignora toda defensa
        reality_tear: {
            name: "Desgarro de Realidad",
            type: "true_damage", // Nuevo tipo
            logMessage: (enemyName, damage) => `${enemyName} desgarra el tejido de la realidad, ¡causándote ${damage} de daño verdadero que ignora toda defensa!`,
            effect: {
                damage: 500 // Un valor fijo y alto de daño verdadero
            }
        },
        // --- HABILIDADES DE CURACIÓN Y ROBO DE VIDA ---
        basic_heal: {
          name: "Recuperación Menor",
          type: "heal",
          logMessage: (enemyName, healAmount) =>
            `${enemyName} se concentra y recupera ${healAmount} de vida.`,
          effect: {
            healAmount: 50,
          },
        },
        life_drain: {
          name: "Drenaje Vital",
          type: "heal_damage", // Hace daño Y se cura
          logMessage: (enemyName, damage, healAmount) =>
            `¡${enemyName} usa Drenaje Vital! Te roba ${damage} de vida y se cura ${healAmount}.`,
          effect: {
            baseDamageMultiplier: 0.8,
            lifesteal: 0.5, // 50% del daño infligido se convierte en curación para el enemigo
          },
        },

        //--- HABILIDADES DE ATURDIMIENTO
        concussive_blow: {
          name: "Golpe Conmocionador",
          type: "stun_chance", // <--- TIPO NUEVO
          logMessage: (enemyName, damage, didStun) => {
            let msg = `${enemyName} te asesta un Golpe Conmocionador, infligiendo ${damage} de daño.`;
            if (didStun) {
              msg += " ¡Quedas aturdido y pierdes tu próximo turno!";
            }
            return msg;
          },
          effect: {
            baseDamageMultiplier: 0.7, // Menos daño directo a cambio del potente efecto
            stunChance: 0.4, // 40% de probabilidad de aturdir
          },
        },

        //  HABILIDADES DE BLANCO ESPECIAL

        //  Un ataque que golpea a un clon si está activo, o al jugador si no.
        clone_hunter: {
          name: "Cazador de Ilusiones",
          type: "special_target_damage", // <--- TIPO NUEVO
          logMessage: (enemyName, damage, target) => {
            if (target === "clone") {
              return `${enemyName} usa Cazador de Ilusiones y destruye tu clon!`;
            } else {
              return `${enemyName} usa Cazador de Ilusiones, ¡y te golpea directamente con ${damage} de daño!`;
            }
          },
          effect: {
            baseDamageMultiplier: 1.5, // Muy dañino si no hay clon
          },
        },
      };
//PATRONES DE FORMACIONES /  RUNAS
      const FORMATION_PATTERNS = {

      fengs_initiation_seal: {
            name: "Sello de Iniciación de Feng",
            description: "Un patrón de tres puntos simple, usado para probar la habilidad de un estudiante para canalizar Qi.",
            pattern: [ // Un patrón simple de 3x3
                [0, 1, 0],
                [1, 0, 1],
                [0, 0, 0]
            ],
            effect: {
                type: 'utility_mission_trigger' // Un tipo especial solo para completar la misión
            }
        },
      shattering_hexagram: {
          name: "Hexagrama Devastador",
          description: "Un patrón ofensivo que quiebra las defensas del enemigo al inicio del combate.",
          // El patrón es una matriz 5x5. 0=vacío, 1=runa, 2=centro (enemigo)
          pattern: [
              [0, 1, 0, 1, 0],
              [0, 0, 0, 0, 0],
              [1, 0, 0, 0, 1],
              [0, 0, 0, 0, 0],
              [0, 1, 0, 1, 0]
          ],
          effect: {
              type: 'enemy_debuff',
              stat: 'defense',
              amount: 50, // Reduce la defensa en 50 puntos
              duration: 'permanent', // Dura toda la batalla
              sourcePatternId: 'shattering_hexagram'
          }
      },
      verdant_life_circle: {
          name: "Círculo de Vida Frondoso",
          description: "Un círculo de energía vital que te cura al inicio de cada uno de tus turnos en combate.",
          pattern: [
              [0, 1, 1, 1, 0],
              [1, 0, 0, 0, 1],
              [1, 0, 0, 0, 1],
              [1, 0, 0, 0, 1],
              [0, 1, 1, 1, 0]
          ],
          effect: {
              type: 'player_buff',
              stat: 'hpRegenPerTurn',
              amount: 20, // Regenera 20 HP por turno en batalla
              sourcePatternId: 'verdant_life_circle'
          }
      },
      arcane_vortex_array: {
        name: "Matriz del Vórtice Arcano",
        description: "Una formación asimétrica que crea un pozo de energía espiritual, aumentando tu regeneración de maná durante el combate.",
        // Patrón: [0,0,1,1,1;1,0,0,0,1;0,0,2,0,0;1,0,0,0,1;1,1,1,0,0]
        pattern: [
            [0, 0, 1, 1, 1],
            [1, 0, 0, 0, 1],
            [0, 0, 0, 0, 0],
            [1, 0, 0, 0, 1],
            [1, 1, 1, 0, 0]
        ],
        effect: {
            type: 'player_buff',
            stat: 'manaRegenPerTurn', // Usaremos una nueva propiedad para esto
            amount: 15, // Regenera 15 de Maná por turno en batalla
            sourcePatternId: 'arcane_vortex_array'
        }
    },

    aegis_of_the_mountain: {
        name: "Égida de la Montaña Inamovible",
        description: "Este patrón de sellado canaliza la solidez de la tierra, otorgándote un significativo aumento de defensa al inicio del combate.",
        // Patrón: [1,1,1,1,1;1,0,0,0,1;1,0,2,0,1;0,0,0,0,0;0,0,1,0,0]
        // CORRECCIÓN: Tu patrón tenía un error de simetría, lo ajusté ligeramente para que tenga más sentido visual.
        // Si prefieres el original, simplemente copia y pega el tuyo. Este es el corregido:
        pattern: [
            [1, 1, 1, 1, 1],
            [1, 0, 0, 0, 1],
            [1, 0, 0, 0, 1],
            [1, 0, 0, 0, 1],
            [0, 0, 1, 0, 0]
        ],
        effect: {
            type: 'player_buff',
            stat: 'defenseBoost',
            amount: 40, // Aumenta la defensa en 40 puntos para toda la batalla
            sourcePatternId: 'aegis_of_the_mountain'
        }
    },
        emergency_return_matrix: {
        name: "Matriz de Retorno de Emergencia",
        description: "Una matriz que abre un portal directo al centro de la secta.",
        // El patrón es 3x3. El jugador estará en el centro (1) al completarlo.
        pattern: [
            [1, 0, 1],
            [0, 1, 0],
            [1, 0, 1]
        ],
        effect: {
            type: 'utility_teleport',
            // ¡Importante! Este ID debe coincidir con un teletransportador en TELEPORTER_DATA
            destinationId: 'tp_sect_hub' 
        }
    },
      // ¡Puedes añadir más patrones aquí en el futuro!
  };

      const entityTypes = {
        //FIJOS
        shop: {
          symbol: "🏪",
          name: "Tienda Misteriosa",
          spriteUrl: "img/shop.png",
          interaction: "browse",
          type: "shop", // 'type' es importante para la interacción
          // fixedX: 12, // Podrías tener esto
          // fixedY: 13, // O esto
          fixedLocation: { x: 12, y: 13 }, // O esto (preferiblemente esto)
          discovered: true, // ¡IMPORTANTE para que se muestre desde el inicio!
        },
        tutorial_formation_mural: {
            symbol: "🎨",
            name: "Mural de Formaciones Antiguas",
            spriteUrl: "img/mural_formaciones.png", // ¡Necesitarás crear esta imagen! (Ver nota abajo)
            interaction: "read_formation_tutorial", // Una nueva interacción específica
            fixedLocation: { x: 19, y: 14 }, // Cerca de la Anciana Su en la "biblioteca"
            discovered: true, // Para que sea visible desde el principio
        },
        mural_circulo_vital: {
          symbol: "🎨",
          name: "Mural Desgastado",
          spriteUrl: "img/mural_formaciones.png", // Puedes reutilizar la imagen existente
          interaction: "read_lore", // Un nuevo tipo de interacción
          loreText: "La imagen muestra ocho figuras rodeando a una novena en un círculo protector. Una inscripción casi ilegible reza: '...y en el abrazo de los ocho, la vida misma florece de nuevo...'",
          fixedLocation: { x: 58, y: 12 }, // Una ubicación escondida en el Bosque Esmeralda Profundo
          discovered: true,
      },

        secta_entrada_principal: {
          symbol: "⛩️",
          name: "Salón Principal de la Secta",
          spriteUrl: "img/secta.png",
          interaction: "access_sect_hall",
          // fixedX: 12, // Si tenías esto antes
          // fixedY: 15, // Si tenías esto antes
          // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 15, y: 15 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },
        secta_entrada_principal_2: {
          symbol: "",
          name: "Salón Principal de la Secta",
          
          interaction: "access_sect_hall",
          // fixedX: 12, // Si tenías esto antes
          // fixedY: 15, // Si tenías esto antes
          // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 16, y: 15 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },
        secta_entrada_principal_3: {
          symbol: "",
          name: "Salón Principal de la Secta",
          
          interaction: "access_sect_hall",
          // fixedX: 12, // Si tenías esto antes
          // fixedY: 15, // Si tenías esto antes
          // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 15, y: 14 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },
        secta_entrada_principal_4: {
          symbol: "",
          name: "Salón Principal de la Secta",
          
          interaction: "access_sect_hall",
          // fixedX: 12, // Si tenías esto antes
          // fixedY: 15, // Si tenías esto antes
          // ASEGÚRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 16, y: 14 }, // O las coordenadas correctas para tu secta
          discovered: true,
        },

        // --- ELEMENTOS DECORATIVOS ---
        deco_pino: {
          symbol: "🌳",
          name: "Pino",
          spriteUrl: "img/pino.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_pequeño: {
          symbol: "🌳",
          name: "Pino",
          spriteUrl: "img/arbol.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_normal: {
          symbol: "",
          name: "Otro arbol",
          spriteUrl: "img/arbol.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_desierto: {
          symbol: "🪨",
          name: "Roca Musgosa",
          spriteUrl: "img/deco_desierto.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_agua_estancada: {
          name: "Agua Estancada",
          spriteUrl: "img/agua_estancada.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_pantano: {
          symbol: "🌳",
          name: "Arbol Pantano",
          spriteUrl: "img/arbol_pantano.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_ruina_pilar: {
          symbol: "🏛",
          name: "Pilar Caído",
          spriteUrl: "img/columnas.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        }, // Usar un símbolo diferente si '🏛️' ya está en uso
        deco_flor_rara: {
          symbol: "🌸",
          name: "Flor Luminiscente",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_montaña: {
          symbol: "🏛",
          name: "Montaña",
          spriteUrl: "img/terreno_mont.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_montaña_large: {
          symbol: "🏛",
          name: "Montaña",
          spriteUrl: "img/deco_montaña_large.png",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        // === NUEVAS DECORACIONES DE ALTO NIVEL ===
        deco_huesos_gigantes: {
          symbol: "🦴",
          name: "Restos de Dragón",
          spriteUrl: "img/deco_huesos.png", // Necesitarás una imagen para esto
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_cristal_corrupto: {
          symbol: "🔮",
          name: "Cristal Demoníaco",
          spriteUrl: "img/deco_cristal_corrupto.png", // Necesitarás una imagen para esto
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },

        ///----------------- FIN DECORACIONES------------
        /// ============================  NPCs  ========================================
        npc_secta_guia: {
          symbol: "👨‍🏫",
          name: "Guía Lin",
          spriteUrl: "img/guia_lin.png",
          interaction: "talk_secta_npc",
          npcId: "guia_lin",
          fixedLocation: { x: 13, y: 15 },
          discovered: true,
        },
        npc_secta_admin: {
          symbol: " 👴",
          name: "Administrador Yao",
          spriteUrl: "img/adm_yao.png",
          interaction: "talk_secta_npc",
          npcId: "admin_yao",
          fixedLocation: { x: 17, y: 15 },
          discovered: true,
        },
        npc_anciana_su: {
          symbol: "👵",
          name: "Anciana Su, la Archivista",
          spriteUrl: "img/anciana_su.png",
          interaction: "talk_story_npc",
          npcId: "anciana_su",
          fixedLocation: { x: 18, y: 14 },
          discovered: true,
        },
        npc_maestro_jian: {
          symbol: "👑",
          name: "Maestro de Secta Jian",
          spriteUrl: "img/maestro_jian.png",
          interaction: "talk_story_npc",
          npcId: "maestro_jian",
          fixedLocation: { x: 15, y: 18 },
          discovered: true,
        },
        npc_maestro_feng: {
          symbol: "🗺️",
          name: "Maestro Feng, el Cartógrafo",
          spriteUrl: "img/maestro_feng.png", // Necesitarás un sprite de un erudito anciano
          interaction: "talk_dynamic_npc", // Usaremos la función de diálogos dinámicos
          npcId: "npc_maestro_feng",
          fixedLocation: { x: 2, y: 23 }, // 
          discovered: false // El jugador debe descubrirlo primero
        },
        santuario_del_eco: {
          symbol: "⛩️",
          name: "Santuario del Eco",
          spriteUrl: "img/santuario_eco.png",
          interaction: "interact_shrine",
          type: "story_shrine",
          fixedLocation: { x: 180, y: 40 },
          discovered: false,
        },
        rival_interno_1: {
          symbol: "😠",
          name: "Han Li (Guardián Interno)",
          spriteUrl: "img/rival_1.png",
          typeOverride: "monster",
          hp: 250,
          attack: 60,
          defense: 15,
          exp: 150,
          maxHp: 250,
          isSectChallengeRival: true,
          npcId: "rival_interno_1",
          fixedLocation: { x: 5, y: 12 },
        },
        rival_principal_1: {
          symbol: "😡",
          name: "Anciana Shui (Prueba Principal)",
          spriteUrl: "img/rival_2.png",
          typeOverride: "monster",
          hp: 600,
          attack: 90,
          defense: 25,
          exp: 400,
          maxHp: 600,
          isSectChallengeRival: true,
          npcId: "rival_principal_1",
          fixedLocation: { x: 4, y: 12 },
          specialChance: 0.2,
          specialAttackMultiplier: 1.6,
        },
        guardian_diacono_1: {
          symbol: "👨‍⚖️",
          name: "Guardián de la Arena, Feng (Prueba de Diácono)",
          spriteUrl: "img/rival_3.png", // Necesitarás una imagen para él
          typeOverride: "monster",
          level: 28,
          hp: 2000,
          maxHp: 2000,
          attack: 150,
          defense: 80,
          exp: 1500,
          isSectChallengeRival: true,
          npcId: "guardian_diacono_1", // ID único para la misión
          abilities: [
            { abilityId: "armor_piercing_strike", chance: 0.3 },
            { abilityId: "stone_skin_1", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [300, 400],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 6, y: 14 }, // Posición en la Arena de la Secta
        },

        guardian_anciano_1: {
          symbol: "👴",
          name: "Anciano Guardián, Yao (Prueba de Anciano)",
          spriteUrl: "img/adm_yao.png", // Necesitarás una imagen para él
          typeOverride: "monster",
          level: 45,
          hp: 4500,
          maxHp: 4500,
          attack: 300,
          defense: 150,
          exp: 4000,
          isSectChallengeRival: true,
          npcId: "guardian_anciano_1",
          abilities: [
            { abilityId: "thorns_aura", chance: 0.25 },
            { abilityId: "life_drain", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [800, 1000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 7, y: 14 }, // Posición en la Arena de la Secta
        },

        guardian_gran_anciano_1: {
          symbol: "👵",
          name: "Gran Anciano de la Hoja, Lin (Prueba de Gran Anciano)",
          spriteUrl: "img/guia_lin.png", // Necesitarás una imagen para ella
          typeOverride: "monster",
          level: 62,
          hp: 8000,
          maxHp: 8000,
          attack: 550,
          defense: 220,
          exp: 8000,
          isSectChallengeRival: true,
          npcId: "guardian_gran_anciano_1",
          abilities: [
            { abilityId: "clone_hunter", chance: 0.3 },
            { abilityId: "concussive_blow", chance: 0.25 },
            { abilityId: "basic_heal", chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [1500, 2000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 5, y: 15 }, // Posición en la Arena de la Secta
        },

        guardian_maestro_1: {
          symbol: "👑",
          name: "Maestro de Secta Anterior (Prueba Final)",
          spriteUrl: "img/maestro_jian.png", // Necesitarás una imagen para él
          typeOverride: "monster",
          level: 75,
          hp: 15000,
          maxHp: 15000,
          attack: 700,
          defense: 300,
          exp: 15000,
          isSectChallengeRival: true,
          npcId: "guardian_maestro_1",
          abilities: [
            { abilityId: "mana_curse", chance: 0.4 },
            { abilityId: "intimidating_roar", chance: 0.3 },
            { abilityId: "fire_breath", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Sello del Maestro de Secta",
              quantity: [1, 1],
              chance: 1.0,
            },
          ], // Un item único como prueba
          fixedLocation: { x: 6, y: 15 }, // Posición en la Arena de la Secta
        },
         // EL RIVAL
         npc_rival_xiao: {
          symbol: "😠",
          name: "Xiao Chen, el Prodigio Celoso",
          spriteUrl: "img/rival_1.png", // Puedes reusar un sprite o crear uno nuevo
          interaction: "talk_dynamic_npc",
          npcId: "rival_xiao",
          // Su ubicación cambiará, así que no es fija. Lo haremos aparecer dinámicamente.
          discovered: true
        },

        // EL MENTOR/ALQUIMISTA
        npc_alquimista_mo: {
          symbol: "⚗️",
          name: "Viejo Mo, el Alquimista del Pantano",
          spriteUrl: "img/alquimista_mo.png", // Necesitarás un sprite de un anciano ermitaño
          interaction: "talk_dynamic_npc",
          npcId: "alquimista_mo",
          fixedLocation: { x: 88, y: 12 }, // Un lugar apartado en la Ciénaga Sombría
          discovered: false // El jugador debe encontrarlo
        },
        
        // LA RENEGADA
        npc_renegada_li: {
            symbol: "👤",
            name: "Li Mei, la Exiliada",
            spriteUrl: "img/renegada_li.png", // Un sprite de cultivadora solitaria
            interaction: "talk_dynamic_npc",
            npcId: "renegada_li",
            // Aparecerá en las ruinas después de cierto punto de la trama
            fixedLocation: { x: 530, y: 530 },
            discovered: false
        },
        //== FIN NPC===
        //RECURSOS
        cristal_qi: {
          symbol: "💎",
          name: "Cristal de Qi",
          spriteUrl: "img/cristal_de_qi.png",
          reward: "Cristales de Qi",
          interaction: "collect_resource",
        },
        piedras_espirituales: {
          symbol: "💎",
          name: "Piedra espiritual",
          spriteUrl: "img/piedra_esp.png",
          reward: "Piedras Espirituales",
          interaction: "collect_resource",
        },
        cultivation: {
          symbol: "🌸",
          name: "Lugar de Cultivo",
          benefit: "mana",
          manaGain: 20,
          interaction: "meditate_spot",
        },
        resource_hierbas_bosque: {
          symbol: "🌿", // <--- ¡ASEGÚRATE DE QUE ESTO ESTÉ!
          name: "Hierbas del Bosque Profundo",
          spriteUrl: "img/hierbas.png",
          type: "resource",
          reward: "Hierbas Medicinales",
          interaction: "collect_resource",
        },
        // Tipo genérico para la plataforma
        teleport_platform: {
          symbol: "🌀",
          name: "Matriz de Teletransporte",
          spriteUrl: "img/teleport_plat.png", // ¡Necesitarás crear o encontrar esta imagen!
          interaction: "activate_teleporter", // Esta es la nueva interacción clave
          discovered: true, // Queremos que se vean en el mapa desde el principio
        },
        tp_sect_hub: {
          symbol: "🌀",
          name: "Matriz Central",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",
          teleporterId: "tp_sect_hub",
          fixedLocation: { x: 15, y: 10 },
          discovered: true,
        },
        tp_forest_shrine: {
          symbol: "🌀",
          name: "Matriz Bosque esmeralda",
          spriteUrl: "img/teleport_plat.png",

          teleporterId: "tp_forest_shrine",
          interaction: "activate_teleporter",
          fixedLocation: { x: 45, y: 25 },

          discovered: true,
        },
        tp_desert_oasis: {
          symbol: "🌀",
          name: "Matriz Desierto",
          spriteUrl: "img/teleport_plat.png",
          teleporterId: "tp_desert_oasis",
          interaction: "activate_teleporter",
          fixedLocation: { x: 40, y: 60 },
          discovered: false,
        },
        tp_swamp_ruin: {
          symbol: "🌀",
          name: "Matriz Ruinas 1",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",
          teleporterId: "tp_swamp_ruin",
          fixedLocation: { x: 75, y: 30 },
          discovered: false,
        },
        tp_desfiladero: {
          symbol: "🌀",
          name: "Matriz desfiladero",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",
          teleporterId: "tp_desfiladero",
          fixedLocation: { x: 125, y: 30 },
          discovered: false,
        },
        tp_dragon_valley: {
          symbol: "🌀",
          name: "Matriz del Valle del Dragón",
          spriteUrl: "img/teleport_plat.png",
          interaction: "activate_teleporter",  // La interacción clave
          teleporterId: "tp_dragon_valley",    // ¡DEBE coincidir con el ID de TELEPORTER_DATA!
          fixedLocation: { x: 150, y: 15 },    // La ubicación física DENTRO del valle
          discovered: true, // Para que sea visible en cuanto entres a la zona
      },

        // === NUEVAS ENTIDADES DE TRANSICIÓN ===
        transition_ruins_entrance: {
          symbol: "🌀",
          name: "Entrada a las Ruinas",
          spriteUrl: "img/entrada_ruinas.png", // Crea o usa una imagen para el portal
          interaction: "transition",
          fixedLocation: { x: 45, y: 45 }, // Ubicación en el mundo principal
          targetX: 501, // Coordenada X de destino (dentro de la zona de ruinas)
          targetY: 501, // Coordenada Y de destino
          discovered: true,
        },
        transition_ruins_exit: {
          symbol: "🌀",
          name: "Salida de las Ruinas",
          spriteUrl: "img/portal.png",
          interaction: "transition",
          fixedLocation: { x: 501, y: 500 }, // Ubicación DENTRO de las ruinas
          targetX: 45, // Coordenada X de destino (de vuelta al mundo principal)
          targetY: 45, // Coordenada Y de destino (aparece al lado de la entrada)
          discovered: true,
        },
        transition_valley_entrance: {
          symbol: "🌀",
          name: "Entrada al valle del Dragón",
          spriteUrl: "img/entrada_valle_dragon.png", // Crea o usa una imagen para el portal
          interaction: "transition",
          fixedLocation: { x: 143, y: 20 }, // Ubicación en el mundo principal
          targetX: 147, // Coordenada X de destino (dentro de la zona de ruinas)
          targetY: 20, // Coordenada Y de destino
          discovered: true,
        },
        transition_valley_exit: {
          symbol: "🌀",
          name: "Salida del valle del Dragón",
          spriteUrl: "img/entrada_valle_dragon.png",
          interaction: "transition",
          fixedLocation: { x: 147, y: 20 }, // Ubicación DENTRO de las ruinas
          targetX: 143, // Coordenada X de destino (de vuelta al mundo principal)
          targetY: 20, // Coordenada Y de destino (aparece al lado de la entrada)
          discovered: true,
        },
        transition_fisura_entrance: {
          symbol: "🌀",
          name: "Entrada a la Fisura Demoníaca",
          spriteUrl: "img/portal.png", // Puedes reutilizar un sprite de portal
          interaction: "transition",
          fixedLocation: { x: 200, y: 47 }, // Colócalo en una zona accesible del mapa principal
          targetX: 401, // Coordenada X de destino (dentro de la Fisura)
          targetY: 11,  // Coordenada Y de destino
          discovered: true,
      },
      transition_fisura_exit: {
          symbol: "🌀",
          name: "Salida de la Fisura",
          spriteUrl: "img/portal.png",
          interaction: "transition",
          fixedLocation: { x: 401, y: 10 }, // Ubicación DENTRO de la Fisura
          targetX: 140, // Coordenada X de vuelta al mapa principal
          targetY: 60,  // Coordenada Y de vuelta
          discovered: true,
      },

        //ENEMIGOS
        lider_renegado_kai: {
            symbol: "👤",
            name: "Líder Cultor Renegado Kai",
            spriteUrl: "img/renegado_Kai.png",
            type: "mission_boss", // Un tipo específico en lugar de un override.
            typeOverride: "monster",
            hp: 500,
            level: 15,
            attack: 70,
            defense: 25,
            exp: 250,
            maxHp: 500,
            isMiniBoss: true,
            specialChance: 0.25,
            specialAttackMultiplier: 1.6,
            lootTable: [
                { itemName: "Compás Espiritual Antiguo", quantity: [1, 1], chance: 1.0 }, // ¡Garantizado!
                { itemName: "Píldora de Qi Condensado", quantity: [1, 1], chance: 0.3 },
                { itemName: "Piedras Espirituales", quantity: [10, 20], chance: 0.8 },
            ],
            fixedLocation: { x: 55, y: 35 } // Por ejemplo, en el Bosque Esmeralda Profundo
        },
        monster: {
          symbol: "👹",
          name: "Demonio Menor",
          spriteUrl: "img/demonio_menor.png",
          level: 2,
          hp: 90,
          attack: 30,
          defense: 2,
          exp: 25,
          maxHp: 90,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_secta_debil: {
          symbol: "🐾",
          name: "Bestia Menor de Pradera",
          spriteUrl: "img/monstruo_pradera.png",
          level: 1,
          hp: 40,
          attack: 30,
          defense: 1,
          exp: 12,
          maxHp: 40,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_bosque_lobo: {
          symbol: "🐺",
          name: "Lobo del Bosque",
          spriteUrl: "img/lobo_bosque.png",
          hp: 170,
          level: 2,
          attack: 40,
          defense: 3,
          exp: 20,
          maxHp: 170,
          lootTable: [
            { itemName: "Colmillo de Lobo", quantity: [1, 1], chance: 0.4 },
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.6,
            },
            { itemName: "Tinta Rúnica", quantity: [1, 2], chance: 0.6 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
          ],
        },
        monster_bosque_arana: {
          symbol: "🕷️",
          name: "Araña Tejesombras",
          hp: 250,
          level: 1,
          attack: 45,
          defense: 5,
          exp: 18,
          maxHp: 250,
          lootTable: [
            { itemName: "Seda de Araña", quantity: [1, 3], chance: 0.7 },
            { itemName: "Veneno Débil", quantity: [1, 1], chance: 0.2 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
            {
              itemName: "Raíz de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.3,
            },
          ],
        },

        monster_desierto_escorpion: {
          symbol: "🦂",
          name: "Escorpión de las Dunas",
          spriteUrl: "img/escorpion.png",
          hp: 390,
          level: 9,
          attack: 30,
          defense: 10,
          exp: 35,
          maxHp: 390,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              abilityId: "poison_sting", // ID de la habilidad en enemyAbilityData
              chance: 0.4, // 40% de probabilidad de usar esta habilidad en su turno
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Tinta Rúnica", quantity: [1, 2], chance: 0.6 },
            { itemName: "Aguijón de Escorpión", quantity: [1, 1], chance: 0.5 },
            { itemName: "Quitina Resistente", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
          ],
        },
        monster_desierto_golem_arena: {
          symbol: "🧱",
          name: "Golem de Tormenta de Arena",
          spriteUrl: "img/golem_arena.png",
          hp: 400,
          level: 12,
          attack: 35,
          defense: 15,
          exp: 80,
          maxHp: 400,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              abilityId: " piel_de_piedra", // ID de la habilidad en enemyAbilityData
              chance: 0.4, // 40% de probabilidad de usar esta habilidad en su turno
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [2, 3], chance: 0.3 },
            { itemName: "Núcleo de Arena", quantity: [1, 1], chance: 0.6 },
            { itemName: "Fragmento Desértico", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
          ],
        },
        monster_cienaga_serpiente: {
          symbol: "🐍",
          name: "Serpiente de Ciénaga",
          spriteUrl: "img/serpiente.png",
          hp: 360,
          level: 15,
          attack: 50,
          defense: 6,
          exp: 100,
          maxHp: 360,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              abilityId: "poison_sting", // ID de la habilidad en enemyAbilityData
              chance: 0.3,
            },
          ],
          lootTable: [
            { itemName: "Escama de Serpiente", quantity: [1, 2], chance: 0.5 },
            
            { itemName: "Veneno de Ciénaga", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [4, 7], chance: 1 },
          ],
        },
        cultivator_rival_low: {
          symbol: "😠",
          name: "Cultivador Novato Hostil",
          spriteUrl: "img/cultivador_hostil.png",
          hp: 150,
          level: 5,
          attack: 50,
          defense: 5,
          exp: 80,
          maxHp: 150,
          specialChance: 0.2,
          specialAttackMultiplier: 1.5,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            { itemName: "Tinta Rúnica", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_alpha: {
          symbol: "🐺",
          name: "Lobo Alfa",
          spriteUrl: "img/lobo_alfa.png",
          hp: 200,
          level: 9,
          attack: 60,
          defense: 4,
          exp: 100,
          maxHp: 200,
          abilities: [
            { abilityId: "armor_break", chance: 0.3 },
            { abilityId: "intimidating_roar", chance: 0.2 },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            {
              itemName: "Núcleo de Bestia Menor",
              quantity: [1, 1],
              chance: 0.25,
            },
            { itemName: "Cristal de Hielo", quantity: [1, 2], chance: 0.1 },
            { itemName: "Esencia de Fuego", quantity: [1, 2], chance: 0.1 },
            { itemName: "Piedras Espirituales", quantity: [4, 10], chance: 1 },
          ],
        },
        cultivator_adept_hostile: {
          symbol: "😡",
          name: "Cultivador Adepto Agresivo",
          spriteUrl: "img/cultivador_hostil.png",
          hp: 400,
          level: 15,
          attack: 80,
          defense: 20,
          exp: 250,
          maxHp: 400,
          specialChance: 0.25,
          specialAttackMultiplier: 1.7,
          healChance: 0.1,
          lootTable: [
            { itemName: "Piedras Espirituales", quantity: [5, 10], chance: 1 },
            { itemName: "Cristales de Qi", quantity: [3, 10], chance: 0.3 },
            { itemName: "Tinta Rúnica", quantity: [3, 6], chance: 1 },
           
            { itemName: "Fragmentos de Jade", quantity: [1, 2], chance: 0.02 },
            { itemName: "Esencia Oscura", quantity: [1, 1], chance: 0.05 },
           
          
          ],
        },

        flor_luna_escarchada_guardian: {
          symbol: "❄️",
          name: "Espíritu de Hielo Protector",
          typeOverride: "monster",
          hp: 120,
          level: 5,
          attack: 35,
          defense: 10,
          exp: 40,
          maxHp: 120,
          lootTable: [
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.8,
            },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
          ],
        },
        raiz_fuego_terrenal_elemental: {
          symbol: "🔥",
          name: "Elemental de Magma Menor",
          typeOverride: "monster",
          hp: 150,
          level: 17,
          attack: 40,
          defense: 5,
          exp: 45,
          maxHp: 150,
          lootTable: [
            {
              itemName: "Raíz de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.7,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [5, 10],
              chance: 0.5,
            },
          ],
        },
        

        esqueleto_podrido: {
          symbol: "💀",
          name: "Esqueleto podrido",
          spriteUrl: "img/esqueleto_1.png",
          typeOverride: "monster",
          hp: 500,
          maxHp: 500,
          level: 20,
          attack: 80,
          defense: 30,
          exp: 120,
          abilities: [
            { abilityId: "mana_curse", chance: 0.35 }, // Dificulta a los jugadores que usan maná
            { abilityId: "basic_heal", chance: 0.2 }, // Prolonga el combate curándose
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [8, 10],
              chance: 0.8,
            },
          ],
        },
        jabali_alfa_1: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 53, y: 26 },
        },
        jabali_alfa_2: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 55, y: 26 },
        },
        jabali_alfa_3: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 57, y: 26 },
        },
        jabali_alfa_4: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 59, y: 26 },
        },
        jabali_alfa_5: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 50, y: 28 },
        },
        jabali_alfa_6: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 28 },
        },
        jabali_alfa_7: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 54, y: 28 },
        },
        jabali_alfa_8: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 56, y: 30 },
        },
        jabali_alfa_9: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            /* (mismo loot) */
          ],
          fixedLocation: { x: 58, y: 30 },
        },
        jabali_alfa_10: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 55, y: 32 },
        },
        jabali_alfa_10: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 30 },
        },
        jabali_alfa_11: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 32 },
        },
        jabali_alfa_12: {
          symbol: "🐗",
          name: "Jabalí Colmilludo",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 300,
          level: 9,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,

          lootTable: [
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },

            { itemName: "Piedras Espirituales", quantity: [4, 6], chance: 1 },
          ],
          fixedLocation: { x: 52, y: 34 },
        },
        // ==========================================================
        // === NUEVOS ENEMIGOS DE NIVEL MEDIO (10-20) ===
        // ==========================================================

        // --- ENEMIGOS DEL BOSQUE PROFUNDO ---

        // 1. Osa Mayor Esmeralda (Tanque con Buff de Defensa)
        osa_mayor_esmeralda: {
          symbol: "🐻",
          name: "Osa Mayor Esmeralda",
          spriteUrl: "img/osa_mayor.png", // Necesitarías un sprite para este
          level: 12,
          hp: 1450,
          maxHp: 1450,
          attack: 90,
          defense: 25,
          exp: 150,
          abilities: [
            { abilityId: "stone_skin_1", chance: 0.3 }, // Se vuelve muy dura
            { abilityId: "concussive_blow", chance: 0.15 }, // Un golpe poderoso pero poco frecuente
          ],
          lootTable: [
            {
              itemName: "Piel de Bestia Gruesa",
              quantity: [1, 2],
              chance: 0.7,
            },
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [2, 4],
              chance: 0.5,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 20],
              chance: 1.0,
            },
          ],
        },

        // 2. Treant Anciano (Drenaje de Recursos y Curación)
        treant_anciano: {
          symbol: "🌳",
          name: "Treant Anciano",
          spriteUrl: "img/treant.png", // Necesitarías un sprite para este
          level: 12,
          hp: 600,
          maxHp: 600,
          attack: 80,
          defense: 30,
          exp: 220,
          abilities: [
            { abilityId: "mana_curse", chance: 0.35 }, // Dificulta a los jugadores que usan maná
            { abilityId: "basic_heal", chance: 0.2 }, // Prolonga el combate curándose
          ],
          lootTable: [
            {
              itemName: "Corazón de Madera Viviente",
              quantity: [1, 1],
              chance: 0.4,
            },
            { itemName: "Tinta Rúnica", quantity: [4, 8], chance: 1 },
            { itemName: "Semillas Ancestrales", quantity: [1, 3], chance: 0.2 },
            {
              itemName: "Piedras Espirituales",
              quantity: [15, 25],
              chance: 1.0,
            },
          ],
        },

        // --- ENEMIGOS DE LA CIÉNAGA SOMBRÍA ---

        // 3. Basilisco de Ciénaga (Aturdimiento y Veneno)
        basilisco_cienaga: {
          symbol: "🦎",
          name: "Basilisco de Ciénaga",
          spriteUrl: "img/basilisco.png", // Necesitarías un sprite para este
          level: 12,
          hp: 1380,
          maxHp: 1380,
          attack: 65,
          defense: 80,
          exp: 300,
          abilities: [
            { abilityId: "concussive_blow", chance: 0.25 }, // Simula una mirada petrificante con el stun
            { abilityId: "poison_sting", chance: 0.4 }, // Su mordida es venenosa
          ],
          lootTable: [
            { itemName: "Ojo de Basilisco", quantity: [1, 1], chance: 0.3 },
            { itemName: "Escamas Iridiscentes", quantity: [2, 3], chance: 0.6 },
            {
              itemName: "Piedras Espirituales",
              quantity: [12, 22],
              chance: 1.0,
            },
          ],
        },
        bandido_desfiladero: {
          symbol: "😠",
          name: "Bandido del Desfiladero",
          spriteUrl: "img/mercenario.png",
          typeOverride: "monster",
          hp: 600,
          level: 14,
          attack: 100,
          defense: 80,
          exp: 600,
          maxHp: 600,
          healChance: 0.15,
          abilities: [
            { abilityId: "stone_skin_1", chance: 0.4 }, // Siempre mantiene su defensa alta
            { abilityId: "concussive_blow", chance: 0.2 }, // Golpe de escudo
            { abilityId: "armor_piercing_strike", chance: 0.6 },
            { itemName: "Tinta Rúnica", quantity: [5, 10], chance: 1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 30],
              chance: 0.5,
            },
           
          ],
          
        },
        // 4. Espectro del Pantano (Drena Vida y Debilita)
        espectro_pantano: {
          symbol: "👻",
          name: "Espectro del Pantano",
          spriteUrl: "img/espectro.png", // Necesitarías un sprite para este
          level: 11,
          hp: 550,
          maxHp: 550,
          attack: 100,
          defense: 15, // Baja defensa física, pero peligroso
          exp: 250,
          abilities: [
            { abilityId: "life_drain", chance: 0.8 }, // Se cura a costa del jugador
            { abilityId: "intimidating_roar", chance: 0.25 }, // Su lamento debilita el ataque
          ],
          lootTable: [
            { itemName: "Esencia Espectral", quantity: [1, 2], chance: 0.5 },
            { itemName: "Almas Condenadas", quantity: [1, 1], chance: 0.25 },
            {
              itemName: "Piedras Espirituales",
              quantity: [20, 30],
              chance: 1.0,
            },
          ],
        },

        // --- ENEMIGOS DEL DESIERTO ABRASADOR ---

        // 5. Djinn de las Arenas (Ataque perforante)
        djinn_arenas: {
          symbol: "🧞",
          name: "Djinn de las Arenas",
          spriteUrl: "img/djinn.png", // Necesitarías un sprite para este
          level: 12,
          hp: 650,
          maxHp: 650,
          attack: 100,
          defense: 20,
          exp: 300,
          abilities: [
            { abilityId: "armor_piercing_strike", chance: 0.4 }, // Su cimitarra de viento corta cualquier armadura
            { abilityId: "fire_breath", chance: 0.2 }, // Aliento abrasador del desierto
          ],
          lootTable: [
            {
              itemName: "Corazón de Tormenta de Arena",
              quantity: [1, 1],
              chance: 0.2,
            },
            { itemName: "Esencia de Fuego", quantity: [2, 4], chance: 0.5 },
            {
              itemName: "Piedras Espirituales",
              quantity: [25, 40],
              chance: 1.0,
            },
          ],
        },

        // 6. Gusano de las Dunas Colosal (Tanque con reflejo de daño)
        gusano_dunas_colosal: {
          symbol: "🐛",
          name: "Gusano de las Dunas Colosal",
          spriteUrl: "img/gusano.png", // Necesitarías un sprite para este
          level: 13,
          hp: 1000,
          maxHp: 1000,
          attack: 160,
          defense: 60,
          exp: 500,
          abilities: [
            { abilityId: "thorns_aura", chance: 0.3 }, // Su piel quitinosa daña a los atacantes
            { abilityId: "armor_break", chance: 0.2 }, // Su mordida aplastante rompe defensas
          ],
          lootTable: [
    
            {
              itemName: "Piedras Espirituales",
              quantity: [50, 75],
              chance: 1.0,
            },
          ],
        },

        // --- CULTIVADORES RIVALES Y BANDIDOS ---

        // 7. Cultivador Renegado (Equilibrado y peligroso)
        cultivador_renegado: {
          symbol: "😡",
          name: "Cultivador Renegado",
          spriteUrl: "img/cultivador_hostil.png", // Un sprite de cultivador más avanzado
          level: 14,
          hp: 500,
          maxHp: 500,
          attack: 75,
          defense: 50,
          exp: 1000,
          abilities: [
            { abilityId: "armor_piercing_strike", chance: 0.25 }, // Sabe dónde golpear
            { abilityId: "basic_heal", chance: 0.15 }, // Usa píldoras para curarse
            { abilityId: "fire_breath", chance: 0.2 }, // Usa una técnica de fuego
            { itemName: "Tinta Rúnica", quantity: [10, 20], chance: 1 },
          ],
          lootTable: [
            {
              itemName: "Píldora de Recuperación Menor",
              quantity: [1, 2],
              chance: 0.3,
            },
           /*  {
              itemName: "Rollo: Técnica Aleatoria Menor",
              quantity: [1, 1],
              chance: 0.05,
            }, // Requeriría una lógica de loot especial */
            {
              itemName: "Piedras Espirituales",
              quantity: [30, 50],
              chance: 1.0,
            },
          ],
        },

        // 8. Mercenario Acorazado (Defensa y Stun)//valle del dragon
        mercenario_acorazado: {
          symbol: "🛡️",
          name: "Mercenario Acorazado",
          spriteUrl: "img/mercenario.png", // Necesitarías un sprite para este
          level: 18,
          hp: 1500,
          maxHp: 1500,
          attack: 150,
          defense: 70,
          exp: 1600,
          abilities: [
            { abilityId: "stone_skin_1", chance: 0.4 }, // Siempre mantiene su defensa alta
            { abilityId: "concussive_blow", chance: 0.2 }, // Golpe de escudo
          ],
          lootTable: [
            {
              itemName: "Fragmento de Armadura Pesada",
              quantity: [1, 1],
              chance: 0.6,
            },
            {
              itemName: "Contrato de Mercenario",
              quantity: [1, 1],
              chance: 0.1,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [15, 25],
              chance: 1.0,
            },
          ],
        },

        // --- ENEMIGOS DE RUINAS ANTIGUAS ---

        // 9. Guardián de Terracota (Defensivo y con Reflejo)
        guardian_terracota: {
          symbol: "🗿",
          name: "Guardián de Terracota",
          spriteUrl: "img/guardian_terracota.png", // Necesitarías un sprite para este
          level: 10,
          hp: 1000,
          maxHp: 1000,
          attack: 70,
          defense: 50,
          exp: 350,
          abilities: [
            { abilityId: "thorns_aura", chance: 0.25 }, // Su superficie encantada devuelve el daño
            { abilityId: "stone_skin_1", chance: 0.25 }, // Se endurece aún más
            { abilityId: "armor_break", chance: 0.15 }, // Un golpe para ablandar al objetivo
          ],
          lootTable: [
            { itemName: "Fragmentos de Jade", quantity: [2, 5], chance: 0.5 },
            {
              itemName: "Núcleo de Golem Antiguo",
              quantity: [1, 1],
              chance: 0.2,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [40, 60],
              chance: 1.0,
            },
          ],
        },

        // 10. Ilusionista Sombrío (Cazador de Clones y Drenaje de Maná)// valle del dragon
        ilusionista_sombrio: {
          symbol: "👤",
          name: "Ilusionista Sombrío",
          spriteUrl: "img/ilusionista.png", // Necesitarías un sprite para este
          level: 20,
          hp: 800,
          maxHp: 800,
          attack: 85, // Golpea duro si te pilla sin defensas
          defense: 40,
          exp: 320,
          abilities: [
            { abilityId: "clone_hunter", chance: 0.5 }, // Su principal estrategia es eliminar clones
            { abilityId: "mana_curse", chance: 0.3 }, // Te deja sin recursos para contraatacar
          ],
          lootTable: [
    
            {
              itemName: "Piedras Espirituales",
              quantity: [35, 55],
              chance: 1.0,
            },
          ],
        },
        // === NUEVOS ENEMIGOS Y JEFES DE ALTO NIVEL ===

        // -- Nivel Diácono (Nivel 15-18) --
        cultivador_secta_rival: {
          symbol: "⚔️",
          name: "Cultivador de la Secta de la Llama Negra",
          spriteUrl: "img/rival_1.png",
          level: 15,
          hp: 800,
          maxHp: 800,
          attack: 170,
          defense: 80,
          exp: 450,
          abilities: [
            { abilityId: "fire_breath", chance: 0.3 },
            { abilityId: "armor_piercing_strike", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Píldora de Recuperación Menor",
              quantity: [1, 2],
              chance: 0.2,
            },
            {
              itemName: "Insignia de Secta Rival",
              quantity: [1, 1],
              chance: 0.5,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [40, 60],
              chance: 1.0,
            },
            { itemName: "Tinta Rúnica", quantity: [10, 20], chance: 1 },

          ],
        },
        murcielago_cristal_sangriento: {
          symbol: "🦇",
          name: "Murciélago de Cristal Sangriento",
          spriteUrl: "img/murcielago_sangre.png",
          level: 16,
          hp: 800,
          maxHp: 800,
          attack: 190,
          defense: 80,
          exp: 500,
          abilities: [{ abilityId: "life_drain", chance: 0.4 }],
          lootTable: [
            {
              itemName: "Cristal de Sangre Puro",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [50, 75],
              chance: 1.0,
            },
          ],
        },
        diacono_renegado_jin: {
          symbol: "👿",
          name: "Diácono Renegado Jin (Jefe)",
          spriteUrl: "img/rival_3.png",
          typeOverride: "monster",
          level: 17,
          hp: 2500,
          maxHp: 2500,
          attack: 180,
          defense: 60,
          exp: 2000,
          isBoss: true,
          abilities: [
            { abilityId: "thorns_aura", chance: 0.3 },
            { abilityId: "armor_break", chance: 0.25 },
            { abilityId: "basic_heal", chance: 0.15 },
          ],
          lootTable: [
           
            {
              itemName: "Piedras Espirituales",
              quantity: [50, 100],
              chance: 1.0,
            },
            {
            itemName: "Rollo: Técnica de Absorción de Qi Celestial",
              quantity: [1, 1],
              chance: 1.0, // 
            },
            { itemName: "Tinta Rúnica", quantity: [20, 50], chance: 1 },
          ],
          fixedLocation: { x: 90, y: 15 }, // Ubicación en el Desfiladero
        },

        // -- Nivel Anciano (Nivel 35-45) --
        draco_hueso_antiguo: {
          symbol: "🐉",
          name: "Draco de Hueso Antiguo",
          spriteUrl: "img/draco_hueso.png",
          level: 18,
          hp: 1500,
          maxHp: 1500,
          attack: 250,
          defense: 100,
          exp: 1200,
          abilities: [
            { abilityId: "intimidating_roar", chance: 0.3 },
            { abilityId: "mana_curse", chance: 0.2 },
            { abilityId: 'fire_breath', chance: 0.3 },
          ],
          lootTable: [
            {
              itemName: "Escama de Dragón Espectral",
              quantity: [1, 2],
              chance: 0.4,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [200, 250],
              chance: 1.0,
            },
          ],
        },
        draco_hueso_antiguo_boss: {
          symbol: "🐉",
          name: "Draco de Hueso Antiguo (BOSS)",
          spriteUrl: "img/draco_hueso_boss.png",
          level: 19,
          hp: 2000,
          maxHp: 2000,
          attack: 280,
          defense: 120,
          exp: 12000,
          abilities: [
            { abilityId: "intimidating_roar", chance: 0.8 },
            { abilityId: "mana_curse", chance: 0.5 },
            { abilityId: 'fire_breath', chance: 0.3 }
          ],
          lootTable: [
            {
              itemName: "Escama de Dragón Espectral",
              quantity: [1, 2],
              chance: 0.4,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [1000, 1200],
              chance: 1.0,
            },
          ],
        },
        espectro_tifonico: {
          symbol: "🌪️",
          name: "Espectro Tifónico",
          spriteUrl: "img/espectro_tifon.png",
          level: 18,
          hp: 1200,
          maxHp: 1200,
          attack: 300,
          defense: 80,
          exp: 1500,
          abilities: [
            { abilityId: "mana_curse", chance: 0.4 },
            { abilityId: "concussive_blow", chance: 0.6 },
          ],
          lootTable: [
            { itemName: "Corazón de Tifón", quantity: [1, 1], chance: 0.25 },
            {
              itemName: "Piedras Espirituales",
              quantity: [120, 250],
              chance: 1.0,
            },
          ],
        },
        emperador_lich_del_valle: {
          symbol: "👑",
          name: "Emperador Lich del Valle (Jefe)",
          spriteUrl: "img/lich_emperador.png",
          typeOverride: "monster",
          level: 19,
          hp: 5000,
          maxHp: 5000,
          attack: 600,
          defense: 120,
          exp: 5000,
          isBoss: true,
          // --- LÍNEA CLAVE AÑADIDA ---
          // Ahora el jefe tiene un ID que el sistema de misiones puede reconocer.
          npcId: "emperador_lich_del_valle",
          // --- FIN DE LA LÍNEA AÑADIDA ---
          abilities: [
              { abilityId: "life_drain", chance: 0.3 },
              { abilityId: "mana_curse", chance: 0.3 },
              { abilityId: "clone_hunter", chance: 0.2 },
          ],
          lootTable: [
              { itemName: "Filacteria del Lich", quantity: [1, 1], chance: 1.0 },
              { itemName: "Rollo: Técnica de Anciano Aleatoria", quantity: [1, 1], chance: 1.0 },
              { itemName: "Piedras Espirituales", quantity: [200, 250], chance: 1.0 },
          ],
          fixedLocation: { x: 200, y: 42 },
      },

        // -- Nivel Gran Anciano (Nivel 50-60) --
        demonio_de_la_fisura: {
          symbol: "👹",
          name: "Demonio de la Fisura",
          spriteUrl: "img/demonio_fisura.png",
          level: 20,
          hp: 2500,
          maxHp: 2500,
          attack: 500,
          defense: 350,
          exp: 3000,
          abilities: [
            {
              abilityId: "fire_breath",
              chance: 0.5,
              effect: { burnDamagePerTurn: 50000, duration: 3 },
            },
            { abilityId: "reality_tear", chance: 0.3 },
            { abilityId: "armor_break", chance: 0.6 },
            { abilityId: "shattering_curse", chance: 0.4 },
            { abilityId: "armor_piercing_strike", chance: 0.6 },
          ],
          lootTable: [
            {
              itemName: "Fragmento de la Fisura",
              quantity: [1, 1],
              chance: 0.4,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [250, 400],
              chance: 1.0,
            },
          ],
        },
        guardian_celestial_caido: {
          symbol: "👼",
          name: "Guardián Celestial Caído",
          spriteUrl: "img/guardian_caido.png",
          level: 25,
          hp: 4000,
          maxHp: 4000,
          attack: 550,
          defense: 450,
          exp: 4000,
          abilities: [
          { abilityId: "reality_tear", chance: 0.3 },
            { abilityId: "stone_skin_1", chance: 0.3 },
            { abilityId: "basic_heal", chance: 0.6 },
            { abilityId: "armor_piercing_strike", chance: 0.2 },
          ],
          lootTable: [
            { itemName: "Lágrima Celestial", quantity: [1, 1], chance: 0.2 },
            {
              itemName: "Piedras Espirituales",
              quantity: [300, 500],
              chance: 1.0,
            },
          ],
        },
        general_demoniaco_abismal: {
          symbol: "😈",
          name: "General Demoníaco Abismal (Jefe)",
          spriteUrl: "img/general_abismal.png",
          typeOverride: "monster",
          level: 65,
          hp: 10000,
          maxHp: 10000,
          attack: 700,
          defense: 500,
          exp: 10000,
          isBoss: true,
          abilities: [
            { abilityId: "abyssal_drain", chance: 0.4 }, 
            { abilityId: "shattering_curse", chance: 0.3 }, 
            { abilityId: "intimidating_roar", chance: 0.4 },
            { abilityId: "thorns_aura", chance: 0.3 },
            { abilityId: "fire_breath", chance: 0.2 },
          ],
          lootTable: [
            { itemName: "Corazón del Abismo", quantity: [1, 1], chance: 1.0 },
            {
              itemName: "Rollo: Técnica de Gran Anciano Aleatoria",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [2000, 3000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 425, y: 35 }, // Ubicación en la Fisura
        },

        // -- Nivel Maestro de Secta (Nivel 70+) --
        avatar_del_dao_corrupto: {
          symbol: "☯️",
          name: "Avatar del Dao Corrupto (Jefe Final)",
          spriteUrl: "img/avatar_dao.png",
          typeOverride: "monster",
          level: 80,
          hp: 25000,
          maxHp: 25000,
          attack: 800,
          defense: 300,
          exp: 50000,
          isBoss: true,
          abilities: [
            { abilityId: "mana_curse", chance: 0.5 },
            { abilityId: "life_drain", chance: 0.4 },
            { abilityId: "thorns_aura", chance: 0.3 },
            { abilityId: "concussive_blow", chance: 0.2 },
          ],
          lootTable: [
            {
              itemName: "Semilla del Dao Verdadero",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [10000, 10000],
              chance: 1.0,
            },
          ],
          fixedLocation: { x: 15, y: 12 }, // Aparece cerca de la secta para el enfrentamiento final
        },

        //BOSSES
        jabali_colmilludo_alfa: {
          symbol: "🐗",
          name: "Jabalí Colmilludo Alfa (BOSS)",
          spriteUrl: "img/jabali.png",
          typeOverride: "monster",
          hp: 400,
          level: 10,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,
          isBoss: true,
          healChance: 0.2,
          lootTable: [
            {
              itemName: "Colmillo de Jabalí Alfa",
              quantity: [1, 1],
              chance: 0.9,
            },
            {
              itemName: "Carne de Bestia Exótica",
              quantity: [1, 3],
              chance: 0.6,
            },
            { itemName: "Piel Resistente", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [6, 10], chance: 1 },
          ],
          fixedLocation: { x: 57, y: 28 },
        },

        golem_de_piedra: {
          symbol: "🗿",
          name: "Golem de piedra",
          spriteUrl: "img/golem_jade.png",
          typeOverride: "monster",
          hp: 800,
          level: 11,
          attack: 55,
          defense: 50,
          exp: 500,
          maxHp: 800,
          abilities: [
            {
              name: "Golpe Sísmico",
              damageMultiplier: 2.0,
              chance: 0.1,
              type: "area_attack_simulated",
            },
            { name: "Restauración Pétrea", healPercentage: 0.2, chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 15],
              chance: 1.0,
            },
            {
              itemName: "Corazón de Golem de Jade",
              quantity: [1, 1],
              chance: 0.9,
            },

            { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
            {
              itemName: "Núcleo Elemental",
              quantity: [1, 2],
              chance: 0.3,
              extraData: { elementalType: "earth" },
            },
          ],
        },

        lider_renegado_1: {
          symbol: "👤",
          name: "Líder Cultor Renegado Kai",
          typeOverride: "monster",
          hp: 500,
          level: 15,
          attack: 70,
          defense: 25,
          exp: 250,
          maxHp: 500,
          isMiniBoss: true,
          specialChance: 0.25,
          specialAttackMultiplier: 1.6,
          lootTable: [
            {
              itemName: "Compás Espiritual Antiguo",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "Píldora de Qi Condensado",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 20],
              chance: 0.8,
            },
          ],
          fixedLocation: { x: 17, y: 12 },
        },

        //BOSSES

        boss_dem: {
          symbol: "👿",
          name: "General Demonio",
          spriteUrl: "img/boss_dem.png",
          typeOverride: "monster",
          hp: 500,
          level: 10,
          attack: 50,
          defense: 20,
          exp: 1000,
          maxHp: 500,
          isBoss: true,
          npcId: "boss_dem",
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          healChance: 0.15,
          abilities: [{ abilityId: "fire_breath", chance: 0.3 }],

          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [20, 100],
              chance: 1.0,
            },
            {
              itemName: "Núcleo Demoníaco Mayor",
              quantity: [1, 1],
              chance: 0.8,
            },
            { itemName: "Diagrama: Hexagrama Devastador", quantity: [1, 1], chance: 1.0 },
       

        
          ],
          
          fixedLocation: { x: 9, y: 36 },
        },

        boss_ancient_golem: {
          symbol: "🗿",
          name: "Golem Geo",
          spriteUrl: "img/golem_jade.png",
          typeOverride: "monster",
          hp: 800,
          level: 11,
          attack: 65,
          defense: 500, // ¡Defensa EXTREMADAMENTE ALTA!
          exp: 500,
          maxHp: 800,
          isBoss: true,
          npcId: "boss_ancient_golem",
          formationVulnerability: "shattering_hexagram", 
          abilities: [
            {
              name: "Golpe Sísmico",
              damageMultiplier: 2.0,
              chance: 0.2,
              type: "area_attack_simulated",
            },
            { name: "Restauración Pétrea", healPercentage: 0.2, chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [44, 45],
              chance: 1.0,
            },
            {
              itemName: "Corazón de Golem de Jade",
              quantity: [1, 1],
              chance: 0.9,
            },

            { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
            {
              itemName: "Núcleo Elemental",
              quantity: [1, 2],
              chance: 0.3,
              extraData: { elementalType: "earth" },
            },
            // 
          ],
          
          fixedLocation: { x: 6, y: 22 },
        },
      };
      //------------------------   ITEMS ---------------------------------------------------
      const itemData = {
        "Tinta Rúnica": {
            description: "Tinta especial para inscribir runas de poder. No se puede usar directamente.",
            canUse: () => false, // No es un consumible normal
        },
        "Diagrama: Hexagrama Devastador": {
            description: "Un trozo de pergamino antiguo. Muestra un diagrama de seis puntos rodeando un centro [0, 0, 0, 0, 0][1, 0, 2, 0, 1][0, 0, 0, 0, 0][0, 1, 0, 1, 0] con notas que dicen: 'El sello del caparazón se rompe cuando la estrella lo abraza.'",
            canUse: () => false, // Es un objeto de lore, no se consume
        },
        "Compás Espiritual Antiguo": {
            description: "Un artefacto delicado que vibra débilmente. Al usarlo, señalará la fuente de una anomalía rúnica.",
            canUse: (playerState) => {
                // Solo se puede usar si la subtrama de Feng no ha comenzado.
                return playerState.worldState.subplotFlags.fengQuestProgress === 0;
            },
            effect: (playerState, gainExpFunc, itemName) => {
                console.groupCollapsed(`[useItem Effect v3] ==> Ejecutando efecto de: "${itemName}"`);
                
                // --- INICIO DE LA CORRECCIÓN DEFINITIVA ---
                
                // PASO 1: Aceptar la misión. ESTA ES LA ACCIÓN MÁS IMPORTANTE.
                console.log(`[v3] Paso 1: Llamando a acceptMission con 'mision_feng_0_encontrar_maestro'.`);
                acceptMission('mision_feng_0_encontrar_maestro');
                
                // PASO 2: Marcar el progreso de la subtrama.
                playerState.worldState.subplotFlags.fengQuestProgress = 1;
                console.log(`[v3] Paso 2: 'fengQuestProgress' establecido a 1.`);
                
                // PASO 3: Forzar sincronización del mundo y la UI.
                console.log(`[v3] Paso 3: Llamando a ensureFixedEntities y refrescando la UI.`);
                ensureFixedEntities();
                renderMap();
                updateUI();
                updateSectUI();
                
                console.log(`[v3] Proceso de efecto del compás completado.`);
                console.groupEnd();

                // PASO 4: Devolver el mensaje de feedback para el jugador.
                return "El compás gira violentamente y luego apunta hacia una zona escondida en los campos de la secta. La ubicación de una extraña anomalía ha sido marcada en tu percepción espiritual. Dirígete a las coordenadas x:2, y:23";
                
                // --- FIN DE LA CORRECCIÓN DEFINITIVA ---
            }
    },
        
        
      
        
        
        "Herramientas de Agrimensura de Feng": {
            description: "Un conjunto de delicadas herramientas para medir la energía espiritual. Objeto de misión.",
            canUse: () => false,
        },
        "Diagrama Roto: Círculo Vital": {
            description: "Un pergamino que muestra parte de un patrón circular. Se pueden leer las palabras '...en el abrazo de los ocho, la vida misma florece...'",
            canUse: () => false,
        },
        "Runa de Sondeo": {
            description: "Una runa compleja diseñada por Feng para absorber y registrar datos de un nexo de poder. Objeto de misión.",
            canUse: () => false,
        },
        "Hierbas Medicinales": {
          description: "Restaura un 30 de HP.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al máximo.";
            const h = 30;
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Usada Píldora, recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Cristales de Qi": {
          description: "Restaura un 30% de tu Maná Máximo.",
          effect: (ps) => {
            if (ps.mana >= ps.maxMana) return "Maná al máximo.";
            const h = Math.floor(ps.maxMana * 0.3);
            const o = ps.mana;
            ps.mana = Math.min(ps.maxMana, ps.mana + h);
            return `Recuperado ${ps.mana - o} Maná.`;
          },
          canUse: (ps) => ps.mana < ps.maxMana,
        },
        "Piedras Espirituales": {
          description: "Imbuida de energía. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Piedra Espiritual y ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Flor de Luna Escarchada": {
          description: "Flor brillante usada en alquimia.Item de misión",
          canUse: () => false,
        },
        "Raíz de Fuego Terrenal": {
          description: "Raíz que irradia calor, ingrediente alquímico.",
          canUse: () => false,
        },
        "Píldora de Recuperación Menor": {
          description: "Píldora alquímica que restaura 50 HP.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al máximo.";
            const h = 50;
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Usada Píldora, recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Esencia Espectral": {
          description:
            "Un residuo etéreo dejado por un espectro. Se usa en rituales y alquimia avanzada. Item de Misión.",
          canUse: () => false, // No es un consumible
        },
        "Talismán de Percepción": {
          description: "Agudiza sentidos. Otorga EXP.",
          effect: (ps, gex) => {
            gex(100);
            return `Estudiado Talismán, ganado 100 EXP.`;
          },
          canUse: () => true,
        },
        "Nota del Alquimista": {
          description: "Una nota arrugada con una caligrafía experta. Habla de un lugar 'donde el suelo llora' (la ciénaga).",
          canUse: () => false, // No es un consumible
        },
        "Colmillo de Jabalí Alfa": {
          description:
            "Colmillo intacto de Jabalí Alfa. Item de misión de caza.",
          canUse: () => false,
        },
        "Carne de Bestia Exótica": {
          description: "Nutritiva. Restaura 25% HP y 10% Maná.",
          effect: (ps) => {
            let m = "";
            const hA = Math.floor(ps.maxHp * 0.25);
            if (ps.hp < ps.maxHp) {
              const o = ps.hp;
              ps.hp = Math.min(ps.maxHp, ps.hp + hA);
              m += `Recuperado ${ps.hp - o} HP. `;
            }
            const mA = Math.floor(ps.maxMana * 0.1);
            if (ps.mana < ps.maxMana) {
              const o = ps.mana;
              ps.mana = Math.min(ps.maxMana, ps.mana + mA);
              m += `Recuperado ${ps.mana - o} Maná.`;
            }
            return m || "HP y Maná al máximo.";
          },
          canUse: (ps) => ps.hp < ps.maxHp || ps.mana < ps.maxMana,
        },
        "Mapa del Tesoro Fragmentado": {
          description: "Fragmento de mapa antiguo. ¿Otras partes?",
          effect: (ps, gex) => {
            gex(50);
            return `Examinado fragmento, ganado 50 EXP. Indica zona montañosa...`;
          },
          canUse: () => true,
        },
        "Compás Espiritual Antiguo": {
            description: "Un artefacto delicado que vibra débilmente. Al usarlo, señalará la fuente de una anomalía rúnica.",
            canUse: (playerState) => {
                return playerState.worldState.subplotFlags.fengQuestProgress === 0;
            },
            effect: (playerState, gainExpFunc, itemName) => {
                // He cambiado el nombre del log a v4 para que sea 100% seguro que es la nueva versión.
                console.groupCollapsed(`[useItem Effect v4] ==> ¡SE ESTÁ EJECUTANDO LA VERSIÓN CORRECTA DEL EFECTO!`);
                
                // PASO 1: Aceptar la misión. Esta es la acción clave.
                console.log(`[v4] Paso 1: Llamando a acceptMission...`);
                acceptMission('mision_feng_0_encontrar_maestro');
                
                // PASO 2: Marcar el progreso de la subtrama.
                playerState.worldState.subplotFlags.fengQuestProgress = 1;
                console.log(`[v4] Paso 2: 'fengQuestProgress' establecido a 1.`);
                
                // PASO 3: Sincronizar el mundo y la UI.
                console.log(`[v4] Paso 3: Sincronizando entidades y UI...`);
                ensureFixedEntities();
                renderMap();
                updateUI();
                updateSectUI();
                
                console.log(`[v4] Proceso del compás finalizado.`);
                console.groupEnd();

                // PASO 4: Mensaje para el jugador.
                return "El compás gira violentamente y luego apunta hacia una zona escondida en los campos de la secta. La ubicación de una extraña anomalía ha sido marcada en tu percepción espiritual. Dirígete a las coordenadas x:2, y:23";
            }
        },
        "Manual de Formación Básica": {
          description: "Enseña principios de formaciones defensivas.",
          effect: (ps) => {
            ps.baseDefense += 2;
            recalculatePlayerStats();
            return `Estudiado Manual. Defensa base +2.`;
          },
          canUse: () => true,
        },
        "Núcleo de Bestia Menor": {
          description: "Núcleo de bestia demoníaca. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido Núcleo, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Insignia de Secta Rival": {
          description:
            "Una insignia de la Secta de la Llama Negra. Prueba de tus victorias.",
          canUse: () => false,
        },
        "Cristal de Sangre Puro": {
          description:
            "Un cristal que pulsa con energía vital. Valioso para la alquimia de alto nivel.",
          canUse: () => false,
        },
        "Manual de Técnica de Diácono": {
          description:
            "Un manual que detalla una técnica de nivel Diácono. Contiene profundos conocimientos.",
          effect: (ps, gex) => {
            gex(1000); // Da una buena cantidad de EXP
            return `Has estudiado el manual del diácono renegado. Ganas 1000 EXP y una nueva comprensión del combate.`;
          },
          canUse: () => true,
        },
        "Escama de Dragón Espectral": {
          description:
            "Una escama etérea y resistente, imbuida con el resentimiento de un dragón.",
          canUse: () => false,
        },
        "Corazón de Tifón": {
          description:
            "El núcleo arremolinado de un espectro elemental. Irradia un poder inmenso.",
          canUse: () => false,
        },
        "Filacteria del Lich": {
          description:
            "El recipiente del alma del Emperador Lich. Su destrucción asegura su final. Irradia poder oscuro.",
          effect: (ps, gex) => {
            gex(5000);
            return `Al destruir la filacteria, una oleada de energía pura te recorre. Ganas 5000 EXP.`;
          },
          canUse: () => true,
        },
        "Fragmento de la Fisura": {
          description:
            "Un trozo de realidad de un plano demoníaco. Es inestable y peligroso.",
          canUse: () => false,
        },
        "Lágrima Celestial": {
          description:
            "Una lágrima cristalizada de un ser celestial. Contiene una pureza increíble.",
          canUse: () => false,
        },
        "Corazón del Abismo": {
          description:
            "El corazón de un general demoníaco. Es la fuente de su poder abismal.",
          effect: (ps, gex) => {
            gex(10000);
            player.baseMaxHp += 500;
            recalculatePlayerStats();
            return `Has purificado el Corazón del Abismo, fortaleciendo tu propia base vital. Ganas 10000 EXP y 500 HP Máximo base.`;
          },
          canUse: () => true,
        },
        "Rollo: Técnica de Gran Anciano Aleatoria": {
          description: "Un rollo que contiene el conocimiento de una poderosa técnica de nivel Gran Anciano.",
          effect: (ps) => {
              // Lógica para dar una técnica aleatoria de nivel 5
              const t5_techniques = ["sword_t5", "body_t5", "fire_t5", "lightning_t5", "formation_t5", "movement_t5"];
              const availableTechniques = t5_techniques.filter(t => !ps.learnedTechniques[t]);
              if (availableTechniques.length > 0) {
                  const randomTechId = availableTechniques[Math.floor(Math.random() * availableTechniques.length)];
                  return learnTechniqueFromRoll(ps, randomTechId);
              }
              return "Ya conoces todas las técnicas de este nivel. El rollo se disipa en pura energía, otorgando 5000 EXP.";
          },
          canUse: () => true,
      },
        "Semilla del Dao Verdadero": {
          description:
            "Un fragmento del origen de toda la cultivación. Su estudio podría llevarte a la trascendencia.",
          effect: (ps) => {
            // Podría desbloquear una mecánica de post-juego o dar una mejora final masiva.
            ps.level += 5;
            levelUp(); // Simula varias subidas de nivel
            return `Has meditado sobre la Semilla del Dao, alcanzando una iluminación sin precedentes. Tu nivel y poder se disparan.`;
          },
          canUse: () => true,
        },
        
      

        "Sello del Maestro de Secta": {
          description:
            "La prueba de que has superado al Maestro anterior. Irradia una autoridad inmensa. Item de Misión.",
          canUse: () => false,
        },
        "Rollo: Técnica de Absorción de Qi Celestial": {
          description: "Enseña 'Técnica de Absorción de Qi Celestial'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        
        /// ========================   ROLLOS DE TÉCNICAS    ============================

        // -- Rollos Grado 1 --
        "Rollo: Inscripción Rúnica": {
            description: "Un manual antiguo que enseña el arte de trazar formaciones rúnicas en el suelo. Te permite aprender la habilidad 'Inscripción Rúnica'.",
            effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
            canUse: () => true, // Se puede usar desde el inventario
        },
        "Rollo: Tajo del Viento Veloz (Inferior)": {
          description: "Enseña 'Tajo del Viento Veloz'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Físico de Buey de Piedra (Inferior)": {
          description: "Enseña 'Físico de Buey de Piedra'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz de Escudo de Qi (Inferior)": {
          description: "Enseña 'Matriz de Escudo de Qi'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Chispa Ígnea (Inferior)": {
          description: "Enseña 'Chispa Ígnea'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Dedo de Relámpago (Inferior)": {
          description: "Enseña 'Dedo de Relámpago'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Paso Veloz (Inferior)": {
          description: "Enseña 'Paso Veloz'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },

        // -- Rollos Grado 2 --
        "Rollo: Estocada Perfora-Armadura (Terrenal)": {
          description: "Enseña 'Estocada Perfora-Armadura'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Piel de Acero Fundido (Terrenal)": {
          description: "Enseña 'Piel de Acero Fundido'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz de Grilletes de Qi (Terrenal)": {
          description: "Enseña 'Matriz de Grilletes de Qi'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Paso Etéreo (Terrenal)": {
          description: "Enseña 'Paso Etéreo'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Aliento de Dragón Menor (Terrenal)": {
          description: "Enseña 'Aliento de Dragón Menor'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },

        // -- Rollos Grado 3 --
        "Rollo: Danza de Espada Ciclónica (Marcial)": {
          description: "Enseña 'Danza de Espada Ciclónica'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Corazón de Voluntad Indomable (Marcial)": {
          description: "Enseña 'Corazón de Voluntad Indomable'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz de Supresión Espiritual (Marcial)": {
          description: "Enseña 'Matriz de Supresión Espiritual'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
       "Rollo: Jaula de Rayos (Marcial)": {
          description: "Enseña 'Jaula de Rayos'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Parpadeo de Sombra (Marcial)": {
          description: "Enseña 'Parpadeo de Sombra'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },

        // -- Rollos Grado 4 --
        "Rollo: Intento de Espada del Tirano (Soberano)": {
          description: "Enseña 'Intento de Espada del Tirano'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Cuerpo Dorado Inmortal (Soberano)": {
          description: "Enseña 'Cuerpo Dorado Inmortal'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Sol Abrasador (Soberano)": {
          description: "Enseña 'Sol Abrasador'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Llamada del Juicio del Trueno (Soberano)": {
          description: "Enseña 'Llamada del Juicio del Trueno'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Santuario Dorado Protector (Soberano)": {
          description: "Enseña 'Santuario Dorado Protector'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        // -- Rollos Grado 5 --
        "Rollo: Corte que Divide Cielos y Tierra (Trascendente)": {
          description: "Enseña 'Corte que Divide Cielos y Tierra'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Constitución de Dragón Ancestral (Trascendente)": {
          description: "Enseña 'Constitución de Dragón Ancestral'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Llama del Fénix Renaciente (Trascendente)": {
          description: "Enseña 'Llama del Fénix Renaciente'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Tribulación de los Nueve Cielos (Trascendente)": {
          description: "Enseña 'Tribulación de los Nueve Cielos'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz de Reversión del Cosmos (Trascendente)": {
          description: "Enseña 'Matriz de Reversión del Cosmos'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Paso del Vacío Infinito (Trascendente)": {
          description: "Enseña 'Paso del Vacío Infinito'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },

        // -- Rollos Grado 6 --
        "Rollo: Espada del Emperador (Celestial)": {
          description: "Enseña 'Espada del Emperador Celestial'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Cuerpo Inmortal de Jade (Celestial)": {
          description: "Enseña 'Cuerpo Inmortal de Jade'.",
          
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
      },
        "Rollo: Incineración del Mundo Mortal (Celestial)": {
          description: "Enseña 'Incineración del Mundo Mortal'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Decreto del Señor del Trueno (Celestial)": {
          description: "Enseña 'Decreto del Señor del Trueno'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz del Sello del Demonio (Celestial)": {
          description: "Enseña 'Matriz del Sello del Demonio'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Omnipresencia Divina (Celestial)": {
          description: "Enseña 'Omnipresencia Divina'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        // -- Rollos Grado 7 --
        "Rollo: Lamento del Fin del Mundo": {
          description: "Enseña 'Lamento del Fin del Mundo'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Forma del Ancestro Primordial": {
          description: "Enseña 'Forma del Ancestro Primordial'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Génesis Ígneo": {
          description: "Enseña 'Génesis Ígneo'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Cólera del Emperador Celestial": {
          description: "Enseña 'Cólera del Emperador Celestia'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz del Caos Primordial": {
          description: "Enseña 'Matriz del Caos Primordial'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Danza del Tejido Espacio-Tiempo": {
          description: "Enseña 'Danza del Tejido Espacio-Tiempo'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },

        // -- Rollos Grado 8 --
        "Rollo: Decreto Imperial: Extinción": {
          description: "Decreto Imperial: Extinción'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Avatar del Dao Eterno": {
          description: "Enseña 'Avatar del Dao Eterno'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Apocalipsis de Llamas Divinas": {
          description: "Enseña 'Apocalipsis de Llamas Divinas'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Tribulación del Fin de los Tiempos": {
          description: "Enseña 'Tribulación del Fin de los Tiempos'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Matriz de Reescritura de la Realidad": {
          description: "Enseña 'Matriz de Reescritura de la Realidad'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Trascendencia Dimensional": {
          description: "Enseña 'Trascendencia Dimensional'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
 

        

        "Rollo: Absorción de Qi Menor": {
          description: "Enseña 'Absorción de Qi Menor'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },

        "Rollo: Fortificación Corporal Básica": {
          description: "Enseña 'Fortificación Corporal Básica'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
     
        "Rollo: Conversión de Qi": {
          description: "Enseña 'Conversión de Qi'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
    
    
    
    
        "Rollo: Paso de las Sombras": {
          description: "Enseña 'Paso de las Sombras'.",
          eeffect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
 
   
   
  
        "Rollo: Voluntad de Hierro": {
          description: "Enseña 'Voluntad de Hierro'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
  

        "Rollo: Clon Fantasma": {
          description: "Enseña 'Clon Fantasma'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
        "Rollo: Cambio Temporal": {
          description: "Enseña 'Cambio Temporal'.",
          effect: (ps, _, itemName) => learnTechniqueFromRoll(ps, itemName),
          canUse: () => true,
        },
  
 
  
        "Cristal de Hielo": {
          description: "Cristal gélido. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Cristal de Hielo, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia de Fuego": {
          description: "Energía ígnea concentrada. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Esencia de Fuego, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Núcleo de Tormenta": {
          description: "Corazón de tormenta. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Núcleo de Tormenta, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Venenos Mortales": {
          description: "Venenos potentes. Otorga 15 EXP.",
          effect: (ps, gex) => {
            gex(15);
            return `Estudiado Venenos Mortales, ganado 15 EXP.`;
          },
          canUse: () => true,
        },
        "Fragmentos de Jade": {
          description: "Jade imbuido de energía. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido Fragmentos de Jade, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia Oscura": {
          description: "Energía de sombras. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Absorbido Esencia Oscura, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Almas Condenadas": {
          description: "Ecos de almas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Liberado Almas Condenadas, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "Núcleo de Vórtice": {
          description: "Energía caótica. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Núcleo de Vórtice, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Rocío Celestial": {
          description: "Gotas de energía celestial. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Bebido Rocío Celestial, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "Cristales Psíquicos": {
          description: "Resuenan con poder mental. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Meditado con Cristales Psíquicos, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "Mineral de Hierro Espiritual": {
          description: "Hierro imbuido con Qi. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Refinado Mineral, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Plumas de Fénix": {
          description: "Imbuidas con esencia de renovación. Otorga 60 EXP.",
          effect: (ps, gex) => {
            gex(60);
            return `Meditado con Plumas de Fénix, ganado 60 EXP.`;
          },
          canUse: () => true,
        },
        "Semillas Ancestrales": {
          description: "Llenas de vitalidad. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Plantado Semillas en dantian, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Escamas de Dragón": {
          description: "Imbuidas con poder dracónico. Otorga 70 EXP.",
          effect: (ps, gex) => {
            gex(70);
            return `Estudiado Escamas de Dragón, ganado 70 EXP.`;
          },
          canUse: () => true,
        },
        "Espejos Astrales": {
          description: "Reflejan otros planos. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Meditado con Espejos Astrales, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "Relojes de Arena": {
          description: "Manipulan flujo del tiempo. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Estudiado Relojes de Arena, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Sangre de Demonio": {
          description: "Sangre corrupta pero potente. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Analizado Sangre de Demonio, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "Lágrimas de Unicornio": {
          description:
            "Purificadoras con propiedades curativas. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Usado Lágrimas para purificar Qi, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "Núcleo Elemental": {
          description: "Esencia de poder elemental. Otorga 65 EXP.",
          effect: (ps, gex) => {
            gex(65);
            return `Absorbido Núcleo Elemental, ganado 65 EXP.`;
          },
          canUse: () => true,
        },
        "Polvo de Arcano": {
          description: "Brillante con propiedades mágicas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Utilizado Polvo de Arcano en ritual, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
      };

      let zoneNotificationTimeout = null;

      ///======================   FUNCIONES ========================================
      function updateGameOverlayVisibility() {
        const overlay = document.getElementById("game-overlay");
        if (!overlay) {
          console.error("No se encontró el elemento #game-overlay.");
          return;
        }

        // El velo debe estar activo si la batalla está activa O si cualquier modal está abierto.
        const shouldBeActive = gameState.battle.active || isAnyModalOpen();

        if (shouldBeActive) {
          overlay.classList.add("active");
        } else {
          overlay.classList.remove("active");
        }
      }
      function getStoryNpcDialogue(npcId) {
        const player = gameState.player;
        const flags = player.worldState.storyFlags;

        switch (npcId) {
          case "anciana_su":
            // --- INICIO DE LA MODIFICACIÓN ---
            // Si el jugador acaba de conocerla, le da la misión principal.
            if (!flags.metAncianaSu) {
                // Marcar que ya la conoció para que este diálogo no se repita.
                flags.metAncianaSu = true; 
                
                // Acepta la misión automáticamente en nombre del jugador.
                acceptMission('mision_historia_1_demonio');

                return "Joven discípulo... tu flujo de Qi es... peculiar. Me recuerda a las viejas leyendas. La energía en la región es inestable. Un 'General Demonio' ha aparecido al sur. Su presencia es una afrenta que debe ser eliminada. Considera esta tu primera gran prueba. Vuelve a verme cuando lo hayas derrotado.";
            }
            // --- FIN DE LA MODIFICACIÓN ---

            if (flags.knowsAboutCalamity && !flags.knowsAboutSoberano) {
                return "La derrota del General Demonio es un gran logro, pero es solo el comienzo. La Gran Calamidad fue una herida profunda para nuestra secta. Siento que sus ecos aún resuenan. Ten cuidado en tus misiones.";
            }
            if (flags.knowsAboutSoberano) {
                return "Así que el Maestro te ha contado... El peso sobre tus hombros es grande. Busca la verdad completa, el Santuario del Eco en el Valle del Dragón Caído podría tener respuestas.";
            }
            return "El conocimiento del pasado es la llave del futuro. Si tienes preguntas, los archivos siempre están abiertos.";


        case "maestro_jian":
            if (flags.knowsFullTruth) {
                return `La carga que llevas es inmensa. Toda la secta confía en ti. No dudes de tu camino. El destino del mundo está en tus manos.`;
            }
            if (flags.knowsAboutSoberano) {
                return `Ahora que conoces parte del secreto, debes entender la gravedad de la situación. El sello se debilita. Cada victoria tuya nos da más tiempo.`;
            }
            // --- NUEVO DIÁLOGO TRAS DERROTAR AL DEMONIO ---
            if (player.secta.misionesCompletadas['mision_historia_1_demonio']) {
                 return `He oído de tu victoria contra el General Demonio. Un logro notable que demuestra tu potencial. Sigue por este camino, y quizás seas tú quien restaure la gloria de nuestra secta.`;
            }
            return "El camino del cultivador es largo y arduo. Que el Viento Azure guíe tus pasos.";
    }
    return "..."; // Diálogo por defecto
}
      function showZoneNotification(zoneName) {
      
        const notificationElement =
          document.getElementById("zone-notification");

        if (!notificationElement) {
        
          return;
        }
      

        if (zoneNotificationTimeout) {
          clearTimeout(zoneNotificationTimeout);
         
        }

        notificationElement.textContent = `Has entrado en: ${zoneName}`;
      

        notificationElement.classList.add("show");
        
       

        zoneNotificationTimeout = setTimeout(() => {
          notificationElement.classList.remove("show");
         
        }, 3000);
      
      }
      // --- FUNCIONES HELPER PARA UI MÓVIL ---
      function isMobileView() {
        return (
          window.matchMedia("(max-width: 768px)").matches ||
          window.matchMedia("(hover: none) and (pointer: coarse)").matches
        );
      }

      /// <!-- CAMBIO TAMAÑO MAPA MÓVIL -->
      //TAMAÑO TILE
      function calculateAndSetTileSize() {
        
        // Usamos las dimensiones de la ventana directamente, que es más fiable en móviles.
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;
        // ===================================

        // Las constantes que definiste para la cantidad de tiles deseada.
        // ¡He actualizado los valores para que coincidan con los que proporcionaste!
        const TILES_VISIBLE_X_PORTRAIT = 7; 
        const TILES_VISIBLE_Y_PORTRAIT = 10; // En vertical, queremos ver más arriba/abajo

        const TILES_VISIBLE_X_LANDSCAPE = 11; // Aprovechamos el ancho
        const TILES_VISIBLE_Y_LANDSCAPE = 5;  // Reducimos drásticamente el alto

        // Determina si estamos en modo horizontal (landscape) o vertical (portrait)
        const isLandscape = availableWidth > availableHeight;

        let tileSizeBasedOnWidth;
        let tileSizeBasedOnHeight;

        if (isLandscape) {
            tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_LANDSCAPE;
            tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_LANDSCAPE;
        } else {
            tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_PORTRAIT;
            tileSizeBasedOnHeight = availableHeight / TILES_VISIBLE_Y_PORTRAIT;
        }

        // El tamaño del tile será el menor de los dos cálculos para asegurar que todo quepa.
        currentTileSize = Math.floor(
            Math.min(tileSizeBasedOnWidth, tileSizeBasedOnHeight)
        );
        currentTileSize = Math.max(20, currentTileSize); // Asegurar un tamaño mínimo razonable

        console.log(
            `Viewport W: ${availableWidth}, H: ${availableHeight}. Orientation: ${isLandscape ? 'Landscape' : 'Portrait'}. Calculated Tile Size: ${currentTileSize}`
        );
        
        return currentTileSize;
    }
      // <!-- FIN CAMBIO TAMAÑO MAPA MÓVIL -->

      function isAnyModalOpen() {
        const modals = [
          "interactionModal",
          "activeCultivationModal",
          "shopModal",
          "sectHallModal",
          "cultivationChoiceModal",
          "techniqueModal",
        ];
        for (const modalId of modals) {
          const modalElement = document.getElementById(modalId);
          if (modalElement && modalElement.style.display === "flex") {
            return true;
          }
        }
        return false;
      }

      // NUEVA FUNCIÓN para controlar la visibilidad de la barra inferior
      function updateTopNavVisibility() {
        // Renombramos la función para claridad
        if (!topNavBar) return;

        if (gameState.battle.active || isAnyModalOpen()) {
          topNavBar.classList.add("hidden");
        } else {
          topNavBar.classList.remove("hidden");
        }
      }

      function openMissionsModal() {
          const container = document.getElementById("missionsContainer");
          container.innerHTML = "";
          const player = gameState.player;

          if (player.secta.misionesActivas.length === 0) {
              container.innerHTML = "<p style='text-align: center; opacity: 0.7;'>No tienes misiones activas en este momento.</p>";
          } else {
              player.secta.misionesActivas.forEach((misionActiva) => {
                  const misionData = MISIONES_DATA[misionActiva.id];
                  if (!misionData) return;

                  // ¡Llamamos a nuestra nueva función centralizada!
                  const progresoTexto = getMissionProgressText(misionActiva);

                  const div = document.createElement("div");
                  div.style.border = "1px solid #d4af37";
                  div.style.borderRadius = "8px";
                  div.style.padding = "10px";
                  div.style.marginBottom = "10px";
                  div.style.background = "rgba(0,0,0,0.2)";

                  div.innerHTML = `
                      <h4>${misionData.titulo}</h4>
                      <p style="font-size: 0.9em; margin-top: 5px;">${misionData.descripcion}</p>
                      <p style="font-size: 0.8em; color: #f4d03f; margin-top: 8px;">${progresoTexto}</p>
                  `;
                  container.appendChild(div);
              });
          }

          document.getElementById("missionsModal").style.display = "flex";
          hideTouchControls();
          updateStatsPanelVisibility();
      }

      function closeMissionsModal() {
        document.getElementById("missionsModal").style.display = "none";
        showTouchControls();
        updateStatsPanelVisibility();
      }
      function showTouchControls() {
        const controlsOverlay = document.getElementById('touch-controls-overlay');
        const toggleBtn = document.getElementById('toggleMapControlsBtn');

        if (!controlsOverlay || !toggleBtn) return;

        // === CORRECCIÓN CLAVE ===
        // Comprobamos si el navegador está en modo de pantalla completa.
        const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        
        // Los controles deben mostrarse si estamos en vista móvil O si el juego está en pantalla completa.
        const forceShowDueToDeviceOrMode = isMobileView() || isFullscreen;

        // La condición final para mostrar los controles
        const shouldShow = forceShowDueToDeviceOrMode && !mapControlsManuallyHidden && !gameState.battle.active && !isAnyModalOpen();

        if (shouldShow) {
            controlsOverlay.style.display = 'block';
            toggleBtn.style.display = 'block';
        } else {
            controlsOverlay.style.display = 'none';
            // También ocultamos el botón de toggle si no estamos en una vista que los requiera
            if (!forceShowDueToDeviceOrMode) {
                toggleBtn.style.display = 'none';
            }
        }
    }

      function hideTouchControls() {
          const controlsOverlay = document.getElementById('touch-controls-overlay');
          if (controlsOverlay) {
              controlsOverlay.style.display = 'none';
          }
      }

      function toggleMapControlsVisibility() {
          mapControlsManuallyHidden = !mapControlsManuallyHidden;
          const btn = document.getElementById("toggleMapControlsBtn");
          
          if (mapControlsManuallyHidden) {
              btn.textContent = "Mostrar Controles";
              hideTouchControls(); // Esta función ahora oculta el overlay completo
          } else {
              btn.textContent = "Ocultar Controles";
              showTouchControls(); // Esta función ahora muestra el overlay completo si se cumplen las condiciones
          }
      }
      function handleTeleporterInteraction(entity) {
        if (!entity.teleporterId) return;

        const teleporterId = entity.teleporterId;
        const teleporterInfo = TELEPORTER_DATA[teleporterId];
        const player = gameState.player;

        if (!teleporterInfo) {
          console.error(
            `Datos no encontrados para el teletransportador con ID: ${teleporterId}`
          );
          return;
        }

        // Comprobar si ya está activado
        if (!player.unlockedTeleporters[teleporterId]) {
          // ¡Primera activación!
          player.unlockedTeleporters[teleporterId] = true;
          showModal(
            "Matriz Sintonizada",
            `Has canalizado tu Qi en la matriz. ¡Ahora puedes viajar hacia y desde "${teleporterInfo.name}"!`
          );
          // Podríamos abrir el menú de teletransporte directamente después,
          // pero un mensaje de feedback primero es mejor.
        } else {
          // Si ya está activado, simplemente abrimos el menú de viaje.
          openTeleportModal();
        }
      }

      function handleFullscreenChange() {
          updateFullscreenButton();
          // Vuelve a comprobar si los controles deben ser visibles después de cambiar de modo.
          showTouchControls(); 
      }

      function openTeleportModal() {
        const container = document.getElementById("teleportOptionsContainer");
        const player = gameState.player;
        container.innerHTML = ""; // Limpiar opciones anteriores

        let hasDestinations = false;

        for (const id in player.unlockedTeleporters) {
          // No mostrar la ubicación actual como un destino
          const currentTeleporter = getTeleporterAt(player.x, player.y);
          if (currentTeleporter && currentTeleporter.id === id) {
            continue;
          }

          hasDestinations = true;
          const destinationInfo = TELEPORTER_DATA[id];
          const button = document.createElement("button");
          button.className = "cultivation-option-btn";
          button.textContent = `Viajar a: ${destinationInfo.name}`;
          button.onclick = () => teleportPlayer(id);
          container.appendChild(button);
        }

        if (!hasDestinations) {
          container.innerHTML =
            "<p>No has sintonizado otras Matrices de Teletransporte todavía. ¡Explora para activarlas!</p>";
        }

        document.getElementById("teleportModal").style.display = "flex";
        hideTouchControls();
      }

      function teleportPlayer(destinationId) {
        const destination = TELEPORTER_DATA[destinationId];
        if (!destination) return;

        // Actualizar coordenadas del jugador
        gameState.player.x = destination.x;
        gameState.player.y = destination.y;

        closeTeleportModal();

        // Mostrar un feedback visual rápido
        showModal("Viaje Espiritual", "Te materializas en tu destino...", true);
        setTimeout(() => {
          closeModal();
        }, 1200);

        // ¡Muy importante! Actualizar la vista del mapa
        updatePlayerPosition("teleport");
      }

      function closeTeleportModal() {
        document.getElementById("teleportModal").style.display = "none";
        showTouchControls();
        updateStatsPanelVisibility();
      }

      // Pequeña función de ayuda para saber si el jugador está en un teletransportador
      function getTeleporterAt(x, y) {
        for (const id in TELEPORTER_DATA) {
          const tp = TELEPORTER_DATA[id];
          if (tp.x === x && tp.y === y) {
            return { ...tp, id: id };
          }
        }
        return null;
      }
      // --- FUNCIONES DEL JUEGO (MODIFICADAS Y EXISTENTES) ---

      /**
 * FUNCIÓN DE APRENDER TÉCNICA (MEJORADA)
 * Aprende una técnica basándose en el nombre del rollo, no en un ID pasado manualmente.
 * @param {object} playerState - El estado del jugador.
 * @param {string} itemName - El nombre del rollo que se está usando (ej: "Rollo: Cuerpo Inmortal de Jade").
 * @returns {string} Un mensaje de feedback para el jugador.
 */
 function learnTechniqueFromRoll(playerState, itemName) {
    console.group(`[learnTechniqueFromRoll] Procesando el rollo: "${itemName}"`);
    if (!itemName.startsWith("Rollo: ")) {
        console.error("Fallo: El nombre del ítem no empieza con 'Rollo: '.");
        console.groupEnd();
        return "Error: Este objeto no es un rollo de técnica válido.";
    }

    const techNameToLearn = itemName.substring(7);
    console.log(`Paso 1: Nombre de la técnica a aprender extraído -> "${techNameToLearn}"`);
    
    const techId = Object.keys(techniqueData).find(
        (id) => techniqueData[id].name === techNameToLearn
    );
    console.log(`Paso 2: Búsqueda en techniqueData por nombre...`);

    if (!techId) {
        console.error(`¡FALLO CRÍTICO! No se encontró ninguna técnica con el nombre exacto "${techNameToLearn}" en el objeto techniqueData.`);
        console.groupEnd();
        return `Error: No se encontró la definición de la técnica llamada '${techNameToLearn}'.`;
    }
    console.log(`   -> Éxito. ID de la técnica encontrado: "${techId}"`);
    
    const techInfo = techniqueData[techId];
    console.log(`Paso 3: Comprobando si el jugador ya conoce la técnica "${techId}"...`);
    
    if (playerState.learnedTechniques[techId]) {
        console.warn("Fallo: El jugador ya tiene esta técnica en su libro.");
        console.groupEnd();
        return `Ya conoces esta técnica: ${techInfo.name}.`;
    }
    console.log("   -> El jugador NO conoce la técnica. Continuando...");

    console.log(`Paso 4: Verificando requisitos de rango...`);
    if (techInfo.requiredRank) {
        const playerRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === playerState.secta.rango);
        const requiredRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === techInfo.requiredRank);
        if (playerRankIndex < requiredRankIndex) {
            console.error(`Fallo: Rango insuficiente.`);
            console.groupEnd();
            return `Rango insuficiente. Necesitas ser al menos <strong>${techInfo.requiredRank}</strong> para aprender '${techInfo.name}'.`;
        }
        console.log("   -> Rango suficiente. Continuando...");
    } else {
        console.log("   -> No se requiere rango. Continuando...");
    }
    
    console.log(`Paso 5: Añadiendo la técnica al estado del jugador...`);
    playerState.learnedTechniques[techId] = {
        level: 1, 
        currentCultivationProgress: 0,
        cultivationTimeToNextLevel: techInfo.cultivationSettings?.baseTimeToLevelUp || 120,
    };
    console.log("   -> Técnica añadida con éxito:", playerState.learnedTechniques[techId]);

    // --- INICIO DE LA MODIFICACIÓN CLAVE ---
    // Si la técnica que acabamos de aprender es la de Conversión de Qi, activamos la bandera.
    if (techId === 'qi_to_hp_conversion_1') {
        playerState.canUseQiConversion = true;
        console.log(`[learnTechniqueFromRoll] ¡Técnica de Conversión de Qi aprendida! Se ha activado 'canUseQiConversion'.`);
    }
    // --- FIN DE LA MODIFICACIÓN CLAVE ---

    recalculatePlayerStats(); 
    renderQuickSlotBar(); // ¡Muy importante! Redibujamos la barra para que el nuevo botón aparezca.
    
    console.log("Proceso completado con éxito.");
    console.groupEnd();
    return `Has aprendido '${techInfo.name}' (Nivel 1). Puedes cultivarla para mejorarla.`;
}

function showModal(title, text, nonInteractive = false, onCloseCallback = null) { // <-- Se añade '= null'
    const modalElement = document.getElementById("interactionModal");
    const modalTitleEl = document.getElementById("modalTitle");
    const modalTextEl = document.getElementById("modalText");
    const closeButton = modalElement.querySelector('button.close-modal-btn');

    if (!modalElement || !modalTitleEl || !modalTextEl || !closeButton) {
        console.error("CRITICAL: Modal o sus elementos internos no encontrados.");
        alert(`Error UI: Modal no encontrado.\nMensaje: ${title} - ${text}`);
        return;
    }

    modalTitleEl.textContent = title;
    modalTextEl.innerHTML = text.replace(/\n/g, "<br>");

    // Asignamos la función de callback al botón de cierre
    closeButton.style.display = nonInteractive ? "none" : "block";
    
    // ¡IMPORTANTE! Reemplazamos el onclick para que llame a una nueva función de cierre,
    // pasando el callback (que podría ser null).
    closeButton.onclick = () => closeModal(onCloseCallback);

    modalElement.style.display = "flex";
    
    hideTouchControls();
    updateTopNavVisibility();
    updateStatsPanelVisibility();
    updateGameOverlayVisibility();
}

function closeModal(callback = null) { // <-- Se añade '= null'
    const modalElement = document.getElementById("interactionModal");
    if (modalElement) {
        modalElement.style.display = "none";
    }

    // --- ¡AQUÍ ESTÁ LA VERIFICACIÓN CLAVE! ---
    // Solo ejecuta el callback si se proporcionó y si es realmente una función.
    if (typeof callback === 'function') {
        console.log("[closeModal] Ejecutando función de callback proporcionada.");
        try {
            callback();
        } catch (e) {
            console.error("Error al ejecutar el callback de closeModal:", e);
        }
    }
    // --- FIN DE LA VERIFICACIÓN ---
    
    // Restaurar la visibilidad de otros elementos de la UI
    showTouchControls();
    updateTopNavVisibility();
    updateStatsPanelVisibility();
    updateGameOverlayVisibility();
}
      //ENEMIGOS Y NPC FIJOS
      // REEMPLAZA TU FUNCIÓN ensureFixedEntities COMPLETA CON ESTA VERSIÓN
function ensureFixedEntities() {
    console.groupCollapsed(`[ensureFixedEntities v3] Ciclo de Verificación y Sincronización`);
    const player = gameState.player;
    
    const shouldExist = {};
    const alwaysOnEntities = [
        'shop', 'tutorial_formation_mural', 'secta_entrada_principal', 'secta_entrada_principal_2', 
        'secta_entrada_principal_3', 'secta_entrada_principal_4', 'npc_secta_guia', 'npc_secta_admin', 
        'npc_maestro_jian', 'npc_anciana_su', 'transition_ruins_entrance', 'transition_ruins_exit',
        'transition_valley_entrance', 'transition_valley_exit', 'transition_fisura_entrance', 'transition_fisura_exit',
        'tp_sect_hub', 'tp_forest_shrine', 'tp_desert_oasis', 'tp_swamp_ruin', 'tp_desfiladero', 'tp_dragon_valley',
        'mural_circulo_vital',
        //'boss_ancient_golem'
    ];
    alwaysOnEntities.forEach(id => shouldExist[id] = true);
    
    if (player.worldState.subplotFlags.fengQuestProgress > 0) {
        shouldExist['npc_maestro_feng'] = true;
    }

    player.secta.misionesActivas.forEach(misionActiva => {
        const misionData = MISIONES_DATA[misionActiva.id];
        const objetivo = misionData?.objetivo;

        if (objetivo?.tipo === 'derrotar_npc_especifico' && objetivo.npcId) {
            // --- ¡MODIFICACIÓN CLAVE! ---
            // Solo debe existir si la misión está activa Y el jefe NO ha sido derrotado permanentemente.
            if (!player.worldState.defeatedFixedEntities[objetivo.npcId]) {
                shouldExist[objetivo.npcId] = true;
                console.log(`[EnsureFixed v3] REQUISITO: '${objetivo.npcId}' debe existir por la misión '${misionActiva.id}'.`);
            } else {
                console.log(`[EnsureFixed v3] IGNORANDO: '${objetivo.npcId}' porque ya está marcado como derrotado permanentemente.`);
            }
        }
    });

    for (const entityId in shouldExist) {
        const definition = entityTypes[entityId];
        if (!definition || !definition.fixedLocation) continue;

        const alreadyExists = gameState.map.entities.some(
            e => e.originalEntityTypeId === entityId || e.npcId === entityId
        );

        if (!alreadyExists) {
            console.log(`%c[EnsureFixed v3] AÑADIENDO entidad faltante: ${entityId}`, 'color: #66ff66; font-weight: bold;');
            const newEntity = {
                ...definition,
                ...definition.fixedLocation,
                type: definition.typeOverride || entityId,
                id: `${entityId}_fixed_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                isFixed: true,
                originalEntityTypeId: entityId
            };
            if (newEntity.hp && !newEntity.maxHp) newEntity.maxHp = newEntity.hp;
            gameState.map.entities.push(newEntity);
        }
    }

    for (let i = gameState.map.entities.length - 1; i >= 0; i--) {
        const entity = gameState.map.entities[i];
        if (entity.isFixed && !entity.isDecorative) {
            const entityId = entity.originalEntityTypeId || entity.npcId;
            // --- ¡MODIFICACIÓN CLAVE! ---
            // También comprobamos si ha sido derrotado permanentemente antes de eliminarlo.
            if (entityId && !shouldExist[entityId] && !player.worldState.defeatedFixedEntities[entityId]) {
                console.log(`%c[EnsureFixed v3] ELIMINANDO entidad sobrante: ${entityId}`, 'color: #ff9933;');
                gameState.map.entities.splice(i, 1);
            }
        }
    }
    
    console.groupEnd();
}
      //GENERAR MAPA!
      function generateMap(isFullReset = true) {
        // Si no es un reseteo completo, no hacemos NADA relacionado con la población de entidades.
        // La carga de partida se encargará de proveer las entidades.
        if (!isFullReset) {
            console.log("[generateMap] Llamada con isFullReset=false. Saltando repoblación de entidades.");
            updatePlayerPosition(); // Solo actualizamos la vista.
            return;
        }

        // --- La lógica a continuación solo se ejecuta para un JUEGO NUEVO o un reseteo forzado ---
        console.log("[generateMap] Iniciando reseteo completo y repoblación del mapa.");
        calculateAndSetTileSize();

        // Limpiar todas las entidades que no sean de historia o fijas (NPCs, tiendas).
        gameState.map.entities = gameState.map.entities.filter(
          (e) => e.isFixed && !e.isDecorative
        );

        // Resetear contadores de spawn para todas las zonas.
        gameState.map.terrainZones.forEach((zone) => {
          if (zone.spawnSettings && zone.spawnSettings.targetEntities) {
            zone.spawnSettings.targetEntities.forEach((target) => {
              target.currentCount = 0;
            });
            zone.spawnSettings.respawnTimer = 0;
            zone.spawnSettings.lastSpawnCheck = 0;
          }
        });

        // Poblar cada zona con monstruos, recursos y decoraciones.
        gameState.map.terrainZones.forEach((zone) => {
          if (zone.decorations) {
            populateZoneWithDecorations(zone);
          }
          if (zone.spawnSettings) {
            populateZoneWithObjects(zone, true);
          }
        });
        
        updatePlayerPosition();
        showTouchControls();
        ensureFixedEntities();
      }
      function selectEnemyForRunePlacement(entityId) {
          // Si se hace clic en el enemigo que ya está seleccionado, se deselecciona.
          if (gameState.selectedEnemyId === entityId) {
              gameState.selectedEnemyId = null;
              console.log("[Selección] Enemigo deseleccionado.");
          } else {
              // Si se hace clic en un nuevo enemigo, se selecciona.
              gameState.selectedEnemyId = entityId;
              console.log(`[Selección] Enemigo seleccionado: ${entityId}`);
          }
          
          // Volvemos a dibujar el mapa para que los cambios visuales (el sombreado) se apliquen.
          renderMap();
      }
      function dev_defeatEnemy(entityTypeId) {
        console.log(`[DEV] Intentando forzar la derrota de: ${entityTypeId}`);

        const enemyInstance = gameState.map.entities.find(
            (e) => (e.originalEntityTypeId === entityTypeId || e.npcId === entityTypeId) && !e.isDecorative
        );

        if (!enemyInstance) {
            const message = `[DEV] Error: No se encontró una instancia activa de '${entityTypeId}' en el mapa.`;
            console.error(message);
            alert(message);
            return;
        }

        console.log("[DEV] Enemigo encontrado en el mapa:", enemyInstance);

        // --- CORRECCIÓN CLAVE ---
        // Obtenemos la definición maestra del enemigo.
        const enemyDefinition = entityTypes[entityTypeId];
        if (!enemyDefinition) {
            console.error(`[DEV] Error: No se encontró la definición maestra para '${entityTypeId}' en entityTypes.`);
            return;
        }

        // Construimos el objeto del enemigo de la forma correcta:
        // 1. Copiamos la definición maestra completa (que tiene el npcId).
        // 2. Sobrescribimos con los datos de la instancia del mapa (como el HP actual si fuera relevante).
        gameState.battle.enemy = {
            ...enemyDefinition,
            ...enemyInstance
        };
        // --- FIN DE LA CORRECIÓN ---

        gameState.battle.enemy.hp = 0;
        
        // Ahora, cuando llamemos a handleEnemyDefeat, el objeto 'enemy' tendrá la propiedad 'npcId'.
        handleEnemyDefeat();

        console.log(`[DEV] La derrota de '${entityTypeId}' ha sido procesada con éxito.`);
    }

    function populateZoneWithDecorations(zone) {
        if (!zone.decorations || zone.decorations.length === 0) {
          return;
        }
        console.log(`[Decor] Poblando decoraciones para la zona: ${zone.name}`);

        for (let y = zone.y1; y <= zone.y2; y++) {
          for (let x = zone.x1; x <= zone.x2; x++) {
            
            // --- INICIO DE LA MODIFICACIÓN PREVENTIVA ---
            // Comprobamos si la celda ya está ocupada por CUALQUIER entidad (fija, de spawn, etc.)
            const isOccupied = gameState.map.entities.some((e) => e.x === x && e.y === y);
            if (isOccupied) {
              // Si ya hay un jefe, NPC, monstruo o recurso, NO ponemos decoración encima.
              continue; 
            }
            // --- FIN DE LA MODIFICACIÓN PREVENTIVA ---

            for (const deco of zone.decorations) {
              if (Math.random() < deco.density) {
                const decoDefinition = entityTypes[deco.entityTypeId];
                if (decoDefinition) {
                  const newDeco = {
                    ...decoDefinition,
                    x: x,
                    y: y,
                    type: deco.entityTypeId,
                    id: `${deco.entityTypeId}_${x}_${y}_${Math.random()}`,
                    discovered: true,
                    isFixed: true,
                    isDecorative: true,
                  };
                  gameState.map.entities.push(newDeco);
                  break; 
                }
              }
            }
          }
        }
      }

      function populateDecorativeElements(numberOfElements = 3000) {
        const decorativeKeys = Object.keys(entityTypes).filter(
          (key) => entityTypes[key].isDecorative
        );
        if (decorativeKeys.length === 0) {
          console.log("[Decor] No decorative entity types found."); // LOG
          return;
        }
        // MODIFICACIÓN: Añadir las claves encontradas al log
        console.log(
          `[Decor] Attempting to populate ${numberOfElements} decorative elements. Found ${decorativeKeys.length} types:`,
          decorativeKeys.join(", ")
        );

        let addedCount = 0;
        for (let i = 0; i < numberOfElements; i++) {
          let spawnX,
            spawnY,
            attempts = 0;
          let positionFound = false;
          const randomDecoKey =
            decorativeKeys[Math.floor(Math.random() * decorativeKeys.length)];

          while (attempts < 20 && !positionFound) {
            // Intentos para encontrar posición
            spawnX = Math.floor(Math.random() * gameState.map.width);
            spawnY = Math.floor(Math.random() * gameState.map.height);

            // Para decorativos, la condición de "caminable" puede ser menos estricta
            // Lo importante es que la celda no esté ya ocupada.
            const isOccupied = gameState.map.entities.some(
              (e) => e.x === spawnX && e.y === spawnY
            );
            const isPlayerPos =
              spawnX === gameState.player.x && spawnY === gameState.player.y;

            if (!isOccupied && !isPlayerPos) {
              positionFound = true;
            }
            attempts++;
          }

          if (positionFound) {
            const decoDefinition = entityTypes[randomDecoKey];
            if (!decoDefinition || !decoDefinition.symbol) {
              console.warn(
                `[Decor] Definition or symbol missing for deco key: ${randomDecoKey}`
              );
              continue;
            }
            const newDeco = {
              ...decoDefinition, // Copia todas las propiedades de la definición
              x: spawnX,
              y: spawnY,
              type: randomDecoKey, // El tipo ES la clave original de entityTypes
              id: `${randomDecoKey}_${Date.now()}_${i}_${Math.random()
                .toString(16)
                .slice(2)}`,
              discovered: true, // Importante: los decorativos suelen estar descubiertos
              isFixed: true, // Importante: para que no se limpien fácilmente
              isDecorative: true, // Asegura que sea true, incluso si la definición lo omite
            };

            gameState.map.entities.push(newDeco);
            addedCount++;
            // MODIFICACIÓN: Log más detallado, incluyendo si isDecorative es true en la instancia
            console.log(
              `[Decor] Added: ${newDeco.name} (Symbol: ${newDeco.symbol}, Type: ${newDeco.type}, IsDecorative: ${newDeco.isDecorative}) at ${spawnX},${spawnY}. ID: ${newDeco.id}`
            );
          } else {
            // console.log(`[Decor] Could not find position for a decorative element of type ${randomDecoKey} after 20 attempts.`);
          }
        }
        console.log(
          `[Decor] Finished populating. Added ${addedCount} decorative elements out of ${numberOfElements} attempts.`
        );
      }

      function populateZoneWithObjects(zone, initialPopulation = false) {
        if (!zone.spawnSettings) {
          console.log(
            `populateZoneWithObjects: Zone "${zone.name}" has no spawnSettings. Skipping.`
          );
          return;
        }

        console.log(
          `populateZoneWithObjects: Called for zone "${zone.name}". InitialPopulation: ${initialPopulation}`
        );

        zone.spawnSettings.targetEntities.forEach((targetSpawnInfo) => {
          console.log(
            `  Zone "${zone.name}": Processing target spawn info for entityTypeId "${targetSpawnInfo.entityTypeId}", count: ${targetSpawnInfo.count}, currentCount: ${targetSpawnInfo.currentCount}`
          );

          const entityTypeDefinition =
            entityTypes[targetSpawnInfo.entityTypeId];
          if (!entityTypeDefinition) {
            console.warn(
              `  Zone "${zone.name}": Definition for entityTypeId "${targetSpawnInfo.entityTypeId}" NOT FOUND in entityTypes.`
            );
            return;
          }

          let attemptSpawns =
            targetSpawnInfo.count - targetSpawnInfo.currentCount;
          console.log(
            `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Need to spawn ${attemptSpawns} (target: ${targetSpawnInfo.count}, current: ${targetSpawnInfo.currentCount})`
          );

          if (!initialPopulation && zone.spawnSettings.respawnTimer > 0) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Zone in cooldown (timer: ${zone.spawnSettings.respawnTimer}). Skipping spawn.`
            );
            return;
          }

          if (attemptSpawns <= 0 && !initialPopulation) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": No spawns needed and not initial population. Skipping.`
            );
            return;
          }
          if (
            attemptSpawns <= 0 &&
            initialPopulation &&
            targetSpawnInfo.currentCount >= targetSpawnInfo.count
          ) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Initial population, but already at target count. Skipping.`
            );
            return;
          }

          let spawnedThisCycle = 0;
          for (let i = 0; i < attemptSpawns; i++) {
            if (targetSpawnInfo.currentCount >= targetSpawnInfo.count) {
              console.log(
                `    Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Reached target count (${targetSpawnInfo.currentCount}/${targetSpawnInfo.count}). Stopping spawns for this type.`
              );
              break;
            }

            let spawnX,
              spawnY,
              attempts = 0;
            let positionFound = false;
            while (attempts < 20 && !positionFound) {
              spawnX =
                zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1 + 1));
              spawnY =
                zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1 + 1));

              const targetTerrainId = getTerrainTypeAt(spawnX, spawnY);
              const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
              const terrainWalkable =
                !targetTerrainData || targetTerrainData.walkable !== false;

              const isOccupied = gameState.map.entities.some(
                (e) => e.x === spawnX && e.y === spawnY
              );
              const isPlayerPos =
                spawnX === gameState.player.x && spawnY === gameState.player.y;

              if (terrainWalkable && !isOccupied && !isPlayerPos) {
                positionFound = true;
              }
              attempts++;
            }

            if (positionFound) {
              let newEntity;
              newEntity = {
                ...entityTypeDefinition, // <--- COPIAR TODAS LAS PROPIEDADES DE LA DEFINICIÓN PRIMERO
                x: spawnX,
                y: spawnY,
                type:
                  entityTypeDefinition.typeOverride ||
                  targetSpawnInfo.entityTypeId,
                id: `${
                  targetSpawnInfo.entityTypeId
                }_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                zoneOrigin: zone.name,
                originalEntityTypeId: targetSpawnInfo.entityTypeId,
                discovered: false,
                //name: entityTypeDefinition.name,
                //symbol: entityTypeDefinition.symbol,
                //interaction: entityTypeDefinition.interaction,
                //reward: entityTypeDefinition.reward,
              };
              // Asegurar HP/MaxHP para entidades de combate y limpiar para no combatientes
              if (
                G_COMBAT_ENTITY_TYPES.includes(newEntity.type) ||
                newEntity.isBoss ||
                newEntity.isSectChallengeRival
              ) {
                // Si entityTypeDefinition ya tiene hp/maxHp, el spread ya los copió.
                // Este bloque es más para asegurar que existan o para poner valores por defecto.
                newEntity.hp = newEntity.hp ?? entityTypeDefinition.hp ?? 50;
                newEntity.maxHp = newEntity.maxHp ?? newEntity.hp;
                // Aquí 'attack', 'defense', 'exp', 'lootTable' ya deberían estar copiados por el spread de entityTypeDefinition
              } else {
                // Para recursos u otras entidades no combativas
                delete newEntity.hp;
                delete newEntity.maxHp;
                delete newEntity.attack; // Asegurarse de que no tengan stats de combate
                delete newEntity.defense;
                delete newEntity.exp;
                // lootTable podría ser relevante para recursos si lo usaras para definir múltiples items de un nodo.
              }

              // Corrección específica si es un recurso, para que su 'type' en el mapa sea solo 'resource' si así lo deseas
              // para la lógica de interacción, o mantener el tipo específico si prefieres.
              // La lógica actual en handleEntityInteraction ya maneja bien `targetSpawnInfo.entityTypeId` como type.
              // if (entityTypeDefinition.type === "resource") newEntity.type = "resource";

              gameState.map.entities.push(newEntity);
              targetSpawnInfo.currentCount++;
              spawnedThisCycle++;
              console.log(
                `    SUCCESS: Spawned "${newEntity.name}" (Attack: ${newEntity.attack}, Final Type: ${newEntity.type}, OrigTypeID: ${newEntity.originalEntityTypeId}) in zone "${zone.name}" at (${spawnX},${spawnY}).`
              );
            } else {
              // console.log(`    FAILED: Could not find position for "${targetSpawnInfo.entityTypeId}" ...`);
              break;
            }
          }
          if (spawnedThisCycle > 0 && !initialPopulation) {
            zone.spawnSettings.respawnTimer =
              zone.spawnSettings.respawnCooldown;
            console.log(
              `  Zone "${zone.name}": Spawned ${spawnedThisCycle} of "${targetSpawnInfo.entityTypeId}". Setting respawn timer to ${zone.spawnSettings.respawnCooldown}s.`
            );
          }
        });
      }

      // Función para llamar en el bucle principal del juego o con setInterval
      function gameTickUpdater() {
      
        // Definimos la variable 'player' para que apunte al estado del jugador.
        const player = gameState.player; 
        

        const now = Date.now();
        const deltaTime = (now - gameState.lastGameTimeUpdate) / 1000;
        gameState.gameTime += deltaTime;
        gameState.lastGameTimeUpdate = now;

        if (player.passiveHpRegen > 0 && player.hp < player.maxHp && !gameState.battle.active && !player.isCultivating) {
          const regenAmount = player.passiveHpRegen * deltaTime;
          player.hp = Math.min(
            player.maxHp,
            player.hp + regenAmount
          );
          // Actualizamos solo las barras para no spamear la UI completa
          updateUI();
        }

    

        gameState.map.terrainZones.forEach((zone) => {
          if (zone.spawnSettings) {
            if (zone.spawnSettings.respawnTimer > 0) {
              zone.spawnSettings.respawnTimer -= deltaTime;
              if (zone.spawnSettings.respawnTimer < 0)
                zone.spawnSettings.respawnTimer = 0;
            }

            let needsRespawn = false;
            for (const target of zone.spawnSettings.targetEntities) {
              if (target.currentCount < target.count) {
                needsRespawn = true;
                break;
              }
            }
            
            const SPAWN_CHECK_COOLDOWN = 10;
            if (
              needsRespawn &&
              zone.spawnSettings.respawnTimer <= 0 &&
              gameState.gameTime - (zone.spawnSettings.lastSpawnCheck || 0) >
                SPAWN_CHECK_COOLDOWN
            ) {
              zone.spawnSettings.lastSpawnCheck = gameState.gameTime; 
              populateZoneWithObjects(zone, false);
            }
          }
        });
      }

      let animationFrameIndex = 0; // Para ciclar a través de PLAYER_WALK_CYCLE
      let lastPlayerMoveTime = 0; // Para controlar el tiempo de la animación

      function movePlayer(dx, dy) {
    // Los logs pueden ser útiles, los mantendremos por ahora pero colapsados.
   

    movePlayerCallCount++;
    const callId = movePlayerCallCount;

    const now = Date.now();
    if (now - lastSuccessfulMoveTime < PLAYER_MOVE_COOLDOWN) {
        console.log("-> Bloqueado por COOLDOWN.");
        console.groupEnd();
        return;
    }

    const player = gameState.player;
    const newX = player.x + dx;
    const newY = player.y + dy;
    let canMove = true;
    
    console.log(`-> Destino: (${newX}, ${newY})`);
    
    // Verificaciones de Límites y Terreno (sin cambios)
    if (newX < 0 || newX >= gameState.map.width || newY < 0 || newY >= gameState.map.height) { canMove = false; }
    if (canMove) {
        const targetTerrainId = getTerrainTypeAt(newX, newY);
        if (G_TERRAIN_TYPES[targetTerrainId]?.walkable === false) { canMove = false; }
    }
    
    if (canMove) {
        const entitiesAtNewPosition = gameState.map.entities.filter(e => e.x === newX && e.y === newY);
        let entityToBlock = null;

        if (entitiesAtNewPosition.length > 0) {
            // --- INICIO DE LA MODIFICACIÓN: LOS ENEMIGOS AHORA BLOQUEAN EL PASO ---
            // Ahora buscamos cualquier entidad que deba detener al jugador,
            // ya sea un enemigo o un obstáculo fijo.
            entityToBlock = entitiesAtNewPosition.find(e => {
                const entityIdentifier = e.originalEntityTypeId || e.type;
                const isCombatTarget = G_COMBAT_ENTITY_TYPES.includes(entityIdentifier) || e.isBoss || e.isMiniBoss;
                const isBlockingObject = G_BLOCKING_ENTITY_TYPES.includes(entityIdentifier);
                return isCombatTarget || isBlockingObject;
            });
            // --- FIN DE LA MODIFICACIÓN ---
        }

        if (entityToBlock) {
            // Si se encontró una entidad que bloquea (enemigo, NPC, tienda), detenemos el movimiento.
            canMove = false;
            console.log(`%c-> Decisión: Movimiento bloqueado por la entidad '${entityToBlock.name}'. canMove = false`, "color: orange;");
        }
    }

    // Si después de todas las comprobaciones, 'canMove' sigue siendo true, ejecutamos el movimiento.
    if (canMove) {
        console.log("%c-> Decisión FINAL: PERMITIR MOVIMIENTO.", "color: #33cc33; font-weight: bold;");

        const oldZone = getPlayerCurrentZone();
        const oldZoneName = oldZone ? oldZone.name : "Tierras Salvajes";
        
        player.x = newX;
        player.y = newY;
        
        const misionesActivas = [...player.secta.misionesActivas];
        misionesActivas.forEach(misionActiva => {
            const misionData = MISIONES_DATA[misionActiva.id];
            if (misionData?.objetivo?.tipo === 'llegar_a_punto' && misionActiva.progreso !== 1) {
                if (player.x === misionData.objetivo.x && player.y === misionData.objetivo.y) {
                    misionActiva.progreso = 1; // Marcar como objetivo cumplido
                    const npcEntregaNombre = SECTA_DATA.npcs[misionData.objetivo.npcEntrega]?.nombre || "el NPC correspondiente";
                    showModal(
                        "Objetivo Alcanzado", 
                        `Has llegado a: <strong>${misionData.objetivo.nombreArea}</strong>.<br><br>Ahora debes hablar con <strong>${npcEntregaNombre}</strong> para continuar.`
                    );
                    renderMap(); // Redibuja el mapa para quitar el marcador de misión si lo hubiera
                }
            }
        });
        // Lógica de cambio de zona
        const newZone = getPlayerCurrentZone();
        const newZoneName = newZone ? newZone.name : "Tierras Salvajes";
        if (newZoneName !== oldZoneName) {
          showZoneNotification(newZoneName);
        }
        player.currentZoneName = newZoneName;

        updatePlayerPosition(`movePlayer_success_call_${callId}`);
        updateUI();
        lastSuccessfulMoveTime = now;
    } else {
        console.log("%c-> Decisión FINAL: MOVIMIENTO BLOQUEADO.", "color: red; font-weight: bold;");
    }
    
    console.groupEnd();
  }
      //FIN FUNCION MOVE PLAYER
      function placeRuneAt(x, y) {
        const player = gameState.player;
        
        // Gasta los recursos
        gameState.inventory["Tinta Rúnica"]--;
        player.mana -= techniqueData.formation_scribing_1.manaCost || 10;
        
        const runeKey = `${x},${y}`;
        let targetEnemy = null;
        
        if (gameState.selectedEnemyId) {
            targetEnemy = gameState.map.entities.find(e => e.id === gameState.selectedEnemyId);
        }
        
        // --- LÓGICA DE COMBATE ---
        if (targetEnemy) {
            if (!targetEnemy.formationRunes) targetEnemy.formationRunes = {};
            targetEnemy.formationRunes[runeKey] = 1;
            gameState.utilityRunes = {}; // Limpia runas de utilidad si empezamos un patrón de combate
            
            const combatPattern = checkCombatPatterns(targetEnemy);
            if (combatPattern) {
                if (!targetEnemy.pendingFormationEffects) targetEnemy.pendingFormationEffects = [];
                targetEnemy.pendingFormationEffects.push(combatPattern.effect);
                targetEnemy.formationRunes = {}; // Limpiar runas de combate del enemigo tras un éxito
                showModal("¡Formación de Combate Completa!", `Has completado <strong>"${combatPattern.name}"</strong>. Su efecto se activará al iniciar la batalla.`);
            } else {
                showModal("Runa de Combate Inscrita", `Has trazado una runa para ${targetEnemy.name}.`);
            }
        
        // --- LÓGICA DE UTILIDAD (CORREGIDA) ---
      } else {
        gameState.utilityRunes[runeKey] = 1;
        const utilityPattern = checkUtilityPatterns();

        if (utilityPattern) {
            console.log(`[placeRuneAt v2] Patrón de utilidad encontrado: ${utilityPattern.name}`);
            
            gameState.utilityRunes = {};
            
            switch (utilityPattern.effect.type) {
                // --- INICIO DE LA CORRECCIÓN CLAVE ---
                case 'utility_mission_trigger':
                    // Buscamos en las misiones activas una que requiera trazar este patrón.
                    const activeMission = player.secta.misionesActivas.find(m => 
                        MISIONES_DATA[m.id]?.objetivo?.tipo === 'trazar_patron' && 
                        MISIONES_DATA[m.id]?.objetivo?.patternId === utilityPattern.sourcePatternId
                    );

                    if (activeMission) {
                        // ¡Encontramos la misión! Ahora actualizamos su progreso.
                        activeMission.progreso = 1;
                        console.log(`[placeRuneAt v2] ¡OBJETIVO DE MISIÓN CUMPLIDO! Misión: '${activeMission.id}', Progreso: ${activeMission.progreso}`);
                        
                        // Mostramos un modal específico para la misión cumplida.
                        showModal(
                            "¡Patrón Replicado!",
                            `Has trazado con éxito el patrón <strong>${utilityPattern.name}</strong> para la misión. Vuelve con el Maestro Feng para reportar tu éxito.`
                        );
                        updateSectUI(); // Actualizamos la UI para que el diario refleje el cambio.
                    } else {
                        // Si se traza un patrón de misión pero no se tiene la misión, se informa.
                        console.warn(`[placeRuneAt v2] Se trazó un patrón de misión, pero no se encontró la misión activa correspondiente.`);
                        showModal("Patrón Reconocido", `Has trazado la formación "${utilityPattern.name}", pero no parece tener un efecto inmediato...`);
                    }
                    break;
                    case 'utility_teleport':
                        teleportPlayer(utilityPattern.effect.destinationId);
                        showModal("¡Portal Abierto!", `La ${utilityPattern.name} se activa...`, true);
                        setTimeout(() => closeModal(), 2000);
                        break;
                    default:
                        showModal("¡Formación de Utilidad Completa!", `Has activado: <strong>${utilityPattern.name}</strong>.`);
                        break;
                }
            } else {
                // No se encontró ningún patrón, simplemente informamos que se plantó la runa
                showModal("Runa de Utilidad Inscrita", `Has trazado una runa en el suelo. Continúa para formar un patrón.`);
            }
        }

        updateUI();
        renderMap(); // Volvemos a dibujar para que las runas aparezcan o desaparezcan.
        renderQuickSlotBar();
    }

      function checkForAggressiveEnemies() {
        if (gameState.battle.active || isAnyModalOpen() || gameState.player.isChannelingRune) {
          return;
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;

        // Comprobamos las 8 casillas adyacentes y la casilla actual
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue; // No comprobar la propia casilla del jugador

            const checkX = playerX + dx;
            const checkY = playerY + dy;

            const entity = gameState.map.entities.find(
              (e) => e.x === checkX && e.y === checkY
            );

            if (entity) {
              const isHostile =
                G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
                entity.isBoss ||
                entity.isMiniBoss;

              // Si la entidad es hostil, iniciamos la batalla
              if (isHostile) {
                showModal(
                  "¡Emboscada!",
                  `¡Un ${entity.name} te ataca al acercarte demasiado!`,
                  true
                );
                setTimeout(() => {
                  closeModal();
                  startBattle(entity);
                }, 1500);
                return; // Detenemos la función para no iniciar múltiples combates
              }
            }
          }
        }
      }

      function getEnemyNameColor(playerLevel, enemyLevel) {
        const levelDiff = enemyLevel - playerLevel;

        if (levelDiff >= 5) {
          return { color: "#ff4d4d", fontWeight: "bold" }; // Rojo (Muy Peligroso)
        } else if (levelDiff >= 3) {
          return { color: "#ff9b57", fontWeight: "normal" }; // Naranja (Peligroso)
        } else if (levelDiff >= 1) {
          return { color: "#f4d03f", fontWeight: "normal" }; // Amarillo (Más fuerte)
        } else if (levelDiff <= -5) {
          return { color: "#a0a0a0", fontWeight: "normal" }; // Gris (Trivial)
        } else {
          return { color: "#f4e4bc", fontWeight: "normal" }; // Blanco (Normal)
        }
      }

      function gameLoop() {
        if (
          isAnyModalOpen() ||
          gameState.battle.active ||
          gameState.player.isCultivating
        ) {
          gameState.player.isMoving = false; // Detener animación si el juego está pausado
          return;
        }

        handleMovement(); // Maneja la lógica de movimiento
        checkForAggressiveEnemies();
        // Actualiza el frame de la animación basado en el estado
        if (gameState.player.isMoving) {
          // Cicla entre los frames 1, 2, 3...
          const frameCount = gameState.player.animationFrames - 1; // e.g., si hay 4 frames, cicla entre 1,2,3
          gameState.player.currentFrame =
            (gameState.player.currentFrame % frameCount) + 1;
        } else {
          gameState.player.currentFrame = 0; // Frame 0 es quieto
        }

        updatePlayerSpriteVisual(); // Actualiza el sprite visualmente
      }

      // Ajuste menor en window.addEventListener('resize')
      window.addEventListener("resize", () => {
        calculateAndSetTileSize();
        // renderMap(); // updatePlayerPosition se encarga de esto
        updatePlayerPosition();
      });

      function getTerrainTypeAt(x, y) {
        if (
          x < 0 ||
          x >= gameState.map.width ||
          y < 0 ||
          y >= gameState.map.height
        ) {
          return null; // Fuera de los límites del mapa
        }

        // Opción A: Si usas terrainGrid directamente
        if (
          gameState.map.terrainGrid &&
          gameState.map.terrainGrid[y] &&
          gameState.map.terrainGrid[y][x]
        ) {
          return gameState.map.terrainGrid[y][x];
        }

        // Opción B: Usando terrainZones
        for (const zone of gameState.map.terrainZones) {
          if (x >= zone.x1 && x <= zone.x2 && y >= zone.y1 && y <= zone.y2) {
            return zone.type;
          }
        }
        return gameState.map.defaultTerrain; // Devuelve el terreno por defecto
      }

      function renderMap(callerId = "unknown") {
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!mapElement || !mapContainerElement) {
            return;
        }
        
     
        const currentZone = getPlayerCurrentZone();
        let currentAmbientColor = "#1a3d2e";
        if (currentZone && currentZone.isIsolated) {
            mapContainerElement.style.backgroundColor = currentZone.ambientColor || "#000";
        } else {
            mapContainerElement.style.backgroundColor = "#1a3d2e";
        }
        const currentContainerWidth = mapContainerElement.clientWidth;
        const currentContainerHeight = mapContainerElement.clientHeight;
        // Calculamos la posición del jugador en la pantalla para saber dónde centrar la cámara.
        const playerScreenX = currentContainerWidth / 2 - (gameState.player.frameWidth / 2);
        const playerScreenY = currentContainerHeight / 2 - (gameState.player.frameHeight / 2);

        // Calculamos cuál debería ser la posición de la esquina superior izquierda del mapa (el scroll).
        // Esta es la misma lógica que en updatePlayerPosition, asegurando consistencia.
        // NO leemos del DOM para evitar datos desactualizados.
        const mapScrollX = -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapScrollY = -(gameState.player.y * currentTileSize) + playerScreenY;
        
        // Basado en ese scroll calculado, determinamos qué tiles del mundo son visibles.
        const viewWorldXStart = Math.floor(-mapScrollX / currentTileSize);
        const viewWorldYStart = Math.floor(-mapScrollY / currentTileSize);
        
        // Y calculamos el área a renderizar, incluyendo nuestro margen de seguridad para evitar franjas.
        const tilesInViewX = Math.ceil(currentContainerWidth / currentTileSize) + 2;
        const tilesInViewY = Math.ceil(currentContainerHeight / currentTileSize) + 2;
        
        const viewWorldXEnd = viewWorldXStart + tilesInViewX;
        const viewWorldYEnd = viewWorldYStart + tilesInViewY;

        // --- FIN DE LA MODIFICACIÓN ---

                mapElement.innerHTML = ""; 
       
        // 1. Renderizar TERRENO BASE
        for (let y = viewWorldYStart; y < viewWorldYEnd; y++) {
          for (let x = viewWorldXStart; x < viewWorldXEnd; x++) {
            let shouldDrawVoid = false;

            if (currentZone && currentZone.isIsolated) {
              if (
                x < currentZone.x1 ||
                x > currentZone.x2 ||
                y < currentZone.y1 ||
                y > currentZone.y2
              ) {
                shouldDrawVoid = true;
              }
            } else {
              // Si no estamos en una zona aislada, el "vacío" es cualquier cosa fuera de los límites del mapa.
              if (
                x < 0 ||
                x >= gameState.map.width ||
                y < 0 ||
                y >= gameState.map.height
              ) {
                shouldDrawVoid = true;
              }
            }
            if (shouldDrawVoid) {
              const voidTile = document.createElement("div");
              voidTile.className = "tile void-tile";
              voidTile.style.left = `${x * currentTileSize}px`;
              voidTile.style.top = `${y * currentTileSize}px`;
              voidTile.style.width = `${currentTileSize}px`;
              voidTile.style.height = `${currentTileSize}px`;
              voidTile.style.backgroundColor = currentAmbientColor; // Rellena con el color de ambiente
              voidTile.style.zIndex = "0";
              const voidTerrainData = G_TERRAIN_TYPES.VOID;
              if (voidTerrainData && voidTerrainData.textureUrl) {
                voidTile.style.backgroundImage = `url('${voidTerrainData.textureUrl}')`;
                voidTile.style.backgroundSize = "cover";
              } else {
                // Si la textura del vacío no se encuentra, vuelve a usar el color ambiental
                voidTile.style.backgroundColor = currentAmbientColor;
              }
              mapElement.appendChild(voidTile);
              continue; // Pasa al siguiente tile del bucle
            }
            const terrainId = getTerrainTypeAt(x, y);
            const terrainData = G_TERRAIN_TYPES[terrainId];
            if (terrainData) {
              const terrainTile = document.createElement("div");
              terrainTile.className = "tile terrain-tile";
              terrainTile.style.left = `${x * currentTileSize}px`;
              terrainTile.style.top = `${y * currentTileSize}px`;
              terrainTile.style.width = `${currentTileSize}px`;
              terrainTile.style.height = `${currentTileSize}px`;
              terrainTile.style.zIndex = "1";

              if (terrainData.textureUrl) {
                terrainTile.style.backgroundImage = `url('${terrainData.textureUrl}')`;
                terrainTile.style.backgroundSize = "cover";
              } else {
                terrainTile.style.backgroundColor = terrainData.color;
              }

              mapElement.appendChild(terrainTile);
              // === INICIO DEL CÓDIGO NUEVO: MARCADOR DE MISIÓN ===
              gameState.player.secta.misionesActivas.forEach(misionActiva => {
                  const misionData = MISIONES_DATA[misionActiva.id];
                  if (misionData?.objetivo?.tipo === 'llegar_a_punto' && misionActiva.progreso !== 1) {
                      const objetivo = misionData.objetivo;
                      // Si la casilla actual (x, y) es la del objetivo de la misión
                      if (x === objetivo.x && y === objetivo.y) {
                          const missionMarker = document.createElement('div');
                          missionMarker.style.position = 'absolute';
                          missionMarker.style.left = `${x * currentTileSize}px`;
                          missionMarker.style.top = `${y * currentTileSize}px`;
                          missionMarker.style.width = `${currentTileSize}px`;
                          missionMarker.style.height = `${currentTileSize}px`;
                          missionMarker.style.pointerEvents = 'none'; // Para que no interfiera con clics
                          missionMarker.style.zIndex = '2'; // Justo encima del terreno
                          missionMarker.style.animation = 'pulse-mission-marker 2s infinite';
                          
                          // Usamos un borde brillante para marcar la casilla
                          missionMarker.style.border = '3px solid rgba(255, 223, 0, 0.7)';
                          missionMarker.style.boxSizing = 'border-box';
                          missionMarker.style.borderRadius = '4px';

                          mapElement.appendChild(missionMarker);
                      }
                  }
              });
            }
          }
        }

        // 2. Renderizar ENTIDADES
        gameState.map.entities.forEach((entity) => {
          if (entity.discovered) {
            if (
              entity.x >= viewWorldXStart &&
              entity.x < viewWorldXEnd &&
              entity.y >= viewWorldYStart &&
              entity.y < viewWorldYEnd
            ) {
              const entityContainer = document.createElement("div");
              entityContainer.style.position = "absolute";
              entityContainer.style.left = `${entity.x * currentTileSize}px`;
              entityContainer.style.top = `${entity.y * currentTileSize}px`;
              entityContainer.style.width = `${currentTileSize}px`;
              entityContainer.style.height = `${currentTileSize}px`;
              entityContainer.style.display = "flex";
              entityContainer.style.alignItems = "center";
              entityContainer.style.justifyContent = "center";
              entityContainer.style.zIndex = "5";

              const definition =
                entityTypes[entity.originalEntityTypeId] ||
                entityTypes[entity.type] ||
                (entity.typeOverride && entityTypes[entity.typeOverride]);

              // La URL del sprite se toma de la instancia, o de la definición encontrada.
              const spriteUrl =
                entity.spriteUrl || (definition ? definition.spriteUrl : null);
              if (spriteUrl) {
                entityContainer.style.backgroundImage = `url('${spriteUrl}')`;

                if (entity.originalEntityTypeId === "secta_entrada_principal") {
                  entityContainer.style.backgroundSize = "120%";
                  entityContainer.style.top = `${
                    (entity.y - 1.2) * currentTileSize
                  }px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                  // 1. Aumentamos el ancho del contenedor para que quepa el sprite
                  entityContainer.style.width = `${currentTileSize * 3}px`;

                  // 2. Ajustamos la posición izquierda para centrar el nuevo contenedor ancho
                  // Posición original: entity.x * currentTileSize
                  // Nuevo ancho: currentTileSize * 2.5
                  // Para centrarlo, debemos desplazarlo a la izquierda la mitad de su ancho extra.
                  // Ancho extra = (2.5 - 1) = 1.5. Mitad del ancho extra = 0.75.
                  entityContainer.style.left = `${
                    (entity.x - 0.75) * currentTileSize
                  }px`;
                } else if (entity.originalEntityTypeId === "shop") {
                  entityContainer.style.backgroundSize = "120%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.height = `${currentTileSize * 2}px`;
                  entityContainer.style.width = `${currentTileSize * 2}px`;
                  entityContainer.style.left = `${
                    (entity.x - 0.75) * currentTileSize
                  }px`;
                } else if (
                  entity.originalEntityTypeId === "deco_arbol_grande"
                ) {
                  entityContainer.style.backgroundSize = "120%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.height = `${currentTileSize * 1.2}px`;
                }else if (
                  entity.originalEntityTypeId === "deco_montaña_large"
                ) {
                  entityContainer.style.backgroundSize = "180%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 4}px`;
                  entityContainer.style.height = `${currentTileSize * 1}px`;
                }
                 else if (entity.originalEntityTypeId === "boss_dem") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 0.2) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (entity.originalEntityTypeId === "tp_sect_hub") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (entity.originalEntityTypeId === "tp_forest_shrine") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (entity.originalEntityTypeId === "tp_desert_oasis") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                } else if (
                  entity.originalEntityTypeId === "osa_mayor_esmeralda"
                ) {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1.5) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 1}px`;
                  entityContainer.style.height = `${currentTileSize * 2}px`;
                } else if (
                  entity.originalEntityTypeId === "monster_desierto_golem_arena"
                ) {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1.5) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 1}px`;
                  entityContainer.style.height = `${currentTileSize * 2}px`;
                } else if (entity.originalEntityTypeId === "tp_swamp_ruin") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                }else if (entity.originalEntityTypeId === "tp_desfiladero") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                }else if (entity.originalEntityTypeId === "tp_dragon_valley") {
                  entityContainer.style.backgroundSize = "100%";
                  entityContainer.style.top = `${
                    (entity.y - 1) * currentTileSize
                  }px`;
                  entityContainer.style.width = `${currentTileSize * 3}px`;
                  entityContainer.style.height = `${currentTileSize * 3}px`;
                }
                 else {
                  entityContainer.style.backgroundSize = "80%";
                }

                entityContainer.style.backgroundPosition = "center bottom";
                entityContainer.style.backgroundRepeat = "no-repeat";
              } else {
                entityContainer.textContent =
                  entity.symbol || (definition ? definition.symbol : "?");
                entityContainer.style.fontSize = `${
                  currentTileSize * (entity.isDecorative ? 0.5 : 0.6)
                }px`;
              }

              if (entity.isDecorative) {
                entityContainer.style.opacity = "0.7";
                entityContainer.style.zIndex = "3";
              }

              mapElement.appendChild(entityContainer);

              const isHostile =
                G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
                entity.isBoss ||
                entity.isMiniBoss;
              if (isHostile && isGridVisible) {
                    entityContainer.classList.add("selectable-enemy");
                    entityContainer.onclick = (e) => {
                        e.stopPropagation(); // Evita que el clic se propague a otros elementos del mapa
                        selectEnemyForRunePlacement(entity.id);
                    };
                }

               // ---  AÑADIR INDICADOR DE MISIÓN ---
               const isNPC = !!entity.npcId && !isHostile; // Es un NPC si tiene npcId y no es un enemigo

                if (isNPC) {
                    const indicator = getNpcIndicator(entity.npcId);
                    if (indicator) {
                        const indicatorDiv = document.createElement("div");
                        indicatorDiv.className = `quest-indicator ${indicator.class}`;
                        indicatorDiv.textContent = indicator.type;
                        entityContainer.appendChild(indicatorDiv); // Añadirlo al contenedor de la entidad
                    }
                }  
              const isImportantNPC = entity.npcId && !isHostile;
              

              if (isHostile || isImportantNPC) {
                const namePlate = document.createElement("div");
                namePlate.className = "entity-name-plate";

                let displayText = entity.name;

                if (isHostile) {
                  // 1. Añadir etiqueta de estatus si existe
                  if (entity.isBoss) {
                    displayText += ` (Jefe)`;
                  } else if (entity.isMiniBoss) {
                    displayText += ` (Élite)`;
                  }

                  // 2. Añadir SIEMPRE el nivel si la entidad lo tiene
                  if (entity.level) {
                    displayText += ` (Nv. ${entity.level})`;
                  }

                  // 3. Aplicar color
                  if (entity.isBoss) {
                    namePlate.style.color = "#ff4d4d"; // Rojo para Jefes
                    namePlate.style.fontWeight = "bold";
                  } else {
                    // Para todos los demás enemigos (miniboss y comunes), usar la escala de color
                    const nameStyle = getEnemyNameColor(
                      gameState.player.level,
                      entity.level || 1
                    );
                    namePlate.style.color = nameStyle.color;
                    namePlate.style.fontWeight = nameStyle.fontWeight;
                  }
                }

                namePlate.textContent = displayText;
                entityContainer.appendChild(namePlate);
              }
            }
          }
        });
        // --- DIBUJAR RUNAS DE COMBATE (LIGADAS A ENEMIGOS) ---
        gameState.map.entities.forEach(entity => {
        if (entity.formationRunes) {
            Object.keys(entity.formationRunes).forEach(runeKey => {
                const [x, y] = runeKey.split(',').map(Number);
                if (x >= viewWorldXStart && x < viewWorldXEnd && y >= viewWorldYStart && y < viewWorldYEnd) {
                    const runeMarker = document.createElement('div');
                    runeMarker.className = 'tile rune-marker';
                    runeMarker.style.left = `${x * currentTileSize}px`;
                    runeMarker.style.top = `${y * currentTileSize}px`;
                    runeMarker.style.width = `${currentTileSize * 0.6}px`;
                    runeMarker.style.height = `${currentTileSize * 0.6}px`;
                    runeMarker.style.margin = `${currentTileSize * 0.2}px`;
                    runeMarker.style.zIndex = '4';
                    runeMarker.style.pointerEvents = 'none';
                    mapElement.appendChild(runeMarker);
                }
            });
        }
    });
    // Esto se ejecuta después de dibujar todas las entidades.
    if (gameState.selectedEnemyId && isGridVisible) {
        const selectedEnemy = gameState.map.entities.find(e => e.id === gameState.selectedEnemyId);

        if (selectedEnemy) {
            // Recorremos las 8 casillas adyacentes al enemigo
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    // Saltamos la casilla central (la del propio enemigo)
                    if (dx === 0 && dy === 0) continue;

                    const tileX = selectedEnemy.x + dx;
                    const tileY = selectedEnemy.y + dy;

                    const dangerTile = document.createElement("div");
                    dangerTile.className = "danger-zone-tile";
                    dangerTile.style.left = `${tileX * currentTileSize}px`;
                    dangerTile.style.top = `${tileY * currentTileSize}px`;
                    dangerTile.style.width = `${currentTileSize}px`;
                    dangerTile.style.height = `${currentTileSize}px`;
                    mapElement.appendChild(dangerTile);
                }
            }
        }
    }
    // 4. Renderizar el ÁREA DE PELIGRO para plantar runas si un enemigo está seleccionado
    if (gameState.selectedEnemyId && isGridVisible) {
            const selectedEnemy = gameState.map.entities.find(e => e.id === gameState.selectedEnemyId);

            if (selectedEnemy) {
                // Recorremos las 8 casillas adyacentes al enemigo
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        // Saltamos la casilla central (la del propio enemigo)
                        if (dx === 0 && dy === 0) continue;

                        const tileX = selectedEnemy.x + dx;
                        const tileY = selectedEnemy.y + dy;
                        
                        // Solo dibujamos si la casilla está dentro del área visible del mapa
                        if (tileX >= viewWorldXStart && tileX < viewWorldXEnd && tileY >= viewWorldYStart && tileY < viewWorldYEnd) {
                            const dangerTile = document.createElement("div");
                            dangerTile.className = "danger-zone-tile";
                            dangerTile.style.left = `${tileX * currentTileSize}px`;
                            dangerTile.style.top = `${tileY * currentTileSize}px`;
                            dangerTile.style.width = `${currentTileSize}px`;
                            dangerTile.style.height = `${currentTileSize}px`;
                            mapElement.appendChild(dangerTile);
                        }
                    }
                }
            }
        }
    // --- DIBUJAR RUNAS DE UTILIDAD (NO LIGADAS A ENEMIGOS) ---
    Object.keys(gameState.utilityRunes).forEach(runeKey => {
        const [x, y] = runeKey.split(',').map(Number);
        
        if (x >= viewWorldXStart && x < viewWorldXEnd && y >= viewWorldYStart && y < viewWorldYEnd) {
            const runeMarker = document.createElement('div');
            runeMarker.className = 'tile rune-marker'; 
            runeMarker.style.left = `${x * currentTileSize}px`;
            runeMarker.style.top = `${y * currentTileSize}px`;
            runeMarker.style.width = `${currentTileSize * 0.6}px`;
            runeMarker.style.height = `${currentTileSize * 0.6}px`;
            runeMarker.style.margin = `${currentTileSize * 0.2}px`;
            runeMarker.style.zIndex = '4';
            runeMarker.style.pointerEvents = 'none';
            // Damos un color diferente para distinguirlas visualmente
            runeMarker.style.borderColor = '#66ccff';
            runeMarker.style.boxShadow = '0 0 15px #66ccff, inset 0 0 10px #66ccff';
            mapElement.appendChild(runeMarker);
        }
    });

        updatePlayerVisualSize();
      }
    
      function checkAndApplyFormation(enemyEntity) {
        // La función ahora se enfoca en aplicar los efectos ya guardados
        if (!enemyEntity.pendingFormationEffects || enemyEntity.pendingFormationEffects.length === 0) {
          console.log("[checkAndApplyFormation] No hay efectos de formación pendientes para este enemigo.");
            return; // No hay efectos de formación pendientes para este enemigo
        }
        console.group(`[DEBUG FORMACIÓN] Aplicando efectos para: ${enemyEntity.name}`);
        logBattle("¡Las formaciones rúnicas preestablecidas se activan!");

        const scribingTech = gameState.player.learnedTechniques["formation_scribing_1"];
        let amplification = 1.0; // Por defecto, sin amplificación
        if (scribingTech && scribingTech.level > 1) {
            const baseAmplification = techniqueData.formation_scribing_1.effect.amplificationPerLevel;
            amplification += (scribingTech.level - 1) * baseAmplification;
            console.log(` -> Nivel de Inscripción Rúnica: ${scribingTech.level}. Amplificación: ${amplification.toFixed(2)}x`);
        }
        // Iteramos sobre cada efecto acumulado y lo aplicamos
        enemyEntity.pendingFormationEffects.forEach(effect => {
            const formationName = Object.keys(FORMATION_PATTERNS).find(key => FORMATION_PATTERNS[key].effect === effect)?.name || "Formación Desconocida";
            console.log(` -> Procesando efecto de: "${formationName}"`, effect);
            switch(effect.type) {
              case 'enemy_debuff':
                if (effect.stat === 'defense') {
                    // Aplicamos la amplificación
                    const defenseReduction = Math.floor(effect.amount * amplification);
                    gameState.battle.enemy.defense -= defenseReduction;
                    if(gameState.battle.enemy.defense < 0) gameState.battle.enemy.defense = 0;
                    let logMsg = `"${formationName}" quiebra las defensas del enemigo, reduciéndolas en ${defenseReduction}`;
                    if (amplification > 1.0) logMsg += " (¡Amplificado!)";
                    logBattle(logMsg + ".");
                    showFloatingText(document.getElementById('enemySprite'), `Defensa ↓↓`, 'debuff');
                }
                break;
                case 'player_buff':
                if (effect.stat === 'hpRegenPerTurn') {
                    // Aplicamos la amplificación
                    const hpRegen = Math.floor(effect.amount * amplification);
                    gameState.player.hpRegenPerTurn = (gameState.player.hpRegenPerTurn || 0) + hpRegen;
                    let logMsg = `"${formationName}" te envuelve en energía vital, curándote ${hpRegen} HP cada turno`;
                    if (amplification > 1.0) logMsg += " (¡Amplificado!)";
                    logBattle(logMsg + ".");
                    showFloatingText(document.querySelector('.character-sprite'), `Regeneración+`, 'ability');
                }else if (effect.stat === 'defenseBoost') 
                {
                  
                    const defenseBonus = Math.floor(effect.amount * amplification);
                    // Aplicamos el bono directamente a los stats de batalla del jugador
                    
                    let logMsg = `La "${formationName}" endurece tu cuerpo, ¡ganas ${defenseBonus} de Defensa para este combate!`;
                    if (amplification > 1.0) logMsg += " (¡Amplificado!)";

                    logBattle(logMsg);
                    showFloatingText(document.querySelector('.character-sprite'), `Defensa +${defenseBonus}`, 'ability');
                }
                
                else if (effect.stat === 'manaRegenPerTurn') {
                    const manaRegenBonus = Math.floor(effect.amount * amplification);
                    gameState.player.manaRegenPerTurn = (gameState.player.manaRegenPerTurn || 0) + manaRegenBonus;
                    logBattle(`El "${formationName}" crea un pozo de energía, restaurando ${manaRegenBonus} Maná cada turno.`);
                    showFloatingText(document.querySelector('.character-sprite'), `Flujo de Qi`, 'ability');
                }
                // =======================================
        
                    break;
                // Aquí puedes añadir más tipos de efectos en el futuro
            }
        });

        // Limpiamos los efectos pendientes después de aplicarlos
        enemyEntity.pendingFormationEffects = [];
        console.log(" -> Todos los efectos pendientes han sido aplicados y limpiados.");
        console.groupEnd();
        // También limpiamos cualquier runa restante que no formara un patrón
        enemyEntity.formationRunes = {};
    }

      function updatePlayerSpriteVisual() {
        // Asegúrate que el nombre sea este
        const player = gameState.player;
        const playerElement = document.getElementById("player");
        if (!playerElement) return;

        // Verificación para depurar el error de la línea 2263
        if (
          !player.directionRowMap ||
          typeof player.currentDirection === "undefined"
        ) {
          console.error(
            "CRITICAL: player.directionRowMap o player.currentDirection no están definidos en updatePlayerSpriteVisual.",
            player
          );
          // Podrías establecer valores por defecto aquí como un parche temporal,
          // pero lo ideal es que estén bien inicializados en gameState.
          // player.currentDirection = player.currentDirection || 'down';
          // player.directionRowMap = player.directionRowMap || { 'down': 0, 'left': 1, 'right': 2, 'up': 3 };
          // player.currentFrame = player.currentFrame || 0;
          // player.frameWidth = player.frameWidth || 64;
          // player.frameHeight = player.frameHeight || 64;
          return; // Salir si faltan datos cruciales para evitar más errores
        }

        const row = player.directionRowMap[player.currentDirection];
        const col = player.currentFrame;

        // Otra verificación
        if (typeof row === "undefined" || typeof col === "undefined") {
          console.error(
            "CRITICAL: 'row' o 'col' son undefined en updatePlayerSpriteVisual.",
            {
              playerDir: player.currentDirection,
              playerFrame: player.currentFrame,
              map: player.directionRowMap,
            }
          );
          return;
        }

        const offsetX = col * player.frameWidth;
        const offsetY = row * player.frameHeight;

        playerElement.style.backgroundPosition = `-${offsetX}px -${offsetY}px`;

        if (gameState.battle.active) {
          const battlePlayerSprite = document.querySelector(
            ".battle-area .character-sprite"
          );
          if (battlePlayerSprite) {
            const battleRow = player.directionRowMap["down"];
            const battleFrame = 0;
            const battleOffsetX = battleFrame * player.frameWidth;
            const battleOffsetY = battleRow * player.frameHeight;
            battlePlayerSprite.style.backgroundPosition = `-${battleOffsetX}px -${battleOffsetY}px`;
          }
        }
      }

      function updatePlayerVisualSize() {
        const playerElement = document.getElementById("player");
        if (playerElement) {
          // ESTO ES CRUCIAL: El tamaño del div del jugador DEBE ser el tamaño de UN FRAME
          // Si currentTileSize representa el tamaño deseado del jugador en pantalla,
          // y tus frames en la hoja de sprites son de un tamaño fijo (ej. 64x64),
          // entonces el div del jugador también debe ser de ese tamaño fijo para que background-position funcione.
          // O, si quieres que el jugador se reescale con currentTileSize, entonces frameWidth/Height
          // deben ser iguales a currentTileSize, y background-size debe escalar la hoja completa.

          // Opción A: El jugador mantiene el tamaño del frame original, y currentTileSize es solo para el mapa.
          playerElement.style.width = `${gameState.player.frameWidth}px`;
          playerElement.style.height = `${gameState.player.frameHeight}px`;
        }
      }

      function updatePlayerPosition(callerId = "unknown") {
        const playerElement = document.getElementById("player");
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!playerElement || !mapElement || !mapContainerElement) {
          console.error(
            "UpdatePlayerPosition: Elemento(s) clave no encontrado(s)."
          );
          return;
        }

        const playerVisualWidth = gameState.player.frameWidth; // Usar el tamaño real del frame del sprite
        const playerVisualHeight = gameState.player.frameHeight;

        const playerScreenX =
          mapContainerElement.clientWidth / 2 - playerVisualWidth / 2;
        const playerScreenY =
          mapContainerElement.clientHeight / 2 - playerVisualHeight / 2;

        playerElement.style.left = `${playerScreenX}px`;
        playerElement.style.top = `${playerScreenY}px`;

        const mapScrollX =
          -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapScrollY =
          -(gameState.player.y * currentTileSize) + playerScreenY;

        mapElement.style.transform = `translate(${mapScrollX}px, ${mapScrollY}px)`;

        gameState.map.entities.forEach((entity) => {
          const distance =
            Math.abs(entity.x - gameState.player.x) +
            Math.abs(entity.y - gameState.player.y);
          if (distance <= G_PLAYER_DISCOVERY_RANGE) {
            if (!entity.discovered) entity.discovered = true;
          }
        });

        renderMap(callerId);
        updatePlayerSpriteVisual();
        updatePlayerVisualSize();
        updatePlayerBarsOnMap();
        updateExtraStatsUI();
        updateGrid();
      }

      function updateUI() {
        const player = gameState.player;
        document.getElementById("playerLevel").textContent = player.level;
        document.getElementById("playerRealm").textContent = player.realm;
        document.getElementById("hpText").textContent = `${Math.floor(
          player.hp
        )}/${player.maxHp}`;
        document.getElementById("manaText").textContent = `${Math.floor(
          player.mana
        )}/${player.maxMana}`;
        document.getElementById("expText").textContent = `${Math.floor(
          player.exp
        )}/${player.expToNext}`;

        // Barras del Sidebar
        const hpBarSidebar = document.getElementById("hpBar");
        const manaBarSidebar = document.getElementById("manaBar");
        const expBarSidebar = document.getElementById("expBar");

        if (hpBarSidebar)
          hpBarSidebar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        if (manaBarSidebar)
          manaBarSidebar.style.width = `${
            (player.mana / player.maxMana) * 100
          }%`;
        if (expBarSidebar)
          expBarSidebar.style.width = `${
            (player.exp / player.expToNext) * 100
          }%`;

        document.getElementById(
          "playerCoords"
        ).textContent = `X: ${player.x}, Y: ${player.y}`;

        updateExtraStatsUI();
        updateInventoryUI(); // Asumo que esta función existe y es correcta
        updateSectUI(); // Asumo que esta función existe y es correcta

        updatePlayerBarsOnMap(); // <--- LLAMADA AÑADIDA para las barras sobre el jugador
      }

      function updateInventoryUI() {
        const inventoryDisplay = document.getElementById("inventory");
        inventoryDisplay.innerHTML = "";
        Object.entries(gameState.inventory).forEach(([itemName, count]) => {
          if (count <= 0 && itemName !== "Piedras Espirituales") return;

          const itemDiv = document.createElement("div");
          itemDiv.className = "inventory-item";

          const itemInfo = itemData[itemName];
          const description = itemInfo
            ? itemInfo.description
            : "Un objeto misterioso.";
          itemDiv.innerHTML = `<strong>${itemName}: ${count}</strong><br><small><em>${description}</em></small>`;

          if (count > 0 && itemInfo && itemInfo.effect) {
            const canBeUsedNow = itemInfo.canUse
              ? itemInfo.canUse(gameState.player)
              : true;
            itemDiv.style.cursor = canBeUsedNow ? "pointer" : "not-allowed";
            itemDiv.style.opacity = canBeUsedNow ? 1 : 0.6;
            itemDiv.title = canBeUsedNow
              ? `Usar ${itemName}`
              : `No puedes usar ${itemName} ahora.`;
            if (canBeUsedNow) {
              itemDiv.onclick = () => useItem(itemName);
            }
          } else {
            itemDiv.style.opacity = 0.8;
            itemDiv.style.cursor = "default";
          }
          inventoryDisplay.appendChild(itemDiv);
        });
      }

      function updateRefinementUI() {}

      let lastPlayerAnimationUpdateTime = 0; // Renombrado para claridad

      function handleMovement() {
        let dx = 0;
        let dy = 0;
        let newDirection = null;

        // Determina la dirección del movimiento
        if (playerMovementKeysDown.up) {
          dy = -1;
          newDirection = "up";
        } else if (playerMovementKeysDown.down) {
          dy = 1;
          newDirection = "down";
        } else if (playerMovementKeysDown.left) {
          dx = -1;
          newDirection = "left";
        } else if (playerMovementKeysDown.right) {
          dx = 1;
          newDirection = "right";
        }

        // Si hay una dirección presionada, intenta mover al jugador
        if (newDirection) {
          gameState.player.currentDirection = newDirection;
          movePlayer(dx, dy); // La lógica de cooldown y colisión está dentro
        }

        // Lógica de animación visual (separada de la lógica de movimiento)
        const isActuallyMoving =
          playerMovementKeysDown.up ||
          playerMovementKeysDown.down ||
          playerMovementKeysDown.left ||
          playerMovementKeysDown.right;
        gameState.player.isMoving = isActuallyMoving;
      }

      function interact() {
        console.groupCollapsed(`[Interact LOG] ==> Intento de Interacción`);

          if (gameState.player.isChannelingRune) {
              console.log("-> Acción: plantRune (jugador está canalizando).");
              console.groupEnd();
              plantRune();
              return;
          }
          if (gameState.player.isCultivating || gameState.battle.active) {
              console.log("-> Acción bloqueada (cultivando o en batalla).");
              console.groupEnd();
              showModal("Acción no permitida", "No puedes interactuar ahora.");
              return;
          }

          const playerX = gameState.player.x;
          const playerY = gameState.player.y;
          console.log(`-> Posición del jugador: (${playerX}, ${playerY})`);
        
        // El orden de los offsets ahora importa: priorizamos las casillas cardinales.
        const offsets = [
          { dx: 0, dy: -1 }, // Arriba
          { dx: 1, dy: 0 },  // Derecha
          { dx: 0, dy: 1 },  // Abajo
          { dx: -1, dy: 0 }, // Izquierda
          { dx: 0, dy: 0 },   // La propia casilla (para tiendas, etc.)
          { dx: -1, dy: -1}, // Diagonales
          { dx: 1, dy: -1 },
          { dx: -1, dy: 1 },
          { dx: 1, dy: 1 }
        ];

        // --- INICIO DE LA LÓGICA CORREGIDA ---

        console.log("--- BÚSQUEDA DE COMBATE ---");
          for (const offset of offsets) {
              const targetX = playerX + offset.dx;
              const targetY = playerY + offset.dy;
              const entity = gameState.map.entities.find(e => e.x === targetX && e.y === targetY);

              if (entity) {
                  const entityIdentifier = entity.originalEntityTypeId || entity.type;
                  console.log(`   - Revisando casilla ${offset.name} (${targetX},${targetY}): Encontrado '${entity.name}' (ID maestro: ${entityIdentifier})`);
                  
                  // Esta es la comprobación de si es un enemigo.
                  const isCombatTarget = G_COMBAT_ENTITY_TYPES.includes(entityIdentifier) || entity.isBoss || entity.isMiniBoss;

                  if (isCombatTarget) {
                      console.log(`%c   -> ¡DECISIÓN: INICIAR COMBATE! La entidad '${entity.name}' es un objetivo de combate.`, 'color: #ff6666; font-weight: bold;');
                      console.groupEnd();
                      showModal("¡A la Batalla!", `Decides enfrentar a ${entity.name}.`, true);
                      setTimeout(() => {
                          closeModal();
                          startBattle(entity);
                      }, 1000);
                      return; // ¡ACCIÓN TOMADA! Salimos de la función.
                  } else {
                      console.log(`   -> No es un objetivo de combate.`);
                  }
              }
          }
          // --- PASO 2: SI NO HAY COMBATE, BUSCAR OTRAS INTERACCIONES ---
          console.log("--- BÚSQUEDA DE OTRAS INTERACCIONES ---");
          for (const offset of offsets) {
              const targetX = playerX + offset.dx;
              const targetY = playerY + offset.dy;
              const entitiesInTile = gameState.map.entities.filter(e => e.x === targetX && e.y === targetY);

              if (entitiesInTile.length > 0) {
                   console.log(`   - Revisando casilla ${offset.name} (${targetX},${targetY}): Se encontraron ${entitiesInTile.length} entidades.`);
                  
                   // Buscamos la primera entidad que tenga una interacción definida.
                   const interactableEntity = entitiesInTile.find(e => e.interaction);

                   if (interactableEntity) {
                       console.log(`%c   -> ¡DECISIÓN: INTERACCIÓN GENERAL! La entidad '${interactableEntity.name}' tiene la propiedad 'interaction'.`, 'color: #66ccff; font-weight: bold;');
                       console.groupEnd();
                       handleEntityInteraction(interactableEntity);
                       return; // ¡ACCIÓN TOMADA! Salimos de la función.
                   }
              }
          }
          
          console.log("-> DECISIÓN FINAL: No se encontró ninguna entidad interactuable en las casillas adyacentes.");
          console.groupEnd();
        // PASO 2: Si no se encontró ningún enemigo, buscar otras interacciones (NPCs, tiendas, etc.).
     
        
        console.log("[Interact] No se encontró ninguna entidad interactuable en las casillas adyacentes.");
        // --- FIN DE LA LÓGICA CORREGIDA ---
      }

      function handleEntityInteraction(entity) {
        if (!entity) return;

        let interactionType = entity.interaction; // Priorizar la interacción de la instancia

        // Si no hay interacción en la instancia, buscar en la definición de entityTypes
        // usando entity.originalEntityTypeId si está disponible, sino entity.type
        const definitionKey = entity.originalEntityTypeId || entity.type;
        if (!interactionType && entityTypes[definitionKey]) {
          interactionType = entityTypes[definitionKey].interaction;
        }
        // === INICIO DE LA NUEVA LÓGICA DE TRANSICIÓN ===
        if (interactionType === "transition") {
          const definition = entityTypes[definitionKey];
          if (
            definition &&
            typeof definition.targetX === "number" &&
            typeof definition.targetY === "number"
          ) {
            // Función que se ejecutará si el jugador confirma
            const doTransition = () => {
              gameState.player.x = definition.targetX;
              gameState.player.y = definition.targetY;
              updatePlayerPosition(`transition_to_${definitionKey}`); // ¡Muy importante!
              showModal(
                "Transición Completa",
                `Has llegado a ${definition.name}.`
              );
            };

            // Mostramos el modal de confirmación
            showConfirmationModal(
              `Entrar a ${entity.name}`,
              "¿Deseas pasar a la siguiente zona?",
              doTransition // Pasamos la función como callback
            );
          } else {
            console.warn(
              `La entidad de transición ${definitionKey} no tiene coordenadas de destino (targetX, targetY).`
            );
          }
          return; // Detenemos la ejecución para no procesar otros switches
        }
        if (interactionType === "activate_teleporter") {
          handleTeleporterInteraction(entity);
          return; // Detener para no procesar otros switches
        }
        if (interactionType) {
          switch (interactionType) {
            case "browse":
              if (entity.type === "shop") {
                openShop();
                return;
              }
              break;
            case "talk_story_npc":
              if (entity.npcId) {
                    const dialogue = getStoryNpcDialogue(entity.npcId);
                    showModal(`Hablando con ${entity.name}`, dialogue);
                }
              return;
              
              case "talk_dynamic_npc":
                    if (entity.npcId) {
                        interactWithSectNPC(entity.npcId); // Delegamos a la función principal, que ahora sabrá qué hacer.
                    }
                    return;

            case "read_formation_tutorial":
              openFormationTutorial();
              return;
            case "interact_shrine": // <-- NUEVO CASO
                if (entity.type === 'story_shrine') {
                    const player = gameState.player;
                    const flags = player.worldState.storyFlags;
                    if (flags.knowsAboutSoberano && !flags.knowsFullTruth) {
                        flags.knowsFullTruth = true;
                        showModal("Un Eco del Pasado",
                            "Al tocar el santuario, una voz antigua resuena en tu mente...<br><br><em>'El Soberano Silente... fue nuestro mayor héroe, Longwei. Su poder amenazó con consumir todo, y lo sellamos. Pero el sello no es eterno... La resonancia en tu alma... el Arte del Corazón Celeste... no es para sellar, sino para purificar. Esa es tu verdadera prueba.'</em><br><br><strong>La verdad completa te ha sido revelada.</strong>"
                        );
                    } else if (flags.knowsFullTruth) {
                        showModal("Santuario del Eco", "El santuario permanece en silencio, su propósito cumplido. El camino ahora es tuyo.");
                    } else {
                        showModal("Santuario del Eco", "Sientes una energía antigua y melancólica, pero no puedes descifrar su significado... todavía.");
                    }
                }
                return;
            case "read_lore":
              if (entity.loreText) {
                  showModal(entity.name, `<em>${entity.loreText}</em>`);
              }
              return;
            case "talk_secta_npc":
              if (entity.npcId) {
                interactWithSectNPC(entity.npcId);
                return;
              }
              break;
            case "access_sect_hall":
              if (entity.type === "secta_entrada_principal") {
                openSectHallInterface();
                return;
              }
              break;
            case "collect_resource":
              const rewardItem =
                entity.reward ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].reward
                  : null) ||
                "Piedras Espirituales"; // Último fallback

              const itemNameDisplay =
                entity.name ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].name
                  : entity.type);

              gameState.inventory[rewardItem] =
                (gameState.inventory[rewardItem] || 0) + 1;
              showModal(
                "Recurso Encontrado",
                `Has obtenido: 1 ${rewardItem}! (de ${itemNameDisplay})`
              );
              removeEntity(entity);
              updateInventoryUI();
              return;
            case "learn_from_master":
              const expGain =
                entity.expGain || entityTypes[entity.type]?.expGain || 50;
              gainExperience(expGain);
              showModal(
                "Encuentro con Maestro",
                `El ${entity.name} te ha enseñado sabiduría. Ganas ${expGain} EXP!`
              );
              removeEntity(entity);
              return;
            case "meditate_spot":
              const manaGain =
                entity.manaGain || entityTypes[entity.type]?.manaGain || 20;
              gameState.player.mana = Math.min(
                gameState.player.maxMana,
                gameState.player.mana + manaGain
              );
              showModal(
                "Lugar de Cultivo",
                `Has meditado en '${entity.name}'. Recuperas ${manaGain} Maná.`
              );
              removeEntity(entity);
              updateUI();
              return;
            default:
              console.warn(
                `Interacción '${interactionType}' desconocida para ${entity.name} (Tipo: ${entity.type}, ID: ${entity.id}).`
              );
              break;
          }
        } else {
          console.log(
            `No hay acción definida para tipo '${entity.type}' (Entidad: ${entity.name}, ID: ${entity.id}, OrigTypeID: ${entity.originalEntityTypeId}).`
          );
        }
      }

      

     
function interactWithSectNPC(npcId) {

    const npcData = SECTA_DATA.npcs[npcId] || entityTypes[npcId];
    
    
    const player = gameState.player;
    console.groupCollapsed(`[interactWithSectNPC v3] ==> Hablando con NPC: ${npcId}`);

    // Si no encontramos datos del NPC en ninguna parte, salimos.
    if (!npcData) {
        console.error(`[v3] FATAL: No se encontraron datos para el NPC con ID '${npcId}' ni en SECTA_DATA ni en entityTypes.`);
        console.groupEnd();
        return;
    }

    if (npcId === 'npc_maestro_feng') {
        const fengProgress = player.worldState.subplotFlags.fengQuestProgress;
        console.log(`-> Es Maestro Feng. Progreso de subtrama actual: ${fengProgress}`);

        // --- PASO 1: ¿HAY UNA MISIÓN LISTA PARA COMPLETAR? (Prioridad Absoluta) ---
        const missionReadyToComplete = player.secta.misionesActivas.find(m => 
            (MISIONES_DATA[m.id]?.objetivo?.npcEntrega === 'npc_maestro_feng' || MISIONES_DATA[m.id]?.npcInicio === 'npc_maestro_feng') && 
            m.progreso >= 1
        );

        if (missionReadyToComplete) {
            console.log(`%c-> CASO 1: Se encontró una misión lista para completar: ${missionReadyToComplete.id}. Llamando a completeMission...`, 'color: #33cc33');
            console.groupEnd();
            completeMission(missionReadyToComplete.id, 'npc_maestro_feng');
            return; // ¡ACCIÓN TOMADA! Salimos de la función.
        }
        
        // --- PASO 2: SI NO, DETERMINAR QUÉ HACER BASADO EN EL PROGRESO ---
        const dialogue = getDynamicNpcDialogue(npcId);
        const fengMissionMap = {
            1: 'mision_feng_1_tutorial',
            2: 'mision_feng_2_prueba_vital',
            3: 'mision_feng_3_romper_sello',
            4: 'mision_feng_4_la_egida',
        };
        const expectedMissionId = fengMissionMap[fengProgress];
        
        if (expectedMissionId) {
            const isMissionAlreadyActive = player.secta.misionesActivas.some(m => m.id === expectedMissionId);
            
            if (isMissionAlreadyActive) {
                // La misión que corresponde a este paso ya está en el diario, pero su objetivo no está cumplido.
                console.log(`%c-> CASO 2: La misión esperada (${expectedMissionId}) ya está activa. Mostrando recordatorio.`, 'color: #ffcc00');
                const missionData = MISIONES_DATA[expectedMissionId];
                showModal(npcData.name, `Aún no has completado mi prueba. Recuerda tu tarea actual: <em>"${missionData.descripcion}"</em>`);
            } else {
                // No tenemos la misión que corresponde a este paso. Hay que ofrecerla.
                console.log(`%c-> CASO 3: La misión esperada (${expectedMissionId}) no está activa. Ofreciéndola ahora.`, 'color: #66ccff');
                showConfirmationModal(
                    `Un Desafío de ${npcData.name}`,
                    dialogue,
                    () => { acceptMission(expectedMissionId); }
                );
            }
        } else {
            // --- PASO 3: SI NO HAY MISIÓN ESPERADA, ES UN DIÁLOGO GENÉRICO ---
            console.log(`-> CASO 4: No hay misión asociada al progreso actual. Mostrando diálogo estándar.`);
            showModal(npcData.name, dialogue);
        }
        
        console.groupEnd();
        return;
    }
    
    // --- LÓGICA PARA NPCs ESTÁTICOS DE LA SECTA (SIN CAMBIOS) ---
    console.log(`-> Es un NPC estándar de la secta.`);
    let modalContentHTML = `<h3>${npcData.nombre} (${npcData.rol})</h3><p><em>"${npcData.dialogoInicial}"</em></p><hr>`;
    const elementsToProcess = [];

    modalContentHTML += `<h4>Misiones para Entregar/Reportar:</h4>`;
    const misionesParaCompletar = player.secta.misionesActivas.filter(m => {
        const mData = MISIONES_DATA[m.id];
        if (!mData || mData.objetivo?.npcEntrega !== npcId) return false;
        
        const objetivo = mData.objetivo;
        switch (objetivo.tipo) {
            case "eliminar_enemigo":
            case "derrotar_npc_especifico":
            case "llegar_a_punto":
            case "trazar_patron":
                return (m.progreso || 0) >= (objetivo.cantidad || 1);
            case "entregar_item":
                return (gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad;
            case "cazar_y_recuperar_item_de_loot":
                return (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba;
            case "recolectar_multiples_items":
                return objetivo.items.every(itemReq => (gameState.inventory[itemReq.nombre] || 0) >= itemReq.cantidad);
            default: return false;
        }
    });

    if (misionesParaCompletar.length > 0) {
        misionesParaCompletar.forEach(misionActiva => {
            const misionDef = MISIONES_DATA[misionActiva.id];
            const buttonId = `complete-mission-btn-${misionActiva.id}`;
            modalContentHTML += `<div style="padding: 5px; border: 1px solid #55cc55; margin-bottom: 5px; background-color: rgba(85,204,85,0.1);">
                                  <strong>${misionDef.titulo}</strong> ${getMissionProgressText(misionActiva)}<br>
                                  <button id="${buttonId}">Completar Misión</button>
                              </div>`;
            elementsToProcess.push({
                buttonId: buttonId,
                action: () => {
                    if (completeMission(misionActiva.id, npcId)) {
                        setTimeout(() => interactWithSectNPC(npcId), 100);
                    }
                },
            });
        });
    } else {
        modalContentHTML += "<p>No tienes misiones listas para entregarme.</p>";
    }
    modalContentHTML += "<hr>";

    modalContentHTML += `<h4>Misiones Disponibles:</h4>`;
    let algunaMisionDisponible = false;
    (npcData.misionesOfrecidas || []).forEach(misionId => {
        const mision = MISIONES_DATA[misionId];
        if (mision && !player.secta.misionesActivas.some(m => m.id === misionId) && !player.secta.misionesCompletadas[misionId]) {
            const nivelOk = player.level >= (mision.requisitoNivel || 0);
            const rankIndexPlayer = SECTA_DATA.rangos.findIndex(r => r.nombre === player.secta.rango);
            const rankIndexReq = mision.requisitoRango ? SECTA_DATA.rangos.findIndex(r => r.nombre === mision.requisitoRango) : -1;
            const rangoOk = rankIndexPlayer >= rankIndexReq;

            if (nivelOk && rangoOk) {
                algunaMisionDisponible = true;
                const buttonId = `accept-mission-btn-${misionId}`;
                modalContentHTML += `<div style="padding: 5px; border: 1px solid #555; margin-bottom: 5px;">
                                          <strong>${mision.titulo}</strong><br><small>${mision.descripcion}</small><br>
                                          <button id="${buttonId}">Aceptar</button>
                                      </div>`;
                elementsToProcess.push({
                    buttonId: buttonId,
                    action: () => {
                        acceptMission(misionId);
                        setTimeout(() => interactWithSectNPC(npcId), 100);
                    },
                });
            }
        }
    });

    if (!algunaMisionDisponible) {
        modalContentHTML += "<p>No tengo nuevas asignaciones para ti en este momento.</p>";
    }

    console.groupEnd();
    showModal("Interacción con " + npcData.nombre, modalContentHTML);
    const modalTextEl = document.getElementById("modalText");
    if (modalTextEl) {
        elementsToProcess.forEach(item => {
            const buttonElement = modalTextEl.querySelector("#" + item.buttonId);
            if (buttonElement) {
                buttonElement.onclick = item.action;
            }
        });
    }
}
          

      function sanitizeActiveMissions(player) {
    if (!player || !player.secta || !player.secta.misionesActivas) {
        console.warn("[Sanitize] No se encontraron misiones activas para sanitizar.");
        return;
    }

    console.log("[Sanitize] Iniciando la revisión y actualización de misiones activas...");
    
    // Usamos filter para crear una nueva lista de misiones saneadas y eliminar las obsoletas.
    const saneadasYValidas = player.secta.misionesActivas.filter(misionActiva => {
        const masterMissionData = MISIONES_DATA[misionActiva.id];
        
        // Si la misión ya no existe en los datos maestros, la eliminamos del guardado.
        if (!masterMissionData || !masterMissionData.objetivo) {
            console.warn(`[Sanitize] Misión obsoleta '${misionActiva.id}' eliminada del guardado.`);
            return false; // 'filter' descartará este elemento.
        }

        // --- LÓGICA DE ACTUALIZACIÓN CLAVE ---
        // Comparamos el objetivo guardado con el maestro. Si son diferentes, lo actualizamos.
        // Usamos JSON.stringify para una comparación profunda y sencilla de los objetos.
        const guardadoJSON = JSON.stringify(misionActiva.objetivoOriginal);
        const maestroJSON = JSON.stringify(masterMissionData.objetivo);

        if (guardadoJSON !== maestroJSON) {
            console.warn(`[Sanitize] ¡INCONSISTENCIA DETECTADA! Misión: '${misionActiva.id}'.`);
            console.warn(`           -> Objetivo Guardado: ${guardadoJSON}`);
            console.warn(`           -> Objetivo Maestro:  ${maestroJSON}`);
            console.log(`[Sanitize]   CORRIGIENDO: Se reemplazará el objetivo guardado con la versión más reciente.`);
            
            // Reemplazamos el objetivo corrupto o desactualizado con una copia nueva y correcta del maestro.
            misionActiva.objetivoOriginal = JSON.parse(maestroJSON);
        }
        
        return true; // Mantenemos la misión en la lista.
    });

    // Reemplazamos la lista de misiones del jugador por la versión saneada.
    player.secta.misionesActivas = saneadasYValidas;
    
    console.log("[Sanitize] Revisión de misiones completada.");
}
      
      function openFormationTutorial() {
        const modal = document.getElementById('formationTutorialModal');
        const gridContainer = document.getElementById('formation-pattern-grid');
        gridContainer.innerHTML = ''; // Limpiar la cuadrícula

        // Usamos el patrón de ejemplo "Hexagrama Devastador"
        const examplePattern = FORMATION_PATTERNS.shattering_hexagram.pattern;

        for (let r = 0; r < examplePattern.length; r++) {
            for (let c = 0; c < examplePattern[r].length; c++) {
                const cellValue = examplePattern[r][c];
                const cellDiv = document.createElement('div');
                cellDiv.className = 'grid-cell';

                if (cellValue === 1) {
                    cellDiv.classList.add('rune');
                    cellDiv.textContent = '●'; // Símbolo para la runa
                } else if (cellValue === 2) {
                    cellDiv.classList.add('enemy');
                    cellDiv.textContent = 'X'; // Símbolo para el enemigo
                }
                gridContainer.appendChild(cellDiv);
            }
        }
        
        modal.style.display = 'flex';
        hideTouchControls();
        updateStatsPanelVisibility();
    }

      function closeFormationTutorial() {
        const modal = document.getElementById('formationTutorialModal');
        modal.style.display = 'none';
        showTouchControls();
        updateStatsPanelVisibility();
    }


      function entregarRecursoSecta(itemName, cantidad, pcsGanados) {
        if ((gameState.inventory[itemName] || 0) < cantidad) {
          showModal("Error", "No tienes suficientes objetos.");
          return;
        }
        gameState.inventory[itemName] -= cantidad;
        gameState.player.secta.puntosContribucion += pcsGanados;
        showModal(
          "Recurso Entregado",
          `Entregaste ${cantidad} ${itemName} y ganaste ${pcsGanados} PCS.`
        );
        updateSectUI();
        updateInventoryUI();
        checkAndActivateRankChallengeMissions();
        closeModal();
      }


      function getNpcIndicator(npcId) {
          const player = gameState.player;
          const npcData = SECTA_DATA.npcs[npcId];
          if (!npcData) return null;

          // --- PRIORIDAD 1: ¿Se debe ENTREGAR una misión a este NPC? ---
          const misionParaEntregar = player.secta.misionesActivas.find(misionActiva => {
              const misionDef = MISIONES_DATA[misionActiva.id];
              if (!misionDef || !misionDef.objetivo || misionDef.objetivo.npcEntrega !== npcId) {
                  return false;
              }
              // Comprobar si el objetivo está realmente cumplido
              const progreso = misionActiva.progreso || 0;
              const objetivo = misionDef.objetivo;
              switch (objetivo.tipo) {
                  case "eliminar_enemigo":
                  case "derrotar_npc_especifico":
                  case "llegar_a_punto":
                      return progreso >= (objetivo.cantidad || 1);
                  case "entregar_item":
                      return (gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad;
                  case "cazar_y_recuperar_item_de_loot":
                      return (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba;
                  case "recolectar_multiples_items":
                      return objetivo.items.every(itemReq => (gameState.inventory[itemReq.nombre] || 0) >= itemReq.cantidad);
                  default:
                      return false;
              }
          });
          if (misionParaEntregar) {
              return { type: '?', class: 'indicator-progress' }; // Interrogación blanca para entregar
          }
          
          // --- PRIORIDAD 2: ¿Tiene este NPC una misión NUEVA para ofrecer? ---
          if (npcData.misionesOfrecidas) {
              const hayMisionNueva = npcData.misionesOfrecidas.some(misionId => {
                  const mision = MISIONES_DATA[misionId];
                  if (!mision || player.secta.misionesActivas.some(m => m.id === misionId) || player.secta.misionesCompletadas[misionId]) {
                      return false; // Misión no existe, ya está activa o completada
                  }
                  // Comprobar requisitos de nivel y rango
                  const nivelOk = (player.level >= (mision.requisitoNivel || 0));
                  let rangoOk = true;
                  if (mision.requisitoRango) {
                      const playerRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === player.secta.rango);
                      const requiredRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === mision.requisitoRango);
                      if (playerRankIndex < requiredRankIndex) {
                          rangoOk = false;
                      }
                  }
                  return nivelOk && rangoOk;
              });
              if (hayMisionNueva) {
                  return { type: '!', class: 'indicator-available' }; // Exclamación amarilla para nueva misión
              }
          }

          // --- PRIORIDAD 3: ¿Tiene el NPC diálogo de HISTORIA principal importante? ---
          const flags = player.worldState.storyFlags;
          if (npcId === 'anciana_su' && player.secta.misionesCompletadas['mision_historia_1_demonio'] && !flags.knowsAboutCalamity) {
              return { type: '?', class: 'indicator-progress' }; // Diálogo importante tras derrotar al demonio
          }
          if (npcId === 'maestro_jian' && flags.knowsAboutCalamity && !flags.knowsAboutSoberano) {
              // Si sabes de la calamidad pero no del soberano, el maestro tiene algo que decirte
              // (Aunque esta lógica está en el desafío de Diácono, la podemos reflejar aquí también)
          }

          return null; // Sin indicador
      }

      function acceptMission(misionId) {
        console.groupCollapsed(`[acceptMission v2] ==> Intentando aceptar misión: ${misionId}`);
        const misionData = MISIONES_DATA[misionId];
        const player = gameState.player;
        
        if (!misionData || !misionData.objetivo) {
            console.error(`[v2] ERROR: No se encontraron datos para la misión '${misionId}'.`);
            console.groupEnd();
            showModal("Error de Misión", "Datos de misión no encontrados o corruptos.");
            return;
        }

        if (player.secta.misionesActivas.some((m) => m.id === misionId) || player.secta.misionesCompletadas[misionId]) {
            console.warn(`[v2] ADVERTENCIA: La misión '${misionId}' ya está activa o completada.`);
            console.groupEnd();
            showModal("Error de Misión", "Ya has aceptado o completado esta misión.");
            return;
        }

        const nuevaMisionActiva = {
            id: misionId,
            progreso: 0,
            objetivoOriginal: JSON.parse(JSON.stringify(misionData.objetivo)),
        };
        
        console.log(`[v2] Misiones activas ANTES de añadir:`, player.secta.misionesActivas.length);
        player.secta.misionesActivas.push(nuevaMisionActiva);
        console.log(`[v2] Misión '${misionId}' añadida. Misiones activas DESPUÉS:`, player.secta.misionesActivas.length);
        
        if (misionId === 'mision_feng_1_tutorial') {
            const patternId = misionData.objetivo.patternId;
            if (patternId && !player.discoveredFormationPatterns[patternId]) {
                player.discoveredFormationPatterns[patternId] = true;
                console.log(`[acceptMission] Patrón de misión '${patternId}' desbloqueado.`);
            }
        }

        showModal("Misión Aceptada", `Has aceptado: ${misionData.titulo}`);
        updateSectUI();

        const npcInteractionModal = document.getElementById("interactionModal");
        if (npcInteractionModal.style.display === "flex") {
            closeModal();
        }
        console.groupEnd();
        // --- FIN DE CORRECCIÓN Y LOGS ---
    }

      function removeEntity(entityToRemove) {
        const index = gameState.map.entities.findIndex(
          (e) => e.id === entityToRemove.id
        ); // Usar ID único

        if (index > -1) {
          const removedEntity = gameState.map.entities.splice(index, 1)[0];

          // Si la entidad provenía de una zona de spawn, actualizar el contador de esa zona
          if (removedEntity.zoneOrigin) {
            const originZone = gameState.map.terrainZones.find(
              (z) => z.name === removedEntity.zoneOrigin && z.spawnSettings
            );
            if (originZone) {
              const targetSpawnInfo =
                originZone.spawnSettings.targetEntities.find(
                  (t) => t.entityTypeId === removedEntity.originalEntityTypeId // <-- USAR ESTO
                );
              if (targetSpawnInfo && targetSpawnInfo.currentCount > 0) {
                targetSpawnInfo.currentCount--;
                // console.log(`Entidad ${removedEntity.name} eliminada de zona ${originZone.name}. Restantes de tipo ${targetSpawnInfo.entityTypeId}: ${targetSpawnInfo.currentCount}`);

                // Si el contador baja y el timer estaba en cooldown, podemos resetear el timer
                // para que intente reaparecer antes si la zona está por debajo del objetivo.
                // Opcional: Podrías querer que el cooldown siempre se cumpla.
                // if (originZone.spawnSettings.respawnTimer > 10) { // Si estaba en cooldown largo
                //    originZone.spawnSettings.respawnTimer = 10; // Poner un cooldown corto para el próximo chequeo
                // }
              }
            }
          }
          renderMap(); // Actualizar visualización
        }
      }

      function isRespawnNeeded() {
        const player = gameState.player;
        const activeBoss = gameState.map.entities.find(
          (e) =>
            e.isBoss &&
            !player.worldState.defeatedBosses[e.id || e.type] &&
            Math.abs(e.x - player.x) <= 5 &&
            Math.abs(e.y - player.y) <= 5
        );
        return !activeBoss;
      }

      function toggleCultivation() {
        if (gameState.battle.active) {
          showModal("Acción no permitida", "No puedes cultivar en combate.");
          return;
        }
        if (gameState.player.isCultivating) {
          showActiveCultivationModal();
        } else {
          openCultivationChoiceModal();
        }
      }

      function openCultivationChoiceModal() {
        const player = gameState.player;
        const techniquesListDiv = document.getElementById(
          "cultivableTechniquesList"
        );

        // Comprobación de seguridad
        if (!techniquesListDiv) {
          console.error(
            "Error: El contenedor 'cultivableTechniquesList' no se encontró en el HTML."
          );
          return;
        }

        techniquesListDiv.innerHTML = ""; // Limpiar contenido anterior
        let hasCultivableTechniques = false;

        for (const techId in player.learnedTechniques) {
          const playerTech = player.learnedTechniques[techId];
          const techData = techniqueData[techId];
          if (
            techData &&
            techData.cultivationSettings &&
            playerTech.level < techData.maxLevel
          ) {
            hasCultivableTechniques = true;
            const techButton = document.createElement("button");
            techButton.className = "cultivation-option-btn";
            techButton.textContent = `${techData.name} (Nv. ${playerTech.level})`;

            // --- LA CORRECCIÓN CLAVE ESTÁ AQUÍ ---
            techButton.onclick = () => {
              // 1. Primero, cerramos el modal actual.
              closeCultivationChoiceModal();
              // 2. Después, iniciamos el nuevo modo de cultivo.
              startCultivationMode("technique", techId);
            };
            // --- FIN DE LA CORRECCIÓN ---

            techniquesListDiv.appendChild(techButton);
          }
        }

        if (!hasCultivableTechniques) {
          techniquesListDiv.innerHTML =
            "<p>No tienes técnicas que requieran más cultivo.</p>";
        }

        document.getElementById("cultivationChoiceModal").style.display =
          "flex";
        hideTouchControls();
      }

      function closeCultivationChoiceModal() {
        document.getElementById("cultivationChoiceModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
      }

      function startCultivationMode(type, targetId = null) {
        // --- INICIO DE LA CORRECCIÓN ---
        // Siempre que se inicie un modo de cultivo, cerramos el modal de elección.
        closeCultivationChoiceModal();
        // --- FIN DE LA CORRECCIÓN ---

        console.log(
          `[Cultivo LOG] ==> INTENTO DE INICIAR CULTIVO (Tipo: '${type}', Técnica: '${targetId}')`
        );
        if (gameState.player.isCultivating || gameState.cultivationInterval) {
          stopCultivation();
        }

        gameState.player.isCultivating = true;
        gameState.player.cultivationMode = {
          type,
          targetId,
          startTime: Date.now(),
          isConversionCultivation: false,
        };

        gameState.cultivationInterval = setInterval(
          processCultivationTick,
          1000
        );
        console.log(
          `[Cultivo LOG] -> NUEVO INTERVALO CREADO. ID: ${gameState.cultivationInterval}`
        );

        showActiveCultivationModal();
        renderQuickSlotBar();
      }

      function stopCultivation(
        showFeedbackModal = false,
        feedbackMessage = {}
      ) {
        const player = gameState.player;
        console.log(`[Cultivo LOG] ==> INTENTO DE DETENER CULTIVO`);

        if (!gameState.cultivationInterval) {
          console.log(
            `[Cultivo LOG]   -> No hay intervalo que detener. El cultivo ya estaba parado.`
          );
          // Aún así, reseteamos el estado del jugador por si está desincronizado.
          player.isCultivating = false;
          player.cultivationMode = {
            type: null,
            targetId: null,
            startTime: 0,
            isConversionCultivation: false,
          };
          console.log(
            `[Cultivo LOG]   -> Estado del jugador reseteado por seguridad.`
          );
          return;
        }

        const intervalToClear = gameState.cultivationInterval;
        console.log(
          `[Cultivo LOG]   -> Limpiando intervalo con ID: ${intervalToClear}`
        );
        clearInterval(intervalToClear);
        gameState.cultivationInterval = null;
        console.log(
          `[Cultivo LOG]   -> Intervalo limpiado. gameState.cultivationInterval ahora es: ${gameState.cultivationInterval}`
        );

        player.isCultivating = false;
        player.cultivationMode = {
          type: null,
          targetId: null,
          startTime: 0,
          isConversionCultivation: false,
        };
        console.log(
          `[Cultivo LOG]   -> Estado del jugador reseteado: isCultivating = ${player.isCultivating}`
        );

        closeActiveCultivationModal();
        renderQuickSlotBar();
        updateUI();

        if (showFeedbackModal) {
          console.log(
            `[Cultivo LOG]   -> Mostrando modal de feedback: "${feedbackMessage.title}"`
          );
          showModal(
            feedbackMessage.title || "Cultivo Detenido",
            feedbackMessage.text || "Has dejado de cultivar."
          );
        }
      }

      function showActiveCultivationModal() {
        const player = gameState.player;
        const modal = document.getElementById("activeCultivationModal");
        if (!modal) return; // Salida temprana si el modal no existe.

        // Ocultar todas las secciones primero
        const techUI = document.getElementById("activeCultivationProgressUI");
        const recoveryUI = document.getElementById(
          "recoveryCultivationProgressUI"
        );
        const boostUI = document.getElementById("cultivationBoostSection");

        if (techUI) techUI.style.display = "none";
        if (recoveryUI) recoveryUI.style.display = "none";
        if (boostUI) boostUI.style.display = "none";

        if (!player.isCultivating) {
          modal.style.display = "none";
          return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        const titleEl = document.getElementById("activeCultivationTitle");
        const descEl = document.getElementById("activeCultivationDescription");
        if (!titleEl || !descEl) return;

        if (mode === "technique" && targetId) {
          const techData = techniqueData[targetId];
          const playerTech = player.learnedTechniques[targetId];

          if (techData && playerTech && techUI) {
            techUI.style.display = "block";
            if (boostUI) boostUI.style.display = "block";

            titleEl.textContent = `Cultivando: ${techData.name}`;
            descEl.textContent = techData.description;

            // Actualizar UI de la técnica
            const nameSpan = document.getElementById(
              "activeCultivationTargetName"
            );
            const levelSpan = document.getElementById(
              "activeCultivationTargetLevel"
            );
            if (nameSpan) nameSpan.textContent = techData.name;
            if (levelSpan) levelSpan.textContent = playerTech.level;

            // Lógica de la barra de progreso
            const progressBar = document.getElementById(
              "activeCultivationProgressBar"
            );
            const progressText = document.getElementById(
              "activeCultivationProgressText"
            );
            if (progressBar && progressText) {
              const progress = playerTech.currentCultivationProgress || 0;
              const timeToNext =
                playerTech.cultivationTimeToNextLevel || Infinity;
              let percent =
                timeToNext > 0 && timeToNext !== Infinity
                  ? (progress / timeToNext) * 100
                  : playerTech.level >= techData.maxLevel
                  ? 100
                  : 0;

              progressBar.style.width = `${Math.min(100, percent)}%`;
              progressText.textContent =
                timeToNext === Infinity
                  ? "Nivel Máximo"
                  : `${Math.floor(progress)}s / ${timeToNext}s`;
            }

            // Actualizar sección de aceleración
            const stonesDisplay = document.getElementById("cultivationModalPlayerStones");
            const boostButton1 = document.getElementById("boostCultivationButton1");
            const boostButton10 = document.getElementById("boostCultivationButton10");
            const boostButtonAll = document.getElementById("boostCultivationButtonAll"); 
            const currentStones = gameState.inventory["Piedras Espirituales"] || 0;
            const isMaxLevel = playerTech.level >= techData.maxLevel;
            if (stonesDisplay) stonesDisplay.textContent = currentStones;
            
            if (boostButton1) {
                boostButton1.disabled = currentStones < 1 || isMaxLevel;
            }
            if (boostButton10) {
                boostButton10.disabled = currentStones < 10 || isMaxLevel;
            }if (boostButtonAll) {
                if (isMaxLevel) {
                    boostButtonAll.disabled = true;
                    boostButtonAll.textContent = "Nivel Máximo";
                } else {
                    const timePerStone = 10;
                    const progressNeeded = playerTech.cultivationTimeToNextLevel - (playerTech.currentCultivationProgress || 0);
                    const stonesNeeded = Math.ceil(progressNeeded / timePerStone);

                    boostButtonAll.disabled = currentStones < 1;
                    // Actualizamos el texto para que sea claro
                    boostButtonAll.textContent = `⏫ Subir Nivel (${stonesNeeded} PS)`;
                    boostButtonAll.onclick = () => boostCultivationWithAllStones();
                }
            }
          
          
              }

          
        } else if (mode === "recovery") {
          if (recoveryUI) {
            recoveryUI.style.display = "block";
            titleEl.textContent = "Meditación Restauradora";
            descEl.textContent = "Recuperando energía...";

            // Actualizar barras de HP/Maná del modal
            const hpText = document.getElementById("modalHpText");
            const hpBar = document.getElementById("modalHpBar");
            const manaText = document.getElementById("modalManaText");
            const manaBar = document.getElementById("modalManaBar");
            if (hpText)
              hpText.textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
            if (hpBar)
              hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
            if (manaText)
              manaText.textContent = `${Math.floor(player.mana)}/${
                player.maxMana
              }`;
            if (manaBar)
              manaBar.style.width = `${(player.mana / player.maxMana) * 100}%`;
          }
        }

        modal.style.display = "flex";
        hideTouchControls();
      }

      function updateStatsPanelVisibility() {
        const statsPanel = document.querySelector(".stats-panel");
        if (!statsPanel) {
          console.error(
            "No se encontró el elemento .stats-panel para actualizar su visibilidad."
          );
          return;
        }

        // El panel debe estar oculto si la batalla está activa O si cualquier modal está abierto.
        const shouldBeHidden = gameState.battle.active || isAnyModalOpen();

        if (shouldBeHidden) {
          statsPanel.classList.add("hidden");
        } else {
          statsPanel.classList.remove("hidden");
        }
      }

      function closeActiveCultivationModal() {
        document.getElementById("activeCultivationModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
      }

      function processCultivationTick() {
        const player = gameState.player;

        // Medida de seguridad: si el tick se ejecuta cuando no debería, se detiene.
        if (!player.isCultivating || !gameState.cultivationInterval) {
          stopCultivation();
          return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        // --- CULTIVO DE TÉCNICA (sin cambios, ya funciona bien) ---
        if (mode === "technique" && targetId) {
          const playerTech = player.learnedTechniques[targetId];
          const techData = techniqueData[targetId];
          if (playerTech && techData && playerTech.level < techData.maxLevel) {
            playerTech.currentCultivationProgress =
              (playerTech.currentCultivationProgress || 0) + 1;
            const progress = playerTech.currentCultivationProgress;
            const required = playerTech.cultivationTimeToNextLevel || Infinity;

            if (progress >= required) {
              playerTech.level++;
              playerTech.currentCultivationProgress = 0;
              playerTech.cultivationTimeToNextLevel =
                playerTech.level < techData.maxLevel
                  ? Math.floor(
                      techData.cultivationSettings.baseTimeToLevelUp *
                        Math.pow(
                          techData.cultivationSettings.levelTimeMultiplier,
                          playerTech.level
                        )
                    )
                  : Infinity;
              applyTechniqueEffect(targetId, playerTech.level);
              recalculatePlayerStats();
              stopCultivation(true, {
                title: "¡Técnica Mejorada!",
                text: `¡'${techData.name}' ha subido al Nivel ${playerTech.level}!`,
              });
              return;
            }
          } else {
            stopCultivation(true, {
              title: "Cultivo Detenido",
              text: "La técnica ha alcanzado su máximo potencial.",
            });
            return;
          }

          // --- CULTIVO DE RECUPERACIÓN ---
        } else if (mode === "recovery") {
          // =========================================================================
          // === CORRECCIÓN CLAVE: Lógica de Conversión de Qi (SI ESTÁ ACTIVA) ===
          // =========================================================================
          if (player.cultivationMode.isConversionCultivation) {
            const conversionTechInfo = techniqueData["qi_to_hp_conversion_1"];
            const playerConversionTech =
              player.learnedTechniques["qi_to_hp_conversion_1"];

            if (conversionTechInfo?.effect && playerConversionTech?.level > 0) {
              const effectDef = conversionTechInfo.effect;
              const techLevel = playerConversionTech.level;

              const manaCost = Math.max(
                0.1,
                effectDef.baseManaCostPerSecond -
                  (effectDef.manaCostReductionPerLevel || 0) * (techLevel - 1)
              );
              const hpGain =
                effectDef.baseHpGainPerSecond +
                (effectDef.hpGainIncreasePerLevel || 0) * (techLevel - 1);

              // Si se puede convertir, se hace y se termina el tick.
              if (player.mana >= manaCost && player.hp < player.maxHp) {
                player.mana -= manaCost; // <-- Se resta el maná.
                player.hp = Math.min(player.maxHp, player.hp + hpGain);
                // IMPORTANTE: No se ejecuta nada más de recuperación en este tick.
              } else {
                // Si no se puede, se detiene el cultivo con un mensaje.
                stopCultivation(true, {
                  title: "Conversión Detenida",
                  text: "Maná insuficiente o vida al máximo.",
                });
                return; // Salimos del tick para no hacer nada más.
              }
            } else {
              // Si por alguna razón falta la técnica, se detiene para evitar errores.
              stopCultivation(true, {
                title: "Error de Técnica",
                text: "No se encontró la técnica de Conversión de Qi.",
              });
              return;
            }

            // ==================================================================================
            // === Lógica de Meditación Restauradora Normal (SOLO SI LA CONVERSIÓN NO ESTÁ ACTIVA) ===
            // ==================================================================================
          } else {
            if (player.hp < player.maxHp) {
              player.hp = Math.min(
                player.maxHp,
                player.hp + player.hpPerSecondBase
              );
            }
            if (player.mana < player.maxMana) {
              player.mana = Math.min(
                player.maxMana,
                player.mana + player.qiPerSecondBase
              );
            }
            gainExperience(player.expPerSecondBase);
          }
        }

        // Al final del tick, se actualiza la UI con los nuevos valores.
        updateUI();
        showActiveCultivationModal();
      }

      function boostCultivationProgress(amount = 1) { // Acepta un argumento 'amount', con 1 como valor por defecto
        const player = gameState.player;
        const mode = player.cultivationMode;
        const timePerStone = 10; // 10 segundos de progreso por cada piedra

        if (!player.isCultivating || mode.type !== 'technique' || !mode.targetId) return;

        // Comprobamos si el jugador tiene suficientes piedras
        if ((gameState.inventory["Piedras Espirituales"] || 0) < amount) {
            showModal("Piedras Insuficientes", `Necesitas al menos ${amount} Piedras Espirituales para hacer esto.`);
            return;
        }

        const techId = mode.targetId;
        const playerTech = player.learnedTechniques[techId];
        const techData = techniqueData[techId];

        if (!playerTech || !techData || !techData.cultivationSettings || playerTech.level >= techData.maxLevel) {
            showModal("Límite Alcanzado", "Esta técnica ya está en su nivel máximo.");
            return;
        }

        // Restamos la cantidad de piedras y añadimos el progreso correspondiente
        gameState.inventory["Piedras Espirituales"] -= amount;
        playerTech.currentCultivationProgress = (playerTech.currentCultivationProgress || 0) + (amount * timePerStone);
        
        let leveledUpThisBoost = false;
        let firstLevelUpMessage = "";

        // Bucle para comprobar si se sube de nivel (puede subir varios niveles de golpe)
        while (
            playerTech.currentCultivationProgress >= playerTech.cultivationTimeToNextLevel &&
            playerTech.level < techData.maxLevel
        ) {
            leveledUpThisBoost = true;
            const progressNeeded = playerTech.cultivationTimeToNextLevel;
            playerTech.currentCultivationProgress -= progressNeeded;
            playerTech.level++;

            if (!firstLevelUpMessage) {
                firstLevelUpMessage = `¡Aceleraste '${techData.name}' al Nivel ${playerTech.level}!`;
                if (playerTech.level >= techData.maxLevel) {
                    firstLevelUpMessage += " (¡Nivel Máximo alcanzado!)";
                }
            }

            if (playerTech.level < techData.maxLevel) {
                playerTech.cultivationTimeToNextLevel = Math.floor(
                    techData.cultivationSettings.baseTimeToLevelUp *
                    Math.pow(techData.cultivationSettings.levelTimeMultiplier, playerTech.level)
                );
            } else {
                playerTech.cultivationTimeToNextLevel = Infinity;
                playerTech.currentCultivationProgress = 0;
            }
            applyTechniqueEffect(techId, playerTech.level);
        }
        
        recalculatePlayerStats();
        updateUI();
        renderQuickSlotBar(); 

        if (leveledUpThisBoost) {
            stopCultivation();
            showModal("¡Técnica Mejorada con Aceleración!", firstLevelUpMessage + "\n\nEl cultivo se ha detenido para que puedas ver los cambios.");
            return;
        }

        if (playerTech.level >= techData.maxLevel) {
            stopCultivation();
            showModal("Nivel Máximo Alcanzado", `La técnica ${techData.name} ya está en su máximo potencial.`);
            return;
        }
        
        // Si no se subió de nivel, solo actualizamos la UI del modal
        if (document.getElementById("activeCultivationModal").style.display === "flex") {
            showActiveCultivationModal();
        }
    }

      function toggleQiConversion() {
        const player = gameState.player;

        // Si ya hay un cultivo de CUALQUIER tipo activo...
        if (player.isCultivating) {
          // ...y ese cultivo es específicamente el de conversión...
          if (player.cultivationMode.isConversionCultivation) {
            // ...entonces lo detenemos.
            console.log("Deteniendo cultivo de conversión de Qi activo.");
            stopCultivation(true, {
              title: "Conversión Detenida",
              text: "Has detenido la conversión de Maná a Vida.",
            });
          } else {
            // Si es otro tipo de cultivo (ej. de técnica), avisamos al jugador.
            showModal(
              "Acción no permitida",
              "Debes detener tu cultivo actual para iniciar la conversión de Qi."
            );
          }
          return;
        }

        // Si no hay ningún cultivo activo, iniciamos el de conversión.
        console.log("Iniciando cultivo con CONVERSIÓN DE QI.");

        // CORRECCIÓN CLAVE 1:
        // Iniciamos el modo de cultivo de recuperación, pero inmediatamente después,
        // marcamos que es un modo especial de conversión.
        startCultivationMode("recovery");
        player.cultivationMode.isConversionCultivation = true; // <-- Esta es la marca especial.

        // También actualizamos la UI para que el botón refleje el estado activo.
        renderQuickSlotBar();
      }

      function toggleGrid() {
        isGridVisible = !isGridVisible;
        const gridOverlay = document.querySelector('.grid-overlay');
        const toggleBtn = document.getElementById('toggleGridBtn');

        if (gridOverlay) {
            if (isGridVisible) {
                gridOverlay.classList.add('active');
                if (toggleBtn) toggleBtn.textContent = "Ocultar Rejilla";
            } else {
                gridOverlay.classList.remove('active');
                if (toggleBtn) toggleBtn.textContent = "Mostrar Rejilla";
            }
            updateGrid(); // Actualiza el estado inicial de la rejilla
        }
    }

    // === AÑADE ESTA NUEVA FUNCIÓN HELPER ===
    function updateGrid() {
      if (!isGridVisible) return;
      
      const gridOverlay = document.querySelector('.grid-overlay');
      const mapElement = document.getElementById("gameMap");
      
      if (gridOverlay && mapElement) {
          // Actualizamos el tamaño del fondo de la rejilla para que coincida con el tamaño del tile
          gridOverlay.style.backgroundSize = `${currentTileSize}px ${currentTileSize}px`;
          
          // Hacemos que la posición del fondo de la rejilla se mueva en sentido opuesto al mapa
          // para que las líneas parezcan estáticas sobre el mundo.
          const mapTransform = new DOMMatrix(window.getComputedStyle(mapElement).transform);
          gridOverlay.style.backgroundPosition = `${mapTransform.e}px ${mapTransform.f}px`;
      }
  }

  function useItem(itemName) {
        console.groupCollapsed(`[useItem v3] ==> Intento de usar el objeto: "${itemName}"`);

        if (gameState.battle.active) {
            console.warn("-> Bloqueado: en combate.");
            console.groupEnd();
            showModal("Acción no permitida", "No puedes usar objetos del inventario de esta forma durante un combate.");
            return;
        }

        if (!gameState.inventory[itemName] || gameState.inventory[itemName] <= 0) {
            console.warn(`-> Bloqueado: no tienes "${itemName}".`);
            console.groupEnd();
            showModal("Inventario Vacío", `No tienes ${itemName}.`);
            return;
        }

        const itemInfo = itemData[itemName];
        console.log(`-> Definición para "${itemName}" encontrada en itemData.`);

        if (!itemInfo) {
            console.error(`-> FATAL: No hay definición para "${itemName}" en itemData.`);
            console.groupEnd();
            showModal("Error", `El objeto "${itemName}" no tiene una definición en la base de datos.`);
            return;
        }

        if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
            console.warn(`-> Condición 'canUse' para "${itemName}" falló.`);
            console.groupEnd();
            showModal("No se puede usar", `No puedes usar ${itemName} ahora.`);
            return;
        }
        
        if (!itemInfo.effect || typeof itemInfo.effect !== 'function') {
            console.error(`-> FATAL: El objeto "${itemName}" no tiene una función de efecto válida.`);
            console.groupEnd();
            showModal("Sin efecto", `El objeto "${itemName}" no tiene un efecto utilizable.`);
            return;
        }

        console.log("-> Condiciones cumplidas. LLAMANDO a la función 'effect' del objeto...");
        // --- LLAMADA DIRECTA Y EXPLÍCITA AL EFECTO ---
        const message = itemInfo.effect(gameState.player, gainExperience, itemName);
        console.log(`-> La función 'effect' se ejecutó y devolvió el mensaje: "${message}"`);

        if (message && !message.toLowerCase().includes("error")) {
            gameState.inventory[itemName]--;
            if (gameState.inventory[itemName] <= 0) {
               for(let i = 0; i < gameState.player.quickSlots.length; i++){
                   if(gameState.player.quickSlots[i] === itemName){
                       gameState.player.quickSlots[i] = null;
                   }
               }
            }
        }

        showModal("Objeto Usado", message);
        updateUI();
        renderQuickSlotBar();
        updatePlayerBarsOnMap();
        console.log("-> UI actualizada. Proceso finalizado.");
        console.groupEnd();
      }


      function gainExperience(amount) {
        if (amount <= 0) return;
        gameState.player.exp += amount;
        while (gameState.player.exp >= gameState.player.expToNext) {
          levelUp();
        }
      }
//SUBIR NIVEL
      function levelUp() {
        const player = gameState.player;
        player.exp -= player.expToNext;
        player.level++;

        const hpIncrease = 20 + Math.floor(player.level / 2);
        const manaIncrease = 10 + Math.floor(player.level / 3);
        const attackIncrease = 2 + Math.floor(player.level / 4);
        const defenseIncrease = 1 + Math.floor(player.level / 5);

        player.baseMaxHp += hpIncrease;
        player.baseMaxMana += manaIncrease;
        player.baseAttack += attackIncrease;
        player.baseDefense += defenseIncrease;

        player.hp = player.baseMaxHp; // Rellenar HP y Mana al subir de nivel
        player.mana = player.baseMaxMana;
        player.expToNext = Math.floor(
          player.expToNext * (1.3 + player.level * 0.02)
        );

        const oldRealm = player.realm;
        const realms = [
          "Mortal",
          "Forjado del Cuerpo",
          "Condensación de Qi",
          "Fundación",
          "Núcleo Dorado",
          "Alma Naciente",
          "Espíritu Primordial",
        ];
        const realmIndex = Math.min(
          Math.floor((player.level - 1) / 5),
          realms.length - 1
        );
        player.realm = realms[realmIndex];
        let realmChangeMessage = "";
        if (player.realm !== oldRealm) {
          realmChangeMessage = `\n\n¡Has avanzado al Reino de ${player.realm}! Sientes una profunda transformación...`;
          generateMap(true);
        }
        recalculatePlayerStats();

        showModal(
          "¡Nivel Aumentado!",
          `Nivel ${player.level}!\nReino: ${player.realm}\n+${hpIncrease} HP, +${manaIncrease} Maná\n+${attackIncrease} Atk, +${defenseIncrease} Def${realmChangeMessage}`
        );
      }

      function recalculatePlayerStats() {
        const player = gameState.player;
        
        // 1. Reiniciar TODAS las estadísticas a sus valores base.
        player.maxHp = player.baseMaxHp;
        player.maxMana = player.baseMaxMana;
        player.attack = player.baseAttack;
        player.defense = player.baseDefense;
        // === REINICIO DE STATS PASIVOS 
        player.damageReduction = 0; // Reiniciamos la reducción de daño
        player.passiveHpRegen = 0;   // Reiniciamos la regeneración pasiva
        player.statusResistChance = 0;
         // ===============================================
        // Reseteamos las estadísticas de cultivo a sus valores por defecto antes de aplicar los bonos.
        player.qiPerSecondBase = 1;     // Valor base de Qi por segundo.
        player.expPerSecondBase = 0.5;   // Valor base de EXP por segundo.
        player.hpPerSecondBase = 1;      // Valor base de HP por segundo.
        // Limpiamos la lista de habilidades activas para reconstruirla.
        
        gameState.activeCombatAbilities = [];
        
        // 2. Iteramos sobre TODAS las técnicas aprendidas por el jugador.
        for (const techId in player.learnedTechniques) {
            const playerTech = player.learnedTechniques[techId];
            const techInfo = techniqueData[techId];

            if (!techInfo || playerTech.level === 0) {
                continue; // Saltar si la técnica no existe o no tiene nivel.
            }
            
            // 3. Aplicamos los efectos según el tipo de técnica.
            switch (techInfo.type) {
              case 'passive_stat':
                if (techInfo.effect) {
                    if (techInfo.effect.statToBoost && techInfo.effect.value) {
                         const effectValue = techInfo.effect.value * playerTech.level;
                         const statToBoost = techInfo.effect.statToBoost;
                         if (player.hasOwnProperty(statToBoost)) {
                            player[statToBoost] += effectValue;
                         } else {
                            player[statToBoost] = (player[statToBoost] || 0) + effectValue;
                         }
                    }
                    
                    // === NUEVA LÓGICA PARA CALCULAR LA RESISTENCIA ===
                    if (techInfo.effect.statusResistChanceBase) {
                        const baseChance = techInfo.effect.statusResistChanceBase;
                        const perLevelChance = techInfo.effect.statusResistChancePerLevel || 0;
                        player.statusResistChance += baseChance + (perLevelChance * (playerTech.level - 1));
                    }
                    // ===============================================

                    if (techInfo.effect.passiveHpRegen) {
                        player.passiveHpRegen += techInfo.effect.passiveHpRegen * playerTech.level;
                    }
                }
                break;
                case 'passive_cultivation':
                    // Multiplicamos el valor del efecto por el nivel de la técnica.
                    const cultivationBonus = techInfo.effect.value * playerTech.level;
                    const cultivationStatToBoost = techInfo.effect.statToBoost;
                    if (player.hasOwnProperty(cultivationStatToBoost)) {
                        player[cultivationStatToBoost] += cultivationBonus;
                    }
                    break;
                    
                case 'active_ability':
                    // Si es una habilidad activa, la añadimos a la lista para el combate.
                    gameState.activeCombatAbilities.push({
                        id: techInfo.abilityId,
                        name: techInfo.name,
                        sourceTechniqueId: techId
                    });
                    break;
                
                // Puedes añadir más casos para otros tipos de técnicas si es necesario.
            }
        }
          // Aseguramos que la probabilidad no supere un límite (ej. 90%)
        player.statusResistChance = Math.min(0.9, player.statusResistChance);
        // 4. Asegurarse de que HP/Mana no excedan el nuevo máximo.
        player.hp = Math.min(player.hp, player.maxHp);
        player.mana = Math.min(player.mana, player.maxMana);
        
        // 5. Finalmente, actualizamos la UI con los valores correctos y recalculados.
        // Ya no es necesario llamar a updateUI() desde aquí, la función que llama a recalculate se encargará.
    }

    function startBattle(mapEntity) {
    updateStatsPanelVisibility();
    updateGameOverlayVisibility();
    battleLogHistory = [];
    
    const toggleBtn = document.getElementById("toggleMapControlsBtn");
    if (toggleBtn) {
        toggleBtn.classList.add("hidden-during-battle");
    }

    const player = gameState.player;
    if (player.isChannelingRune) {
        player.isChannelingRune = false;
        document.getElementById('player').classList.remove('channeling');
    }
    if (player.isCultivating) stopCultivation();
    
    hideTouchControls();
    document.getElementById('quickSlotBar').classList.add('hidden');
    
    player.isMoving = false;
    if (player.animationTimer) clearInterval(player.animationTimer);
    if (player.idleTimeout) clearTimeout(player.idleTimeout);
    player.currentFrame = 0;
    updatePlayerSpriteVisual();

    // --- INICIO DE LA LÓGICA CORREGIDA ---

    // PASO 1: Obtener la definición maestra del enemigo.
    const enemyDefinition = entityTypes[mapEntity.originalEntityTypeId] || entityTypes[mapEntity.type];
    if (!enemyDefinition) {
        console.error(`¡CRÍTICO! No se encontró la definición para el enemigo:`, mapEntity);
        showModal("Error de Batalla", "No se pudieron cargar los datos del enemigo.");
        return;
    }
    
    // PASO 2: Crear el objeto del enemigo en el estado de batalla INMEDIATAMENTE.
    // Esto asegura que `gameState.battle.enemy` nunca sea null a partir de este punto.
    gameState.battle.active = true;
    gameState.battle.enemy = {
        ...enemyDefinition,
        ...mapEntity,
        entityRef: mapEntity,
        // Reseteo de estados de combate
        frozenTurns: 0, stunnedTurns: 0, burningTurns: 0, burnDamage: 0,
        poisonedTurns: 0, poisonDamage: 0, defenseReductionTurns: 0,
        defenseReductionAmount: 0, attackReductionTurns: 0, attackReductionAmount: 0,
        rootedTurns: 0, rootDamage: 0, silencedTurns: 0, sealedTurns: 0,
    };
    
    // PASO 3: AHORA que el enemigo de batalla existe, aplicamos las modificaciones de las formaciones.
    if (enemyDefinition.formationVulnerability && mapEntity.pendingFormationEffects) {
        const requiredPatternId = enemyDefinition.formationVulnerability;
        const matchingEffect = mapEntity.pendingFormationEffects.find(effect => effect.sourcePatternId === requiredPatternId);

        if (matchingEffect) {
            logBattle(`¡La ${FORMATION_PATTERNS[requiredPatternId].name} resuena con el enemigo!`);
            logBattle("¡Su sello mágico se hace añicos!");
            
            // ¡AHORA ESTA LÍNEA FUNCIONARÁ SIN ERRORES!
            gameState.battle.enemy.defense = 5; // Un valor muy bajo.
            showFloatingText(document.getElementById('enemySprite'), '¡DEFENSA ROTA!', 'debuff');
        } else {
            logBattle("La formación que trazaste no tiene efecto sobre la poderosa magia de este ser.");
        }
    }

    // PASO 4: Aplicar otros efectos de formación pendientes (curación, etc.)
    checkAndApplyFormation(mapEntity);

    // PASO 5: Actualizar la UI y finalizar la preparación de la batalla.
    document.getElementById("battleScreen").style.display = "flex";
    if (!gameState.battle.enemy.maxHp) {
        gameState.battle.enemy.maxHp = gameState.battle.enemy.hp;
    }
    gameState.battle.playerTurn = true;
    
    console.groupCollapsed(`[startBattle v2] ==> Enfrentando a: ${gameState.battle.enemy.name}`);
    console.log("Objeto enemigo final en gameState.battle.enemy:", JSON.parse(JSON.stringify(gameState.battle.enemy)));
    console.groupEnd();
    
    populateBattleActionButtons();
    updateBattleUI(); 
    updateGameOverlayVisibility();
    logBattle(`¡Un ${gameState.battle.enemy.name} te enfrenta!`);
    updateTopNavVisibility();
    updatePlayerBarsOnMap();
    
    // --- FIN DE LA LÓGICA CORREGIDA ---
}
    function boostCultivationWithAllStones() {
        const player = gameState.player;
        const mode = player.cultivationMode;
        const timePerStone = 10; // 10 segundos de progreso por cada piedra

        if (!player.isCultivating || mode.type !== 'technique' || !mode.targetId) {
            return; // Salir si no se está cultivando una técnica
        }
        
        const techId = mode.targetId;
        const playerTech = player.learnedTechniques[techId];
        const techData = techniqueData[techId];
        
        if (!playerTech || !techData || playerTech.level >= techData.maxLevel) {
            showModal("Límite Alcanzado", "Esta técnica ya está en su nivel máximo.");
            return;
        }

        // --- INICIO DE LA LÓGICA DE CÁLCULO ---
        const progressNeeded = playerTech.cultivationTimeToNextLevel - (playerTech.currentCultivationProgress || 0);
        if (progressNeeded <= 0) {
            showModal("Listo para Subir", "Esta técnica ya tiene suficiente progreso para subir de nivel al continuar el cultivo.");
            return;
        }

        // Calculamos cuántas piedras se necesitan para cubrir el progreso faltante.
        // Usamos Math.ceil para redondear hacia arriba y asegurar que se complete el nivel.
        const stonesNeeded = Math.ceil(progressNeeded / timePerStone);
        
        const stonesAvailable = gameState.inventory["Piedras Espirituales"] || 0;

        // Determinamos cuántas piedras se usarán realmente: el mínimo entre lo necesario y lo disponible.
        const stonesToUse = Math.min(stonesNeeded, stonesAvailable);

        if (stonesToUse <= 0) {
            showModal("Sin Piedras", "No tienes Piedras Espirituales para acelerar el cultivo.");
            return;
        }
        // --- FIN DE LA LÓGICA DE CÁLCULO ---

        // Llamamos a la función original con la cantidad EXACTA que hemos calculado.
        boostCultivationProgress(stonesToUse);
    }
      function showFloatingText(targetElement, text, type) {
        // --- ¡ESTA ES LA VERIFICACIÓN CLAVE! ---
        if (
          !targetElement ||
          typeof targetElement.getBoundingClientRect !== "function"
        ) {
          console.warn(
            `[showFloatingText] Intento de mostrar texto flotante en un elemento inválido. Texto: "${text}", Tipo: "${type}". El elemento era:`,
            targetElement
          );
          return; // Salir de la función si el elemento no es válido.
        }
        // --- FIN DE LA VERIFICACIÓN ---

        const battleScreen = document.getElementById("battleScreen");
        if (!battleScreen) return; // Salida temprana si la pantalla de batalla no está

        const popup = document.createElement("div");
        popup.className = `damage-popup ${type}`;
        popup.textContent = text;

        // Lo añadimos al contenedor de la pantalla de batalla para que position:absolute funcione bien
        battleScreen.appendChild(popup);

        // Calculamos la posición inicial del popup
        const targetRect = targetElement.getBoundingClientRect();
        const battleRect = battleScreen.getBoundingClientRect();

        // Posición inicial en el centro-superior del objetivo
        const initialTop = targetRect.top - battleRect.top - 20;
        const initialLeft =
          targetRect.left -
          battleRect.left +
          targetRect.width / 2 -
          popup.offsetWidth / 2;

        popup.style.top = `${initialTop}px`;
        popup.style.left = `${initialLeft}px`;

        // Eliminar el elemento del DOM después de que termine la animación
        popup.addEventListener("animationend", () => {
          // Usamos un try-catch por si el popup ya fue eliminado por otra razón (ej. fin de batalla)
          try {
            popup.remove();
          } catch (e) {}
        });
      }

      function populateBattleActionButtons() {
        const battleActionButtons = document.getElementById("battleActionButtons");
        battleActionButtons.innerHTML = `
              <button onclick="battleAction('attack')">⚔️ Atacar</button>
              <button onclick="battleAction('defend')">🛡️ Defender</button>
              <button onclick="battleAction('qi_fist')">🧘 Puño de Qi</button>
              <button onclick="battleAction('escape')">🏃 Huir</button>
          `;
          
        // Iteramos sobre las técnicas equipadas en los slots.
        gameState.player.equippedTechniques.forEach((techId) => {
            // Si el slot está vacío (null) o la técnica no existe (por un save antiguo), lo saltamos.
            if (!techId || !techniqueData[techId]) {
                return;
            }
            
            const techDetails = techniqueData[techId];
            const playerTech = gameState.player.learnedTechniques[techId];
            
            // Comprobación de seguridad: si una técnica está equipada pero el jugador ya no la conoce, no mostramos el botón.
            if (!playerTech) {
                console.warn(`Técnica equipada '${techId}' no encontrada en el libro de hechizos del jugador.`);
                return;
            }

            const abilityButton = document.createElement("button");
            const techLevel = playerTech.level || 0;

            let buttonText = `✨ ${techDetails.name} (Nv.${techLevel})`;
            let canUse = techLevel > 0;
            let reason = canUse ? "" : "Error: Técnica equipada sin nivel";
            
            const manaCost = techDetails.manaCost || 0;
            if (canUse && gameState.player.mana < manaCost) {
                canUse = false;
                reason = "Maná insuficiente";
            }
            
            const cooldownTurns = gameState.player.abilityCooldowns[techDetails.abilityId] || 0;
            if (canUse && cooldownTurns > 0) {
                canUse = false;
                reason = `Enfriamiento: ${cooldownTurns} turnos`;
                buttonText += ` (${cooldownTurns}t)`;
            }

            abilityButton.textContent = buttonText;
            // El onclick pasa el ID de la acción a `battleAction`.
            abilityButton.onclick = () => battleAction(techDetails.abilityId);
            abilityButton.disabled = !canUse;
            abilityButton.title = reason;

            battleActionButtons.appendChild(abilityButton);
        });
    }

      function updateExtraStatsUI() {
        // Actualizar Zona
        const zoneEl = document.getElementById("playerZone");
        if (zoneEl) {
          const currentZone = getPlayerCurrentZone();
          zoneEl.textContent = currentZone
            ? currentZone.name
            : "Tierra Salvaje";
        }

        // Actualizar Piedras Espirituales
        const stonesEl = document.getElementById("playerStonesHud");
        if (stonesEl) {
          stonesEl.textContent =
            gameState.inventory["Piedras Espirituales"] || 0;
        }
      }

      function updateBattleUI() {
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const battleScreenActive = document.getElementById("battleScreen").style.display === "flex";

        // --- Declaraciones de Elementos del DOM al principio ---
        const playerBarsContainer = document.getElementById("playerInBattleSpriteBarsContainer");
        const playerSpriteInBattle = document.querySelector(".battle-area .character .character-sprite");
        const enemyInfoContainer = document.getElementById("enemyInBattleInfoContainer");
        const enemySpriteEl = document.getElementById("enemySprite");

        // --- Lógica del Jugador ---
        if (playerBarsContainer && playerSpriteInBattle && battleScreenActive) {
            playerBarsContainer.style.display = "flex";
            const spriteTop = playerSpriteInBattle.offsetTop;
            const spriteLeft = playerSpriteInBattle.offsetLeft;
            const spriteWidth = playerSpriteInBattle.offsetWidth;
            const barContainerHeight = playerBarsContainer.offsetHeight;

            playerBarsContainer.style.top = `${spriteTop - barContainerHeight - 3}px`;
            playerBarsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

            const playerHpFill = document.getElementById("playerInBattleSpriteHpFill");
            const playerManaFill = document.getElementById("playerInBattleSpriteManaFill");
            if (playerHpFill) playerHpFill.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
            if (playerManaFill) playerManaFill.style.width = `${Math.max(0, (player.mana / player.maxMana) * 100)}%`;
        } else if (playerBarsContainer) {
            playerBarsContainer.style.display = "none";
        }

        // --- Lógica del Enemigo ---
        if (enemy && enemySpriteEl && enemyInfoContainer && battleScreenActive) {
            // --- LÓGICA DEL SPRITE (AHORA DENTRO DEL BLOQUE SEGURO) ---
            if (enemy.spriteUrl) {
                enemySpriteEl.style.backgroundImage = `url('${enemy.spriteUrl}')`;
                enemySpriteEl.textContent = "";
            } else {
                enemySpriteEl.style.backgroundImage = "none";
                enemySpriteEl.textContent = enemy.symbol || "?";
            }
            
            // El resto de la lógica para las barras y el nombre del enemigo
            enemyInfoContainer.style.display = "flex";
            const spriteTop = enemySpriteEl.offsetTop;
            const spriteLeft = enemySpriteEl.offsetLeft;
            const spriteWidth = enemySpriteEl.offsetWidth;
            const infoContainerHeight = enemyInfoContainer.offsetHeight;

            enemyInfoContainer.style.top = `${spriteTop - infoContainerHeight - 5}px`;
            enemyInfoContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

            const enemyNameLevelEl = document.getElementById("enemyBattleNameLevel");
            const enemySpriteHpFill = document.getElementById("enemyInBattleSpriteHpFill");
            const enemyHpPercent = Math.max(0, (enemy.hp / (enemy.maxHp || enemy.hp)) * 100);

            if (enemyNameLevelEl) {
                let enemyDisplayName = enemy.name;
                if (enemy.isBoss) {
                    enemyDisplayName += ` (Jefe)`;
                } else if (enemy.isMiniBoss) {
                    enemyDisplayName += ` (Élite)`;
                }
                if (enemy.level) {
                    enemyDisplayName += ` - Nv. ${enemy.level}`;
                }
                enemyNameLevelEl.textContent = enemyDisplayName;

                const nameStyle = getEnemyNameColor(player.level, enemy.level || 1);
                enemyNameLevelEl.style.color = nameStyle.color;
                enemyNameLevelEl.style.fontWeight = nameStyle.fontWeight;
            }
            if (enemySpriteHpFill) enemySpriteHpFill.style.width = `${enemyHpPercent}%`;

            // Paneles de HP/Nombre principales del enemigo
            document.getElementById("enemyName").textContent = enemy.name;
            document.getElementById("enemyHp").textContent = `${Math.floor(enemy.hp)}/${enemy.maxHp || enemy.hp}`;
            document.getElementById("enemyHpBar").style.width = `${enemyHpPercent}%`;
            
        } else if (enemyInfoContainer) {
            enemyInfoContainer.style.display = "none";
        }

        // --- Lógica de los Paneles Principales del Jugador ---
        if (battleScreenActive) {
            document.getElementById("playerBattleName").textContent = `Cultivador (Nv.${player.level})`;
            document.getElementById("playerBattleHp").textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
            document.getElementById("playerBattleHpBar").style.width = `${(player.hp / player.maxHp) * 100}%`;
        }
    }

    // REEMPLAZA TU FUNCIÓN plantRune() EXISTENTE CON ESTA VERSIÓN CORREGIDA

    // REEMPLAZA por completo tu función plantRune con esta nueva versión

    // REEMPLAZA tu función plantRune completa con esta versión definitiva

// REEMPLAZA tu función plantRune completa con esta versión definitiva

      function plantRune() {
    const player = gameState.player;

    // --- Lógica para el PRIMER clic (Activar el modo) ---
    if (!player.isChannelingRune) {
        // Comprobación de recursos
        if ((gameState.inventory["Tinta Rúnica"] || 0) < 1) {
            showModal("Sin Materiales", "Necesitas Tinta Rúnica para empezar a canalizar.");
            return;
        }
        const manaCost = techniqueData.formation_scribing_1.manaCost || 10;
        if (player.mana < manaCost) {
            showModal("Maná Insuficiente", `Necesitas ${manaCost} de maná para canalizar la runa.`);
            return;
        }

        // Activar Modo Canalización
        player.isChannelingRune = true;
        document.getElementById('player').classList.add('channeling');
        showModal(
            "Canalizando Runa...",
            "Estás en modo de trazado rúnico. Eres inmune a combates. Muévete a la posición deseada y pulsa el botón ✍️ de nuevo para trazar la runa. Tienes 10 segundos.",
            true
        );
        setTimeout(() => closeModal(), 1000);

        // Limpiar cualquier temporizador antiguo por si acaso
        if (player.channelingTimeout) {
            clearTimeout(player.channelingTimeout);
        }

        // Temporizador para salir del modo si no se hace nada
        player.channelingTimeout = setTimeout(() => {
            if (player.isChannelingRune) {
                player.isChannelingRune = false;
                document.getElementById('player').classList.remove('channeling');
                // Mensaje mejorado y más genérico
                showModal("Canalización Terminada", "La energía rúnica que estabas canalizando se ha disipado.");
            }
        }, 10000); // 10 segundos para moverse y plantar

        return; // Salimos después de activar el modo
    }

    // --- Lógica para clics SUBSECUENTES (Plantar la runa) ---
    // Si ya estamos en modo de concentración, este clic planta la runa.
    // Comprobamos los recursos DE NUEVO por si se quieren plantar varias runas.
    if ((gameState.inventory["Tinta Rúnica"] || 0) < 1) {
        showModal("Sin Materiales", "No tienes más Tinta Rúnica para trazar otra runa.");
        return;
    }
    const manaCost = techniqueData.formation_scribing_1.manaCost || 10;
    if (player.mana < manaCost) {
        showModal("Maná Insuficiente", `Necesitas ${manaCost} de maná para trazar otra runa.`);
        return;
    }

    // Llamar a la función que contiene la lógica de colocar y comprobar
    // ¡YA NO DESACTIVAMOS EL MODO AQUÍ!
    placeRuneAt(player.x, player.y);
}

      function checkCombatPatterns(targetEnemy) {
    // --- INICIO DE LA CORRECCIÓN: GUARD CLAUSE ---
    // Esta comprobación de seguridad detiene la función si la constante de patrones no está disponible.
    if (typeof FORMATION_PATTERNS === 'undefined' || FORMATION_PATTERNS === null) {
        console.error("FATAL ERROR: La función checkCombatPatterns se ejecutó, pero FORMATION_PATTERNS no está definido en este punto. Asegúrate de que todas las 'const' de datos están declaradas al principio del script, antes de cualquier función.");
        return null;
    }
    // --- FIN DE LA CORRECCIÓN ---

    const placedRunes = targetEnemy.formationRunes || {};
    const placedKeys = Object.keys(placedRunes);
    const player = gameState.player;

    for (const patternKey in FORMATION_PATTERNS) {
        const formation = FORMATION_PATTERNS[patternKey];
        // Comprobación adicional por si el patrón en sí es inválido
        if (!formation || !formation.effect || !formation.pattern) continue;
        
        if (formation.effect.type === 'utility_teleport') continue;

        const pattern = formation.pattern;
        const requiredRunesForMatch = [];
        const patternCenterX = Math.floor(pattern[0].length / 2);
        const patternCenterY = Math.floor(pattern.length / 2);
        
        for (let r = 0; r < pattern.length; r++) {
            for (let c = 0; c < pattern[r].length; c++) {
                if (pattern[r][c] === 1) {
                    requiredRunesForMatch.push(`${targetEnemy.x + (c - patternCenterX)},${targetEnemy.y + (r - patternCenterY)}`);
                }
            }
        }

        const isMatch = placedKeys.length === requiredRunesForMatch.length && requiredRunesForMatch.every(k => placedKeys.includes(k));

        if (isMatch) {
            if (!player.discoveredFormationPatterns[patternKey]) {
                player.discoveredFormationPatterns[patternKey] = true; 
                showModal(
                    "¡Patrón Antiguo Descifrado!",
                    `Has completado con éxito la formación: <strong>${formation.name}</strong>.<br><br><em>${formation.description}</em><br><br>El diagrama ha sido anotado en tu panel de Técnicas para futuras consultas.`
                );
            }
            return formation; 
        }
    }
    return null;
}
      

function checkUtilityPatterns() {
    if (typeof FORMATION_PATTERNS === 'undefined' || FORMATION_PATTERNS === null) {
        console.error("Error crítico: FORMATION_PATTERNS no está definido.");
        return null;
    }

    const placedRunes = gameState.utilityRunes || {};
    const placedKeys = Object.keys(placedRunes);
    if (placedKeys.length === 0) {
        return null;
    }

    for (const patternKey in FORMATION_PATTERNS) {
        const formation = FORMATION_PATTERNS[patternKey];

        if (!formation || !formation.effect || !formation.effect.type.startsWith('utility_')) {
            continue;
        }

        const patternMatrix = formation.pattern;

        for (const playerRuneKey of placedKeys) {
            const [playerRuneX, playerRuneY] = playerRuneKey.split(',').map(Number);

            for (let anchorR = 0; anchorR < patternMatrix.length; anchorR++) {
                // El error estaba en la siguiente línea.
                for (let anchorC = 0; anchorC < patternMatrix[anchorR].length; anchorC++) { // <-- CORREGIDO: 'c' ahora es 'anchorC'
                    if (patternMatrix[anchorR][anchorC] !== 1) continue;

                    const offsetX = playerRuneX - anchorC;
                    const offsetY = playerRuneY - anchorR;
                    
                    const requiredRunesForMatch = [];
                    for (let r = 0; r < patternMatrix.length; r++) {
                        for (let c = 0; c < patternMatrix[r].length; c++) {
                            if (patternMatrix[r][c] === 1) {
                                requiredRunesForMatch.push(`${c + offsetX},${r + offsetY}`);
                            }
                        }
                    }
                    
                    if (placedKeys.length !== requiredRunesForMatch.length) {
                        continue;
                    }

                    const isMatch = requiredRunesForMatch.every(key => placedKeys.includes(key));

                    if (isMatch) {
                        console.log(`[checkUtilityPatterns] ¡Coincidencia encontrada!: ${formation.name}`);
                        return { ...formation, sourcePatternId: patternKey };
                    }
                }
            }
        }
    }
    
    return null; // No se encontró ninguna coincidencia
}
      function battleAction(action) {
      
        if (!gameState.battle.playerTurn || !gameState.battle.active) return;
        
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const playerSprite = document.querySelector('.character-sprite');
        const enemySprite = document.getElementById('enemySprite');
        let actionTaken = true;

         // Regeneración de vida por formaciones
          if (player.hpRegenPerTurn > 0 && player.hp < player.maxHp) {
              const healAmount = player.hpRegenPerTurn;
              player.hp = Math.min(player.maxHp, player.hp + healAmount);
              logBattle(`La formación rúnica te cura ${healAmount} HP.`);
              showFloatingText(playerSprite, `+${healAmount}`, 'heal');
          }
          // ===  REGENERACIÓN DE MANÁ ===
          if (player.manaRegenPerTurn > 0 && player.mana < player.maxMana) {
              const manaHealAmount = player.manaRegenPerTurn;
              player.mana = Math.min(player.maxMana, player.mana + manaHealAmount);
              logBattle(`La formación arcana restaura ${manaHealAmount} de tu Maná.`);
              showFloatingText(playerSprite, `+${manaHealAmount}`, 'mana'); // Usamos el tipo 'mana' para el color azul
          }
              // Inmunidad de Santuario Dorado Protector
          if (player.intangibleTurns > 0) {
            player.intangibleTurns--;
            console.log(`[battleAction] intangibleTurns DESPUÉS de reducir: ${player.intangibleTurns}`);
            if (player.intangibleTurns === 0) {
                logBattle("La protección del Santuario Dorado se desvanece.");
                showFloatingText(playerSprite, 'Vulnerable', 'debuff');
            }
          }

          // Duración del Escudo de Qi
          if (player.magicShieldTurns > 0) {
              player.magicShieldTurns--;
              if (player.magicShieldTurns === 0 && player.magicShieldValue > 0) {
                  logBattle("La energía de tu escudo de Qi se disipa.");
                  player.magicShieldValue = 0; // El escudo se agota por tiempo
              }
          }

          // Duración de la Matriz de Reversión
          if (player.damageToHealingTurns > 0) {
              player.damageToHealingTurns--;
              if (player.damageToHealingTurns === 0) {
                  logBattle("La Matriz de Reversión del Cosmos vuelve a su estado normal.");
              }
          }

          // Desgaste de debuffs aplicados AL JUGADOR
          if (player.defenseReductionTurns > 0) {
              player.defenseReductionTurns--;
              if (player.defenseReductionTurns === 0) {
                  player.defense += player.defenseReductionAmount; // Restaura la defensa
                  logBattle("Tu defensa vuelve a la normalidad.");
                  player.defenseReductionAmount = 0;
              }
          }
        // Reducir enfriamientos al inicio del turno del jugador
        for (const abilityId in player.abilityCooldowns) {
            if (player.abilityCooldowns[abilityId] > 0) {
                player.abilityCooldowns[abilityId]--;
            }
            if (player.abilityCooldowns[abilityId] <= 0) {
                delete player.abilityCooldowns[abilityId];
            }
        }
        populateBattleActionButtons(); // Actualizar botones para reflejar cooldowns reducidos

        // Procesar DoTs/HoTs y efectos en el jugador
        // (Esta lógica se mantiene como está, no es necesario cambiarla)
        if (player.burningTurns > 0) { /* ... */ }
        // ... el resto de la lógica de DoTs y Debuffs para el jugador ...

        if (player.hp <= 0) {
            // Lógica de derrota si el DoT lo derrota antes de actuar
            return;
        }

        // --- INICIO DE LA LÓGICA DE HABILIDADES REFACTORIZADA ---
        
        // Buscamos si la acción corresponde a una habilidad definida
        const techInfoEntry = Object.entries(techniqueData).find(([key, value]) => value.abilityId === action);

        if (techInfoEntry) {
            // Si es una habilidad, ejecutamos la lógica de técnica
            const [sourceTechniqueId, techDetails] = techInfoEntry;
            const playerTech = player.learnedTechniques[sourceTechniqueId];
            
            if (!playerTech || playerTech.level === 0) {
                logBattle(`Intentas usar ${techDetails.name}, pero no la has dominado (Nivel 0).`);
                return; // No consume el turno, permite elegir otra acción
            }

            const playerTechLevel = playerTech.level;
            const manaCost = techDetails.manaCost || 0;

            if ((player.abilityCooldowns[action] || 0) > 0) {
                logBattle(`¡La técnica ${techDetails.name} aún está en enfriamiento!`);
                return; // No consume el turno
            }

            if (player.mana < manaCost) {
                logBattle(`Maná insuficiente para ${techDetails.name}.`);
                actionTaken = false;
            } else {
                player.mana -= manaCost;
                if (techDetails.cooldown) {
                    player.abilityCooldowns[action] = techDetails.cooldown;
                }

                let damageDealt = 0;
                let logMessage = "";
                const effect = techDetails.effect;

                // Delegamos al switch-case que ya tenías, pero ahora 'playerTechLevel' es correcto.
                // El código interno de cada 'case' usará 'playerTechLevel' para el cálculo.
                // El siguiente bloque 'switch' debe contener TODA tu lógica de habilidades existente.
                // Lo que sigue es un ejemplo de cómo debe quedar el caso de 'sword_t1'.

                switch (action) {
                  
                  case "sword_t1"://Tajo del Viento Veloz
                    const swordTechDetails = techniqueData["sword_t1"];
                    const swordManaCost = swordTechDetails.manaCost || 10;
                    if (player.mana >= swordManaCost) {
                      player.mana -= swordManaCost;
                      // Calculamos el multiplicador de daño de forma genérica, leyendo los valores de la definición.
                      const damageMultiplier =
                        swordTechDetails.effect.baseDamageMultiplier +
                        (playerTechLevel - 1) * (swordTechDetails.effect.multiplierIncreasePerLevel || 0);

                      const swordDamage = Math.max(
                        1,
                        Math.floor(player.attack * damageMultiplier) -
                          (enemy.defense || 0)
                      );
                      enemy.hp -= swordDamage;
                      logBattle(
                        `¡${swordTechDetails.name} (Nv.${playerTechLevel}) causa ${swordDamage} daño!`
                      );
                      showFloatingText(
                        document.querySelector(".character-sprite"),
                        `Tajo Veloz`,
                        "ability"
                      );
                      showFloatingText(
                        document.getElementById("enemySprite"),
                        ` -${swordDamage}`,
                        "damage"
                      );
                    } else {
                      logBattle(`Maná insuficiente para ${swordTechDetails.name}.`);
                      actionTaken = false;
                    }

                    break;
                  case "sword_t2"://Estocada Perfora-Armadura
                              // Obtenemos los detalles de la técnica y su nivel
                    const estocadaDetails = techniqueData["sword_t2"];
                    const estocadaLevel = player.learnedTechniques["sword_t2"]?.level || 1;

                    // --- CÁLCULOS MEJORADOS ---
                    // El multiplicador de daño y la penetración ahora escalan con el nivel de la técnica
                    const damageMultiplier = estocadaDetails.effect.baseDamageMultiplier + ((estocadaLevel - 1) * 0.1);
                    const penetrationPercent = estocadaDetails.effect.defensePenetration + ((estocadaLevel - 1) * 0.02); // +2% por nivel

                    // Calculamos el daño
                    const defenseToIgnore = (enemy.defense || 0) * penetrationPercent;
                    const baseDamage = player.attack * damageMultiplier;
                    damageDealt = Math.max(1, Math.floor(baseDamage - ((enemy.defense || 0) - defenseToIgnore)));
                    
                    enemy.hp -= damageDealt;

                    logMessage = `¡${estocadaDetails.name} (Nv.${estocadaLevel}) ignora ${Math.floor(defenseToIgnore)} de defensa y causa ${damageDealt} de daño!`;
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');

                    // --- LÓGICA PARA LA HEMORRAGIA (BLEED) ---
                    const bleedChance = estocadaDetails.effect.bleedChance + ((estocadaLevel - 1) * 0.05); // La probabilidad de sangrado también mejora
                    if (Math.random() < bleedChance) {
                        const bleedDmg = estocadaDetails.effect.bleedDamagePerTurn + (estocadaLevel * 2); // El daño de sangrado escala
                        const bleedDur = estocadaDetails.effect.bleedDuration;

                        // Para no crear una nueva propiedad, podemos reutilizar la de "poison" o "burn".
                        // Usemos "poison" como si fuera "bleed" para no añadir más complejidad al enemyTurn.
                        enemy.poisonedTurns = Math.max(enemy.poisonedTurns, bleedDur);
                        enemy.poisonDamage = Math.max(enemy.poisonDamage, bleedDmg);
                        
                        logMessage += ` ¡El golpe causa una herida abierta que sangra!`;
                        showFloatingText(enemySprite, 'Hemorragia', 'debuff');
                    }

                    logBattle(logMessage);
                    break;
                  case "sword_t3": { // Danza de Espada Ciclónica
                        const hits = Math.round(effect.baseHits + (playerTechLevel - 1) * effect.hitsIncreasePerLevel);
                        let totalDamage = 0;
                        for (let i = 0; i < hits; i++) {
                            const damageDealt = Math.max(1, Math.floor((player.attack * effect.baseDamageMultiplier) - enemy.defense));
                            enemy.hp -= damageDealt;
                            totalDamage += damageDealt;
                        }
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) golpea ${hits} veces, causando ${totalDamage} de daño!`;
                        showFloatingText(enemySprite, `-${totalDamage}`, 'damage');
                        break;
                    }
                  case "sword_t4": { // Intento de Espada del Tirano
                        const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.multiplierIncreasePerLevel;
                        const damageDealt = Math.max(1, Math.floor(player.attack * currentMultiplier) - enemy.defense);
                        enemy.hp -= damageDealt;
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) golpea con ${damageDealt} de daño!`;
                        const stunChance = effect.baseStunChance + (playerTechLevel - 1) * effect.stunChanceIncreasePerLevel;
                        if (Math.random() < stunChance) {
                            enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                            logMessage += " ¡El enemigo queda aturdido!";
                        }
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }
                  case "sword_t5": // Corte que Divide Cielos y Tierra
                    const sword5DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.floor(player.attack * sword5DmgMultiplier);
                    enemy.hp -= damageDealt;
                    logMessage = `¡${techDetails.name} corta la realidad misma, infligiendo ${damageDealt} de daño absoluto!`;

                    const critChance = techDetails.effect.criticalChance + (playerTechLevel - 1) * (techDetails.effect.criticalChanceIncreasePerLevel || 0);
                    if (Math.random() < critChance) {
                        const critDamage = Math.floor(damageDealt * 0.5); // 50% extra de daño crítico
                        enemy.hp -= critDamage;
                        logMessage += ` ¡Fue un golpe crítico, causando ${critDamage} de daño extra!`;
                        damageDealt += critDamage;
                    }

                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    break;
                  case "sword_t6": // Espada del Emperador Celestial
                        const executeThreshold = techDetails.effect.executeThreshold + (playerTechLevel - 1) * (techDetails.effect.executeThresholdIncreasePerLevel || 0);
                        logMessage = `¡${techDetails.name} desata un poder absoluto!`;
                        if (enemy.hp / enemy.maxHp <= executeThreshold) {
                            damageDealt = enemy.hp;
                            enemy.hp = 0;
                            logMessage += " ¡El enemigo es ejecutado por decreto celestial!";
                            showFloatingText(enemySprite, '¡EJECUTADO!', 'damage');
                        } else {
                            const sword6DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                            damageDealt = Math.floor(player.attack * sword6DmgMultiplier);
                            enemy.hp -= damageDealt;
                            logMessage += ` Causa ${damageDealt} de daño que ignora toda protección.`;
                            showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        }
                        break;
                  
                  case "fire_t1"://Chispa Ígnea
                    const fireDamageMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * fireDamageMultiplier) - (enemy.defense || 0));
                    enemy.hp -= damageDealt;

                    const burnDamage = techDetails.effect.burnDamagePerTurn + (playerTechLevel - 1) * (techDetails.effect.burnDamageIncreasePerLevel || 0);
                    enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                    enemy.burnDamage = Math.max(enemy.burnDamage, burnDamage);
                    
                    logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} de daño y quema al enemigo!`;
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    break;

                  case "fire_t2"://Aliento de Dragón Menor
                    const fire2DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * fire2DmgMultiplier) - (enemy.defense || 0));
                    enemy.hp -= damageDealt;
                    
                    const burn2Damage = techDetails.effect.burnDamagePerTurn + (playerTechLevel - 1) * (techDetails.effect.burnDamageIncreasePerLevel || 0);
                    enemy.burningTurns = Math.max(enemy.burningTurns, techDetails.effect.burnDuration);
                    enemy.burnDamage = Math.max(enemy.burnDamage, burn2Damage);

                    logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} de daño e inflige una quemadura intensa!`;
                    break;
                  
                  case "fire_t4": { // Sol Abrasador
                        const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.multiplierIncreasePerLevel;
                        const damageDealt = Math.max(1, Math.floor(player.attack * currentMultiplier) - enemy.defense);
                        enemy.hp -= damageDealt;
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) inflige ${damageDealt} de daño masivo!`;
                        
                        // --- INICIO DE LA MODIFICACIÓN ---
                        // Calculamos el daño de la quemadura, incluyendo el escalado por nivel.
                        const burnDamage = effect.burnDamagePerTurn + (playerTechLevel - 1) * (effect.burnIncreasePerLevel || 0);
                        
                        // Aplicamos la quemadura al enemigo. Usamos Math.max para no reemplazar una quemadura más fuerte.
                        enemy.burningTurns = Math.max(enemy.burningTurns, effect.burnDuration);
                        enemy.burnDamage = Math.max(enemy.burnDamage, burnDamage);
                        
                        // Actualizamos el mensaje del log y mostramos un texto flotante.
                        logMessage += ` ¡El enemigo queda envuelto en llamas, sufriendo una quemadura intensa!`;
                        showFloatingText(enemySprite, '¡Quemadura!', 'debuff');
                        // --- FIN DE LA MODIFICACIÓN ---

                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }
                  case "fire_t5": // Llama del Fénix Renaciente
                            damageDealt = Math.max(1, Math.floor(player.attack * techDetails.effect.baseDamageMultiplier) - enemy.defense);
                            enemy.hp -= damageDealt;
                            const reviveChance = techDetails.effect.reviveChance + (playerTechLevel - 1) * (techDetails.effect.reviveChanceIncreasePerLevel || 0);
                            if (Math.random() < reviveChance) {
                                player.canRevive = true;
                            }
                            logMessage = `¡${techDetails.name} incinera al enemigo con ${damageDealt} de daño y te imbuye con la esencia del Fénix!`;
                            showFloatingText(playerSprite, 'Fénix Interior', 'ability');
                            showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                            break; 
                  

                  case "lightning_t1": // Dedo de Relámpago
                      const lightningDmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                      damageDealt = Math.max(1, Math.floor(player.attack * lightningDmgMultiplier) - enemy.defense);
                      enemy.hp -= damageDealt;

                      const stunChance = techDetails.effect.stunChance + (playerTechLevel - 1) * (techDetails.effect.stunChanceIncreasePerLevel || 0);
                      logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) golpea con ${damageDealt} de daño!`;
                      
                      if (Math.random() < stunChance) {
                          enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                          logMessage += " ¡El enemigo queda aturdido!";
                          showFloatingText(enemySprite, '¡Aturdido!', 'debuff');
                      }
                      showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                      break;
                  case "lightning_t2": // Látigo de Trueno
                    const lightning2DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * lightning2DmgMultiplier) - enemy.defense);
                    
                    const defenseReduction = techDetails.effect.defenseReduction + (playerTechLevel - 1) * (techDetails.effect.defenseReductionIncreasePerLevel || 0);
                    const duration = techDetails.effect.duration;
                    
                    enemy.hp -= damageDealt;
                    enemy.defenseReductionTurns = Math.max(enemy.defenseReductionTurns, duration);
                    enemy.defenseReductionAmount = Math.max(enemy.defenseReductionAmount, defenseReduction);

                    logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} de daño y reduce la defensa del enemigo en ${defenseReduction}!`;
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    showFloatingText(enemySprite, 'Defensa ↓', 'debuff');
                    break;
                  case "lightning_t3": { // Jaula de Rayos
                      const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.damageMultiplierIncreasePerLevel;
                      const damageDealt = Math.max(1, Math.floor(player.attack * currentMultiplier) - enemy.defense);
                      enemy.hp -= damageDealt;
                      logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) electrocuta con ${damageDealt} de daño!`;
                      const stunChance = effect.baseStunChance + (playerTechLevel - 1) * effect.stunChanceIncreasePerLevel;
                      if (Math.random() < stunChance) {
                          enemy.stunnedTurns = Math.max(enemy.stunnedTurns, effect.duration);
                          logMessage += ` ¡El enemigo queda paralizado!`;
                          showFloatingText(enemySprite, '¡Paralizado!', 'debuff');
                      }
                      showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                      break;
                  }
                  case "lightning_t4": { // Llamada del Juicio del Trueno
                        const currentMultiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * effect.multiplierIncreasePerLevel;
                        const damageDealt = Math.floor(player.attack * currentMultiplier); // Ignora defensa
                        enemy.hp -= damageDealt;
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) ignora la defensa, causando ${damageDealt} de daño verdadero!`;
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }          
                  case "lightning_t5": // Tribulación de los Nueve Cielos
                    const lightning5DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                    damageDealt = Math.max(1, Math.floor(player.attack * lightning5DmgMultiplier) - enemy.defense);
                    enemy.hp -= damageDealt;
                    logMessage = `¡Invocas la ${techDetails.name}, causando ${damageDealt} de daño celestial!`;

                    const paralyzeChance = techDetails.effect.paralyzeChance + (playerTechLevel - 1) * (techDetails.effect.paralyzeChanceIncreasePerLevel || 0);
                    if (Math.random() < paralyzeChance) {
                        enemy.stunnedTurns = Math.max(enemy.stunnedTurns, techDetails.effect.duration || 2);
                        logMessage += ` ¡El poder de la tribulación lo deja paralizado por ${enemy.stunnedTurns} turnos!`;
                        showFloatingText(enemySprite, '¡Paralizado!', 'debuff');
                    }
                    showFloatingText(playerSprite, '¡Tribulación!', 'ability');
                    showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                    break;

                  case "movement_t1": { // Paso Veloz (TIER 1)
                      const defenseBonus = techDetails.effect.tempDefenseBuff + ((playerTechLevel - 1) * techDetails.effect.buffIncreasePerLevel);
                      
                      if(player.tempDefenseBoostAmount > 0) {
                          player.defense -= player.tempDefenseBoostAmount;
                      }
                      player.defense += defenseBonus;
                      player.tempDefenseBoostAmount = defenseBonus;
                      player.tempDefenseBoostTurns = techDetails.effect.buffDuration;
                      
                      logMessage = `¡Ejecutas un ${techDetails.name}! Tu defensa aumenta en ${defenseBonus} por ${player.tempDefenseBoostTurns} turnos.`;
                      showFloatingText(playerSprite, `Defensa +${defenseBonus}`, 'ability');
                      break;
                  }
                  case "movement_t2"://Paso Etéreo
                    const etereoDetails = techniqueData["movement_t2"];
                    const etereoLevel = player.learnedTechniques["movement_t2"]?.level || 1;

                    // --- LÓGICA PARA APLICAR ESQUIVA Y BUFF ---
                    player.dodgeNextAttack = true;

                    // Calculamos y aplicamos el buff de defensa
                    const defenseBonus = etereoDetails.effect.tempDefenseBuff + (etereoDetails.effect.buffIncreasePerLevel * (etereoLevel - 1));
                    
                    // Evitamos acumular el mismo buff, lo refrescamos
                    if (player.tempDefenseBoostAmount > 0) {
                        player.defense -= player.tempDefenseBoostAmount; // Quita el buff anterior
                    }
                    player.defense += defenseBonus;
                    player.tempDefenseBoostAmount = defenseBonus;
                    player.tempDefenseBoostTurns = etereoDetails.effect.buffDuration;
                    
                    logMessage = `¡Usas ${etereoDetails.name} (Nv.${etereoLevel})! Te preparas para esquivar y tu defensa aumenta en ${defenseBonus} por ${player.tempDefenseBoostTurns} turnos.`;
                    showFloatingText(playerSprite, '¡Esquiva!', 'ability');
                    showFloatingText(playerSprite, `Defensa +${defenseBonus}`, 'ability');
                    
                    logBattle(logMessage);
                    break;              
                  case "movement_t3": { // Parpadeo de Sombra
                        const effect = techDetails.effect;
                        
                        // Calculamos el multiplicador actual: Base + (Nivel - 1) * AumentoPorNivel
                        const currentMultiplier = effect.baseDamageMultiplier + ((playerTechLevel - 1) * (effect.multiplierIncreasePerLevel || 0));
                        
                        let baseDamage = player.attack * currentMultiplier;

                        // Aplicamos el multiplicador de crítico si la técnica lo especifica
                        if (effect.isCritical) {
                            baseDamage *= 1.5; // Multiplicador de crítico estándar (150%)
                        }

                        const damageDealt = Math.max(1, Math.floor(baseDamage) - (enemy.defense || 0));
                        enemy.hp -= damageDealt;

                        logMessage = `¡Con ${techDetails.name} (Nv.${playerTechLevel}), apareces para un golpe crítico de ${damageDealt}!`;
                        showFloatingText(playerSprite, '¡Golpe Súbito!', 'ability');
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                    }              
                  case "movement_t4": // Danza del Viento Espectral
                        const move4DmgMultiplier = techDetails.effect.baseDamageMultiplier + (playerTechLevel - 1) * (techDetails.effect.multiplierIncreasePerLevel || 0);
                        damageDealt = Math.max(1, Math.floor(player.attack * move4DmgMultiplier) - enemy.defense);
                        enemy.hp -= damageDealt;
                        player.dodgeNextAttack = true;
                        logMessage = `¡Ejecutas la ${techDetails.name}! Causas ${damageDealt} de daño y te preparas para esquivar.`;
                        showFloatingText(playerSprite, '¡Esquiva!', 'ability');
                        showFloatingText(enemySprite, `-${damageDealt}`, 'damage');
                        break;
                  case "movement_t5": // Paso del Vacío Infinito
                    player.intangibleTurns = techDetails.effect.intangibleTurns;
                    const numHits = techDetails.effect.multiHit;
                    let totalVoidDamage = 0;
                    for (let i = 0; i < numHits; i++) {
                        damageDealt = Math.max(1, Math.floor((player.attack * (techDetails.effect.baseDamageMultiplier / numHits)) - enemy.defense));
                        enemy.hp -= damageDealt;
                        totalVoidDamage += damageDealt;
                    }
                    logMessage = `¡Con ${techDetails.name} te vuelves intangible por ${player.intangibleTurns} turnos y golpeas ${numHits} veces, causando un total de ${totalVoidDamage} de daño!`;
                    showFloatingText(enemySprite, `-${totalVoidDamage}`, 'damage');
                    break;        

                  case "formation_t1":
                      const shieldDetails = techniqueData["formation_t1"];
                      const shieldLevel = player.learnedTechniques["formation_t1"]?.level || 1;

                      // --- CÁLCULO DE ESCUDO MEJORADO ---
                      const shieldBase = shieldDetails.effect.shieldValue;
                      const shieldBonusPerLevel = shieldDetails.effect.shieldIncreasePerLevel;
                      const shieldValue = shieldBase + (shieldBonusPerLevel * (shieldLevel - 1));
                      const shieldDuration = shieldDetails.effect.duration;

                      // Aplicamos el escudo
                      player.magicShieldValue = (player.magicShieldValue || 0) + shieldValue;
                      player.magicShieldTurns = Math.max(player.magicShieldTurns || 0, shieldDuration);

                      logMessage = `¡${shieldDetails.name} (Nv.${shieldLevel}) crea un escudo que absorbe ${shieldValue} de daño! (Total: ${Math.floor(player.magicShieldValue)})`;
                      showFloatingText(playerSprite, `Escudo +${shieldValue}`, 'ability');

                      // --- LÓGICA PARA LA CURACIÓN SECUNDARIA ---
                      const healReqLevel = shieldDetails.effect.healOnCastLevelReq;
                      if (shieldLevel >= healReqLevel) {
                          const healBase = shieldDetails.effect.healOnCastAmount;
                          // La curación también puede escalar un poco
                          const healAmount = healBase + ((shieldLevel - healReqLevel) * 5);
                          
                          player.hp = Math.min(player.maxHp, player.hp + healAmount);
                          
                          logMessage += ` El flujo de Qi regenera ${healAmount} de vida.`;
                          showFloatingText(playerSprite, `+${healAmount}`, 'heal');
                      }
                      
                      logBattle(logMessage);
                      break;
                  case "formation_t2":
                    const rootTechDetails = techniqueData["formation_t2"];
                    const rootTechLevel = player.learnedTechniques["formation_t2"]?.level || 1;
                    const rootChance = (rootTechDetails.effect.rootChance || 0.7) + (rootTechLevel - 1) * 0.03;

                    if (Math.random() < rootChance) {
                      const rootDuration = rootTechDetails.effect.rootDuration;
                      const rootDmgPerTurn = rootTechDetails.effect.damagePerTurn + (rootTechLevel - 1) * (rootTechDetails.effect.damagePerTurnIncreasePerLevel || 0);
                      const shacklesHealth = rootTechDetails.effect.shacklesHP + (rootTechLevel - 1) * (rootTechDetails.effect.shacklesHPIncreasePerLevel || 0);

                      enemy.rootedTurns = rootDuration;
                      enemy.rootDamage = rootDmgPerTurn;

                      player.activeChanneledAbility.id = "formation_t2";
                      player.activeChanneledAbility.hp = shacklesHealth;
                      
                      logMessage = `¡${rootTechDetails.name} (Nv.${rootTechLevel}) atrapa al enemigo con grilletes de ${shacklesHealth} de resistencia!`;
                      showFloatingText(enemySprite, "¡Atrapado!", "debuff");
                    } else {
                      logMessage = `¡${rootTechDetails.name} (Nv.${rootTechLevel}) falla y el enemigo esquiva los grilletes!`;
                      showFloatingText(enemySprite, "¡Falló!", "ability");
                    }
                    logBattle(logMessage);
                    break;
                  case "formation_t3": { // Matriz de Supresión Espiritual
                        const reduction = effect.baseReduction + (playerTechLevel - 1) * effect.reductionIncreasePerLevel;
                        enemy.defenseReductionTurns = Math.max(enemy.defenseReductionTurns, effect.duration);
                        enemy.defenseReductionAmount = Math.max(enemy.defenseReductionAmount, reduction);
                        enemy.attackReductionTurns = Math.max(enemy.attackReductionTurns, effect.duration);
                        enemy.attackReductionAmount = Math.max(enemy.attackReductionAmount, reduction);
                        logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) debilita al enemigo! Su Ataque y Defensa se reducen en ${reduction}.`;
                        showFloatingText(enemySprite, 'Ata/Def ↓', 'debuff');
                        break;
                    }      
                  case "formation_t4": { // Santuario Dorado Protector
                      const duration = effect.baseDuration + (playerTechLevel >= effect.levelForExtraTurn ? 1 : 0);
                      player.intangibleTurns = duration;
                      logMessage = `¡${techDetails.name} (Nv.${playerTechLevel}) te hace inmune al daño por ${duration} turnos!`;
                      showFloatingText(playerSprite, '¡Invulnerable!', 'ability');
                      break;
                  }
                  case "formation_t5": // Matriz de Reversión del Cosmos
                    player.damageToHealingTurns = techDetails.effect.damageToHealingDuration;
                    logMessage = `¡Activaste ${techDetails.name}! Durante ${player.damageToHealingTurns} turnos, el daño recibido te curará.`;
                    showFloatingText(playerSprite, 'Inversión Cósmica', 'ability');
                    break;                  
                  case "formation_t6": // Matriz del Sello del Demonio
                          enemy.sealedTurns = techDetails.effect.sealDuration;
                          logMessage = `¡${techDetails.name} sella completamente al enemigo por ${enemy.sealedTurns} turnos! No podrá realizar ninguna acción.`;
                          showFloatingText(enemySprite, '¡SELLADO!', 'debuff');
                          break; 

                    
                  default:
                        // Este bloque ahora se encarga de TODAS las habilidades que hemos estandarizado
                        logMessage = `Usando ${techDetails.name} (Nv.${playerTechLevel})...`;
                        let tempDamage = 0;
                        
                        // Daño base
                        if (effect.baseDamageMultiplier) {
                             const multiplier = effect.baseDamageMultiplier + (playerTechLevel - 1) * (effect.multiplierIncreasePerLevel || 0);
                             tempDamage = Math.max(1, Math.floor(player.attack * multiplier) - (enemy.defense || 0));
                             enemy.hp -= tempDamage;
                             logMessage += ` ¡Causa ${tempDamage} de daño!`;
                             showFloatingText(enemySprite, `-${tempDamage}`, "damage");
                        }
                        // Aquí puedes añadir la lógica genérica para DoTs, stuns, etc. si lo deseas en el futuro
                        break;
                }
                 if(logMessage) logBattle(logMessage);
            }
        } else {
            // --- FIN DE LA LÓGICA DE HABILIDADES ---
            // Si no es una habilidad, es una acción básica (ataque, defensa, huida)
            switch (action) {
              case "attack":
                const damage = Math.max(
                  1,
                  player.attack -
                    (enemy.defense || 0) +
                    Math.floor(Math.random() * 5 - 2)
                );
                enemy.hp -= damage;
                logBattle(`Atacas causando ${damage} daño.`);
                showFloatingText(
                  document.getElementById("enemySprite"),
                  `-${damage}`,
                  "damage"
                );

                // ESTA LÍNEA DEBERÍA SER logBattle, NO showFloatingText.
                // O es un resto de una depuración anterior que hay que eliminar.
                if (player.hp <= 0) {
                  logBattle("Has sucumbido antes de actuar.");
                  // ... Lógica de derrota ...
                }
                break; // <-- Fin del caso de ataque
              case "qi_fist":
                const qiFistCost = 10;
                if (player.mana >= qiFistCost) {
                  player.mana -= qiFistCost;
                  const magicDamage = Math.max(
                    1,
                    Math.floor(player.attack * 0.8 + player.maxMana * 0.2) -
                      (enemy.defense || 0)
                  );
                  enemy.hp -= magicDamage;
                  logBattle(`Puño de Qi causa ${magicDamage} daño mágico.`);
                  showFloatingText(
                    document.querySelector(".character-sprite"),
                    `Puño de QI`,
                    "ability"
                  );
                  showFloatingText(
                    document.getElementById("enemySprite"),
                    `-${magicDamage}`,
                    "damage"
                  );
                } else {
                  logBattle("Maná insuficiente para Puño de Qi.");
                  actionTaken = false;
                }

                break;
              case "defend":
                let healAmount = Math.floor(player.maxHp * 0.1);
                player.hp = Math.min(player.maxHp, player.hp + healAmount);
                showFloatingText(
                  document.querySelector(".character-sprite"),
                  `+${healAmount}`,
                  "heal"
                );
                logBattle(`Te defiendes y recuperas ${healAmount} HP.`);
                break;
              case "escape":
                if (enemy.isBoss) {
                  logBattle(`¡No puedes huir de un ${enemy.name}!`);
                  showFloatingText(
                    document.querySelector(".character-sprite"),
                    "¡Imposible!",
                    "debuff"
                  );
                  actionTaken = false; // La acción falló, no se consume el turno
                } else if (Math.random() < 0.7) {
                  // Probabilidad de éxito de huida

                  const escapeTile = findEscapeTile(player, enemy);

                  if (escapeTile) {
                    logBattle("¡Escapaste con éxito!");
                    showFloatingText(
                      document.querySelector(".character-sprite"),
                      "¡Huida!",
                      "ability"
                    );

                    // Mover al jugador a la casilla segura ANTES de terminar la batalla
                    player.x = escapeTile.x;
                    player.y = escapeTile.y;

                    // Esperar un breve momento para que el texto flotante se vea
                    setTimeout(() => {
                      endBattle(false); // false = no fue una victoria
                      updatePlayerPosition("escape_success"); // Actualizar la posición visual en el mapa
                    }, 500);
                  } else {
                    logBattle("¡Intentaste huir, pero no hay a dónde ir!");
                    showFloatingText(
                      document.querySelector(".character-sprite"),
                      "¡Atrapado!",
                      "debuff"
                    );
                    actionTaken = true; // El intento de huir consume el turno
                  }

                  // Como la huida (exitosa o no) ya manejó el flujo, salimos de la función
                  return;
                } else {
                  logBattle("¡No pudiste escapar!");
                  showFloatingText(
                    document.querySelector(".character-sprite"),
                    "¡Falló!",
                    "debuff"
                  );
                  actionTaken = true; // El intento fallido también consume el turno
                }
                break;
              default:
                logBattle("Acción desconocida.");
                actionTaken = false;
                break;
          }
        
        }
        
        if (!actionTaken) {
          updateBattleUI();
          return;
        }

        gameState.battle.playerTurn = false;
        updateBattleUI();

        if (enemy.hp <= 0) {
          handleEnemyDefeat();
        } else {
          let enemyDiedToDot = false;
          if (enemy.burningTurns > 0) {
            enemy.hp -= enemy.burnDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.burnDamage
              } por quemadura. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.poisonedTurns > 0) {
            enemy.hp -= enemy.poisonDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.poisonDamage
              } por veneno. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.rootedTurns > 0) {
            enemy.hp -= enemy.rootDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.rootDamage
              } por enredo. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }

          if (enemyDiedToDot) {
            handleEnemyDefeat();
          } else {
            setTimeout(enemyTurn, 1000);
          }
        }
      }


      /**
 * FUNCIÓN CENTRALIZADA (Reemplazar la existente)
 * Genera el texto de progreso para una misión activa.
 * @param {object} misionActiva - El objeto de la misión activa del jugador.
 * @returns {string} El texto formateado del progreso de la misión.
 */
      function getMissionProgressText(misionActiva) {
          const misionData = MISIONES_DATA[misionActiva.id];
          if (!misionData || !misionActiva.objetivoOriginal) {
              return "(Error: Datos de misión no encontrados)";
          }

          const objetivo = misionActiva.objetivoOriginal;
          const progreso = misionActiva.progreso || 0;
          const npcEntregaNombre = SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre || "el NPC correspondiente";
          let texto = "";
          let completado = false;

          switch (objetivo.tipo) {
              case "eliminar_enemigo":
                  completado = progreso >= objetivo.cantidad;
                  texto = `Eliminados: ${progreso}/${objetivo.cantidad} ${objetivo.nombreDisplay || "objetivos"}`;
                  break;

              case "entregar_item":
                  const tiene = gameState.inventory[objetivo.item] || 0;
                  completado = tiene >= objetivo.cantidad;
                  texto = `Reunidos: ${tiene}/${objetivo.cantidad} ${objetivo.item}`;
                  break;
                  
              case "derrotar_npc_especifico":
                  const rivalName = entityTypes[objetivo.npcId]?.name || "objetivo";
                  completado = progreso === 1;
                  texto = completado ? `Derrotado: ${rivalName}` : `Pendiente: Derrotar a ${rivalName}`;
                  break;

              case "recolectar_multiples_items":
                  let todosListos = true;
                  const itemsStatus = objetivo.items.map(itemReq => {
                      const tiene = gameState.inventory[itemReq.nombre] || 0;
                      if (tiene < itemReq.cantidad) todosListos = false;
                      return `${tiene}/${itemReq.cantidad} ${itemReq.nombre}`;
                  }).join(', ');
                  completado = todosListos;
                  texto = `Recolectar: ${itemsStatus}`;
                  break;
              
              case "cazar_y_recuperar_item_de_loot":
                  const tieneItem = (gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba;
                  completado = progreso === 1 && tieneItem;
                  texto = `Cazar y obtener: ${objetivo.cantidadItemPrueba} ${objetivo.itemPrueba}`;
                  break;
                  
              case "llegar_a_punto":
                  completado = progreso === 1;
                  texto = completado ? `Ubicación encontrada: ${objetivo.nombreArea}` : `Objetivo: Llegar a ${objetivo.nombreArea}`;
                  break;

              default:
                  // Si llega aquí, es porque el 'tipo' de objetivo en MISIONES_DATA está mal escrito o falta.
                  return "(Progreso no rastreable)";
          }

          if (completado) {
              texto += ` <strong>(¡Listo para entregar a ${npcEntregaNombre}!)</strong>`;
          }

          return texto;
      }
      // REEMPLAZA tu función handleEnemyDefeat completa con esta versión

// REEMPLAZA tu función handleEnemyDefeat completa con esta versión definitiva

function handleEnemyDefeat() {
    const battleEnemy = gameState.battle.enemy;
    const player = gameState.player;
    const enemyDefinition = entityTypes[battleEnemy.originalEntityTypeId] || {};
    const enemy = { ...enemyDefinition, ...battleEnemy };

    console.groupCollapsed(`[handleEnemyDefeat v2] ==> Procesando derrota de: ${enemy.name}`);
    logBattle(`¡Has derrotado al ${enemy.name}!`);
    gainExperience(enemy.exp);

    // --- INICIO DE LA CORRECCIÓN CLAVE ---

    // PASO 1: Marcar la misión como completada INMEDIATAMENTE.
    // Esto es crucial para que ensureFixedEntities no lo vuelva a crear.
    const misionesActivasDelJugador = [...player.secta.misionesActivas];
    misionesActivasDelJugador.forEach((misionActiva) => {
        const misionData = MISIONES_DATA[misionActiva.id];
        if (!misionData || !misionData.objetivo) return;

        const objetivo = misionData.objetivo;

        if (objetivo.tipo === "derrotar_npc_especifico" && enemy.originalEntityTypeId === objetivo.npcId) {
            console.log(`[handleEnemyDefeat v2] Objetivo de misión 'derrotar_npc_especifico' para '${misionActiva.id}' CUMPLIDO.`);
            misionActiva.progreso = 1; // Marcamos que el objetivo está listo para la entrega.
            // NO lo movemos a 'completadas' aquí, eso se hace en completeMission().
        }
        
        // El resto de la lógica de progreso de misión no cambia.
        if (objetivo.tipo === "eliminar_enemigo" && enemy.originalEntityTypeId === objetivo.enemigoTipo) {
             misionActiva.progreso = (misionActiva.progreso || 0) + 1;
             logBattle(`Progreso '${misionData.titulo}': ${misionActiva.progreso}/${objetivo.cantidad}`);
        }
        
        if (objetivo.tipo === "cazar_y_recuperar_item_de_loot" && enemy.originalEntityTypeId === objetivo.enemigoTipo) {
            misionActiva.progreso = 1;
            logBattle(`Has derrotado a un ${enemy.name}. Busca el ${objetivo.itemPrueba} entre el botín.`);
        }
    });

    // PASO 2: Procesar el botín.
    let lootObtenidoTexto = "Botín Obtenido: ";
    let algoObtenido = false;
    if (enemy.lootTable) {
        enemy.lootTable.forEach((loot) => {
            if (Math.random() < loot.chance) {
                const cantidad = loot.quantity[0] + Math.floor(Math.random() * (loot.quantity[1] - loot.quantity[0] + 1));
                gameState.inventory[loot.itemName] = (gameState.inventory[loot.itemName] || 0) + cantidad;
                lootObtenidoTexto += `${cantidad} ${loot.itemName}, `;
                algoObtenido = true;
            }
        });
    }

    if (!algoObtenido) lootObtenidoTexto += "Nada.";
    else lootObtenidoTexto = lootObtenidoTexto.slice(0, -2) + ".";
    
    // PASO 3: Marcar al jefe como derrotado permanentemente en el estado del mundo.
    if (enemy.isBoss || enemy.isMiniBoss) {
        if (enemy.originalEntityTypeId) {
            player.worldState.defeatedFixedEntities[enemy.originalEntityTypeId] = true;
            console.log(`[handleEnemyDefeat v2] Entidad fija '${enemy.originalEntityTypeId}' marcada como derrotada permanentemente.`);
        }
    }
    
    // PASO 4: Eliminar la entidad del mapa.
    if (battleEnemy.entityRef) {
        removeEntity(battleEnemy.entityRef);
    }
    
    // PASO 5: Forzar una llamada a ensureFixedEntities AHORA, mientras la batalla
    // todavía está técnicamente "activa" (antes de endBattle).
    // Como ya marcamos al jefe como derrotado, no debería volver a crearlo.
    console.log(`[handleEnemyDefeat v2] Llamando a ensureFixedEntities para verificar el estado POST-derrota.`);
    ensureFixedEntities(); 
    
    // PASO 6: Lógica post-derrota y finalización de la batalla.
    if (enemy.originalEntityTypeId === 'lider_renegado_kai') {
        setTimeout(() => {
            showModal("Artefacto Recuperado", "Entre las pertenencias del líder renegado, encuentras un extraño compás que parece resonar con la energía del mundo. Quizás pueda señalar algo... o a alguien.");
        }, 1500); // Retraso para que el modal de victoria no lo tape.
    }

    setTimeout(() => {
        endBattle(true); // Termina la batalla.
        // Ahora, el jugador debe ir con el Guía Lin para COMPLETAR la misión y recibir las recompensas de PCS y EXP.
        showModal("¡Victoria!", `Has ganado el combate.\n\n${lootObtenidoTexto}\n\nAhora debes reportar tu éxito al Guía Lin para recibir tu recompensa final.`);
        updateSectUI();
    }, 500);
    
    console.groupEnd();
    // --- FIN DE LA CORRECCIÓN CLAVE ---
}
      
      function dev_resetMission(missionId) {
    const player = gameState.player;
    if (!player || !player.secta) {
        console.error("[DEV] No se puede resetear la misión, estado del jugador no encontrado.");
        return;
    }

    // Eliminar de misiones activas
    const initialActiveCount = player.secta.misionesActivas.length;
    player.secta.misionesActivas = player.secta.misionesActivas.filter(m => m.id !== missionId);
    const finalActiveCount = player.secta.misionesActivas.length;

    if (initialActiveCount > finalActiveCount) {
        console.log(`[DEV] Misión '${missionId}' eliminada de la lista de misiones activas.`);
    }

    // Eliminar de misiones completadas
    if (player.secta.misionesCompletadas[missionId]) {
        delete player.secta.misionesCompletadas[missionId];
        console.log(`[DEV] Misión '${missionId}' eliminada del historial de misiones completadas.`);
    }
    
    // Actualizar toda la interfaz para reflejar el cambio.
    updateUI();
    updateSectUI();
    openMissionsModal(); // Abrimos el diario para ver que ha desaparecido.

    const message = `El estado de la misión '${missionId}' ha sido reseteado. Ahora puedes volver a aceptarla del NPC correspondiente.`;
    console.log(message);
    alert(message);
}
      
      function dev_forceCompleteMission(missionId) {
    const player = gameState.player;
    const misionActiva = player.secta.misionesActivas.find(m => m.id === missionId);

    if (!misionActiva) {
        const message = `[DEV] Error: La misión '${missionId}' no está activa. No se puede forzar su finalización.`;
        console.error(message);
        alert(message);
        return;
    }

    const misionData = MISIONES_DATA[missionId];
    if (!misionData) {
        const message = `[DEV] Error: No se encontraron datos para la misión '${missionId}' en MISIONES_DATA.`;
        console.error(message);
        alert(message);
        return;
    }

    console.log(`[DEV] Forzando la finalización de: "${misionData.titulo}"`);

    // --- 1. OTORGAR RECOMPENSAS (Lógica copiada de completeMission) ---
    player.secta.puntosContribucion += misionData.recompensa.pcs || 0;
    gainExperience(misionData.recompensa.exp || 0);
    if (misionData.recompensa.items) {
        for (const itemName in misionData.recompensa.items) {
            gameState.inventory[itemName] = (gameState.inventory[itemName] || 0) + misionData.recompensa.items[itemName];
        }
    }
    console.log("[DEV] Recompensas otorgadas.");

    // --- 2. MOVER LA MISIÓN DE ACTIVA A COMPLETADA ---
    player.secta.misionesActivas = player.secta.misionesActivas.filter(m => m.id !== missionId);
    player.secta.misionesCompletadas[missionId] = true;
    console.log(`[DEV] Misión movida de 'activas' a 'completadas'.`);

    // --- 3. LIMPIAR EL JEFE DEL MAPA ---
    const objetivo = misionData.objetivo;
    if (objetivo.tipo === 'derrotar_npc_especifico' && objetivo.npcId) {
        const bossInstance = gameState.map.entities.find(e => e.npcId === objetivo.npcId);
        if (bossInstance) {
            removeEntity(bossInstance); // Llama a la función que ya tienes para borrar entidades
            player.worldState.defeatedBosses[objetivo.npcId] = true;
            console.log(`[DEV] Jefe asociado '${objetivo.npcId}' eliminado del mapa y marcado como derrotado.`);
        }
    }
    
    // --- 4. ACTUALIZAR TODA LA INTERFAZ ---
    updateUI();
    updateSectUI();
    renderMap(); // Para que el jefe desaparezca visualmente

    const message = `La misión '${misionData.titulo}' ha sido marcada como completada por la fuerza.`;
    showModal("Finalización Forzada", message);
    console.log(message);
}
      
function completeMission(misionId, npcIdEntregaManual = null) {
    const player = gameState.player;
    const misionActiva = player.secta.misionesActivas.find((m) => m.id === misionId);
    const misionDataOriginal = MISIONES_DATA[misionId];

    // --- PASO 1: VERIFICACIONES INICIALES ---
    if (!misionActiva || !misionDataOriginal) {
        showModal("Error de Misión", "Datos de la misión no encontrados.");
        return false;
    }

    const objetivo = misionActiva.objetivoOriginal;
    let objetivosCumplidos = false;

    // --- PASO 2: COMPROBACIÓN DE OBJETIVOS ---
    switch (objetivo.tipo) {
        case "entregar_item":
            if ((gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad) {
                if (npcIdEntregaManual === objetivo.npcEntrega) {
                    gameState.inventory[objetivo.item] -= objetivo.cantidad;
                    objetivosCumplidos = true;
                }
            }
            break;

        case "recolectar_multiples_items":
            let todosItemsRecolectados = true;
            for (const itemReq of objetivo.items) {
                if ((gameState.inventory[itemReq.nombre] || 0) < itemReq.cantidad) {
                    todosItemsRecolectados = false;
                    break;
                }
            }
            if (todosItemsRecolectados && npcIdEntregaManual === objetivo.npcEntrega) {
                for (const itemReq of objetivo.items) {
                    gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                }
                objetivosCumplidos = true;
            }
            break;

        case "cazar_y_recuperar_item_de_loot":
            if ((gameState.inventory[objetivo.itemPrueba] || 0) >= objetivo.cantidadItemPrueba) {
                if (npcIdEntregaManual === objetivo.npcEntrega) {
                    gameState.inventory[objetivo.itemPrueba] -= objetivo.cantidadItemPrueba;
                    objetivosCumplidos = true;
                }
            }
            break;

        case "eliminar_enemigo":
        case "derrotar_npc_especifico":
        case "llegar_a_punto":
        case "trazar_patron":
            if (misionActiva.progreso >= (objetivo.cantidad || 1)) {
                objetivosCumplidos = true;
            }
            break;

        default:
            showModal("Error de Misión", "Tipo de objetivo no reconocido.");
            return false;
    }

    // --- PASO 3: CLÁUSULA DE GUARDA ---
    if (!objetivosCumplidos) {
        console.log(`[completeMission] Objetivos para '${misionId}' no cumplidos. La función termina aquí.`);
        return false;
    }
    
    // --- PASO 4: PROCESAMIENTO DE RECOMPENSAS (SI LA MISIÓN FUE EXITOSA) ---
    console.log(`%c[completeMission] ¡Misión '${misionId}' completada con éxito! Procediendo a dar recompensas.`, 'color: #33cc33');

    const recompensa = misionDataOriginal.recompensa;
    let recompensaItemsTexto = ""; // Declarada aquí para que exista en todo el ámbito.

    // Dar recompensas (PCS y EXP)
    player.secta.puntosContribucion += recompensa.pcs || 0;
    gainExperience(recompensa.exp || 0);

    // Procesar recompensas de objetos
    if (recompensa.items) {
        for (const itemName in recompensa.items) {
            gameState.inventory[itemName] = (gameState.inventory[itemName] || 0) + recompensa.items[itemName];
            recompensaItemsTexto += `${recompensa.items[itemName]} ${itemName}, `;
        }
    }
    
    // Procesar recompensa de aprender un patrón
    if (recompensa.learnPattern) {
        const patternId = recompensa.learnPattern;
        if (FORMATION_PATTERNS[patternId]) {
            player.discoveredFormationPatterns[patternId] = true;
            recompensaItemsTexto += `Diagrama: ${FORMATION_PATTERNS[patternId].name}, `;
        }
    }
    
    // --- PASO 5: ACTUALIZACIÓN DE ESTADO Y UI ---
    player.secta.misionesActivas = player.secta.misionesActivas.filter(m => m.id !== misionId);
    player.secta.misionesCompletadas[misionId] = true;
    
    let recompensaFinalTexto = `Recompensas: ${recompensa.pcs || 0} PCS, ${recompensa.exp || 0} EXP`;
    if (recompensaItemsTexto) {
        recompensaFinalTexto += ", " + recompensaItemsTexto.slice(0, -2); // Quitamos la última coma y espacio
    }
    showModal("¡Misión Completada!", `Completaste: ${misionDataOriginal.titulo}.\n${recompensaFinalTexto}`);

    

    // --- PASO 6: LÓGICA POST-MISIÓN (SUBTRAMAS Y EVENTOS) ---
    console.log(`[completeMission v3] Comprobando si la misión '${misionId}' afecta a una subtrama...`);
    
    // Avance de la subtrama de Feng
    if (misionDataOriginal.npcInicio === 'npc_maestro_feng' || misionDataOriginal.objetivo.npcEntrega === 'npc_maestro_feng') {
        const currentProgress = player.worldState.subplotFlags.fengQuestProgress;
        player.worldState.subplotFlags.fengQuestProgress++;
        console.log(`%c[SUBTRAMA FENG] Progreso avanzado de ${currentProgress} a ${player.worldState.subplotFlags.fengQuestProgress}.`, 'color: #9933ff; font-weight: bold;');
        
        // Al completar la misión, inmediatamente intentamos interactuar de nuevo con Feng
        // para que ofrezca la siguiente misión, creando un flujo continuo.
        setTimeout(() => {
            interactWithSectNPC('npc_maestro_feng');
        }, 1500); // Pequeño retraso para que el jugador lea el modal de "misión completada".
    }

    // Activador de subtrama del Alquimista
    if (misionId === 'mision_componentes_alquimia_1' && !player.worldState.subplotFlags.foundAlchemistNote) {
        // ... (Tu lógica para la nota del alquimista) ...
    }

    // Recompensa de Ascenso de Rango
    if (recompensa.nuevoRango) {
        if (misionDataOriginal.recompensa.nuevoRango) {
            const newRankName = misionDataOriginal.recompensa.nuevoRango;
            player.secta.rango = newRankName;
            let rankUpMessage = `¡Felicidades! Ascendiste a ${player.secta.rango}.`;
          let specialRewardText = "";
  
            // Recompensa específica para el rango de Anciano
            if (newRankName === "Anciano") {
                const scrollItem = "Rollo: Inscripción Rúnica";
                gameState.inventory[scrollItem] = (gameState.inventory[scrollItem] || 0) + 1;
                specialRewardText = `<br><br><strong>¡Has obtenido un manual antiguo!</strong><br>Revisa tu inventario para aprender el <em>"${scrollItem}"</em>.`;
            }
  
            setTimeout(() => {
                  showModal("¡Ascenso en la Secta!", rankUpMessage + specialRewardText);
              }, 2500);
  
            applyRankBenefits(player.secta.rango);
  
            // === INICIO DE LA MODIFICACIÓN CLAVE ===
            // Comprobamos si el nuevo rango tiene una elección de técnica como recompensa.
            const rankData = SECTA_DATA.rangos.find(
              (r) => r.nombre === newRankName
            );
            if (rankData && rankData.techniqueChoice) {
              // Esperamos un poco más para que no se solape con el modal de ascenso.
              setTimeout(() => {
                openRankUpRewardModal(newRankName);
              }, 4500);
            }
            // === FIN DE LA MODIFICACIÓN CLAVE ===
          }
    }
    
    // Activadores de la historia principal
    const flags = player.worldState.storyFlags;
    if (misionId === "mision_desafio_interno_1" && !flags.metAncianaSu) {
        flags.metAncianaSu = true;
        flags.knowsAboutCalamity = true; // Aprovechamos para que sepa del desastre
        setTimeout(() => {
            showModal("Una Invitación Inesperada", 
            "Poco después de tu ascenso, recibes una nota de la Anciana Su, la archivista de la secta. Te pide que la visites.<br><br><em>'Tu control sobre el Qi... es especial. Visítame en los archivos cuando puedas. Hay cosas que deberías saber sobre la Gran Calamidad que hirió a nuestra secta.'</em>");
        }, 2500); // Pequeño retraso para no solapar modales
    }
    if (misionId === "mision_historia_1_demonio" && !player.worldState.storyFlags.knowsAboutCalamity) {
        // Ahora, al derrotar al demonio, se activa la siguiente fase de la historia
        flags.knowsAboutCalamity = true;
        setTimeout(() => {
            showModal("Una Invitación Inesperada", 
            "Tu victoria contra el General Demonio ha llamado la atención de los altos mandos. Recibes una nota de la Anciana Su, la archivista de la secta, pidiéndote que la visites de nuevo.<br><br><em>'Tu control sobre el Qi... es especial. Visítame en los archivos. Hay cosas que deberías saber sobre la Gran Calamidad que hirió a nuestra secta.'</em>");
        }, 2500); // Pequeño retraso para no solapar modales
    }
    if (misionId === "mision_desafio_diacono_1" && !flags.knowsAboutSoberano) {
        flags.knowsAboutSoberano = true;
        setTimeout(() => {
            showModal("La Convocatoria del Maestro", 
            "Tu ascenso a Diácono no ha pasado desapercibido. El Maestro de Secta Jian te convoca a sus aposentos privados.<br><br><em>'Joven Diácono, debo confiarte un terrible secreto. La Gran Calamidad que hirió a nuestra secta no fue un accidente. Fue obra de nuestro más grande patriarca, corrompido por un poder prohibido. Lo sellamos, pero ese sello... se está rompiendo.'</em><br><br><strong>Has aprendido sobre el Soberano Sellado.</strong>");
        }, 2500);
    }
    if (misionId === "mision_desafio_anciano_1") {
        const santuario = gameState.map.entities.find(e => e.type === 'story_shrine' || e.originalEntityTypeId === 'santuario_del_eco');
        if (santuario && !santuario.discovered) {
            santuario.discovered = true;
            renderMap(); // Actualiza el mapa para mostrar el santuario
            setTimeout(() => {
                showModal("Un Susurro en el Viento",
                "Al derrotar al Anciano Guardián, sientes una extraña llamada desde el Valle del Dragón Caído. Un lugar de poder oculto te está esperando. El Maestro Jian asiente, como si supiera que este momento llegaría.");
            }, 2500);
        }
    }

    checkAndActivateRankChallengeMissions(); // Comprobar si se desbloquea un nuevo desafío.
    updateInventoryUI();
    updateSectUI();
    updateUI();
    return true; // Devolvemos 'true' para indicar que la misión se completó con éxito.
}

      function openRankUpRewardModal(newRankName) {
        const modal = document.getElementById("rankUpRewardModal");
        const titleEl = document.getElementById("rankUpRewardTitle");
        const optionsContainer = document.getElementById(
          "rankUpRewardOptionsContainer"
        );

        if (!modal || !titleEl || !optionsContainer) {
          console.error(
            "Elementos del modal de recompensa de rango no encontrados."
          );
          return;
        }

        const rankData = SECTA_DATA.rangos.find(
          (r) => r.nombre === newRankName
        );
        if (
          !rankData ||
          !rankData.techniqueChoice ||
          rankData.techniqueChoice.length === 0
        ) {
          console.log(
            `No hay recompensas de técnica para el rango ${newRankName}.`
          );
          return;
        }

        titleEl.textContent = `Recompensa por ascender a ${newRankName}`;
        optionsContainer.innerHTML = ""; // Limpiar opciones anteriores

        rankData.techniqueChoice.forEach((techId) => {
          const techInfo = techniqueData[techId];
          if (techInfo) {
            const button = document.createElement("button");
            button.className = "cultivation-option-btn";
            button.innerHTML = `
                      <strong>${techInfo.icon || "📜"} ${techInfo.name}</strong>
                      <br>
                      <small style="opacity: 0.8;">${
                        techInfo.description
                      }</small>
                  `;
            button.onclick = () => claimRankUpReward(techId);
            optionsContainer.appendChild(button);
          }
        });

        modal.style.display = "flex";
        hideTouchControls();
      }

      function claimRankUpReward(techId) {
        // Buscamos el nombre del "Rollo" que enseña esta técnica
        let scrollItemName = null;
        const techDefinition = techniqueData[techId];

        // Este bucle asume que el nombre de la técnica en la definición y en el nombre del rollo coinciden.
        // Ej: techniqueData.sword_slash_1.name es "Corte de Espada Básico"
        // y el item se llama "Rollo: Corte de Espada Básico"
        if (techDefinition) {
          const expectedScrollName = `Rollo: ${techDefinition.name}`;
          if (itemData[expectedScrollName]) {
            scrollItemName = expectedScrollName;
          }
        }

        if (scrollItemName) {
          gameState.inventory[scrollItemName] =
            (gameState.inventory[scrollItemName] || 0) + 1;
          updateInventoryUI();
          closeRankUpRewardModal();
          showModal(
            "¡Recompensa Obtenida!",
            `Has recibido el "${scrollItemName}".\nRevisa tu inventario para aprender la técnica.`
          );
        } else {
          console.error(
            `No se pudo encontrar el objeto 'Rollo' para la técnica con ID: ${techId}`
          );
          showModal(
            "Error de Recompensa",
            "No se pudo otorgar la recompensa. Contacta a un Anciano de la Secta (o al desarrollador)."
          );
        }
      }

      function closeRankUpRewardModal() {
        const modal = document.getElementById("rankUpRewardModal");
        if (modal) modal.style.display = "none";
        showTouchControls();
      }

      function updateSectUI() {
        const player = gameState.player;
        document.getElementById("sectaNombreDisplay").textContent = player.secta.nombre;
        document.getElementById("playerSectRank").textContent = player.secta.rango;
        document.getElementById("playerPCS").textContent = player.secta.puntosContribucion;

        const missionsListDiv = document.getElementById("activeMissionsList");
        missionsListDiv.innerHTML = "";

        if (player.secta.misionesActivas.length === 0) {
            missionsListDiv.innerHTML = "<p>Ninguna misión activa.</p>";
        } else {
            player.secta.misionesActivas.forEach((misionActiva) => {
                const misionDataOriginal = MISIONES_DATA[misionActiva.id];
                if (misionDataOriginal) {
                    // ¡Llamamos a nuestra nueva función centralizada también aquí!
                    const progresoTexto = getMissionProgressText(misionActiva);

                    const p = document.createElement("p");
                    p.innerHTML = `<strong>${misionDataOriginal.titulo}</strong><br><small style="font-style: italic;">${progresoTexto}</small>`;
                    missionsListDiv.appendChild(p);
                }
            });
        }
        updateStatsPanelVisibility();
    }

      function checkAndActivateRankChallengeMissions() {
        const player = gameState.player;
        const currentRankIndex = SECTA_DATA.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );

        if (currentRankIndex === -1) {
          console.error(
            "Error: Rango actual del jugador no encontrado en SECTA_DATA.rangos"
          );
          return;
        }

        if (currentRankIndex + 1 >= SECTA_DATA.rangos.length) {
          return;
        }

        const nextRankData = SECTA_DATA.rangos[currentRankIndex + 1];

        if (player.secta.puntosContribucion >= nextRankData.pcsRequeridos) {
          if (nextRankData.desafioRivalId) {
            // --- LÓGICA MEJORADA PARA ENCONTRAR LA MISIÓN ---
            const desafioMisionId = Object.keys(MISIONES_DATA).find((mId) => {
              const mision = MISIONES_DATA[mId];
              return (
                mision.autoActivarAlCumplirRequisitos === true &&
                mision.recompensa?.nuevoRango === nextRankData.nombre &&
                mision.objetivo?.npcId === nextRankData.desafioRivalId
              );
            });
            // --- FIN DE LA LÓGICA MEJORADA ---

            if (desafioMisionId) {
              const isMissionActive = player.secta.misionesActivas.some(
                (m) => m.id === desafioMisionId
              );
              const isMissionCompleted =
                player.secta.misionesCompletadas[desafioMisionId];

              if (!isMissionActive && !isMissionCompleted) {
                acceptMission(desafioMisionId);
                const misionData = MISIONES_DATA[desafioMisionId];
                showModal(
                  "¡Nuevo Desafío de Rango!",
                  `Has alcanzado los requisitos de PCS para el rango de ${nextRankData.nombre}.\n` +
                    `Se ha activado la misión de desafío: "${misionData.titulo}".\n` +
                    `¡Prepárate y busca a tu oponente en la arena de la secta!`
                );

                // La función ensureFixedEntities se encargará de hacer aparecer al guardián
                // porque la misión está ahora activa.
                ensureFixedEntities();
                renderMap();
              }
            } else {
              console.warn(
                `No se encontró una misión de desafío auto-activable para el rival ${nextRankData.desafioRivalId} del rango ${nextRankData.nombre}.`
              );
            }
          }
        }
        updateSectUI();
      }

      function applyRankBenefits(newRankName) {
        const rankData = SECTA_DATA.rangos.find(
          (r) => r.nombre === newRankName
        );
        if (rankData) {
          showModal(
            "Beneficios de Rango",
            `Has obtenido beneficios de ${newRankName}: ${rankData.beneficios}`
          );
        }
        updateUI();
      }

      function enemyTurn() {
        if (!gameState.battle.active || gameState.battle.playerTurn) return;

        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const playerSprite = document.querySelector('.character-sprite');
        const enemySprite = document.getElementById('enemySprite');

        // --- PROCESAR EFECTOS DE ESTADO EN EL ENEMIGO AL INICIO DE SU TURNO ---
        let canEnemyAct = true;
        let reasonForInaction = "";
        let chosenAbility = null;
        const enemyBaseDamage = enemy.attack;

        // --- PROCESAMIENTO DE EFECTOS DE ESTADO (DoTs, Stuns, etc.) ---

        // 1. DAÑO POR TURNO de efectos como Grilletes, Veneno, Quemadura
        if (enemy.rootedTurns > 0) {
            enemy.hp -= enemy.rootDamage;
            logBattle(`${enemy.name} sufre ${enemy.rootDamage} de daño por los grilletes. HP: ${Math.floor(enemy.hp)}`);
            showFloatingText(enemySprite, `-${enemy.rootDamage}`, 'damage');
            if (enemy.hp <= 0) { handleEnemyDefeat(); return; }
        }
        if (enemy.burningTurns > 0) {
            enemy.hp -= enemy.burnDamage;
            logBattle(`${enemy.name} sufre ${enemy.burnDamage} por quemadura. HP: ${Math.floor(enemy.hp)}`);
            showFloatingText(enemySprite, `-${enemy.burnDamage}`, 'damage');
            if (enemy.hp <= 0) { handleEnemyDefeat(); return; }
        }
        if (enemy.poisonedTurns > 0) {
            enemy.hp -= enemy.poisonDamage;
            logBattle(`${enemy.name} sufre ${enemy.poisonDamage} por veneno. HP: ${Math.floor(enemy.hp)}`);
            showFloatingText(enemySprite, `-${enemy.poisonDamage}`, 'damage');
            if (enemy.hp <= 0) { handleEnemyDefeat(); return; }
        }

        // 2. LÓGICA DE CONTROL (Stun, Seal, Freeze) - Impiden la acción completamente
        if (enemy.sealedTurns > 0) {
            canEnemyAct = false;
            reasonForInaction = "¡Sellado!";
            enemy.sealedTurns--;
        } else if (enemy.frozenTurns > 0) {
            canEnemyAct = false;
            reasonForInaction = "¡Congelado!";
            enemy.frozenTurns--;
        } else if (enemy.stunnedTurns > 0) {
            canEnemyAct = false;
            reasonForInaction = "¡Aturdido!";
            enemy.stunnedTurns--;
        }

        if (!canEnemyAct) {
            logBattle(`¡${enemy.name} está ${reasonForInaction.toLowerCase().replace('!','')} y no puede actuar!`);
            showFloatingText(enemySprite, reasonForInaction, 'debuff');
            endEnemyTurn();
            return;
        }

        // 3. LÓGICA DE GRILLETES (ROOTED) - Impide la acción si resisten
        if (enemy.rootedTurns > 0) {
            logBattle(`${enemy.name} intenta liberarse de los grilletes...`);
            player.activeChanneledAbility.hp -= enemyBaseDamage;

            if (player.activeChanneledAbility.hp <= 0) {
                logBattle(`¡Con un golpe poderoso, ${enemy.name} rompe los grilletes!`);
                showFloatingText(enemySprite, '¡Liberado!', 'ability');
                enemy.rootedTurns = 0;
                enemy.rootDamage = 0;
                player.activeChanneledAbility.id = null;
                player.activeChanneledAbility.hp = 0;
                canEnemyAct = false;
            } else {
                logBattle(`Los grilletes resisten el ataque. (Resistencia: ${Math.floor(player.activeChanneledAbility.hp)})`);
                showFloatingText(enemySprite, '¡Atrapado!', 'debuff');
                canEnemyAct = false;
            }

            enemy.rootedTurns--;
            if (enemy.rootedTurns === 0 && player.activeChanneledAbility.id === 'formation_t2') {
                logBattle("Los grilletes de Qi se disipan por el paso del tiempo.");
                player.activeChanneledAbility.id = null;
                player.activeChanneledAbility.hp = 0;
            }
        }
        
        // 2. Reducir duración de debuffs
        if(enemy.defenseReductionTurns > 0) {
            enemy.defenseReductionTurns--;
            if (enemy.defenseReductionTurns === 0) {
                logBattle(`La defensa de ${enemy.name} vuelve a la normalidad.`);
                // La restauración de la estadística se maneja mejor en el momento de la aplicación para evitar errores.
            }
        }
        if(enemy.attackReductionTurns > 0) {
            enemy.attackReductionTurns--;
            if (enemy.attackReductionTurns === 0) {
                logBattle(`El ataque de ${enemy.name} vuelve a la normalidad.`);
            }
        }
        // 4. EJECUCIÓN DE LA ACCIÓN DEL ENEMIGO
        if (canEnemyAct) {
            if (enemy.abilities && enemy.silencedTurns <= 0) {
                for (const abilityInfo of enemy.abilities) {
                    if (Math.random() < abilityInfo.chance) {
                        chosenAbility = enemyAbilityData[abilityInfo.abilityId];
                        if (chosenAbility) break;
                    }
                }
            }

            if (chosenAbility) {
             
                showFloatingText(enemySprite, chosenAbility.name, 'ability');
                const effect = chosenAbility.effect;
                let damage = 0;
                let finalDamage = 0;
                let heal = 0;

                // --- SWITCH COMPLETO PARA HABILIDADES DE ENEMIGO ---
                switch (chosenAbility.type) {
                    case 'buff_stat':
                        if (enemy.defenseBoostTurns === 0) {
                            enemy.defenseBoostAmount = effect.amount;
                            enemy.defense += effect.amount;
                            enemy.defenseBoostTurns = effect.duration;
                            logBattle(chosenAbility.logMessage(enemy.name, effect.amount, effect.duration));
                        } else {
                            logBattle(`${enemy.name} intenta fortalecerse, ¡pero ya lo está!`);
                        }
                        break;

                    case 'debuff_stat_percent':
                        if (effect.debuff && effect.debuff.stat === 'defense') {
                            const reductionAmount = Math.floor(player.defense * effect.debuff.percentage);
                            player.defenseReductionAmount += reductionAmount;
                            player.defense -= reductionAmount;
                            player.defenseReductionTurns = Math.max(player.defenseReductionTurns, effect.debuff.duration);
                            
                            logBattle(chosenAbility.logMessage(enemy.name, effect.debuff.percentage * 100, effect.debuff.duration));
                            showFloatingText(playerSprite, 'Defensa ↓↓↓', 'debuff');
                        }
                        break;
                    case 'percent_hp_damage':
                      damage = Math.floor(player.maxHp * effect.percentage);
                      applyDamageToPlayer(damage, chosenAbility.name);
                      logBattle(chosenAbility.logMessage(enemy.name, damage));
                      break;
                    case 'true_damage':
                      damage = effect.damage;
                      // El daño verdadero se aplica directamente, sin pasar por applyDamageToPlayer para evitar reducciones.
                      player.hp -= damage;
                      logBattle(chosenAbility.logMessage(enemy.name, damage));
                      showFloatingText(playerSprite, `-${damage}`, 'damage');
                      break;
                    case 'dot_damage':
                    case 'heal_damage':
                        damage = Math.floor(enemy.attack * (effect.baseDamageMultiplier || 1.0));
                        finalDamage = applyDamageToPlayer(damage, chosenAbility.name); // Usamos el daño real aplicado

                        if (effect.debuff && player.defenseReductionTurns === 0) {
                            player.defenseReductionAmount = effect.debuff.amount;
                            player.defense -= effect.debuff.amount;
                            player.defenseReductionTurns = effect.debuff.duration;
                            showFloatingText(playerSprite, 'Defensa ↓', 'debuff');
                        }
                        if (effect.dot) {
                            if (effect.dot.type === 'burn') {
                                player.burningTurns = Math.max(player.burningTurns, effect.dot.duration);
                                player.burnDamage = Math.max(player.burnDamage, effect.dot.damagePerTurn);
                                showFloatingText(playerSprite, 'Quemadura', 'debuff');
                            } else if (effect.dot.type === 'poison') {
                                player.poisonedTurns = Math.max(player.poisonedTurns, effect.dot.duration);
                                player.poisonDamage = Math.max(player.poisonDamage, effect.dot.damagePerTurn);
                                showFloatingText(playerSprite, 'Envenenado', 'debuff');
                            }
                        }
                        if (effect.lifesteal) {
                            heal = Math.floor(finalDamage * effect.lifesteal);
                            enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                            showFloatingText(enemySprite, `+${heal}`, 'heal');
                        }
                        logBattle(chosenAbility.logMessage(enemy.name, finalDamage, heal || effect.debuff?.amount || effect.dot?.damagePerTurn, effect.debuff?.duration || effect.dot?.duration));
                        break;

                    case 'piercing_damage':
                        const defenseToIgnore = player.defense * (effect.armorPenetration || 0);
                        damage = Math.max(0, Math.floor(enemy.attack * (effect.baseDamageMultiplier || 1.0)) - (player.defense - defenseToIgnore));
                        applyDamageToPlayer(damage, chosenAbility.name);
                        logBattle(chosenAbility.logMessage(enemy.name, damage));
                        break;

                    case 'stun_chance':
                        damage = Math.floor(enemy.attack * (effect.baseDamageMultiplier || 1.0));
                        finalDamage = applyDamageToPlayer(damage, chosenAbility.name);

                        
                        const didStun = Math.random() < (effect.stunChance || 0);
                        let stunSuccessful = false; // Bandera para el log

                        // Comprobamos si el aturdimiento tiene éxito Y el jugador no es inmune
                        if (didStun) {
                            if (player.statusResistChance > 0 && Math.random() < player.statusResistChance) {
                                logBattle(`¡${enemy.name} intenta aturdirte, pero tu Constitución de Dragón te protege!`);
                                showFloatingText(playerSprite, '¡Resistido!', 'ability');
                            } else if (player.stunnedTurns === 0) {
                                player.stunnedTurns = 1;
                                showFloatingText(playerSprite, '¡Aturdido!', 'debuff');
                                stunSuccessful = true;
                            }
                        }
                        
                        // --- CORRECCIÓN: Llamamos al log DESPUÉS de saber el resultado ---
                        logBattle(chosenAbility.logMessage(enemy.name, finalDamage, stunSuccessful));
                        break;

                    case 'dot_resource':
                      // === INICIO DE LA LÓGICA DE RESISTENCIA ===
                        if (player.statusResistChance > 0 && Math.random() < player.statusResistChance) {
                            logBattle(`¡Tu Constitución de Dragón te permite resistir el efecto de ${chosenAbility.name}!`);
                            showFloatingText(playerSprite, '¡Resistido!', 'ability');
                            
                            if (effect.baseDamageMultiplier) {
                                const damage = Math.floor(enemy.attack * effect.baseDamageMultiplier);
                                applyDamageToPlayer(damage, chosenAbility.name);
                            }
                            break; // El efecto se resiste, pero el daño (si lo hay) se aplica.
                        }
                        // === FIN DE LA LÓGICA DE RESISTENCIA ===
                        if (effect.dot.resource === 'mana' && player.manaDrainTurns === 0) {
                            player.manaDrainTurns = effect.dot.duration;
                            player.manaDrainAmount = effect.dot.drainPerTurn;
                            showFloatingText(playerSprite, 'Maldición de Maná', 'debuff');
                            logBattle(chosenAbility.logMessage(enemy.name, player.manaDrainAmount, player.manaDrainTurns));
                        } else {
                            logBattle(`${enemy.name} intenta maldecirte, ¡pero ya estás bajo un efecto similar!`);
                        }
                        break;

                    case 'heal':
                        heal = effect.healAmount;
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                        showFloatingText(enemySprite, `+${heal}`, 'heal');
                        logBattle(chosenAbility.logMessage(enemy.name, heal));
                        break;
                    
                    // Añade aquí más 'case' si defines nuevas habilidades de enemigo
                    
                    default:
                        logBattle(`(${chosenAbility.name}) ¡La habilidad del enemigo no tuvo efecto!`);
                        break;
                }
            } else {
               
                // Ataque básico si no se usa habilidad
                const damage = Math.max(0, enemy.attack - player.defense);
                applyDamageToPlayer(damage, `${enemy.name}`);
            }
        }

        endEnemyTurn();
    }

  
      function endEnemyTurn() {
          const player = gameState.player;
          
          // --- LÓGICA DE MANTENIMIENTO (UPKEEP) ---
          // Se ejecuta al final del turno del enemigo, antes de devolver el control al jugador.
          if (player.activeChanneledAbility.id === 'formation_t2') {
              const upkeepCost = techniqueData['formation_t2'].effect.manaUpkeep;
              if (player.mana >= upkeepCost) {
                  player.mana -= upkeepCost;
                  logBattle(`Mantener los Grilletes de Qi consume ${upkeepCost} maná.`);
              } else {
                  logBattle(`¡Maná insuficiente para mantener los grilletes! Se disipan.`);
                  gameState.battle.enemy.rootedTurns = 0;
                  gameState.battle.enemy.rootDamage = 0;
                  player.activeChanneledAbility.id = null;
                  player.activeChanneledAbility.hp = 0;
              }
          }
          
          // --- LÓGICA DE DERROTA ---
          // Comprobamos si el jugador fue derrotado por el ataque del enemigo.
          if (player.hp <= 0) {
            player.hp = 0;
            updateBattleUI(); // Actualiza la UI para mostrar HP 0

            // Lógica de derrota centralizada
            setTimeout(() => {
              const expLoss = Math.floor(gameState.player.exp * 0.1);
              gameState.player.hp = Math.floor(gameState.player.maxHp * 0.1);
              gameState.player.mana = Math.floor(gameState.player.maxMana * 0.1);
              gameState.player.exp = Math.max(0, gameState.player.exp - expLoss);

              const safeCoords = findSafeRespawnLocation(G_SAFE_RESPAWN_X, G_SAFE_RESPAWN_Y);
              gameState.player.x = safeCoords.x;
              gameState.player.y = safeCoords.y;

              updatePlayerPosition("player_defeat_respawn");
              endBattle(false);
              showModal("Derrota", `Caíste en combate. Pierdes ${expLoss} EXP.`);
            }, 2000);
            return; // Detener la función aquí.
          }
          
          // Devolvemos el control al jugador
          gameState.battle.playerTurn = true;
          
          updateBattleUI();
          populateBattleActionButtons();
      }

    function applyDamageToPlayer(damageAmount, sourceName = "Ataque") {
      const player = gameState.player;
      const playerSprite = document.querySelector('.character-sprite');
      let incomingDamage = damageAmount; 
      
    // 1. INMUNIDAD TOTAL (por Santuario Dorado, etc.)
    if (player.intangibleTurns > 0) {
        
        logBattle(`¡Tu Santuario Dorado anula completamente el ataque de ${sourceName}!`);
        showFloatingText(playerSprite, '¡Inmune!', 'ability');
        return 0; // No se recibe daño
    }
      // 2. CONVERSIÓN DE DAÑO A CURACIÓN (por Matriz de Reversión)
      if (player.damageToHealingTurns > 0) {
            const healingAmount = Math.floor(incomingDamage * 1.2); // Convierte a 120% de curación
            player.hp = Math.min(player.maxHp, player.hp + healingAmount);
            logBattle(`¡La Matriz de Reversión convierte ${Math.floor(incomingDamage)} de daño en ${healingAmount} de curación!`);
            showFloatingText(playerSprite, `+${healingAmount}`, 'heal');
            return 0; // No se recibe daño, al contrario
        }
      // 3. LÓGICA DE ESQUIVAR ---
      // Ahora 'incomingDamage' ya está definido y se puede usar en la condición.
      if (player.dodgeNextAttack && incomingDamage > 0) {
          
          const etereoDetails = techniqueData["movement_t2"];
          const etereoLevel = player.learnedTechniques["movement_t2"]?.level || 1;
          // La mejora de "no consumir" (Opción 2) la implementaremos aquí
          const noConsumeChance = (etereoDetails.effect.noConsumeChancePerLevel || 0) * (etereoLevel - 1);

          logBattle(`¡Esquivas por completo el ataque de ${sourceName}!`);
          showFloatingText(playerSprite, '¡Esquivado!', 'ability');

          // Comprobamos si el efecto se mantiene
          if (Math.random() > noConsumeChance) {
              player.dodgeNextAttack = false; // Se consume normalmente
          } else {
              logBattle("¡Tu movimiento fue tan fluido que sigues listo para esquivar!");
              showFloatingText(playerSprite, '¡Aún Etéreo!', 'ability');
          }

          return 0; // Anulamos todo el daño y terminamos la función.
      }
      
      // --- LÓGICA DE ABSORCIÓN DE DAÑO POR ESCUDO ---
      if (incomingDamage > 0 && player.magicShieldValue > 0 && player.magicShieldTurns > 0) {
          
          const absorbedByShield = Math.min(incomingDamage, player.magicShieldValue);
          player.magicShieldValue -= absorbedByShield;
          incomingDamage -= absorbedByShield;

          logBattle(`¡Tu escudo absorbe ${absorbedByShield} de daño! (Restante: ${Math.floor(player.magicShieldValue)})`);
          showFloatingText(playerSprite, `Absorbe ${absorbedByShield}`, 'ability');

          if (player.magicShieldValue <= 0) {
              logBattle("¡Tu barrera mágica se ha roto!");
              player.magicShieldTurns = 0;
          }
      }

      // --- APLICAR DAÑO RESTANTE ---
      if (incomingDamage > 0) {
          const reductionMultiplier = 1 - (player.damageReduction || 0);
          incomingDamage *= reductionMultiplier;
          player.hp -= incomingDamage;
          logBattle(`Recibes ${Math.floor(incomingDamage)} de daño de ${sourceName}.`);
          showFloatingText(playerSprite, `-${Math.floor(incomingDamage)}`, 'damage');
      } else if (damageAmount > 0) {
          logBattle(`¡Tu defensa absorbió completamente el ataque de ${sourceName}!`);
          showFloatingText(playerSprite, '¡Bloqueado!', 'ability');
      }

      return incomingDamage;
  }
      
      function showBattleReview() {
        const reviewLog = document.getElementById("battleReviewLog");
        reviewLog.innerHTML = ""; // Limpiar contenido anterior

        // Unimos todos los mensajes del historial con un salto de línea
        const formattedLog = battleLogHistory.join("<br>");
        reviewLog.innerHTML = formattedLog;

        document.getElementById("battleReviewModal").style.display = "flex";
      }

      function closeBattleReviewModal() {
        document.getElementById("battleReviewModal").style.display = "none";
      }

      function endBattle(victory) {
       // --- MODIFICACIÓN PARA RESETEAR ESTADOS DE COMBATE ---
       const player = gameState.player;
        
        // Resetea todos los buffs/debuffs temporales del jugador al final del combate
        player.abilityCooldowns = {};
        player.defenseBoostTurns = 0;
        player.defenseBoostAmount = 0;
        player.dodgeNextAttack = false;
        player.healingRainTurns = 0;
        player.magicShieldValue = 0;
        player.magicShieldTurns = 0;
        player.canRevive = false; // El poder del Fénix se desvanece fuera del combate
        player.intangibleTurns = 0;
        player.damageToHealingTurns = 0;
        player.hpRegenPerTurn = 0;
        player.manaRegenPerTurn = 0;
        

        gameState.battle.active = false;
        document.getElementById("battleScreen").style.display = "none";
        document.getElementById("battleLog").innerHTML = "";
        document.getElementById('quickSlotBar').classList.remove('hidden');
        // Ocultar las barras sobre el sprite en batalla explícitamente al finalizar
        const barsInBattleContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        if (barsInBattleContainer) {
          barsInBattleContainer.style.display = "none";
        }
        if (victory && gameState.battle.enemy?.entityRef) {
          removeEntity(gameState.battle.enemy.entityRef);
        }
        gameState.battle.enemy = null;

        // Restaurar sprite a idle después de la batalla
        player.currentDirection = "down"; // O la última dirección antes de la batalla
        player.currentFrame = 0;
        player.isMoving = false; // Asegurarse de que no esté en estado de movimiento
        updatePlayerSpriteVisual();

        recalculatePlayerStats();
        updateUI();
        updateTopNavVisibility();
        showTouchControls();
        updatePlayerBarsOnMap();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function sanitizeMapEntities(mapState) {
          if (!mapState || !mapState.entities || mapState.entities.length === 0) {
              console.warn("[Sanitize Entities] No se encontraron entidades para revisar.");
              return;
          }

          console.log("[Sanitize Entities] Iniciando RECONSTRUCCIÓN y saneamiento de entidades del mapa...");
          
          const sanitizedEntities = [];

          mapState.entities.forEach(savedEntity => {
              // Obtenemos el ID de la definición maestra. originalEntityTypeId es la fuente de verdad.
              const masterId = savedEntity.originalEntityTypeId || savedEntity.type;
              const masterDefinition = entityTypes[masterId];

              // Si la entidad ya no existe en el juego (fue eliminada), no la incluimos en el nuevo array.
              if (!masterDefinition) {
                  console.warn(`[Sanitize Entities] Entidad obsoleta con ID maestro '${masterId}' eliminada del guardado.`);
                  return; // 'return' aquí funciona como un 'continue' en un forEach.
              }

              // --- INICIO DE LA LÓGICA DE RECONSTRUCCIÓN ---

              // 1. Creamos una nueva entidad desde cero usando la definición maestra actual.
              //    Esto garantiza que tenga todas las propiedades nuevas y correctas (como 'type', 'npcId', etc.)
              const newSanitizedEntity = JSON.parse(JSON.stringify(masterDefinition));

              // 2. Transferimos las propiedades de ESTADO que deben persistir desde la entidad guardada.
              //    Estas son las propiedades que son únicas para cada instancia en el mapa.
              newSanitizedEntity.id = savedEntity.id; // El ID único de la instancia siempre se conserva.
              newSanitizedEntity.x = savedEntity.x;
              newSanitizedEntity.y = savedEntity.y;
              newSanitizedEntity.originalEntityTypeId = masterId; // Nos aseguramos de que esta clave persista.

              // Si la entidad tiene vida, conservamos su HP actual, pero no si es mayor que el nuevo máximo.
              if (typeof savedEntity.hp === 'number' && typeof newSanitizedEntity.maxHp === 'number') {
                  newSanitizedEntity.hp = Math.min(savedEntity.hp, newSanitizedEntity.maxHp);
              }

              // Propiedades como 'discovered' también deben persistir.
              if (typeof savedEntity.discovered === 'boolean') {
                  newSanitizedEntity.discovered = savedEntity.discovered;
              }

              // Si en el futuro añades más propiedades de estado (ej: 'isHostile_temp'), las añadirías aquí.

              // 3. Añadimos la entidad completamente reconstruida y saneada a nuestro nuevo array.
              sanitizedEntities.push(newSanitizedEntity);

              // --- FIN DE LA LÓGICA DE RECONSTRUCCIÓN ---
          });

          // Finalmente, reemplazamos el array de entidades antiguo por el completamente nuevo y saneado.
          mapState.entities = sanitizedEntities;
          
          console.log("[Sanitize Entities] Reconstrucción de entidades completada.");
      }
      function findEscapeTile(player, enemy) {
        const playerX = player.x;
        const playerY = player.y;

        // Calcular la dirección opuesta al enemigo
        const dx = playerX - enemy.x;
        const dy = playerY - enemy.y;

        // Normalizar la dirección para obtener un vector unitario (aproximado)
        let escapeX = playerX + Math.sign(dx);
        let escapeY = playerY + Math.sign(dy);

        const checkTile = (x, y) => {
          if (
            x < 0 ||
            x >= gameState.map.width ||
            y < 0 ||
            y >= gameState.map.height
          )
            return false;
          const terrain = G_TERRAIN_TYPES[getTerrainTypeAt(x, y)];
          if (terrain && terrain.walkable === false) return false;
          const isOccupied = gameState.map.entities.some(
            (e) => e.x === x && e.y === y
          );
          return !isOccupied;
        };

        // 1. Intentar moverse a la casilla directamente opuesta
        if (checkTile(escapeX, escapeY)) {
          return { x: escapeX, y: escapeY };
        }

        // 2. Si no es posible, buscar en las 8 casillas adyacentes una que esté vacía
        const possibleMoves = [
          { x: playerX, y: playerY - 1 },
          { x: playerX, y: playerY + 1 }, // Arriba, Abajo
          { x: playerX - 1, y: playerY },
          { x: playerX + 1, y: playerY }, // Izquierda, Derecha
          { x: playerX - 1, y: playerY - 1 },
          { x: playerX + 1, y: playerY - 1 }, // Diagonales
          { x: playerX - 1, y: playerY + 1 },
          { x: playerX + 1, y: playerY + 1 },
        ];

        for (const move of possibleMoves) {
          if (checkTile(move.x, move.y)) {
            return move;
          }
        }

        return null; // No se encontró ninguna casilla segura para huir
      }

      function findSafeRespawnLocation(preferredX, preferredY) {
        const isHostile = (entity) =>
          G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss;
        let preferredSpotOccupiedByHostile = gameState.map.entities.some(
          (e) => e.x === preferredX && e.y === preferredY && isHostile(e)
        );
        if (!preferredSpotOccupiedByHostile)
          return { x: preferredX, y: preferredY };
        for (let r = 1; r <= G_SAFE_RESPAWN_SEARCH_RADIUS; r++) {
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
              const cx = preferredX + dx;
              const cy = preferredY + dy;
              if (
                cx < 0 ||
                cx >= gameState.map.width ||
                cy < 0 ||
                cy >= gameState.map.height
              )
                continue;
              const isCompletelyEmpty = !gameState.map.entities.some(
                (e) => e.x === cx && e.y === cy
              );
              if (isCompletelyEmpty) return { x: cx, y: cy };
            }
          }
        }
        return { x: preferredX, y: preferredY };
      }

      function logBattle(message) {
        battleLogHistory.push(message);
      }

      function showTechniquePanel() {
    const container = document.getElementById("learnedTechniquesContainer");
    container.innerHTML = "";
    
    const player = gameState.player;
    const learnedTechs = Object.keys(player.learnedTechniques);

    if (learnedTechs.length === 0 && Object.keys(player.discoveredFormationPatterns).length === 0) {
        container.innerHTML = "<p style='text-align: center; opacity: 0.7;'>Aún no has aprendido ninguna técnica ni descifrado ningún patrón rúnico.</p>";
    } else {
        if (learnedTechs.length > 0) {
            container.innerHTML += `<h4>Técnicas de Cultivo y Combate</h4>`;
            const sortedTechIds = learnedTechs.sort();

            sortedTechIds.forEach(techId => {
                const techInfo = techniqueData[techId];
                const playerTech = player.learnedTechniques[techId];
                if (!techInfo) return; 

                const div = document.createElement("div");
                div.className = "inventory-modal-item"; 
                
                let levelText = playerTech.level >= techInfo.maxLevel 
                    ? `<span style="color: #f4d03f;">(MAX)</span>`
                    : `(Nv. ${playerTech.level} / ${techInfo.maxLevel})`;
                
                const detailsText = getTechniqueDetailsAsText(techInfo, playerTech.level);
                
                let cultivationProgressText = '';
                if (techInfo.cultivationSettings && playerTech.level < techInfo.maxLevel) {
                    const progress = playerTech.currentCultivationProgress || 0;
                    const timeToNext = playerTech.cultivationTimeToNextLevel || (techInfo.cultivationSettings.baseTimeToLevelUp || Infinity);
                    cultivationProgressText = `<div style="font-size: 0.8em; opacity: 0.7; margin-top: 5px;">Progreso de Cultivo: ${Math.floor(progress)}s / ${timeToNext}s</div>`;
                }

                div.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${techInfo.icon || "📜"} ${techInfo.name} ${levelText}</div>
                        <div class="item-description">${techInfo.description}</div>
                        ${detailsText}
                        ${cultivationProgressText}
                    </div>
                `;
                container.appendChild(div);
            });
        }

        const discoveredPatterns = Object.keys(player.discoveredFormationPatterns);
          if (discoveredPatterns.length > 0) {
              const title = document.createElement('h4');
              title.className = 'technique-section-title'; // Un estilo para separar secciones
              title.textContent = 'Diagramas de Formaciones Rúnicas';
              container.appendChild(title);

              discoveredPatterns.forEach(patternId => {
                  const patternInfo = FORMATION_PATTERNS[patternId];
                  if (!patternInfo) return;

                  const patternDiv = document.createElement("div");
                  patternDiv.className = "inventory-modal-item"; // Reutilizamos el estilo

                  // Creamos un ID único para cada rejilla del diagrama
                  const patternGridId = `diagram-grid-${patternId}`;
                  patternDiv.innerHTML = `
                      <div class="item-details">
                          <div class="item-name">📖 ${patternInfo.name}</div>
                          <div class="item-description">${patternInfo.description}</div>
                          <div class="formation-diagram-grid" id="${patternGridId}"></div>
                      </div>
                  `;
                  container.appendChild(patternDiv);
                  
                  // Ahora generamos la mini-cuadrícula visual del patrón
                  const diagramGridEl = document.getElementById(patternGridId);
                  if (diagramGridEl) {
                      const patternMatrix = patternInfo.pattern;
                      const gridSize = patternMatrix.length;
                      // Ajustamos el CSS Grid para que coincida con el tamaño del patrón
                      diagramGridEl.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                      diagramGridEl.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;

                      for (let r = 0; r < patternMatrix.length; r++) {
                          for (let c = 0; c < patternMatrix[r].length; c++) {
                              const cellValue = patternMatrix[r][c];
                              const cellDiv = document.createElement('div');
                              cellDiv.className = 'grid-cell';
                              if (cellValue === 1) { // 1 = Runa
                                  cellDiv.classList.add('rune');
                                  cellDiv.textContent = '●';
                              } else if (cellValue === 2) { // 2 = Enemigo
                                  cellDiv.classList.add('enemy');
                                  cellDiv.textContent = 'X';
                              }
                              diagramGridEl.appendChild(cellDiv);
                          }
                      }
                  }
              });
        }
    }
    
    document.getElementById("techniqueModal").style.display = "flex";
    hideTouchControls();
}

      function getTechniqueDetailsAsText(techInfo, currentLevel) {
        if (!techInfo) return "";

        const effect = techInfo.effect || {};
        let details = [];
        const isMaxLevel = currentLevel >= techInfo.maxLevel;
        const nextLevel = currentLevel + 1;

        // Función de ayuda interna para calcular valores y generar texto
        const createDetailLine = (label, baseValue, increasePerLevel, unit = '', decimals = 2, isPercentage = false) => {
            if (baseValue === undefined) return null;

            const scaleFactor = isPercentage ? 100 : 1;
            const currentVal = baseValue + ((currentLevel - 1) * (increasePerLevel || 0));
            const nextVal = baseValue + ((nextLevel - 1) * (increasePerLevel || 0));
            
            let text = `${label}: ${(currentVal * scaleFactor).toFixed(decimals)}${unit}`;
            
            if (!isMaxLevel && nextVal.toFixed(decimals + 2) !== currentVal.toFixed(decimals + 2)) {
                text += ` <span style="color:#66ff66;">(Próx: ${(nextVal * scaleFactor).toFixed(decimals)}${unit})</span>`;
            }
            return text;
        };
        
        // --- LÓGICA DE DETALLES REFACTORIZADA ---

        // 1. Daño
        let damageLine = createDetailLine("Daño", effect.baseDamageMultiplier, effect.multiplierIncreasePerLevel, 'x Ataque', 2);
        if (damageLine) details.push(damageLine);
        
        // 2. Daño por Turno (DoT)
        let dotLine = createDetailLine("Daño/Turno", effect.damagePerTurn || effect.burnDamagePerTurn || effect.bleedDamagePerTurn, 2, '', 0); // Asumiendo un escalado fijo de +2 por nivel
        if (dotLine) details.push(dotLine);

        // 3. Probabilidad de Efecto
        let chanceLine = createDetailLine("Prob. Efecto", effect.baseStunChance || effect.bleedChance || effect.stunChance, effect.stunChanceIncreasePerLevel || 0.03, '%', 0, true);
        if (chanceLine) details.push(chanceLine);

        // 4. Reducción de Stats
        let reductionLine = createDetailLine("Reducción Stats", effect.baseReduction, effect.reductionIncreasePerLevel, '', 0);
        if (reductionLine) details.push(reductionLine);

        // 5. Duración
        if (effect.duration || effect.baseDuration) {
            const currentDuration = effect.duration || effect.baseDuration;
            let text = `Duración: ${currentDuration} turnos`;
            if (!isMaxLevel && effect.levelForExtraTurn && nextLevel >= effect.levelForExtraTurn && currentLevel < effect.levelForExtraTurn) {
                text += ` <span style="color:#66ff66;">(Próx: ${currentDuration + 1} turnos)</span>`;
            }
            details.push(text);
        }

        // 6. Golpes Múltiples
        if (effect.baseHits) {
            const currentHits = Math.round(effect.baseHits + (currentLevel - 1) * (effect.hitsIncreasePerLevel || 0));
            const nextHits = Math.round(effect.baseHits + (nextLevel - 1) * (effect.hitsIncreasePerLevel || 0));
            let text = `Golpes: ${currentHits}`;
            if (!isMaxLevel && nextHits > currentHits) text += ` <span style="color:#66ff66;">(Próx: ${nextHits})</span>`;
            details.push(text);
        }
        
        // 7. Habilidades Pasivas que mejoran STATS BASE (ej. Piel de Acero)
        if (techInfo.type === 'passive_stat' && effect.statToBoost) {
            // Las pasivas se aplican una vez por cada nivel que se sube, no tienen un "próximo nivel" visible.
            // Mostramos el beneficio total que se obtiene por cada nivel de la técnica.
            details.push(`Efecto Pasivo: +${effect.value} a ${effect.statToBoost.replace('base','').replace('Max',' Máximo ')} por nivel.`);
        }

        // 8. Habilidades Pasivas de CULTIVO (ej. Absorción de Qi)
        if (techInfo.type === 'passive_cultivation' && effect.statToBoost) {
            details.push(`Efecto de Cultivo: +${effect.value} a ${effect.statToBoost.replace('Base','/s')} por nivel.`);
        }

        // 9. Efectos Únicos y Fijos
        if (effect.isCritical) details.push("Especial: Siempre es un Golpe Crítico.");
        if (effect.ignoreDefense) details.push("Especial: Ignora la defensa del enemigo.");
        if (effect.dodgeNextAttack) details.push("Especial: Esquiva el próximo ataque.");
        
        // Construir el string final
        if (details.length > 0) {
            return `<div style="margin-top: 8px; padding-left: 10px; border-left: 2px solid #555; font-size: 0.85em; line-height: 1.6;">
                        ${details.join('<br>')}
                    </div>`;
        }

        return "";
    }

      function startTechniqueRefinement(techId) {}

      function stopTechniqueRefinement() {}

      function applyTechniqueEffect(techId, newLevel) {
          // La lógica de aplicar efectos específicos se ha movido a `recalculatePlayerStats`.
          // Esta función ahora solo necesita asegurarse de que, después de que una técnica
          // suba de nivel, todas las estadísticas del jugador se actualicen correctamente
          // para reflejar el cambio.
          
          recalculatePlayerStats(); // Esto recalculará todo basado en los niveles actuales.
          updateUI(); // Actualiza la interfaz para mostrar los cambios.
        }

      function closeTechniqueModal() {
          document.getElementById("techniqueModal").style.display = "none";
          updatePlayerBarsOnMap();
          showTouchControls();
          updateStatsPanelVisibility();
        }

      let currentShopPage = 1;
      const shopItemsPerPage = 6;

      function openShop() {
        document.getElementById(
          "playerSpiritualStones"
        ).textContent = `Piedras Espirituales: ${
          gameState.inventory["Piedras Espirituales"] || 0
        }`;
        document.getElementById("shopModal").style.display = "flex";
        renderShopProducts();
        hideTouchControls();
      }

      function renderShopProducts() {
        const shopProductsEl = document.getElementById("shopProducts");
        shopProductsEl.innerHTML = "";
        const activeCategory =
          document.querySelector("#shopCategories .active")?.dataset.category ||
          "all";
        const searchTerm = document
          .getElementById("shopSearch")
          .value.toLowerCase();
        const priceVal = parseInt(document.getElementById("priceRange").value);
        document.getElementById(
          "priceRangeValue"
        ).textContent = `${priceVal} PS`;
        const playerRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === gameState.player.secta.rango);

        let filteredItems = shopData.inventory.filter((item) => {
          const itemNameLower = item.itemName.toLowerCase();
          const itemCategory = item.category || "other";
          const itemTypeForFilter =
            item.type ||
            (itemNameLower.includes("rollo:") ? "scroll" : "other");

          if (
            searchTerm &&
            !itemNameLower.includes(searchTerm) &&
            !(
              item.description &&
              item.description.toLowerCase().includes(searchTerm)
            )
          )
            return false;
          if (item.price > priceVal) return false;
          if (itemNameLower.startsWith("rollo: ")) {
              const techName = item.itemName.substring(7);
              const techId = Object.keys(techniqueData).find(id => techniqueData[id].name === techName);
              
              if (techId && techniqueData[techId].requiredRank) {
                  const requiredRankIndex = SECTA_DATA.rangos.findIndex(r => r.nombre === techniqueData[techId].requiredRank);
                  
                  // El jugador debe tener un rango igual o superior al requerido.
                  if (playerRankIndex < requiredRankIndex) {
                      return false; // No mostrar si el rango es insuficiente.
                  }
              }
          }

          if (activeCategory !== "all") {
            if (activeCategory === "combat" && !techIsCombat(item.itemName))
              return false;
            if (
              activeCategory === "cultivation" &&
              !techIsCultivation(item.itemName)
            )
              return false;
            if (
              activeCategory === "scroll" &&
              !itemNameLower.startsWith("rollo: ")
            )
              return false;
            if (
              activeCategory === "consumable" &&
              itemTypeForFilter !== "consumable" &&
              ![
                "Hierbas Medicinales",
                "Cristales de Qi",
                "Píldora de Recuperación Menor",
              ].includes(item.itemName)
            )
              return false;
            if (activeCategory === "weapon" && itemCategory !== "weapon")
              return false;
            if (activeCategory === "armor" && itemCategory !== "armor")
              return false;
            if (activeCategory === "material" && !isMaterial(item.itemName))
              return false;
          }
          return true;
        });

        const totalPages = Math.ceil(filteredItems.length / shopItemsPerPage);
        const startIndex = (currentShopPage - 1) * shopItemsPerPage;
        const pageItems = filteredItems.slice(
          startIndex,
          startIndex + shopItemsPerPage
        );

        pageItems.forEach((item) => {
          const itemInfo = itemData[item.itemName] || {};
          const productCard = document.createElement("div");
          productCard.className = "product-card";
          let itemIcon = getItemIcon(item.itemName, item.category);
          let itemType = getItemShopType(
            item.itemName,
            item.category,
            item.type
          );

          productCard.innerHTML = `
                  <div class="product-header">
                      <div>
                          <div class="product-name">${itemIcon} ${
            item.itemName
          }</div>
                          <span class="product-type">${itemType}</span>
                      </div>
                      <div class="product-price">${item.price} PS</div>
                  </div>
                  <div class="product-description">${
                    itemInfo.description ||
                    item.description ||
                    "Un objeto misterioso."
                  }</div>
                  ${
                    item.levelRequirement
                      ? `<div><strong>Req:</strong> Nv ${item.levelRequirement}</div>`
                      : ""
                  }
                  ${
                    typeof item.stock === "number"
                      ? `<div><strong>Disp:</strong> ${item.stock}</div>`
                      : ""
                  }
                  <div class="product-actions">
                      <button class="buy-btn" data-item="${
                        item.itemName
                      }" data-price="${item.price}">Comprar</button>
                  </div>`;
          const buyBtn = productCard.querySelector(".buy-btn");
          if (
            (gameState.inventory["Piedras Espirituales"] || 0) < item.price ||
            item.stock === 0
          ) {
            buyBtn.disabled = true;
            buyBtn.title =
              item.stock === 0 ? "Agotado" : "Piedras insuficientes";
          }
          buyBtn.addEventListener("click", () => buyFromShop(item.itemName));
          shopProductsEl.appendChild(productCard);
        });
        renderShopPagination(totalPages);
      }

      function techIsCombat(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "active_ability" ||
            techniqueData[techId].abilityId)
        );
      }

      function techIsCultivation(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "passive_cultivation" ||
            techniqueData[techId].type === "passive_stat" ||
            techniqueData[techId].type === "active_refinement_effect")
        );
      }

      function isMaterial(itemName) {
        const knownMaterials = [
          "Cristal de Hielo",
          "Esencia de Fuego",
          "Núcleo de Tormenta",
          "Venenos Mortales",
          "Fragmentos de Jade",
          "Esencia Oscura",
          "Almas Condenadas",
          "Núcleo de Vórtice",
          "Rocío Celestial",
          "Cristales Psíquicos",
          "Mineral de Hierro Espiritual",
          "Plumas de Fénix",
          "Semillas Ancestrales",
          "Escamas de Dragón",
          "Espejos Astrales",
          "Relojes de Arena",
          "Sangre de Demonio",
          "Lágrimas de Unicornio",
          "Núcleo Elemental",
          "Polvo de Arcano",
          "Piedras Espirituales",
          "Cristales de Qi",
          "Hierbas Medicinales",
        ];
        return knownMaterials.includes(itemName);
      }

      function getItemIcon(itemName, category) {
        if (itemName.includes("Espada") || category === "weapon") return "⚔️";
        if (itemName.includes("Armadura") || category === "armor") return "🛡️";
        if (itemName.includes("Hierba")) return "🌿";
        if (itemName.includes("Cristal")) return "💎";
        if (itemName.includes("Piedra")) return "💎";
        if (itemName.startsWith("Rollo:")) return "📜";
        return "📦";
      }

      function getItemShopType(itemName, category, type) {
        if (itemName.startsWith("Rollo: ")) return "Técnica";
        if (category === "weapon") return "Arma";
        if (category === "armor") return "Armadura";
        if (
          type === "consumable" ||
          [
            "Hierbas Medicinales",
            "Cristales de Qi",
            "Píldora de Recuperación Menor",
          ].includes(itemName)
        )
          return "Consumible";
        if (isMaterial(itemName)) return "Material";
        return "Objeto";
      }

      function renderShopPagination(totalPages) {
        const pagination = document.getElementById("shopPagination");
        pagination.innerHTML = "";
        if (totalPages <= 1) return;
        const prevBtn = document.createElement("button");
        prevBtn.className = "page-btn";
        prevBtn.textContent = "«";
        prevBtn.addEventListener("click", () => {
          if (currentShopPage > 1) {
            currentShopPage--;
            renderShopProducts();
          }
        });
        pagination.appendChild(prevBtn);
        const startPage = Math.max(1, currentShopPage - 1);
        const endPage = Math.min(totalPages, currentShopPage + 1);
        for (let i = startPage; i <= endPage; i++) {
          const pageBtn = document.createElement("button");
          pageBtn.className = `page-btn ${
            i === currentShopPage ? "active" : ""
          }`;
          pageBtn.textContent = i;
          pageBtn.addEventListener("click", () => {
            currentShopPage = i;
            renderShopProducts();
          });
          pagination.appendChild(pageBtn);
        }
        const nextBtn = document.createElement("button");
        nextBtn.className = "page-btn";
        nextBtn.textContent = "»";
        nextBtn.addEventListener("click", () => {
          if (currentShopPage < totalPages) {
            currentShopPage++;
            renderShopProducts();
          }
        });
        pagination.appendChild(nextBtn);
      }

      function closeShopModal() {
        document.getElementById("shopModal").style.display = "none";
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function buyFromShop(itemName) {
        const itemToBuy = shopData.inventory.find(
          (i) => i.itemName === itemName
        );
        const playerStones = gameState.inventory["Piedras Espirituales"] || 0;
        if (
          !itemToBuy ||
          itemToBuy.stock === 0 ||
          playerStones < itemToBuy.price
        ) {
          showModal(
            "Error Compra",
            "No se puede comprar (fondos insuficientes, agotado o no existe)."
          );
          return;
        }
        gameState.inventory["Piedras Espirituales"] -= itemToBuy.price;
        if (itemToBuy.type === "equipment" && itemToBuy.attackBonus) {
          gameState.player.baseAttack += itemToBuy.attackBonus;
          recalculatePlayerStats();
          showModal(
            "¡Equipo Comprado!",
            `Compraste ${itemName}. Ataque base +${itemToBuy.attackBonus}.`
          );
        } else {
          gameState.inventory[itemName] =
            (gameState.inventory[itemName] || 0) + 1;
          if (
            itemData[itemName] &&
            itemData[itemName].effect &&
            itemName.startsWith("Rollo: ")
          ) {
            showModal(
              "¡Rollo Comprado!",
              `Has comprado ${itemName}. Úsalo desde tu inventario para aprender la técnica.`
            );
          } else {
            showModal("¡Objeto Comprado!", `Has comprado ${itemName}.`);
          }
        }
        if (typeof itemToBuy.stock === "number" && itemToBuy.stock > 0)
          itemToBuy.stock--;
        openShop();
        updateUI();
      }
      
      function openManageTechniquesModal() {
          // Primero cerramos el modal de visualización para evitar que se superpongan.
          closeTechniqueModal();

          const player = gameState.player;
          const equippedList = document.getElementById('equipped-techniques-list');
          const availableList = document.getElementById('available-techniques-list');
          
          equippedList.innerHTML = '';
          availableList.innerHTML = '';

          // --- Rellenar los slots de técnicas equipadas ---
          for (let i = 0; i < 3; i++) {
              const techId = player.equippedTechniques[i];
              const slotDiv = document.createElement('div');
              slotDiv.className = 'inventory-modal-item';
              slotDiv.style.cursor = 'pointer';

              if (techId && techniqueData[techId]) {
                  const techInfo = techniqueData[techId];
                  slotDiv.innerHTML = `
                      <div class="item-details">
                          <div class="item-name">${techInfo.icon || '📜'} ${techInfo.name}</div>
                          <div class="item-description">Slot ${i + 1} - Clic para desequipar</div>
                      </div>
                  `;
                  slotDiv.onclick = () => unequipTechnique(i);
              } else {
                  slotDiv.innerHTML = `
                      <div class="item-details" style="opacity: 0.5;">
                          <div class="item-name">Slot ${i + 1} (Vacío)</div>
                      </div>
                  `;
              }
              equippedList.appendChild(slotDiv);
          }

          // --- Rellenar la lista de técnicas disponibles ---
          for (const techId in player.learnedTechniques) {
              const techInfo = techniqueData[techId];
              const playerTech = player.learnedTechniques[techId];

              if (techInfo && techInfo.type === 'active_ability' && playerTech.level > 0) {
                  if (player.equippedTechniques.includes(techId)) {
                      continue;
                  }

                  const itemDiv = document.createElement('div');
                  itemDiv.className = 'inventory-modal-item assignable-item';
                  itemDiv.innerHTML = `
                      <div class="item-details">
                          <div class="item-name">${techInfo.icon || '📜'} ${techInfo.name} (Nv. ${playerTech.level})</div>
                          <div class="item-description">${techInfo.description}</div>
                      </div>
                  `;
                  itemDiv.onclick = () => equipTechnique(techId);
                  availableList.appendChild(itemDiv);
              }
          }
          
          document.getElementById('manageTechniquesModal').style.display = 'flex';
          hideTouchControls();
      }
      function closeManageTechniquesModal() {
          document.getElementById('manageTechniquesModal').style.display = 'none';
          showTouchControls();
          // Al cerrar, volvemos a mostrar el panel de técnicas para una experiencia fluida.
          showTechniquePanel();
      }

      function equipTechnique(techId) {
          const player = gameState.player;
          const firstEmptySlot = player.equippedTechniques.indexOf(null);

          if (firstEmptySlot !== -1) {
              player.equippedTechniques[firstEmptySlot] = techId;
              openManageTechniquesModal(); // Refrescar el modal
          } else {
              showModal("Slots Llenos", "No tienes más slots de técnicas disponibles. Desequipa una para hacer espacio.");
              setTimeout(() => closeModal(), 2000);
          }
      }

      function unequipTechnique(slotIndex) {
          gameState.player.equippedTechniques[slotIndex] = null;
          openManageTechniquesModal(); // Refrescar el modal
      }  
    //REVER ESTO! 
      function sellToShop(itemName, quantityToSell, totalStonesEarned) {}

      function saveGame() {
        try {
          const gameStateToSave = JSON.parse(JSON.stringify(gameState));
          const gameDataJson = JSON.stringify(gameStateToSave, null, 2);
          const blob = new Blob([gameDataJson], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "camino_del_cultivador_save.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showModal("Partida Guardada", "Progreso guardado como archivo JSON.");
        } catch (error) {
          showModal("Error al Guardar", `Hubo un problema: ${error.message}`);
        }
      }

      function triggerFileUpload() {
        document.getElementById("fileInput").click();
      }

      // --- CARGA DE PARTIDA ---

      // Reemplaza tu función 'loadGameFromFile(event)' existente con esta versión mejorada.

      function loadGameFromFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                if (gameState.player.isCultivating) stopCultivation();
                if (gameState.battle.active) endBattle(false);

                const loadedGameState = JSON.parse(e.target.result);

                if (!loadedGameState.player || !loadedGameState.map || !loadedGameState.inventory) {
                    throw new Error("Formato de guardado incorrecto o datos esenciales faltantes.");
                }

                // La lógica de saneamiento es correcta y la mantenemos.
                const sanitizedGameState = sanitizeSaveFile(loadedGameState);

                // --- INICIO DE LA MODIFICACIÓN CLAVE: COPIA PROFUNDA ---
                // En lugar de asignar la referencia, creamos una copia profunda y aislada
                // de los datos saneados para el estado actual del juego.
                
                gameState.player = JSON.parse(JSON.stringify(sanitizedGameState.player));
                gameState.inventory = JSON.parse(JSON.stringify(sanitizedGameState.inventory));
                gameState.map = JSON.parse(JSON.stringify(sanitizedGameState.map));
                
                // Otras propiedades del nivel raíz de gameState si las hubiera
                gameState.gameTime = sanitizedGameState.gameTime || 0;
                // ...etc.

                // --- FIN DE LA MODIFICACIÓN ---

                // Resetear estados transitorios que no deben persistir
                gameState.player.isCultivating = false;
                if (gameState.cultivationInterval) {
                    clearInterval(gameState.cultivationInterval);
                    gameState.cultivationInterval = null;
                }
                
                // Reconstruir el juego con los datos correctos y aislados.
                recalculatePlayerStats(); 
                renderQuickSlotBar();
                updatePlayerPosition("loadGameFromFile_end");

                showModal("Partida Cargada", "¡Partida restaurada con éxito!");

            } catch (error) {
                showModal("Error al Cargar", `Hubo un problema: ${error.message}`);
                console.error("Error loading game:", error);
            } finally {
                event.target.value = null; 
            }
        };
        reader.onerror = () => {
            showModal("Error de Lectura", "No se pudo leer el archivo de guardado.");
            event.target.value = null;
        };
        reader.readAsText(file);
      }

      // =======================================================================
      //                    SISTEMA DE SANEAMIENTO DE PARTIDAS
      // =======================================================================

      /**
       * Función principal que orquesta el saneamiento de un archivo de guardado.
       * @param {object} loadedState - El objeto gameState cargado del archivo JSON.
       * @returns {object} El objeto gameState saneado y listo para usar.
       */
       function sanitizeSaveFile(loadedState) {
          console.group("[Sanitize] Iniciando saneamiento de partida guardada...");

          if (!loadedState.player) {
              console.error("[Sanitize] FATAL: El archivo de guardado no tiene una propiedad 'player'. Abortando.");
              console.groupEnd();
              throw new Error("Archivo de guardado corrupto: falta el jugador.");
          }
          
          // 1. Sanear el objeto del jugador (añadir propiedades faltantes)
          loadedState.player = sanitizePlayerState(loadedState.player);

          // 2. Sanear las técnicas aprendidas por el jugador
          loadedState.player = sanitizeLearnedTechniques(loadedState.player);

          // 3. Sanear las misiones activas (reutilizamos la función existente)
          sanitizeActiveMissions(loadedState.player);

          // 4. Sanear las entidades del mapa (reutilizamos la función existente)
          if(loadedState.map) {
            sanitizeMapEntities(loadedState.map);
          }

          console.log("[Sanitize] Saneamiento completado con éxito.");
          console.groupEnd();

          return loadedState;
      }

      /**
       * Compara un objeto 'target' con un objeto 'defaults' y añade las propiedades
       * que falten en 'target' de forma recursiva.
       * @param {object} target - El objeto a sanear (ej. el player del archivo guardado).
       * @param {object} defaults - El objeto con la estructura por defecto (ej. gameState.player inicial).
       * @returns {object} El objeto 'target' saneado.
       */
      function mergeDefaults(target, defaults) {
          if (!target) return JSON.parse(JSON.stringify(defaults));
          for (const key in defaults) {
              if (typeof target[key] === 'undefined') {
                  // La propiedad no existe en el guardado, la añadimos.
                  console.warn(`[Sanitize Player] Propiedad faltante añadida: 'player.${key}'`);
                  target[key] = JSON.parse(JSON.stringify(defaults[key]));
              } else if (typeof defaults[key] === 'object' && defaults[key] !== null && !Array.isArray(defaults[key])) {
                  // Si ambas son objetos, llamamos recursivamente.
                  target[key] = mergeDefaults(target[key], defaults[key]);
              }
          }
          return target;
      }

      /**
       * Se asegura de que el objeto del jugador tenga todas las propiedades necesarias.
       * @param {object} loadedPlayer - El objeto del jugador del archivo de guardado.
       * @returns {object} El objeto del jugador saneado.
       */
      function sanitizePlayerState(loadedPlayer) {
          // Usamos una copia profunda del gameState inicial como plantilla de lo que debería existir.
          const defaultPlayerState = JSON.parse(JSON.stringify(gameState.player));
          return mergeDefaults(loadedPlayer, defaultPlayerState);
      }

      /**
      * Revisa y actualiza las técnicas aprendidas por el jugador para que coincidan con las definiciones actuales.
      * @param {object} loadedPlayer - El objeto del jugador, ya parcialmente saneado.
      * @returns {object} El objeto del jugador con las técnicas saneadas.
      */
      function sanitizeLearnedTechniques(loadedPlayer) {
          if (!loadedPlayer.learnedTechniques) {
              loadedPlayer.learnedTechniques = {};
              return loadedPlayer;
          }

          const sanitizedTechniques = {};
          for (const techId in loadedPlayer.learnedTechniques) {
              const masterTechDef = techniqueData[techId];
              // Solo mantenemos las técnicas que todavía existen en la base de datos del juego.
              if (masterTechDef) {
                  const playerTech = loadedPlayer.learnedTechniques[techId];
                  // Aseguramos que las propiedades básicas de cultivo existan.
                  playerTech.level = playerTech.level || 1;
                  playerTech.currentCultivationProgress = playerTech.currentCultivationProgress || 0;
                  
                  // Si el tiempo para el siguiente nivel no está definido, lo calculamos desde la base.
                  if (typeof playerTech.cultivationTimeToNextLevel === 'undefined') {
                      if (masterTechDef.cultivationSettings) {
                           playerTech.cultivationTimeToNextLevel = playerTech.level < masterTechDef.maxLevel
                              ? Math.floor(masterTechDef.cultivationSettings.baseTimeToLevelUp * Math.pow(masterTechDef.cultivationSettings.levelTimeMultiplier, playerTech.level -1))
                              : Infinity;
                      } else {
                           playerTech.cultivationTimeToNextLevel = Infinity;
                      }
                  }
                  
                  sanitizedTechniques[techId] = playerTech;
              } else {
                  console.warn(`[Sanitize Techniques] Técnica obsoleta '${techId}' eliminada del guardado del jugador.`);
              }
          }
          loadedPlayer.learnedTechniques = sanitizedTechniques;
          return loadedPlayer;
      }
    
      function renderQuickSlotBar() {
        const bar = document.getElementById("quickSlotBar");
        if (!bar) return;
        bar.innerHTML = "";

        const player = gameState.player;
        const LONG_PRESS_DURATION = 700; // Un poco más rápido para mejorar la sensación en móvil
        const MOVE_THRESHOLD = 10; // El jugador debe mover el dedo más de 10px para que se considere un arrastre
        // Contamos cuántos botones especiales se mostrarán
        let specialButtonCount = 1; // El de Cultivo siempre está
        if (player.canUseQiConversion) specialButtonCount++;
        if (player.learnedTechniques["formation_scribing_1"]) specialButtonCount++;

        // Determinamos cuántos slots de ítems mostrar (máximo 5, menos los especiales)
        const itemSlotCount = 5 - specialButtonCount;

        // --- RENDERIZAR SLOTS DE ÍTEMS ---
        for (let index = 0; index < itemSlotCount; index++) {
            const itemName = player.quickSlots[index];
            const slot = document.createElement("div");
            slot.className = "quick-slot";
            
            // ... (TODA la lógica de TAP vs LONG PRESS que ya tenías para los slots de ítems va aquí, sin cambios)
            let pressTimer = null;
            let isLongPress = false;
            let startX = 0;
            let startY = 0;

            const handlePressStart = (e) => {
              isLongPress = false;
              // Guardamos la posición inicial del toque
              if (e.type === 'touchstart') {
                  startX = e.changedTouches[0].clientX;
                  startY = e.changedTouches[0].clientY;
              }
              
              // Iniciamos el temporizador para el toque largo
              pressTimer = setTimeout(() => {
                  isLongPress = true;
                  openItemAssignmentModal(index);
              }, LONG_PRESS_DURATION);
            };
            const handlePressEnd = () => {
              clearTimeout(pressTimer);
              // Solo se "usa" el item si no fue un toque largo
              if (!isLongPress) {
                  useQuickSlotItem(index);
              }
            };
            
            const handlePressCancel = () => clearTimeout(pressTimer);
            // --- NUEVO MANEJADOR INTELIGENTE PARA touchmove ---
            const handlePressMove = (e) => {
                if (e.type === 'touchmove') {
                    const moveX = e.changedTouches[0].clientX;
                    const moveY = e.changedTouches[0].clientY;
                    // Calculamos la distancia que se ha movido el dedo
                    const distance = Math.hypot(moveX - startX, moveY - startY);
                    
                    // Si la distancia supera nuestro umbral, es un arrastre, no un toque largo.
                    if (distance > MOVE_THRESHOLD) {
                        clearTimeout(pressTimer);
                    }
                }
            };

            // Asignar los listeners
            slot.addEventListener("mousedown", handlePressStart);
            slot.addEventListener("mouseup", handlePressEnd);
            slot.addEventListener("mouseleave", handlePressCancel);
            
            // Usamos { passive: false } para poder prevenir el scroll del navegador si es necesario
            slot.addEventListener("touchstart", handlePressStart, { passive: false });
            slot.addEventListener("touchend", handlePressEnd);
            slot.addEventListener("touchcancel", handlePressCancel);
            // El nuevo listener inteligente
            slot.addEventListener("touchmove", handlePressMove, { passive: false });


            const keyHint = document.createElement("span");

            keyHint.className = "slot-key-hint";
            keyHint.textContent = index + 1;
            slot.appendChild(keyHint);

            if (itemName && itemData[itemName]) {
                  const itemCount = gameState.inventory[itemName] || 0;
                  slot.innerHTML += getItemIcon(itemName); // Mantenemos el ícono
                  slot.appendChild(keyHint); // Re-añadimos el hint que se borra con innerHTML

                  const countDisplay = document.createElement("span");
                  countDisplay.className = "slot-item-count";
                  countDisplay.textContent = itemCount;
                  slot.appendChild(countDisplay);

                  if (itemCount === 0) {
                      slot.style.opacity = 0.5;
                      slot.title = `Slot ${index + 1}: ${itemName} (Agotado)\nToque largo para reasignar.`;
                  } else {
                      slot.title = `Slot ${index + 1}: ${itemName} (x${itemCount})\nToque para usar, toque largo para reasignar.`;
                  }
              } else {
                  slot.classList.add("empty");
                  slot.title = `Slot ${index + 1} (Vacío)\nToque para asignar.`;
              }
              bar.appendChild(slot);
          }


        // --- RENDERIZAR BOTONES DE ACCIÓN ESPECIALES ---

        // Botón de Cultivo (siempre visible)
        const cultivateSlot = document.createElement("div");
        cultivateSlot.className = "quick-slot cultivate-slot";
        cultivateSlot.title = "Cultivar (🧘)";
        cultivateSlot.innerHTML = "🧘";
        cultivateSlot.onclick = () => toggleCultivation();
        if (player.isCultivating) {
            cultivateSlot.classList.add("active-cultivation");
            cultivateSlot.title = "Ver/Detener Cultivo";
        }
        bar.appendChild(cultivateSlot);

        // Botón de Conversión de Qi (condicional)
        if (player.canUseQiConversion) { // <-- ¡ESTA ES LA LÍNEA CLAVE!
            const conversionSlot = document.createElement("div");
            conversionSlot.className = "quick-slot conversion-slot";
            conversionSlot.innerHTML = "☯️";
            conversionSlot.onclick = () => toggleQiConversion();
            if (player.isCultivating && player.cultivationMode.isConversionCultivation) {
                conversionSlot.classList.add("active-conversion");
                conversionSlot.title = "Conversión ACTIVA (clic para detener)";
            } else {
                conversionSlot.title = "Iniciar Conversión de Maná a Vida";
            }
            bar.appendChild(conversionSlot);
        }
        
        // === INICIO DEL CÓDIGO NUEVO: BOTÓN DE RUNAS (CONDICIONAL) ===
        // Comprobamos si el jugador ha aprendido la técnica específica
        if (player.learnedTechniques["formation_scribing_1"]) {
            const runeSlot = document.createElement("div");
            runeSlot.className = "quick-slot rune-slot";
            runeSlot.innerHTML = "✍️"; // O el ícono que prefieras para las runas
            runeSlot.title = "Inscribir Runa (Consume 1 Tinta Rúnica)";
            
            // Al hacer clic, se intenta plantar una runa. La función plantRune ya comprueba si hay tinta y un enemigo cerca.
            runeSlot.onclick = () => {
                // No usamos battleAction aquí porque plantar runas es una acción del mapa, no de combate.
                plantRune(); 
            };
            bar.appendChild(runeSlot);
        }
        // === FIN DEL CÓDIGO NUEVO ===
    }

      function unassignQuickSlot(slotIndex) {
        gameState.player.quickSlots[slotIndex] = null;
        closeModal();
        renderQuickSlotBar();
      }

      function useQuickSlotItem(slotIndex) {
    // 1. Obtener el nombre del objeto desde la ranura
    const itemName = gameState.player.quickSlots[slotIndex];
    if (!itemName) {
        openItemAssignmentModal(slotIndex); // Si la ranura está vacía, abrir el menú de asignación
        return;
    }

    // 2. Obtener la definición maestra del objeto y la cantidad actual
    // Usaremos un nombre de variable claro: "itemDefinition"
    const itemDefinition = itemData[itemName];
    const itemCount = gameState.inventory[itemName] || 0;

    // 3. Comprobar si el objeto está agotado
    if (itemCount <= 0) {
        showModal("Agotado", `No te quedan más ${itemName}.`);
        gameState.player.quickSlots[slotIndex] = null; // Limpiar la ranura vacía
        renderQuickSlotBar();
        return;
    }

    // 4. Comprobar si el objeto tiene una definición y si se puede usar
    if (!itemDefinition) {
        showModal("Error", `El objeto "${itemName}" no se encontró en la base de datos.`);
        return;
    }

    if (itemDefinition.canUse && !itemDefinition.canUse(gameState.player)) {
        showModal("No se puede usar", `No puedes usar ${itemName} ahora.`);
        return;
    }

    // 5. Comprobar si el objeto tiene un efecto y ejecutarlo
    if (itemDefinition.effect) {
        // Llamar al efecto, pasando todos los argumentos necesarios
        const message = itemDefinition.effect(gameState.player, gainExperience, itemName);

        // 6. Procesar el resultado de la acción
        if (message && !message.toLowerCase().includes("error") && !message.toLowerCase().includes("al máximo")) {
            gameState.inventory[itemName]--; // Reducir del inventario
            const newCount = gameState.inventory[itemName] || 0;
            if (newCount <= 0) {
                gameState.player.quickSlots[slotIndex] = null; // Limpiar si fue el último
            }
        }
        showModal("Objeto Usado", message);
        updateUI();
        renderQuickSlotBar(); // Actualizar siempre la UI y la barra rápida
    } else {
        showModal("Sin efecto", `El objeto "${itemName}" no tiene un efecto utilizable.`);
    }
}

      function showHelp() {
        showModal(
          "Ayuda - Camino del Cultivador",
          "Explora y conviértete en un cultivador poderoso.\n\n" +
            '🧘 Cultiva (Botón "Cultivar") para mejorar HP/Maná/EXP y tus Técnicas.\n' +
            "📖 Aprende y Refina Técnicas para obtener nuevas habilidades y mejoras pasivas.\n" +
            "⬆️ Sube de Nivel para aumentar tus estadísticas base.\n" + // Actualizado
            "👹 Combate demonios y rivales.\n" +
            "💎 Recolecta recursos y tesoros.\n" +
            "📜 Busca o compra rollos de técnicas para volverte más fuerte\n\n" + // Eliminada mención al árbol de habilidades
            "Controles (Teclado):\n" +
            "  WASD/Flechas: Moverse\n" +
            "  ESPACIO: Interactuar\n\n" +
            "Controles (Táctil):\n" +
            "  Joystick: Moverse\n" +
            '  Botón "Acción": Interactuar'
        );
        updateStatsPanelVisibility();
      }
      //ACTUALIZAR BARRAS DEL JUGADOR
      function updatePlayerBarsOnMap() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerOnMapBarsContainer"
        );
        const hpFill = document.getElementById("playerOnMapHpFill");
        const manaFill = document.getElementById("playerOnMapManaFill");
        const playerElement = document.getElementById("player"); // El sprite del jugador

        if (!barsContainer || !hpFill || !manaFill || !playerElement) {
          // console.warn("Elementos de barras sobre el jugador no encontrados en el DOM.");
          return;
        }

        // Ocultar barras si el jugador está en batalla o si algún modal principal está abierto.
        if (gameState.battle.active || isAnyModalOpen()) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // La posición del playerElement (sprite) ya está calculada y centrada en updatePlayerPosition.
        // Usamos su 'top' y 'left' (que son relativos al map-container) como referencia.
        const playerVisualTop = parseFloat(playerElement.style.top) || 0;
        const playerVisualLeft = parseFloat(playerElement.style.left) || 0;
        const playerVisualWidth = playerElement.offsetWidth;

        // Posicionar las barras ligeramente encima del sprite del jugador.
        const barHeightWithGap = barsContainer.offsetHeight || 13; // Alto total aprox. de las 2 barras + gap
        barsContainer.style.top = `${playerVisualTop - barHeightWithGap - 5}px`; // 5px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // El 'transform: translateX(-50%)' en el CSS ayuda con esto si 'left' es el centro.
        barsContainer.style.left = `${
          playerVisualLeft + playerVisualWidth / 2
        }px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      function updatePlayerBarsInBattle() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        const hpFill = document.getElementById("playerInBattleSpriteHpFill");
        const manaFill = document.getElementById(
          "playerInBattleSpriteManaFill"
        );
        const playerSpriteInBattle = document.querySelector(
          ".battle-area .character .character-sprite"
        );

        if (!barsContainer || !hpFill || !manaFill || !playerSpriteInBattle) {
          // console.warn("Elementos de barras sobre el sprite del jugador en batalla no encontrados.");
          if (barsContainer) barsContainer.style.display = "none"; // Ocultar si faltan elementos
          return;
        }

        // Solo mostrar si la pantalla de batalla está activa
        if (
          !gameState.battle.active ||
          document.getElementById("battleScreen").style.display !== "flex"
        ) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // Posicionar las barras ligeramente encima del sprite del jugador en batalla.
        // El sprite (.character-sprite) es un div, necesitamos su offsetTop y offsetLeft
        // relativo a su padre (.character) que ahora es 'position: relative'.

        const spriteTop = playerSpriteInBattle.offsetTop; // Distancia desde el borde superior del .character
        const spriteLeft = playerSpriteInBattle.offsetLeft; // Distancia desde el borde izquierdo del .character
        const spriteWidth = playerSpriteInBattle.offsetWidth;

        const barHeightWithGap = barsContainer.offsetHeight || 12; // Alto total aprox. de las 2 barras + gap

        // El 'top' de las barras será el 'top' del sprite menos la altura de las barras y un pequeño margen.
        barsContainer.style.top = `${spriteTop - barHeightWithGap - 3}px`; // 3px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // 'left' será el 'left' del sprite más la mitad del ancho del sprite.
        // El 'transform: translateX(-50%)' en CSS centra el contenedor de barras.
        barsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      const joystickContainer = document.getElementById("joystick-container");
      const joystickPad = document.getElementById("joystick-pad");
      const joystickHandle = document.getElementById("joystick-handle");
      const actionButtonTouch = document.getElementById("action-button-touch");
      let joystickActive = false;
      let joystickCurrentDx = 0; // Guardar la dirección actual del joystick
      let joystickCurrentDy = 0;

      const JOYSTICK_THRESHOLD = 15;
      const JOYSTICK_GAME_MOVE_INTERVAL = 300;
      let joystickGameMoveTimerId = null;
      let lastJoystickMoveTime = 0;
      let joystickLoopId = null;
      let joystickTouchIdentifier = null; // <!-- CAMBIO JOYSTICK: Para seguir el dedo correcto -->

      function initJoystick() {
        if (
          !joystickContainer ||
          !joystickPad ||
          !joystickHandle ||
          !actionButtonTouch
        ) {
          console.error(
            "Error inicializando joystick: Elementos no encontrados."
          );
          return;
        }
        resetJoystickHandle();

        joystickPad.addEventListener(
          "touchstart",
          (event) => {
            if (
              gameState.player.isCultivating ||
              gameState.battle.active ||
              joystickActive
            )
              return;
            const touch = event.changedTouches[0];
            if (!touch) return;
            const padRect = joystickPad.getBoundingClientRect();
            if (
              touch.clientX < padRect.left ||
              touch.clientX > padRect.right ||
              touch.clientY < padRect.top ||
              touch.clientY > padRect.bottom
            ) {
              return;
            }
            event.preventDefault();
            joystickActive = true;
            joystickTouchIdentifier = touch.identifier;
            document.addEventListener("touchmove", handleJoystickMove, {
              passive: false,
            });
            document.addEventListener("touchend", handleJoystickEnd, {
              passive: false,
            });
            document.addEventListener("touchcancel", handleJoystickEnd, {
              passive: false,
            });

            // No iniciar el gameMoveTimer aquí, la animación la maneja handlePlayerMovementInput
            // updateJoystickHandlePosition y determinar dirección inicial
            updateJoystickHandlePosition(touch, true); // true para indicar que es el inicio
          },
          { passive: false }
        );

        actionButtonTouch.addEventListener("click", () => {
          if (!gameState.player.isCultivating && !gameState.battle.active) {
            interact();
          }
        });
      }
      function resetJoystickHandle() {
        if (joystickHandle)
          joystickHandle.style.transform = "translate(0px, 0px)";
        joystickCurrentDx = 0;
        joystickCurrentDy = 0;
      }
      // <!-- CAMBIO JOYSTICK: Modificaciones en los manejadores -->
      function handleJoystickStart(event) {
        if (
          gameState.player.isCultivating ||
          gameState.battle.active ||
          joystickActive
        )
          return;

        // Solo procesar el primer toque en el pad
        const touch = event.changedTouches[0];
        if (!touch) return;

        // Comprobar si el toque está realmente dentro del joystickPad (opcional, pero bueno para evitar activaciones accidentales)
        const padRect = joystickPad.getBoundingClientRect();
        if (
          touch.clientX < padRect.left ||
          touch.clientX > padRect.right ||
          touch.clientY < padRect.top ||
          touch.clientY > padRect.bottom
        ) {
          return;
        }

        event.preventDefault(); // Prevenir scroll/zoom si el toque es para el joystick

        joystickActive = true;
        joystickTouchIdentifier = touch.identifier; // Guardar el ID del dedo

        // Añadir listeners de movimiento y fin al documento para seguir el dedo fuera del pad
        document.addEventListener("touchmove", handleJoystickMove, {
          passive: false,
        });
        document.addEventListener("touchend", handleJoystickEnd, {
          passive: false,
        });
        document.addEventListener("touchcancel", handleJoystickEnd, {
          passive: false,
        });

        // if (!joystickGameMoveTimerId) {
        //   joystickGameMoveTimerId = setInterval(
        //     processJoystickGameMove,
        //     JOYSTICK_GAME_MOVE_INTERVAL
        //   );
        // }
        updateJoystickHandlePosition(touch);
        // console.log("Joystick Start, ID:", joystickTouchIdentifier);
      }
      
      function handleJoystickMove(event) {
        if (!joystickActive) return;

        // Encontrar el toque correcto
        let touch = null;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touch = event.changedTouches[i];
            break;
          }
        }

        if (touch) {
          event.preventDefault(); // Prevenir scroll si el movimiento es del dedo del joystick
          updateJoystickHandlePosition(touch);
          // console.log("Joystick Move");
        }
      }

      function updateJoystickHandlePosition(touch) {
        const padRect = joystickPad.getBoundingClientRect();
        if (padRect.width === 0) return;

        const joystickCenterX = padRect.left + padRect.width / 2;
        const joystickCenterY = padRect.top + padRect.height / 2;

        const currentX = touch.clientX - joystickCenterX;
        const currentY = touch.clientY - joystickCenterY;

        const angle = Math.atan2(currentY, currentX);
        const maxDistance =
          joystickPad.offsetWidth / 2 - joystickHandle.offsetWidth / 2;
        if (maxDistance <= 0) return;

        const distance = Math.min(maxDistance, Math.hypot(currentX, currentY));
        const limitedX = distance * Math.cos(angle);
        const limitedY = distance * Math.sin(angle);
        if (joystickHandle) {
          joystickHandle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
        }

        // --- LÓGICA DE CONTROL SIMPLIFICADA ---
        // Primero, reseteamos todas las direcciones del joystick.
        playerMovementKeysDown.up = false;
        playerMovementKeysDown.down = false;
        playerMovementKeysDown.left = false;
        playerMovementKeysDown.right = false;

        // Ahora, activamos la dirección correcta si el joystick está lo suficientemente inclinado.
        const magnitude = Math.hypot(currentX, currentY);
        if (magnitude > JOYSTICK_THRESHOLD) {
          if (Math.abs(currentX) > Math.abs(currentY)) {
            // Movimiento horizontal (izquierda o derecha)
            if (currentX > 0) {
              playerMovementKeysDown.right = true;
            } else {
              playerMovementKeysDown.left = true;
            }
          } else {
            // Movimiento vertical (arriba o abajo)
            if (currentY > 0) {
              playerMovementKeysDown.down = true;
            } else {
              playerMovementKeysDown.up = true;
            }
          }
        }
      }

      function handleJoystickEnd(event) {
        if (!joystickActive) return;

        let touchEndedIsOurs = false;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touchEndedIsOurs = true;
            break;
          }
        }

        if (touchEndedIsOurs) {
          joystickActive = false;
          joystickTouchIdentifier = null;
          resetJoystickHandle();

          // --- LIMPIEZA DE BANDERAS ---
          // Al soltar el joystick, nos aseguramos de que ninguna tecla de movimiento quede "presionada"
          playerMovementKeysDown.up = false;
          playerMovementKeysDown.down = false;
          playerMovementKeysDown.left = false;
          playerMovementKeysDown.right = false;

          document.removeEventListener("touchmove", handleJoystickMove);
          document.removeEventListener("touchend", handleJoystickEnd);
          document.removeEventListener("touchcancel", handleJoystickEnd);
        }
      }
      // processJoystickGameMove se mantiene igual
      // <!-- FIN CAMBIO JOYSTICK -->
      function processJoystickGameMove() {
        // Esta función se llama cada JOYSTICK_GAME_MOVE_INTERVAL
        if (
          joystickActive &&
          (joystickCurrentDx !== 0 || joystickCurrentDy !== 0)
        ) {
          // console.log(`[processJoystickGameMove] Effective move: dx=${joystickCurrentDx}, dy=${joystickCurrentDy}. Calling movePlayer.`);
          movePlayer(joystickCurrentDx, joystickCurrentDy);
        }
      }
      
      function joystickLoop() {
        if (!joystickActive) {
          joystickLoopId = null;
          return;
        }
        const now = Date.now();
        if (now - lastJoystickMoveTime > JOYSTICK_MOVE_INTERVAL) {
          let dx = 0,
            dy = 0;
          const magnitude = Math.hypot(joystickCurrentX, joystickCurrentY);
          if (magnitude > JOYSTICK_THRESHOLD) {
            if (Math.abs(joystickCurrentX) > Math.abs(joystickCurrentY)) {
              dx = joystickCurrentX > 0 ? 1 : -1;
            } else {
              dy = joystickCurrentY > 0 ? 1 : -1;
            }
          }
          if (dx !== 0 || dy !== 0) {
            movePlayer(dx, dy);
            lastJoystickMoveTime = now;
          }
        }
        joystickLoopId = requestAnimationFrame(joystickLoop);
      }
      // --- NUEVAS FUNCIONES PARA LOS MODALES DE INVENTARIO Y PERSONAJE (EJEMPLOS) ---

      // Modal para Inventario Detallado (si decides usar un modal en lugar del sidebar)
      function openInventoryModal() {
    let inventoryContent = `
        <h2 style="text-align: center; margin-bottom: 20px;">Inventario</h2>
        <div id="inventory-modal-list" style="text-align: left;">
    `;

    const itemsToShow = Object.entries(gameState.inventory).filter(([itemName, count]) => count > 0);

    if (itemsToShow.length === 0) {
        inventoryContent += "<p style='text-align: center; opacity: 0.7;'>No tienes ningún objeto.</p>";
    } else {
        itemsToShow.forEach(([itemName, count]) => {
            const itemInfo = itemData[itemName] || {};
            
            // --- INICIO DE LA LÓGICA CORREGIDA ---
            let isUsable = false;
            let isDisabled = false;
            let disabledReason = "";

            // Un objeto es usable si tiene un efecto.
            if (itemInfo.effect) {
                isUsable = true;
                // Si además tiene una condición 'canUse', la evaluamos.
                if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
                    isDisabled = true;
                    disabledReason = "No se puede usar ahora";
                }
            }
            // --- FIN DE LA LÓGICA CORREGIDA ---

            inventoryContent += `
                <div class="inventory-modal-item">
                    <div class="item-details">
                        <div class="item-name">${getItemIcon(itemName, "")} ${itemName} (x${count})</div>
                        <div class="item-description">${itemInfo.description || "Un objeto misterioso."}</div>
                    </div>
                    <div class="item-actions">
                        ${
                          isUsable
                            ? `<button class="use-item-btn" data-itemname="${itemName}" ${
                                isDisabled ? "disabled" : ""
                              } title="${
                                isDisabled ? disabledReason : "Usar objeto"
                              }">Usar</button>`
                            : ""
                        }
                    </div>
                </div>
            `;
        });
    }

    inventoryContent += "</div>";
    showModal("Detalles del Inventario", inventoryContent);
    document.getElementById("modalTitle").style.display = "none";

    // Los listeners no cambian, siguen funcionando igual.
    document.querySelectorAll(".use-item-btn").forEach((button) => {
        button.addEventListener("click", function () {
            const itemName = this.dataset.itemname;
            useItem(itemName);
            closeModal();
            openInventoryModal();
        });
    });
    updateStatsPanelVisibility();
}

function openItemAssignmentModal(slotIndex) {
        let assignmentContent = `
              <h2 style="text-align: center; margin-bottom: 20px;">Asignar al Slot ${
                slotIndex + 1
              }</h2>
              <p style="text-align: center; opacity: 0.8; margin-bottom: 15px;">Selecciona un objeto consumible para este acceso rápido.</p>
              <div id="assignment-modal-list" style="text-align: left;">
          `;

        // Filtrar para mostrar solo los ítems consumibles que el jugador posee
        const assignableItems = Object.entries(gameState.inventory).filter(
          ([itemName, count]) => {
            const itemInfo = itemData[itemName];
            return count > 0 && itemInfo && itemInfo.canUse; // 'canUse' es nuestro indicador de consumible
          }
        );

        if (assignableItems.length === 0) {
          assignmentContent +=
            "<p style='text-align: center; opacity: 0.7;'>No tienes objetos consumibles para asignar.</p>";
        } else {
          assignableItems.forEach(([itemName, count]) => {
            const itemInfo = itemData[itemName];
            assignmentContent += `
                      <div class="inventory-modal-item assignable-item" data-itemname="${itemName}">
                          <div class="item-details">
                              <div class="item-name">${getItemIcon(
                                itemName,
                                ""
                              )} ${itemName} (x${count})</div>
                              <div class="item-description">${
                                itemInfo.description
                              }</div>
                          </div>
                      </div>
                  `;
          });
        }

        // --- AÑADIMOS EL BOTÓN DE DESASIGNAR ---
        assignmentContent += `</div><button onclick="unassignQuickSlot(${slotIndex})" style="margin-top:20px; background-color: #883333;">Quitar Objeto del Slot</button>`;

        // Mostramos el modal
        showModal("Asignar Objeto", assignmentContent);
        document.getElementById("modalTitle").style.display = "none";

        // --- INICIO DE LA MODIFICACIÓN: BUGFIX DE CLIC INSTANTÁNEO ---
        // Añadimos un pequeño retardo antes de asignar los listeners de clic.
        // Esto evita que el mismo clic que abrió el modal active inmediatamente
        // la asignación de un objeto, resolviendo el bug.
        setTimeout(() => {
          document.querySelectorAll(".assignable-item").forEach((itemDiv) => {
            itemDiv.addEventListener("click", function () {
              const itemName = this.dataset.itemname;
              // Asignar el ítem al slot correspondiente
              gameState.player.quickSlots[slotIndex] = itemName;
              // Cerrar el modal y actualizar la barra
              closeModal();
              renderQuickSlotBar();
            });
          });
        }, 50); // Un retardo de 50ms es suficiente e imperceptible para el usuario.
        // --- FIN DE LA MODIFICACIÓN ---

        updateStatsPanelVisibility();
      }
      
      function unassignQuickSlot(slotIndex) {
        gameState.player.quickSlots[slotIndex] = null;
        closeModal();
        renderQuickSlotBar();
      }

      // Modal para Personaje (Stats, Equipo, etc.)
      function openCharacterModal() {
        const player = gameState.player;
        let characterContent = `
                  <h2>${player.realm} - Nivel ${player.level}</h2>
                  <div style="text-align: left; margin-top: 15px;">
                  <p><strong>Vida:</strong> ${Math.floor(player.hp)} / ${
          player.maxHp
        }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill hp-fill" style="width: ${
                    (player.hp / player.maxHp) * 100
                  }%;"></div></div>
                  <p><strong>Maná:</strong> ${Math.floor(player.mana)} / ${
          player.maxMana
        }</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill mana-fill" style="width: ${
                    (player.mana / player.maxMana) * 100
                  }%;"></div></div>
                  <p><strong>Experiencia:</strong> ${Math.floor(
                    player.exp
                  )} / ${player.expToNext}</p>
                  <div class="stat-bar" style="height:18px;"><div class="stat-fill exp-fill" style="width: ${
                    (player.exp / player.expToNext) * 100
                  }%;"></div></div>
                  <hr style="margin: 15px 0;">
                  <p><strong>Ataque:</strong> ${player.attack}</p>
                  <p><strong>Defensa:</strong> ${player.defense}</p>
                  <p><strong>Piedras Espirituales:</strong> ${
                    gameState.inventory["Piedras Espirituales"] || 0
                  }</p>
                  <hr style="margin: 15px 0;">
                  <h4>Secta: ${player.secta.nombre}</h4>
                  <p><strong>Rango:</strong> ${player.secta.rango}</p>
                  <p><strong>Puntos de Contribución:</strong> ${
                    player.secta.puntosContribucion
                  } PCS</p>
                  </div>
                  `;
        // Aquí podrías añadir una sección para el equipo si lo implementas.
        showModal("Detalles del Personaje", characterContent);
        updateStatsPanelVisibility();
      }

      // Placeholder para un futuro modal de menú principal
      function openMainMenuModal() {
        let menuContent = `
                  <h2>Menú Principal</h2>
                  <button class="cultivation-option-btn" onclick="saveGame(); closeModal();">💾 Guardar Partida</button>
                  <button class="cultivation-option-btn" onclick="triggerFileUpload(); closeModal();">📁 Cargar Partida</button>
                  <button id="fullscreenBtn" class="cultivation-option-btn" onclick="toggleFullscreen()">
                      <span id="fullscreenIcon">⛶</span> Pantalla Completa
                  </button>
                  <button class="cultivation-option-btn" onclick="showHelp();">❓ Ayuda</button>
                  <button class="cultivation-option-btn" onclick="closeModal();">↩️ Volver al Juego</button>
              `;
        // Usamos el showModal genérico pero sin el botón de cierre por defecto, ya que "Volver al Juego" hace esa función.
        // Para ello, tu showModal necesitaría una forma de ocultar su propio botón de cierre.
        // Si showModal no lo permite, necesitarías un modal específico para el menú.
        // Por ahora, asumiré que el showModal genérico tiene un botón de cierre que se ocultará
        // o que el usuario usará el botón "Volver al Juego".

        // Modificamos el modal genérico para que no muestre su propio botón "Cerrar" si se lo indicamos
        const modalElement = document.getElementById("interactionModal");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalTextEl = document.getElementById("modalText");
        const closeButton = modalElement.querySelector(
          "button.close-modal-btn"
        );

        modalTitleEl.textContent = "Menú Principal"; // El H2 ya está en menuContent
        modalTextEl.innerHTML = menuContent.replace(
          "<h2>Menú Principal</h2>",
          ""
        ); // Quitar el H2 duplicado
        if (closeButton) closeButton.style.display = "none"; // Ocultar el botón de cierre por defecto del modal

        modalElement.style.display = "flex";
        hideTouchControls();
        updateTopNavVisibility();
        updateStatsPanelVisibility();
      }

      function toggleFullscreen() {
          if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
              openFullscreen();
          } else {
              closeFullscreen();
          }
      }
      
      function openFullscreen() {
          const elem = document.documentElement; // Queremos que todo el documento sea pantalla completa
          if (elem.requestFullscreen) {
              elem.requestFullscreen();
          } else if (elem.mozRequestFullScreen) { /* Firefox */
              elem.mozRequestFullScreen();
          } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
              elem.webkitRequestFullscreen();
          } else if (elem.msRequestFullscreen) { /* IE/Edge */
              elem.msRequestFullscreen();
          }
          updateFullscreenButton();
      }
      
      function closeFullscreen() {
          if (document.exitFullscreen) {
              document.exitFullscreen();
          } else if (document.mozCancelFullScreen) { /* Firefox */
              document.mozCancelFullScreen();
          } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
              document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) { /* IE/Edge */
              document.msExitFullscreen();
          }
          updateFullscreenButton();
      }
      
      function updateFullscreenButton() {
          const fullscreenBtn = document.getElementById('fullscreenBtn');
          const fullscreenIcon = document.getElementById('fullscreenIcon');
          if (!fullscreenBtn || !fullscreenIcon) return; // Salida temprana si el modal no está abierto

          // Comprobamos si algún navegador está en modo de pantalla completa
          if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
              fullscreenBtn.innerHTML = '<span id="fullscreenIcon"> keluar </span> Salir de Pantalla Completa';
          } else {
              fullscreenBtn.innerHTML = '<span id="fullscreenIcon">⛶</span> Pantalla Completa';
          }
      }

      function openSectHallInterface() {
        const player = gameState.player;
        const sectData = SECTA_DATA;

        document.getElementById(
          "sectHallModalTitle"
        ).textContent = `Salón ${player.secta.nombre}`;
        document.getElementById("sectHallPlayerRank").textContent =
          player.secta.rango;
        document.getElementById("sectHallPlayerPCS").textContent =
          player.secta.puntosContribucion;

        const availableMissionsDiv = document.getElementById(
          "sectHallAvailableMissions"
        );
        availableMissionsDiv.innerHTML =
          "<p>Habla con Guía Lin o Admin Yao para asignaciones generales.</p>";

        const rankChallengesDiv = document.getElementById(
          "sectHallRankChallenges"
        );
        rankChallengesDiv.innerHTML = "";

        const currentRankIndex = sectData.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );
        let challengeButtonAdded = false;

        if (
          currentRankIndex !== -1 &&
          currentRankIndex + 1 < sectData.rangos.length
        ) {
          const nextRankData = sectData.rangos[currentRankIndex + 1];
          const challengeButton = document.createElement("button");
          challengeButton.textContent = `Consultar Desafío para ${nextRankData.nombre}`;
          challengeButton.className = "cultivation-option-btn";
          challengeButton.style.marginBottom = "10px";

          // --- INICIO DE LA CORRECCIÓN CLAVE ---
          challengeButton.onclick = () => {
            // 1. Cerramos el modal actual del Salón de la Secta.
            closeSectHallModal();

            // 2. Preparamos y mostramos el NUEVO modal con la información del desafío.
            // (La lógica interna para generar el mensaje no cambia)
            const pcsNecesarios = nextRankData.pcsRequeridos;
            const tieneSuficientesPCS =
              player.secta.puntosContribucion >= pcsNecesarios;
            const rivalIdParaDesafio = nextRankData.desafioRivalId;
            let mensajeDesafio = `<strong>Desafío para ascender a ${nextRankData.nombre}:</strong><br>`;
            let misionDesafioActiva = null;
            let misionDesafioDataObj = null;
            let idDeLaMisionAsociada = null;

            if (rivalIdParaDesafio) {
              const misionEntry = Object.entries(MISIONES_DATA).find(
                ([mKey, mVal]) =>
                  mVal.autoActivarAlCumplirRequisitos === true &&
                  mVal.recompensa?.nuevoRango === nextRankData.nombre &&
                  mVal.objetivo?.npcId === rivalIdParaDesafio
              );

              if (misionEntry) {
                idDeLaMisionAsociada = misionEntry[0];
                misionDesafioDataObj = misionEntry[1];
                misionDesafioActiva = player.secta.misionesActivas.find(
                  (m) => m.id === idDeLaMisionAsociada
                );
                mensajeDesafio += `<em>"${misionDesafioDataObj.descripcion}"</em><br>`;
                mensajeDesafio += `Oponente: <strong>${
                  entityTypes[rivalIdParaDesafio]?.name ||
                  "Guardián Desconocido"
                }</strong>.<br>`;
                mensajeDesafio += `Recompensas: ${
                  misionDesafioDataObj.recompensa.pcs || 0
                } PCS, ${misionDesafioDataObj.recompensa.exp || 0} EXP, Rango ${
                  nextRankData.nombre
                }.<br><hr>`;
              }
            } else {
              mensajeDesafio += `Este rango no parece requerir un desafío de combate.<br><hr>`;
            }

            mensajeDesafio += `<strong>Requisitos Actuales:</strong><br>`;
            mensajeDesafio += `Puntos de Contribución (PCS): ${player.secta.puntosContribucion} / ${pcsNecesarios} PCS. `;
            mensajeDesafio += tieneSuficientesPCS
              ? "<span style='color: #66ff66;'>(Cumplido)</span><br>"
              : `<span style='color: #ffcc66;'>(Faltan ${
                  pcsNecesarios - player.secta.puntosContribucion
                } PCS)</span><br>`;

            if (misionDesafioActiva) {
              mensajeDesafio +=
                "<br><strong style='color: #66ff66;'>¡El desafío está ACTIVO!</strong> Dirígete a la arena.";
            } else if (
              idDeLaMisionAsociada &&
              player.secta.misionesCompletadas[idDeLaMisionAsociada]
            ) {
              mensajeDesafio +=
                "<br><strong style='color: #aaa;'>Ya has completado este desafío.</strong>";
            } else if (
              tieneSuficientesPCS &&
              rivalIdParaDesafio &&
              misionDesafioDataObj &&
              idDeLaMisionAsociada
            ) {
              mensajeDesafio += `<br><button id="activar-desafio-btn-specific">Activar Misión de Desafío Ahora</button>`;
              // Guardamos la información necesaria para el listener del botón
              window.tempChallengeActivationInfo = {
                misionId: idDeLaMisionAsociada,
                nextRankName: nextRankData.nombre,
              };
            } else if (!tieneSuficientesPCS) {
              mensajeDesafio +=
                "<br>Aún no cumples los requisitos de PCS para activar este desafío.";
            }

            // 3. Mostramos el modal de información. `showModal` se encargará de gestionar el velo y los stats.
            showModal("Información del Desafío de Rango", mensajeDesafio);

            // 4. Asignamos el listener al botón de activar, si existe.
            if (
              window.tempChallengeActivationInfo &&
              document.getElementById("activar-desafio-btn-specific")
            ) {
              document.getElementById("activar-desafio-btn-specific").onclick =
                () => {
                  const info = window.tempChallengeActivationInfo;
                  acceptMission(info.misionId);
                  closeModal(); // Cierra el modal de información del desafío
                  showModal(
                    "¡Desafío Aceptado!",
                    "La misión de desafío ha sido añadida a tu diario. ¡Ve a la arena!"
                  );
                  ensureFixedEntities();
                  renderMap();
                  delete window.tempChallengeActivationInfo;
                };
            }
          };
          // --- FIN DE LA CORRECCIÓN CLAVE ---

          rankChallengesDiv.appendChild(challengeButton);
          challengeButtonAdded = true;
        }

        if (!challengeButtonAdded) {
          if (currentRankIndex === -1) {
            rankChallengesDiv.innerHTML =
              "<p>Error al determinar tu rango actual.</p>";
          } else {
            rankChallengesDiv.innerHTML =
              "<p>¡Has alcanzado el rango más alto o no hay más desafíos definidos!</p>";
          }
        }

        document.getElementById("sectHallModal").style.display = "flex";
        hideTouchControls();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }

      function getDynamicNpcDialogue(npcId) {
        const player = gameState.player;
        const subplots = player.worldState.subplotFlags;

        switch (npcId) {
            case "rival_xiao":
                switch (subplots.rivalryProgress) {
                    case 0:
                        return "Así que tú eres el nuevo 'prodigio' del que todos hablan. No me impresionas. Aléjate de mi camino.";
                    case 1:
                        return `¡Tú! Me humillaste una vez, pero he entrenado. ¡Prepárate para sentir mi verdadero poder!`;
                    case 2:
                        return `Imposible... ¿Cómo puedes seguir superándome? Esto no ha terminado. Encontraré un poder que no podrás igualar.`;
                    default:
                        return "Hmmph.";
                }

            case "alquimista_mo":
                switch (subplots.alchemistTrust) {
                    case 0:
                        return "Lárgate. No tengo tiempo para los mocosos de la Secta del Viento Azure. A menos que... me traigas algo que me interese.";
                    case 1:
                        return "¡Las Flores de Fuego Espectral! No creí que las encontrarías. Tienes agallas. Quizás no eres como los demás. Necesito un favor más...";
                    case 2:
                        return "Has demostrado tu valía. Escucha, la alquimia que practico... no es ortodoxa. Puede darte un poder inmenso, pero a un gran coste. ¿Estás dispuesto a caminar por la senda prohibida del Elixir de Sangre?";
                    default:
                        return "El caldero burbujea... ¿qué necesitas?";
                }
                case "npc_maestro_feng":
                    switch (subplots.fengQuestProgress) {
                        case 1: // El jugador ha llegado, pero aún no ha hablado con él para completar la misión.
                            return "Asombroso... El Compás te ha traído hasta mí. Tu aptitud para sentir las líneas de Qi es innata. Soy Feng, un estudioso de las artes olvidadas. Habla conmigo de nuevo para confirmar que entiendes tu tarea y comenzar tu entrenamiento.";
                        case 2: // Acaba de completar la primera misión, listo para recibir la segunda.
                            return "¡Excelente! Has demostrado tu control básico. Como prometí, te enseñaré el 'Círculo de Vida Frondoso', una formación que regenerará tu vitalidad. Pero el conocimiento sin práctica es inútil. ¿Aceptas tu siguiente desafío? Deberás probar esta nueva formación contra un poderoso Treant Anciano en el Bosque Profundo.";
                        case 3: // Completó la segunda, listo para la tercera.
                            return "¡Derrotaste al Treant! Tu dominio de las formaciones de apoyo es innegable. Ahora, una prueba de intelecto y poder. El Golem Geo del desierto está protegido por un sello mágico que lo hace casi invulnerable. La formación que te enseñaré, la 'Matriz del Vórtice Arcano', no puede romper ese sello. Enbárcate en aventuras y encuentra una formación que pueda debilitarlo! ";
                        case 4: // Completó la tercera, listo para la cuarta.
                            return "¡Rompiste el sello del Golem! Tu mente es tan afilada como tu espada. Pero un verdadero maestro equilibra ataque y defensa. Te he enseñado la 'Égida de la Montaña Inamovible', una formidable formación defensiva. Para dominarla, enfréntate a un furioso Djinn de las Arenas. Su ofensiva implacable pondrá a prueba tu nueva defensa hasta el límite. ¿Aceptas tu prueba final de equilibrio?";
                        case 5: // Todas las misiones completas.
                            return "Has superado todas mis pruebas y has dominado el equilibrio entre ataque, defensa y utilidad. Ya no hay más que pueda enseñarte. Eres, por derecho propio, un Maestro de Formaciones. Usa tu conocimiento con sabiduría.";
                        default:
                            return "El camino de las formaciones es un estudio de por vida. Medita en lo que has aprendido.";
                    }
                    
                    case "renegada_li":
                        switch (subplots.renegadeContact) {
                            case 0:
                                return "Otro perro faldero de la secta. No te acerques. No sabes nada de la verdad.";
                            case 1:
                                return "Así que tú también encontraste el diario. ¿Empiezas a dudar de las mentiras que te cuenta tu 'Maestro'? El 'Soberano' no fue un monstruo. Fue un mártir.";
                            case 2:
                                return "Te daré una opción. Ayúdame a encontrar los artefactos para romper el sello y liberar a nuestro patriarca, o sigue siendo un peón en su juego. La elección es tuya.";
                            default:
                                return "El tiempo se acaba. ¿Has tomado una decisión?";
                        }
                }
                return "...";
            }

      function acceptMissionFromSectHall(misionId) {
        acceptMission(misionId);
        if (document.getElementById("sectHallModal").style.display === "flex") {
          openSectHallInterface();
        }
      }
      
      function closeSectHallModal() {
        document.getElementById("sectHallModal").style.display = "none";
        showTouchControls();
        updatePlayerBarsOnMap();
        showTouchControls();
        updateStatsPanelVisibility();
        updateGameOverlayVisibility();
      }
      
      function openSectShop() {
        showModal("Tienda de Secta", "El Depósito aún está siendo abastecido.");
      }
      // Variable global para almacenar la acción a confirmar
      let onConfirmAction = null;

      function getPlayerCurrentZone() {
        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        
        for (const zone of gameState.map.terrainZones) {
          if (
            playerX >= zone.x1 &&
            playerX <= zone.x2 &&
            playerY >= zone.y1 &&
            playerY <= zone.y2
          ) {
            // console.log(`[getPlayerCurrentZone] ==> Encontrado en zona: "${zone.name}"`); // Descomenta si necesitas depurar esta función específicamente
            return zone;
          }
        }
        // console.log(`[getPlayerCurrentZone] ==> No se encontró en ninguna zona definida. Retornando null.`); // Descomenta si necesitas depurar esta función específicamente
        return null;
      }

      function showConfirmationModal(title, text, onConfirm) {
        document.getElementById("confirmationModalTitle").textContent = title;
        document.getElementById("confirmationModalText").innerHTML = text;

        onConfirmAction = onConfirm; // Guardamos la función que se ejecutará si se confirma

        const confirmButton = document.getElementById("confirmBtn");
        // Usamos .onclick para reemplazar cualquier listener anterior
        confirmButton.onclick = () => {
          if (typeof onConfirmAction === "function") {
            onConfirmAction();
          }
          closeConfirmationModal();
        };

        document.getElementById("confirmationModal").style.display = "flex";
        hideTouchControls();
      }

      function closeConfirmationModal() {
        document.getElementById("confirmationModal").style.display = "none";
        onConfirmAction = null; // Limpiamos la acción
        showTouchControls();
        updateStatsPanelVisibility();
      }
      // --- INICIALIZACIÓN ---
      document.addEventListener("DOMContentLoaded", () => {
        const mobileMenuButton = document.getElementById("mobileMenuBtn");
        const topNavBar = document.getElementById("topNavBar"); // Ya deberías tener esta variable
        if (mobileMenuButton && topNavBar) {
          mobileMenuButton.addEventListener("click", (e) => {
            e.stopPropagation(); // Evita que otros clicks se disparen
            topNavBar.classList.toggle("open");
          });
        }

        // Añadir un listener para cerrar el menú si se hace clic fuera de él
        document.addEventListener("click", (e) => {
          if (
            topNavBar.classList.contains("open") &&
            !topNavBar.contains(e.target)
          ) {
            topNavBar.classList.remove("open");
          }
        });
        renderQuickSlotBar();
        const navBtnMissions = document.getElementById("navBtnMissions");
        if (navBtnMissions) {
          navBtnMissions.addEventListener("click", openMissionsModal);
        }
        const navBtnInventory = document.getElementById("navBtnInventory");
        console.log(
          "Dentro de DOMContentLoaded, navBtnInventory:",
          navBtnInventory
        );
        if (navBtnInventory) {
          navBtnInventory.addEventListener("click", () => {
            openInventoryModal(); // Llama a nuestra nueva y mejorada función
            if (isMobileView() && topNavBar.classList.contains("open")) {
              topNavBar.classList.remove("open");
            }
          });
        }

        if (navBtnCharacter) {
          navBtnCharacter.addEventListener("click", () => {
            // Necesitas una función para abrir un MODAL de personaje
            openCharacterModal(); // Tendrías que crear esta función y el modal
          });
        }

        if (navBtnCultivate) {
          navBtnCultivate.addEventListener("click", () => {
            toggleCultivation(); // Tu función existente para iniciar/detener cultivo
          });
        }

        if (navBtnTechniques) {
          navBtnTechniques.addEventListener("click", () => {
            showTechniquePanel(); // Tu función existente para mostrar el modal de técnicas
          });
        }

        if (navBtnMenu) {
          navBtnMenu.addEventListener("click", () => {
            // Siempre abre el modal del menú principal.
            openMainMenuModal();

            // Adicional: En móvil, cierra el menú desplegable después de hacer clic.
            if (isMobileView() && topNavBar.classList.contains("open")) {
              topNavBar.classList.remove("open");
            }
          });
        }

        // Llamada inicial para asegurar el estado correcto de la barra
        updateTopNavVisibility();

        // --- INICIO DEL REEMPLAZO DE EVENT LISTENERS ---
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        document.addEventListener("keydown", (e) => {
          if (
            isAnyModalOpen() ||
            gameState.battle.active ||
            gameState.player.isCultivating
          ) {
            Object.keys(playerMovementKeysDown).forEach(
              (k) => (playerMovementKeysDown[k] = false)
            );
            return;
          }
          // --- INICIO DE LA MODIFICACIÓN PARA ACCESO RÁPIDO ---
          if (e.code.startsWith("Digit")) {
            const slotIndex = parseInt(e.code.replace("Digit", ""), 10) - 1;
            if (slotIndex >= 0 && slotIndex < 5) {
              e.preventDefault();
              useQuickSlotItem(slotIndex);
              return; // Importante para que no procese el movimiento
            }
          }
          // --- FIN DE LA MODIFICACIÓN ---
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
            case "Space":
              e.preventDefault();
              interact();
              return;
          }

          if (direction) {
            e.preventDefault();
            playerMovementKeysDown[direction] = true;
          }
        });

        document.addEventListener("keyup", (e) => {
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
          }

          if (direction) {
            e.preventDefault();
            playerMovementKeysDown[direction] = false;
          }
        });

        // Helper para convertir dirección a dx/dy para movePlayer
        function dxFromDirection(direction) {
          if (direction === "left") return -1;
          if (direction === "right") return 1;
          return 0;
        }

        function dyFromDirection(direction) {
          if (direction === "up") return -1;
          if (direction === "down") return 1;
          return 0;
        }

        const fileInput = document.getElementById("fileInput");
        if (fileInput) fileInput.addEventListener("change", loadGameFromFile);
        const toggleGridBtn = document.getElementById("toggleGridBtn");
        if (toggleGridBtn) {
            toggleGridBtn.addEventListener("click", toggleGrid);
        }
        const toggleControlsBtn = document.getElementById(
          "toggleMapControlsBtn"
        );
        if (toggleControlsBtn)
          toggleControlsBtn.addEventListener(
            "click",
            toggleMapControlsVisibility
          );

        // Listener para redimensionar y recalcular el tamaño de los tiles
        window.addEventListener("resize", () => {
          calculateAndSetTileSize();
          renderMap(); // Vuelve a dibujar con el nuevo tamaño
          updatePlayerPosition(); // Asegura que el jugador esté bien posicionado
          updateGrid();
          if (isGridVisible) {
            const gridOverlay = document.querySelector('.grid-overlay');
            if (gridOverlay) gridOverlay.style.setProperty('--tile-size', `${currentTileSize}px`);
        }
        });

        // Iniciar el bucle de actualización del juego
        setInterval(gameTickUpdater, 1000); // Llama cada segundo, ajusta según necesidad
        initJoystick();
        setInterval(gameLoop, 100);
        calculateAndSetTileSize();
        // generateMap() ahora es más simple, isRespawn = false para carga inicial completa
        gameState.lastGameTimeUpdate = Date.now(); // Inicializar antes del primer tick

        generateMap(true); // Usar true para la generación inicial completa, incluyendo decorativos

        recalculatePlayerStats();
        updatePlayerVisualSize(); // Asegura el tamaño correcto del div del jugador
        updatePlayerSpriteVisual(); // Establece el sprite inicial
        updatePlayerPosition("DOMContentLoaded_init"); // Llama después de sprite visual

        updatePlayerSpriteVisual(); // Llamar una vez para establecer el sprite inicial

        showTouchControls();
        const initialZone = getPlayerCurrentZone();
        gameState.player.currentZoneName = initialZone
          ? initialZone.name
          : "Tierras Salvajes";

        showModal(
          "Despertar del Cultivador",
          "Has despertado en un mundo de cultivadores buscando poder supremo. " +
            "Te encuentras cerca de la <strong>Secta del Viento Azure</strong>. Quizás allí encuentres tu camino.\n\n" +
            "<strong>Objetivo:</strong> Asciende en la secta, domina técnicas, derrota enemigos y desvela secretos.\n\n" +
            "Busca al <strong>Guía Lin</strong> en la secta (⛩️) para comenzar.\n\n" +
            'Usa Controles (Teclado/Táctil) para moverte e interactuar. Presiona "?" para ayuda.'
        );
        document
          .querySelectorAll("#shopCategories .category-item")
          .forEach((item) => {
            item.addEventListener("click", function () {
              document
                .querySelectorAll("#shopCategories .category-item")
                .forEach((i) => i.classList.remove("active"));
              this.classList.add("active");
              currentShopPage = 1;
              renderShopProducts();
            });
          });
        document.getElementById("shopSearch").addEventListener("input", () => {
          currentShopPage = 1;
          renderShopProducts();
        });
        document.getElementById("priceRange").addEventListener("input", (e) => {
          document.getElementById(
            "priceRangeValue"
          ).textContent = `${e.target.value} PS`;
          currentShopPage = 1;
          renderShopProducts();
        });
      });
    /**
 * =======================================================================
 *                    FUNCIONES DE TESTING (DEV CONSOLE)
 * =======================================================================
 * Estas funciones están diseñadas para ser llamadas desde la consola del
 * navegador para acelerar el testing de la subtrama del Maestro Feng.
 */

/**
 * Inicia la subtrama del Maestro Feng desde cero.
 * Simula la derrota del mini-jefe y te da el compás.
 */
 function dev_resetDefeatedBosses() {
    gameState.player.worldState.defeatedBosses = {};
    ensureFixedEntities(); // Vuelve a comprobar qué jefes deben aparecer
    renderMap();
    const msg = "[DEV] El estado de jefes derrotados ha sido reseteado.";
    console.log(msg);
    alert(msg);
}
function dev_startFengQuest() {
    const itemName = "Compás Espiritual Antiguo";
    gameState.inventory[itemName] = 1;
    updateInventoryUI(); // Actualiza la UI para que veas el objeto

    const message = `[DEV] Subtrama de Feng iniciada. Has recibido el "${itemName}".\n\nPróximo paso: Ve al inventario (o a la barra rápida si lo asignas) y usa el compás para revelar la ubicación de Feng en el mapa.`;
    console.log(message);
    alert(message);
}

/**
 * Fuerza el avance a un paso específico de la cadena de misiones de Feng.
 * Útil si no quieres completar una parte manualmente.
 * @param {number} step - El número del paso al que quieres saltar (1, 2, 3 o 4).
 */
function dev_forceFengQuestStep(step) {
    const player = gameState.player;
    const subplots = player.worldState.subplotFlags;

    switch (step) {
        case 1: // Forzar el inicio de la primera misión (encontrar herramientas)
            // Simula haber usado el compás y hablado con Feng por primera vez.
            subplots.fengQuestProgress = 1;
            const fengNpc = entityTypes['npc_maestro_feng'];
            if (!gameState.map.entities.some(e => e.npcId === 'npc_maestro_feng')) {
                 gameState.map.entities.push({
                    ...fengNpc,
                    ...fengNpc.fixedLocation,
                    id: `feng_instance_${Date.now()}`,
                    originalEntityTypeId: 'npc_maestro_feng'
                });
            }
            gameState.map.entities.find(e => e.npcId === 'npc_maestro_feng').discovered = true;
            acceptMission('mision_feng_1_tutorial');
            renderMap();
            
            const msg1 = "[DEV] Salto al Paso 1: Has encontrado a Feng y aceptado su primera misión ('El Arte de la Inscripción').\n\nPróximo paso: Traza la formación 'Sello de Iniciación' en cualquier lugar para completar el objetivo.";
            console.log(msg1);
            alert(msg1);
            break;

        case 2: // Forzar la finalización de la primera misión y el inicio de la segunda.
            subplots.fengQuestProgress = 2; // Marcas como que ya le entregaste las herramientas.
            player.secta.misionesActivas = player.secta.misionesActivas.filter(m => m.id !== 'mision_feng_1_tutorial');
            player.secta.misionesCompletadas['mision_feng_1_tutorial'] = true;
            acceptMission('mision_feng_2_prueba_vital');
            player.discoveredFormationPatterns['verdant_life_circle'] = true; // Aprender el patrón
            
            const msg2 = "[DEV] Salto al Paso 2: Has completado el tutorial de Feng. Ahora tienes la misión 'Una Prueba de Vitalidad' y has aprendido el 'Círculo de Vida Frondoso'.\n\nPróximo paso: Derrota al Treant Anciano.";
            console.log(msg2);
            alert(msg2);
            break;

        case 3: // Forzar la finalización de la segunda misión y el inicio de la tercera.
            subplots.fengQuestProgress = 3;
            player.secta.misionesActivas = player.secta.misionesActivas.filter(m => m.id !== 'mision_feng_2_prueba_vital');
            player.secta.misionesCompletadas['mision_feng_2_prueba_vital'] = true;
            acceptMission('mision_feng_3_romper_sello');
            player.discoveredFormationPatterns['arcane_vortex_array'] = true; // Aprender el patrón avanzado

            const msg3 = "[DEV] Salto al Paso 3: Has derrotado al Treant. Ahora tienes la misión final 'Rompiendo el Sello Ancestral' y has aprendido la 'Matriz del Vórtice Arcano'.\n\nPróximo paso: Derrota al Golem Ancestral usando la formación correcta.";
            console.log(msg3);
            alert(msg3);
            break;
            
        case 4: // Forzar la finalización de la misión final para recibir la recompensa.
            const mission = player.secta.misionesActivas.find(m => m.id === 'mision_feng_3_romper_sello');
            if (mission) {
                mission.progreso = 1; // Marcar el Golem como derrotado para poder entregar la misión.
                const msg4 = "[DEV] Salto al Paso 4: Has 'derrotado' al Golem Ancestral.\n\nPróximo paso: Habla con el Maestro Feng para completar la misión y recibir tu recompensa final.";
                console.log(msg4);
                alert(msg4);
            } else {
                alert("[DEV] Error: La misión final de Feng no está activa. Usa dev_forceFengQuestStep(3) primero.");
            }
            break;

        default:
            console.error(`[DEV] Paso desconocido: ${step}. Usa un número del 1 al 4.`);
            alert(`[DEV] Paso desconocido: ${step}. Usa un número del 1 al 4.`);
            break;
    }
    updateUI();
    updateSectUI();
}

/**
 * Resetea completamente la subtrama del Maestro Feng a su estado inicial.
 * Útil para probar la cadena de misiones desde el principio varias veces.
 */
function dev_resetFengQuest() {
    const player = gameState.player;

    // Resetear banderas de progreso
    player.worldState.subplotFlags.fengQuestProgress = 0;
    player.worldState.subplotFlags.completedPatternMission = undefined;
    player.worldState.subplotFlags.foundAlchemistNote = false; // Relacionado, mejor resetearlo
    player.worldState.subplotFlags.hasPlacedSondeoRune = false;

    // Quitar objetos de misión del inventario
    delete gameState.inventory["Compás Espiritual Antiguo"];
    delete gameState.inventory["Herramientas de Agrimensura de Feng"];
    delete gameState.inventory["Diagrama Roto: Círculo Vital"];
    delete gameState.inventory["Runa de Sondeo"];

    // Quitar patrones aprendidos de esta subtrama
    delete player.discoveredFormationPatterns['verdant_life_circle'];
    delete player.discoveredFormationPatterns['arcane_vortex_array'];
    delete player.discoveredFormationPatterns['fengs_initiation_seal'];

    // Eliminar las misiones de Feng de las listas activas y completadas
    const fengMissionIds = ['mision_feng_1_tutorial', 'mision_feng_2_prueba_vital', 'mision_feng_3_romper_sello'];
    player.secta.misionesActivas = player.secta.misionesActivas.filter(m => !fengMissionIds.includes(m.id));
    fengMissionIds.forEach(id => {
        delete player.secta.misionesCompletadas[id];
    });

    // Ocultar a Feng de nuevo en el mapa
    const fengInstance = gameState.map.entities.find(e => e.npcId === 'npc_maestro_feng');
    if (fengInstance) {
        fengInstance.discovered = false;
    }

    updateUI();
    updateSectUI();
    renderMap();

    const message = "[DEV] La subtrama del Maestro Feng ha sido completamente reseteada. Puedes empezar de nuevo usando dev_startFengQuest().";
    console.log(message);
    alert(message);
}
    
    </script>
    <!-- BARRA DE ACCESO RÁPIDO INFERIOR -->
    <div class="quick-slot-bar" id="quickSlotBar">
      <!-- Los slots se generarán con JavaScript -->
    </div>
  </body>
</html>
