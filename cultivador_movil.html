<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Camino del Cultivador</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", monospace;
        background: linear-gradient(135deg, #2c1810, #8b4513);
        color: #f4e4bc;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .game-container {
        display: flex;
        flex-grow: 1; /* Para que ocupe el espacio que body le da */
        /* height: 100vh; /* Se gestiona mejor con flex-grow y min-height en body */
      }

      .map-container {
        flex: 1;
        position: relative;
        background: #1a3d2e;
        border: 3px solid #d4af37;
        overflow: hidden; /* MANTENER ESTO para que el mapa no se desborde si los tiles son muy grandes */
      }

      .map {
        width: 100%; /* El div del mapa interno ocupa todo el contenedor */
        height: 100%;
        position: relative; /* Tiles se posicionan relativos a este */
        /* ... el resto de tus estilos para .map ... */
      }

      .tile {
        /* Estilos comunes para todos los tiles, si los tienes */
        position: absolute;

        display: flex;
        align-items: center;
        justify-content: center;
      }

      .player {
        z-index: 10;
        color: transparent;
        font-size: 0;
        border-radius: 0;

        background-image: url("img/tu_sprite_sheet.png"); /* ¬°TU RUTA! */
        background-repeat: no-repeat;
        background-position: 0 0; /* Se actualizar√° por JS */

        background-size: 256px 256px; /* <--- AJUSTA ESTO AL TAMA√ëO TOTAL DE TU SPRITE SHEET */

        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;

        /* El width y height del div se controlan por JS con updatePlayerVisualSize */
        /* La posici√≥n se controla por JS con updatePlayerSpriteVisual */
      }
      /* === ESTILOS PARA BARRAS SOBRE EL JUGADOR EN EL MAPA === */
      #playerOnMapBarsContainer {
        position: absolute; /* Se posicionar√° relativo a la ubicaci√≥n calculada del jugador en pantalla */
        width: 48px; /* Ancho de las barras (ajusta seg√∫n el tama√±o de tu sprite) */
        display: flex;
        flex-direction: column;
        gap: 1px; /* Peque√±o espacio entre barras */
        z-index: 15; /* Encima del jugador, pero debajo de modales y UI principal */
        pointer-events: none; /* Para que no interfieran con clics al mapa */
        /* El top y left se ajustar√°n por JS. Inicialmente pueden estar ocultas o fuera de pantalla */
        transform: translateX(
          -50%
        ); /* Ayuda a centrar si left es el centro del jugador */
        display: none; /* Inicialmente ocultas, JS las mostrar√° */
      }

      .on-map-stat-bar {
        width: 100%;
        height: 6px; /* Altura de cada barra */
        background-color: rgba(
          50,
          50,
          50,
          0.7
        ); /* Fondo oscuro para la parte vac√≠a */
        border: 1px solid rgba(0, 0, 0, 0.5);
        border-radius: 2px;
        overflow: hidden;
      }

      .on-map-stat-fill {
        height: 100%;
        transition: width 0.2s linear; /* Transici√≥n suave para cambios de valor */
      }

      #playerOnMapHpFill {
        background-color: #f44336; /* Rojo para HP */
      }

      #playerOnMapManaFill {
        background-color: #2196f3; /* Azul para Mana */
      }
      .stat-fill {
        height: 100%;
        transition: width 0.3s;
      }
      .hp-fill {
        background: linear-gradient(90deg, #ff4444, #ff6666);
      }
      .mana-fill {
        background: linear-gradient(90deg, #4444ff, #6666ff);
      }
      .exp-fill {
        background: linear-gradient(90deg, #44ff44, #66ff66);
      }
      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      /* === ESTILOS PARA BARRAS SOBRE EL SPRITE DEL JUGADOR EN BATALLA === */
      #playerInBattleSpriteBarsContainer {
        position: absolute; /* Relativo al div.character que lo contiene */
        width: 60px; /* Un poco menos que el sprite (80px) para que no sobresalga mucho */
        display: flex;
        flex-direction: column;
        gap: 1px;
        z-index: 5; /* Encima del sprite, pero no necesariamente de otros elementos del modal */
        pointer-events: none;
        /* top y left se ajustar√°n por JS. Inicialmente pueden estar ocultas o fuera de pantalla */
        transform: translateX(-50%); /* Ayuda a centrar horizontalmente */
        /* Se mostrar√°n/ocultar√°n con la pantalla de batalla */
      }

      .in-battle-sprite-stat-bar {
        width: 100%;
        height: 5px; /* M√°s delgadas que las del mapa quiz√°s */
        background-color: rgba(50, 50, 50, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.6);
        border-radius: 2px;
        overflow: hidden;
      }

      .in-battle-sprite-stat-fill {
        height: 100%;
        transition: width 0.2s linear;
      }

      #playerInBattleSpriteHpFill {
        background-color: #e53935; /* Rojo m√°s intenso para batalla */
      }

      #playerInBattleSpriteManaFill {
        background-color: #1e88e5; /* Azul m√°s intenso para batalla */
      }

      /* Ajuste para que .character sea el contexto de posicionamiento */
      .battle-area .character {
        position: relative; /* Necesario para que position:absolute de las barras funcione correctamente */
      }
      .character-sprite {
        /* Sprite del jugador en batalla */
        width: 80px;
        height: 80px;
        background-image: url("img/tu_sprite_sheet.png"); /* Tambi√©n usa la hoja de sprites */
        background-size: auto; /* O ajusta si es necesario */
        background-position: 0 0; /* Por defecto, mirando hacia abajo, frame 0 */
        background-repeat: no-repeat;
        display: inline-block;
        color: transparent;
        font-size: 0;
      }
      .sidebar {
        width: 300px;
        background: linear-gradient(180deg, #2c1810, #1a1a1a);
        border-left: 3px solid #d4af37;
        padding: 20px;
        overflow-y: auto;
      }

      .stats-panel,
      .inventory-panel,
      .controls-panel,
      .secta-panel {
        /* A√±adido secta-panel aqu√≠ */
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid #d4af37;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
      }
      /* === CORRECCI√ìN/ADICI√ìN PARA BARRAS EN EL SIDEBAR === */
      .stats-panel .stat-bar {
        /* Aseg√∫rate de que este selector sea espec√≠fico si es necesario */
        width: 100%;
        height: 15px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 7px;
        margin-top: 3px;
        margin-bottom: 12px;
        overflow: hidden;
        border: 1px solid rgba(212, 175, 55, 0.3);
        position: relative;
      }
      .inventory-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 8px;
        margin-top: 10px;
        max-height: 120px;
        overflow-y: auto;
        padding-right: 5px;
      }

      .inventory-item {
        font-size: 11px;
        padding: 5px;
        background: rgba(212, 175, 55, 0.2);
        border: 1px solid #d4af37;
        border-radius: 5px;
        text-align: center;
      }

      .hp-fill {
        background: linear-gradient(90deg, #ff4444, #ff6666);
      }
      .mana-fill {
        background: linear-gradient(90deg, #4444ff, #6666ff);
      }
      .exp-fill {
        background: linear-gradient(90deg, #44ff44, #66ff66);
      }

      /* === PANTALLA DE BATALLA === */
        .battle-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: none; /* Se cambia a flex por JS */
            flex-direction: column;
            z-index: 200;
            overflow: hidden; /* IMPORTANTE: Evitar que el contenido desborde la pantalla */
        }

        .battle-area {
            flex: 1; /* Que ocupe el espacio vertical disponible */
            display: flex;
            align-items: center;
            justify-content: space-around; /* O space-evenly */
            padding: 20px 10px; /* Reducir padding horizontal en general, especialmente para m√≥vil */
            gap: 10px; /* Espacio entre personaje y enemigo */
            overflow-y: auto; /* Si el contenido vertical es demasiado, permitir scroll DENTRO del √°rea */
        }

        .character,
        .enemy {

            padding-top: 60px;
            padding-bottom: 60px;

           /* border: 2px solid #d4af37; /* Borde m√°s delgado */
           /* border-radius: 10px;*/
            /*background: rgba(212, 175, 55, 0.1);*/
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;

            /* MODIFICACI√ìN CLAVE: Hacerlos flexibles y con tama√±o m√°ximo */
            flex-basis: 45%; /* Que cada uno intente ocupar cerca de la mitad del espacio disponible */
            max-width: 280px; /* Pero no m√°s de este ancho, incluso en escritorio si se prefiere */
            min-width: 120px; /* Un m√≠nimo para que no se colapsen demasiado */
            box-sizing: border-box; /* Asegurar que padding y border est√©n dentro del width/height */
        }


        .character-sprite,
        .enemy-sprite {
            font-size: 60px; /* Reducir tama√±o del sprite por defecto */
            margin-bottom: 10px; /* Reducir margen */
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .battle-actions {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px; /* Reducir padding */
            border-top: 2px solid #d4af37;
            flex-shrink: 0; /* Evitar que se encoja si el contenido del battle-area es grande */
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); /* Botones m√°s peque√±os */
            gap: 5px; /* Menos espacio entre botones */
            margin-bottom: 10px;
        }
        .battle-actions button { /* Estilos para los botones de acci√≥n espec√≠ficos */
            padding: 8px 10px; /* Botones m√°s peque√±os */
            font-size: 0.8em;
        }

      button {
        background: linear-gradient(135deg, #d4af37, #b8941f);
        color: #2c1810;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      button:hover {
        background: linear-gradient(135deg, #f4d03f, #d4af37);
        transform: translateY(-2px);
      }

      button:disabled {
        background: #666;
        color: #999;
        cursor: not-allowed;
        transform: none;
      }
      #toggleMapControlsBtn.hidden-during-battle {
        display: none !important; /* !important para asegurar que sobreescriba el display: block de la media query */
        }
      .log {
        background: rgba(0, 0, 0, 0.7);
        padding: 8px;
        border-radius: 8px;
        max-height: 100px;
        overflow-y: auto;
        font-size: 0.8rem;
        line-height: 1.4;
      }

      .resource {
        background: #228b22;
      }
      .monster {
        background: #8b0000;
      }
      .master {
        background: #4169e1;
      }
      .cultivation-spot {
        background: #daa520;
      }

      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 300;
        padding: 10px; /* Espacio para que el modal content no pegue a los bordes */
      }

      .modal-content {
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        border: 3px solid #d4af37;
        border-radius: 15px;
        padding: 20px; /* Reducido de 30px */
        max-width: 95%; /* Para m√≥viles */
        width: 500px; /* Ancho base */
        text-align: center;
        max-height: 90vh; /* Para modales largos */
        overflow-y: auto; /* Para modales largos */
      }

      /* Ajuste espec√≠fico para inventory-grid dentro de un modal si es necesario, */
      /* pero ya tiene su propio overflow y max-height. */

      /* Para pantallas m√°s peque√±as, ej. menos de 768px */
      @media (max-width: 768px) {
        .game-container {
          flex-direction: column;
          height: 100vh; /* Ocupa toda la altura de la ventana gr√°fica */
        }

        .sidebar {
          width: 100%;
          height: 40vh; /* Sidebar ocupa el 40% inferior */
          border-left: none;
          border-top: 3px solid #d4af37;
          overflow-y: auto;
          flex-shrink: 0; /* Evita que se encoja */
        }

        .map-container {
          height: 60vh; /* Mapa ocupa el 60% superior */
          border-bottom: none;
          flex-shrink: 0; /* Evita que se encoja */
        }

        .tile {
          width: 30px;
          height: 30px;
          font-size: 18px;
        }

        .action-buttons {
          /* Botones de batalla m√°s adaptables */
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        }
        .battle-area {
            padding: 15px 5px;
            gap: 5px;
          flex: 1;
          display: flex;
          align-items: center; /* Para centrar verticalmente los contenedores .character y .enemy */
          justify-content: space-around; /* CAMBIADO: 'space-around' distribuye el espacio
                                            uniformemente alrededor de los elementos.
                                            Prueba tambi√©n con 'space-evenly' si el resultado no te gusta.
                                            'space-between' los pegar√° a los bordes y dejar√° todo el espacio solo en el medio. */
       /*    padding: 50px; Mantenemos el padding general del √°rea de batalla */
        }
      }
      @media (max-width: 768px) {
        .character-sprite {
          width: 60px;
          height: 60px;
          /* Si la imagen del spritesheet es grande, podr√≠as necesitar ajustar background-size aqu√≠ tambi√©n */
          /* background-size: 192px 192px; /* Ejemplo si cada frame en m√≥vil es 48x48 y hay 4x4 */
        }
      }

      @media (max-width: 480px) {
        .sidebar {
          height: 45vh; /* Un poco m√°s de espacio para el sidebar en pantallas muy peque√±as */
        }
        .map-container {
          height: 55vh;
        }
        .tile {
          width: 25px;
          height: 25px;
          font-size: 16px;
        }
        .modal-content {
          padding: 15px;
        }
        button {
          padding: 10px 15px;
          font-size: 0.9em;
        } /* Botones m√°s peque√±os */

        .battle-area {
            padding: 10px 5px;
            /* Considerar seriamente apilarlos verticalmente aqu√≠ si no caben */
            /* flex-direction: column; */
            /* align-items: center; Si se apilan, centrarlos */
        }

        .character, .enemy {
            flex-basis: 48%; /* Si se mantienen lado a lado, darles un poco m√°s de espacio */
            min-width: 100px; /* M√≠nimo a√∫n m√°s peque√±o */
            padding: 5px;
        }
        /* Si se apilan verticalmente con flex-direction: column en .battle-area: */
        /*
        .character, .enemy {
            width: 90%;
            max-width: 280px;
            margin-bottom: 10px;
        }
        */

        .character-sprite, .enemy-sprite {
            font-size: 50px; /* Sprites m√°s peque√±os */
            width: 50px;
            height: 50px;
        }
    


        .character h3, .enemy h3 {
            font-size: 0.1rem;
        }
        .character div, .enemy div {
            font-size: 50px;
        }
        .character .stat-bar, .enemy .stat-bar {
            height: 8px;
        }

        .action-buttons {
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); /* Botones a√∫n m√°s adaptables */
        }
        .battle-actions button {
            padding: 6px 8px;
            font-size: 0.75em;
        }
        .log {
            max-height: 80px;
            font-size: 0.75rem;
        }
      }

      #joystick-container {
        position: fixed;
        bottom: 20px; /* Ajustado para no superponer tanto con sidebar en vista m√≥vil */
        left: 20px;
        width: 120px; /* M√°s peque√±o */
        height: 120px;
        z-index: 999; /* Un poco menos que el bot√≥n de acci√≥n y el de menu */
        display: none;
        opacity: 0.7;
      }

      #joystick-pad {
        width: 100%;
        height: 100%;
        background-color: rgba(128, 128, 128, 0.5);
        border-radius: 50%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid rgba(255, 255, 255, 0.7);
      }

      #joystick-handle {
        width: 50px; /* M√°s peque√±o */
        height: 50px;
        background-color: rgba(80, 80, 80, 0.8);
        border-radius: 50%;
        position: absolute;
        border: 2px solid rgba(200, 200, 200, 0.9);
      }

      #action-button-touch {
        position: fixed;
        bottom: 20px; /* Ajustado */
        right: 20px;
        width: 70px; /* M√°s peque√±o */
        height: 70px;
        border-radius: 50%;
        z-index: 1000;
        display: none;
        font-size: 0.8em; /* Texto m√°s peque√±o si lo tiene */
      }

      /* Mostrar el joystick y bot√≥n de acci√≥n solo en pantallas t√°ctiles o peque√±as */
      /* La visibilidad real se controla por JS, esta query es una gu√≠a */
      @media (hover: none) and (pointer: coarse), (max-width: 768px) {
        /* #joystick-container, #action-button-touch { } */
      }

      /* Bot√≥n para alternar visibilidad de controles del mapa en m√≥vil */
      #toggleMapControlsBtn {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1005;
        padding: 8px 12px;
        background-color: rgba(44, 24, 16, 0.8);
        color: #f4e4bc;
        border: 1px solid #d4af37;
        border-radius: 5px;
        font-family: "Courier New", monospace;
        font-size: 14px;
        cursor: pointer;
        display: none;
      }
      /* Mostrar bot√≥n de alternar controles solo en m√≥vil (misma query que joystick) */
      @media (hover: none) and (pointer: coarse), (max-width: 768px) {
        #toggleMapControlsBtn {
          display: block;
        }
      }

      /* NUEVOS ESTILOS PARA LA TIENDA (ya existentes y adaptados) */
      #shopModal .modal-content {
        max-width: 95%;
        width: auto; /* Permitir que se ajuste, el max-width lo limita */
        min-width: 300px; /* Para que no se colapse demasiado */
        max-height: 90vh;
        overflow-y: auto;
        padding: 20px;
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        border: 3px solid #d4af37;
        border-radius: 15px;
        display: flex;
        flex-direction: column;
      }

      .shop-container {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        flex-grow: 1;
        overflow: hidden;
      }

      .products-grid {
        display: grid;
        grid-template-columns: repeat(
          auto-fill,
          minmax(250px, 1fr)
        ); /* Reducido minmax para m√≥vil */
        gap: 15px;
        max-height: 50vh; /* Altura del scroll de productos */
        overflow-y: auto;
        padding-right: 10px;
        flex-grow: 1; /* Para que use el espacio en shop-products */
      }

      #shopModal .modal-content > div:last-child {
        /* Bot√≥n de Salir */
        margin-top: auto;
        padding-top: 20px;
        position: sticky;
        bottom: 0;
        background: linear-gradient(135deg, #2c1810, #1a1a1a);
        z-index: 10;
      }

      @media (max-width: 768px) {
        #shopModal .modal-content {
          padding: 10px;
        }

        .shop-container {
          flex-direction: column;
          overflow: visible;
        }

        .shop-filters {
          min-width: unset; /* Quitar min-width en m√≥vil */
          width: 100%;
        }
        .shop-products {
          min-width: unset;
        }

        .products-grid {
          grid-template-columns: 1fr;
          max-height: 40vh; /* Ajustar altura en m√≥viles */
        }

        #shopModal .modal-content > div:last-child {
          padding-top: 15px;
        }
        .character, .enemy {
            /* Aqu√≠ podr√≠as necesitar ajustar flex-basis si quieres que uno sea m√°s peque√±o,
            o si decides ponerlos uno encima del otro. Por ahora, se mantiene el 45% */
            padding: 8px;
        }

        /* Los sprites y sus barras sobre ellos ya tienen estilos para m√≥vil, pero podemos revisar */
        #playerInBattleSpriteBarsContainer { /* Barras SOBRE el sprite del jugador */
            width: 50px; /* Ajustar al tama√±o del sprite m√≥vil */
            /* top y left se ajustan por JS, pero el width es importante */
        }
        .in-battle-sprite-stat-bar { /* Barras individuales SOBRE sprites */
            height: 4px;
        }

        #enemyInBattleInfoContainer { /* Info SOBRE el sprite del enemigo */
            min-width: 50px;
            max-width: 100px; /* Reducir el ancho m√°ximo */
        }
        #enemyInBattleInfoContainer .enemy-battle-name-level {
            font-size: 0.1em;
        }
        #enemyInBattleInfoContainer .in-battle-sprite-stat-bar { /* Barra de vida SOBRE sprite enemigo */
            max-width: 50px; /* Ajustar al sprite */
            height: 4px;
        }
      }
      .shop-header {
        text-align: center;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid #d4af37;
        border-radius: 10px;
      }

      .shop-stats {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 10px;
        font-size: 1.1rem;
      }

      .shop-stats span {
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 15px;
        border-radius: 20px;
        border: 1px solid #d4af37;
      }

      .shop-filters {
        flex: 1;
        min-width: 250px;
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid #d4af37;
        border-radius: 10px;
        padding: 20px;
        height: fit-content;
      }

      .shop-products {
        flex: 3;
        min-width: 300px;
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid #d4af37;
        border-radius: 10px;
        padding: 20px;
        display: flex; /* Para que products-grid pueda crecer */
        flex-direction: column;
      }

      .section-title {
        color: #f4d03f;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 1px solid #d4af37;
        font-size: 1.2rem;
      }

      .search-box {
        width: 100%;
        padding: 10px 15px;
        margin-bottom: 20px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid #d4af37;
        border-radius: 5px;
        color: #f4e4bc;
        font-size: 1rem;
      }

      .search-box::placeholder {
        color: #a99a7a;
      }

      .filter-group {
        margin-bottom: 20px;
      }
      .filter-title {
        margin-bottom: 10px;
        font-weight: bold;
      }
      .category-list {
        list-style: none;
      }
      .category-item {
        padding: 8px 12px;
        margin-bottom: 5px;
        cursor: pointer;
        border-radius: 5px;
        transition: all 0.2s;
      }
      .category-item:hover {
        background: rgba(212, 175, 55, 0.2);
      }
      .category-item.active {
        background: rgba(212, 175, 55, 0.4);
        font-weight: bold;
      }

      .products-grid::-webkit-scrollbar {
        width: 8px;
      }
      .products-grid::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
      }
      .products-grid::-webkit-scrollbar-thumb {
        background: #d4af37;
        border-radius: 10px;
      }

      .product-card {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid #d4af37;
        border-radius: 8px;
        padding: 15px;
        transition: all 0.3s;
      }
      .product-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(212, 175, 55, 0.2);
      }
      .product-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .product-name {
        font-weight: bold;
        font-size: 1.1rem;
        color: #f4d03f;
      }
      .product-price {
        font-size: 1.1rem;
        color: #f4d03f;
      }
      .product-type {
        display: inline-block;
        padding: 3px 8px;
        font-size: 0.8rem;
        border-radius: 10px;
        background: rgba(212, 175, 55, 0.3);
        margin-top: 5px;
      }
      .product-description {
        margin: 10px 0;
        font-size: 0.9rem;
        color: #e6d8b5;
        min-height: 60px;
      }
      .product-stats {
        margin: 10px 0;
        padding: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        font-size: 0.9rem;
      }
      .product-stats div {
        margin-bottom: 5px;
      }
      .product-actions {
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }
      .buy-btn {
        flex-grow: 1;
        padding: 8px 15px;
        background: linear-gradient(135deg, #d4af37, #b8941f);
        color: #2c1810;
        border: none;
        border-radius: 5px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
      }
      .buy-btn:hover {
        background: linear-gradient(135deg, #f4d03f, #d4af37);
      }
      .buy-btn:disabled {
        background: #666;
        color: #999;
        cursor: not-allowed;
      }
      .pagination {
        display: flex;
        justify-content: center;
        margin-top: 20px;
        gap: 10px;
      }
      .page-btn {
        padding: 8px 15px;
        background: rgba(212, 175, 55, 0.2);
        border: 1px solid #d4af37;
        border-radius: 5px;
        color: #f4e4bc;
        cursor: pointer;
        transition: all 0.2s;
      }
      .page-btn:hover {
        background: rgba(212, 175, 55, 0.4);
      }
      .page-btn.active {
        background: rgba(212, 175, 55, 0.6);
        font-weight: bold;
      }

      .cultivation-option-btn {
        display: block;
        width: 100%;
        padding: 10px;
        margin-bottom: 8px;
        text-align: left;
      }
      /* === ESTILOS PARA INFORMACI√ìN Y BARRAS SOBRE EL SPRITE DEL ENEMIGO EN BATALLA === */
      #enemyInBattleInfoContainer {
        position: absolute; /* Relativo al div.enemy que lo contiene */
        left: 0;
        width: auto; /* Se ajustar√° al contenido, o puedes fijarlo como las del jugador */
        min-width: 70px; /* Ancho m√≠nimo para que quepa algo de texto */
        max-width: 150px; /* Evitar que sea demasiado ancho para nombres largos */
        display: flex;
        flex-direction: column;
        align-items: center; /* Centrar la barra de vida si el texto es m√°s ancho */
        gap: 2px; /* Espacio entre el nombre/nivel y la barra */
        z-index: 5; /* Encima del sprite del enemigo */
        pointer-events: none;
        transform: translateX(-50%); /* Ayuda a centrar horizontalmente */
        /* top y left se ajustar√°n por JS. Inicialmente pueden estar ocultas o fuera de pantalla */
        display: none; /* Inicialmente oculto, JS lo mostrar√° */
        padding: 2px 4px; /* Peque√±o padding interno */
        background-color: rgba(
          10,
          10,
          10,
          0.6
        ); /* Fondo semitransparente opcional */
        border-radius: 3px;
        border: 1px solid rgba(212, 175, 55, 0.3); /* Borde sutil */
      }

      .enemy-battle-name-level {
        font-size: 0.5em; /* M√°s peque√±o que el H3 principal */
        color: #f4e4bc;
        font-weight: bold;
        text-align: center;
        white-space: nowrap; /* Evitar que el nombre se parta en dos l√≠neas si es corto */
        overflow: hidden; /* Ocultar si el nombre es muy largo y excede max-width */
        text-overflow: ellipsis; /* A√±adir "..." si el nombre es muy largo */
      }

      /* Reutilizar estilos de barra si es posible, o copiar y ajustar IDs */
      #enemyInBattleInfoContainer .in-battle-sprite-stat-bar {
        /* Selector m√°s espec√≠fico */
        width: 100%; /* La barra de vida ocupa todo el ancho del contenedor de info */
        max-width: 60px; /* Pero no m√°s ancha que las barras del jugador, por ejemplo */
        height: 5px;
        background-color: rgba(50, 50, 50, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.6);
        border-radius: 2px;
        overflow: hidden;
      }

      #enemyInBattleInfoContainer .in-battle-sprite-stat-fill {
        /* Selector m√°s espec√≠fico */
        height: 100%;
        transition: width 0.2s linear;
      }

      /* Espec√≠fico para la barra de vida del enemigo sobre el sprite */
      #enemyInBattleSpriteHpFill {
        background-color: #c62828; /* Rojo un poco m√°s oscuro o diferente para el enemigo */
      }

      /* Aseg√∫rate que .enemy tambi√©n sea position: relative */
      .battle-area .enemy {
        position: relative; /* Necesario para que position:absolute de #enemyInBattleInfoContainer funcione */
        /* El padding que ya ten√≠as en .enemy ayuda a dar espacio para estas barras si se salen un poco */
      }

      /* === ESTILOS PARA LA BARRA DE NAVEGACI√ìN INFERIOR === */
      .bottom-nav-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: linear-gradient(
          180deg,
          #1a1a1a,
          #2c1810
        ); /* Invertido para que la parte m√°s oscura est√© arriba */
        border-top: 2px solid #d4af37;
        display: flex;
        justify-content: space-around; /* Distribuye los botones equitativamente */
        align-items: center;
        padding: 5px 0; /* Un poco de padding vertical */
        z-index: 150; /* Encima del mapa pero debajo de modales */
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5); /* Sombra sutil hacia arriba */
        transition: transform 0.3s ease-in-out; /* Para animar si se oculta/muestra */
      }

      /* Ocultar la barra cuando un modal o la pantalla de batalla est√©n activos */
      .bottom-nav-bar.hidden {
        transform: translateY(100%); /* Desliza hacia abajo para ocultar */
      }

      .nav-button {
        background: transparent;
        border: none;
        color: #f4e4bc;
        display: flex;
        flex-direction: column; /* Icono arriba, texto abajo */
        align-items: center;
        justify-content: center;
        padding: 8px 5px; /* Padding interno del bot√≥n */
        cursor: pointer;
        font-family: "Courier New", monospace;
        font-size: 0.75rem; /* Tama√±o del texto */
        flex-grow: 1; /* Para que los botones ocupen el espacio disponible */
        max-width: 20%; /* Para 5 botones, cada uno toma hasta el 20% */
        transition: background-color 0.2s, color 0.2s;
      }

      .nav-button:hover,
      .nav-button.active {
        /* Para resaltar el bot√≥n activo */
        background-color: rgba(212, 175, 55, 0.15);
        color: #f4d03f;
      }

      .nav-icon {
        font-size: 1.5rem; /* Tama√±o del icono */
        margin-bottom: 3px;
      }

      /* En pantallas muy peque√±as, podr√≠amos querer ocultar el texto */
      @media (max-width: 380px) {
        .nav-text {
          display: none;
        }
        .nav-icon {
          font-size: 1.8rem; /* Hacer iconos un poco m√°s grandes si no hay texto */
          margin-bottom: 0;
        }
        .nav-button {
          padding: 10px 5px;
        }
      }
      /* === AJUSTES ESPEC√çFICOS PARA M√ìVILES EN BATALLA (REVISI√ìN) === */
        @media (max-width: 768px) {
        /* Sprites en tablet */
        .character-sprite, .enemy-sprite {
            font-size: 55px; /* Ligeramente m√°s peque√±o que el default de 60px */
            width: 55px;
            height: 55px;
            margin-bottom: 8px;
        }

        #playerInBattleSpriteBarsContainer {
            width: 50px; /* Coincidir o ser un poco menor que el sprite */
        }
        .in-battle-sprite-stat-bar {
            height: 4px;
        }
        #enemyInBattleInfoContainer {
            min-width: 50px;
            max-width: 100px;
        }
        #enemyInBattleInfoContainer .enemy-battle-name-level {
            font-size: 0.7em;
        }
        #enemyInBattleInfoContainer .in-battle-sprite-stat-bar {
            max-width: 45px; /* Un poco menor que el width de playerInBattleSpriteBarsContainer */
            height: 4px;
        }
        }

        @media (max-width: 480px) { /* Pantallas muy peque√±as */
        .character-sprite, .enemy-sprite {
            font-size: 50px;
            width: 50px;
            height: 50px;
            margin-bottom: 6px;
        }

        #playerInBattleSpriteBarsContainer {
            width: 45px; /* Ajustar al tama√±o del sprite */
        }
        .in-battle-sprite-stat-bar {
            height: 3px; /* Barras m√°s delgadas */
        }

        #enemyInBattleInfoContainer {
            min-width: 45px;
            max-width: 90px;
            padding: 1px 3px;
        }
        #enemyInBattleInfoContainer .enemy-battle-name-level {
            font-size: 0.65em;
        }
        #enemyInBattleInfoContainer .in-battle-sprite-stat-bar {
            max-width: 40px;
            height: 3px;
        }
        }
    </style>
  </head>
  <body>
    <!-- PANEL LATERAL -->
    <input type="file" id="fileInput" accept=".json" style="display: none" />
    <button id="toggleMapControlsBtn">Ocultar Controles</button>
    <!-- Bot√≥n para ocultar/mostrar controles -->

    <div class="game-container">
      <div class="map-container">
        <div class="map" id="gameMap"></div>
        <div class="tile player" id="player">üßò</div>
        <div id="playerOnMapBarsContainer">
          <div class="on-map-stat-bar">
            <!-- Barra de Vida -->
            <div class="on-map-stat-fill" id="playerOnMapHpFill"></div>
          </div>
          <div class="on-map-stat-bar">
            <!-- Barra de Man√° -->
            <div class="on-map-stat-fill" id="playerOnMapManaFill"></div>
          </div>
        </div>
      </div>
      <div id="joystick-container">
        <div id="joystick-pad">
          <div id="joystick-handle"></div>
        </div>
      </div>
      <button id="action-button-touch">Acci√≥n</button>

      <div class="sidebar">
        <div class="stats-panel">
          <h3>Cultivador</h3>
          <p>Coords: <span id="playerCoords">X: 0, Y: 0</span></p>
          <!-- NUEVA L√çNEA -->
          <p>Nivel: <span id="playerLevel">1</span></p>
          <p>Reino: <span id="playerRealm">Mortal</span></p>

          <div>Vida: <span id="hpText">100/100</span></div>
          <div class="stat-bar">
            <div class="stat-fill hp-fill" id="hpBar" style="width: 100%"></div>
          </div>

          <div>Man√°: <span id="manaText">50/50</span></div>
          <div class="stat-bar">
            <div
              class="stat-fill mana-fill"
              id="manaBar"
              style="width: 100%"
            ></div>
          </div>

          <div>Experiencia: <span id="expText">0/100</span></div>
          <div class="stat-bar">
            <div class="stat-fill exp-fill" id="expBar" style="width: 0%"></div>
          </div>
        </div>

        <div class="inventory-panel">
          <h3>Inventario</h3>
          <div class="inventory-grid" id="inventory"></div>
        </div>

        <div class="controls-panel">
          <h3>Controles</h3>
          <p><strong>Escritorio:</strong></p>
          <p>WASD/Flechas: Moverse</p>
          <p>ESPACIO: Interactuar</p>
          <p style="margin-top: 5px"><strong>M√≥vil:</strong></p>
          <p>Joystick: Moverse</p>
          <p>Bot√≥n Acci√≥n: Interactuar</p>
          <p>
            "Ocultar/Mostrar Controles": Alterna visibilidad de controles
            t√°ctiles.
          </p>

          <button id="cultivateButton" onclick="toggleCultivation()">
            üßò‚Äç‚ôÄÔ∏è Cultivar
          </button>
          <button onclick="showTechniquePanel()">üìñ T√©cnicas</button>
          <button
            id="toggleQiConversionButton"
            onclick="toggleQiConversionMode()"
            style="display: none"
          >
            ‚òØÔ∏è Activar Conversi√≥n Qi
          </button>
          <button onclick="saveGame()">üíæ Guardar Partida</button>
          <button onclick="triggerFileUpload()">üìÅ Cargar Partida</button>
          <button onclick="showHelp()">‚ùì Ayuda</button>
        </div>
        <div class="secta-panel">
          <h3><span id="sectaNombreDisplay">Secta</span></h3>
          <p>Rango: <span id="playerSectRank">Disc√≠pulo Externo</span></p>
          <p>Puntos de Contribuci√≥n: <span id="playerPCS">0</span> PCS</p>
          <h4>Misiones Activas:</h4>
          <div
            id="activeMissionsList"
            style="font-size: 0.9em; max-height: 150px; overflow-y: auto"
          >
            <p>Ninguna misi√≥n activa.</p>
          </div>
        </div>
      </div>
    </div>
    <!-- FIN PANEL LATERAL -->
    <!-- Pantalla de Combate -->
    <div class="battle-screen" id="battleScreen">
      <div class="battle-area">
        <div class="character">
          <!-- NUEVO: Contenedor para barras SOBRE el sprite en batalla -->
          <div id="playerInBattleSpriteBarsContainer">
            <div class="in-battle-sprite-stat-bar">
              <!-- Barra de Vida -->
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteHpFill"
              ></div>
            </div>
            <div class="in-battle-sprite-stat-bar">
              <!-- Barra de Man√° -->
              <div
                class="in-battle-sprite-stat-fill"
                id="playerInBattleSpriteManaFill"
              ></div>
            </div>
          </div>
          <!-- FIN NUEVO -->
          <div class="character-sprite">üßò</div>
          <h3 id="playerBattleName">Cultivador</h3>
          <div>Vida: <span id="playerBattleHp">100/100</span></div>
          <div class="stat-bar">
            <div
              class="stat-fill hp-fill"
              id="playerBattleHpBar"
              style="width: 100%"
            ></div>
          </div>
        </div>

        <div class="enemy">
          <!-- === NUEVO: Contenedor para informaci√≥n y barras SOBRE el sprite del ENEMIGO === -->
          <div id="enemyInBattleInfoContainer">
            <div class="enemy-battle-name-level" id="enemyBattleNameLevel">
              Enemigo (Nv. X)
            </div>
            <div class="in-battle-sprite-stat-bar enemy-hp-bar">
              <!-- Barra de Vida del Enemigo -->
              <div
                class="in-battle-sprite-stat-fill"
                id="enemyInBattleSpriteHpFill"
              ></div>
            </div>
          </div>
          <!-- === FIN NUEVO === -->
          <div class="enemy-sprite" id="enemySprite">üëπ</div>
          <h3 id="enemyName">Demonio</h3>
          <div>Vida: <span id="enemyHp">80/80</span></div>
          <div class="stat-bar">
            <div
              class="stat-fill hp-fill"
              id="enemyHpBar"
              style="width: 100%"
            ></div>
            <div
              class="stat-fill hp-fill"
              id="enemyHpBar"
              style="width: 100%"
            ></div>
          </div>
        </div>
      </div>

      <div class="battle-actions">
        <div class="action-buttons" id="battleActionButtons">
          {/* Botones de batalla se generan por JS */}
        </div>
        <div class="log" id="battleLog"></div>
      </div>
    </div>

    <!-- Modal para Cultivo Activo  -->
    <div class="modal" id="activeCultivationModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="activeCultivationTitle">Cultivando...</h3>
        <p id="activeCultivationDescription">Concentrando tu energ√≠a...</p>

        <div id="activeCultivationProgressUI" style="display: none">
          <p>
            Progreso:
            <span id="activeCultivationTargetName">T√©cnica X</span> (Nv.
            <span id="activeCultivationTargetLevel">Y</span>)
          </p>
          <div class="stat-bar" style="background: #444; margin: 10px 0">
            <div
              class="stat-fill exp-fill"
              id="activeCultivationProgressBar"
              style="
                width: 0%;
                background: linear-gradient(90deg, #ffd700, #ffae42);
              "
            ></div>
          </div>
          <p id="activeCultivationProgressText">0s / 0s</p>
        </div>

        <div
          id="recoveryCultivationProgressUI"
          style="display: none; margin-top: 15px"
        >
          <p>Absorbiendo Qi del entorno...</p>
          <div
            class="stat-bar"
            style="background: #2c1810; margin: 10px 0; border-color: #66ccff"
          >
            <div
              class="stat-fill"
              id="recoveryProgressBar"
              style="
                width: 0%;
                background: linear-gradient(90deg, #66ccff, #99ddff);
                transition: width 0.9s linear;
              "
            ></div>
          </div>
          <p><span id="recoveryCycleText"></span></p>

          <!-- SECCI√ìN DE BARRAS DE HP Y MAN√Å PARA RECUPERACI√ìN (ya existente, la usaremos) -->
          <div style="margin-top: 15px; font-size: 0.9em">
            <div>Vida: <span id="modalHpText">100/100</span></div>
            <div class="stat-bar">
              <!-- Barra de HP en Modal -->
              <div
                class="stat-fill hp-fill"
                id="modalHpBar"
                style="width: 100%"
              ></div>
            </div>

            <div>Man√°: <span id="modalManaText">50/50</span></div>
            <div class="stat-bar">
              <!-- Barra de Man√° en Modal -->
              <div
                class="stat-fill mana-fill"
                id="modalManaBar"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <!-- FIN SECCI√ìN BARRAS -->
        </div>
        <!-- NUEVA SECCI√ìN PARA ACELERACI√ìN -->
        <div
          id="cultivationBoostSection"
          style="
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #555;
          "
        >
          <p>
            Piedras Espirituales:
            <span id="cultivationModalPlayerStones">0</span>
          </p>
          <button
            id="boostCultivationButton"
            onclick="boostCultivationProgress()"
            style="margin-top: 8px; width: 100%"
          >
            ‚ö° Acelerar Cultivo (1 Piedra = 10s)
          </button>
        </div>

        <button onclick="stopCultivation()" style="margin-top: 20px">
          üö´ Detener Cultivo
        </button>
      </div>
    </div>

    <!-- Modal para tienda -->
    <div class="modal" id="shopModal">
      <div class="modal-content">
        {/* Estilos de ancho/alto ya definidos en CSS */ }
        <div class="shop-header">
          <h2 id="shopName">Pabell√≥n de Tesoros del Drag√≥n Oculto</h2>
          <div class="shop-stats">
            <span id="playerSpiritualStones">Piedras Espirituales: 0</span>
          </div>
        </div>
        <div class="shop-container">
          <div class="shop-filters">
            <h3 class="section-title">Filtros</h3>
            <input
              type="text"
              class="search-box"
              id="shopSearch"
              placeholder="Buscar..."
            />
            <div class="filter-group">
              <div class="filter-title">Categor√≠as</div>
              <ul class="category-list" id="shopCategories">
                <li class="category-item active" data-category="all">Todas</li>
                <li class="category-item" data-category="combat">T. Combate</li>
                <li class="category-item" data-category="cultivation">
                  T. Cultivo
                </li>
                <li class="category-item" data-category="weapon">Armas</li>
                <li class="category-item" data-category="armor">Armaduras</li>
                <li class="category-item" data-category="consumable">
                  Consumibles
                </li>
                <li class="category-item" data-category="material">
                  Materiales
                </li>
                <li class="category-item" data-category="scroll">Rollos</li>
              </ul>
            </div>
            <div class="filter-group">
              <div class="filter-title">Rango de Precio</div>
              <div>
                <input
                  type="range"
                  id="priceRange"
                  min="0"
                  max="1000"
                  value="1000"
                  style="width: 100%"
                />
              </div>
              <div
                style="
                  display: flex;
                  justify-content: space-between;
                  font-size: 0.8em;
                "
              >
                <span>0 PS</span><span id="priceRangeValue">1000 PS</span>
              </div>
            </div>
          </div>
          <div class="shop-products">
            <h3 class="section-title">T√©cnicas y Objetos</h3>
            <div class="products-grid" id="shopProducts"></div>
            <div class="pagination" id="shopPagination"></div>
          </div>
        </div>
        <div>
          <button onclick="closeShopModal()" style="margin-top: 20px">
            Salir de la Tienda
          </button>
        </div>
      </div>
    </div>

    <!-- Modal para Secta -->
    <div class="modal" id="sectHallModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 id="sectHallModalTitle">Sal√≥n de la Secta del Viento Azure</h3>
        <div id="sectHallOptions">
          <p>
            Bienvenido, Disc√≠pulo <span id="sectHallPlayerRank">Externo</span>.
          </p>
          <p>Puntos de Contribuci√≥n: <span id="sectHallPlayerPCS">0</span></p>
          <hr />
          <h4>Tabl√≥n de Misiones</h4>
          <div
            id="sectHallAvailableMissions"
            style="
              max-height: 150px;
              overflow-y: auto;
              margin-bottom: 10px;
              border: 1px solid #444;
              padding: 5px;
            "
          >
            <p>Habla con el Gu√≠a Lin para nuevas asignaciones.</p>
          </div>
          <h4>Contribuciones a la Secta</h4>
          <div id="sectHallContributions" style="margin-bottom: 10px">
            <p>Visita al Administrador Yao para entregar recursos.</p>
          </div>
          <h4>Desaf√≠os de Rango</h4>
          <div id="sectHallRankChallenges" style="margin-bottom: 10px">
            <p id="sectHallChallengeStatus">
              Consulta con el Maestro de la Arena.
            </p>
          </div>
          <h4>Tienda de la Secta</h4>
          <button onclick="openSectShop()">Visitar Dep√≥sito de la Secta</button>
          <hr />
        </div>
        <button
          onclick="closeSectHallModal()"
          style="display: block; margin: 20px auto 0"
        >
          Salir del Sal√≥n
        </button>
      </div>
    </div>

    <!-- Modal para Selecci√≥n de Cultivo -->
    <div class="modal" id="cultivationChoiceModal">
      <div class="modal-content" style="max-width: 500px; text-align: left">
        <h3>¬øQu√© deseas cultivar?</h3>
        <div id="cultivationOptionsContainer">
          <button
            class="cultivation-option-btn"
            onclick="startCultivationMode('recovery')"
          >
            üßò Meditaci√≥n Restauradora
          </button>
          <hr />
          <h4>Cultivar T√©cnica:</h4>
          <div
            id="cultivableTechniquesList"
            style="max-height: 200px; overflow-y: auto"
          ></div>
        </div>
        <button
          onclick="closeCultivationChoiceModal()"
          style="margin-top: 20px"
        >
          Cancelar
        </button>
      </div>
    </div>

    <!-- Modal gen√©rico para interacciones y notificaciones -->
    <div class="modal" id="interactionModal">
      <div class="modal-content" style="max-width: 450px">
        <h3 id="modalTitle">T√≠tulo del Modal</h3>
        <p
          id="modalText"
          style="margin-top: 15px; margin-bottom: 20px; line-height: 1.5"
        >
          Texto.
        </p>
        <button onclick="closeModal()" class="close-modal-btn">Cerrar</button>
      </div>
    </div>

    <!-- Modal para T√©cnicas -->
    <div class="modal" id="techniqueModal">
      <div class="modal-content" style="max-width: 600px; text-align: left">
        <h3 style="text-align: center">T√©cnicas Aprendidas</h3>
        <div
          id="learnedTechniquesContainer"
          style="
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
          "
        ></div>
        <button
          onclick="closeTechniqueModal()"
          style="display: block; margin: 20px auto 0"
        >
          Cerrar
        </button>
      </div>
    </div>
    <!-- BARRA DE NAVEGACI√ìN INFERIOR FIJA -->
    <nav class="bottom-nav-bar" id="bottomNavBar">
      <button class="nav-button" id="navBtnInventory">
        <span class="nav-icon">üéí</span>
        <span class="nav-text">Inventario</span>
      </button>
      <button class="nav-button" id="navBtnCharacter">
        <span class="nav-icon">üë§</span>
        <span class="nav-text">Personaje</span>
      </button>
      <button class="nav-button" id="navBtnCultivate">
        <span class="nav-icon">üßò</span>
        <span class="nav-text">Cultivar</span>
      </button>
      <button class="nav-button" id="navBtnTechniques">
        <span class="nav-icon">üìñ</span>
        <span class="nav-text">T√©cnicas</span>
      </button>
      <button class="nav-button" id="navBtnMenu">
        <span class="nav-icon">‚ò∞</span>
        <span class="nav-text">Men√∫</span>
      </button>
    </nav>
    <script>
      const bottomNavBar = document.getElementById("bottomNavBar");
      const navBtnInventory = document.getElementById('navBtnInventory');
        console.log("Bot√≥n de Inventario (navBtnInventory):", navBtnInventory);     
      const navBtnCharacter = document.getElementById("navBtnCharacter");
      const navBtnCultivate = document.getElementById("navBtnCultivate");
      const navBtnTechniques = document.getElementById("navBtnTechniques");
      const navBtnMenu = document.getElementById("navBtnMenu");
      // --- ESTADO DEL JUEGO ---
      // --- ESTADO DEL JUEGO ---
      let gameState = {
        /* ... (tu gameState existente sin cambios) ... */
      };
      // Estado del juego y datos principales
      gameState = {
        player: {
          x: 11,
          y: 15,
          level: 1,
          baseMaxHp: 100,
          baseMaxMana: 50,
          baseAttack: 15,
          baseDefense: 5,
          hp: 100,
          maxHp: 100,
          mana: 50,
          maxMana: 50,
          attack: 15,
          defense: 5,
          exp: 0,
          expToNext: 100,
          realm: "Mortal",
          isCultivating: false,
          cultivationMode: {
            type: null,
            targetId: null,
            startTime: 0,
          },
          cultivationStartTime: 0,
          qiPerSecondBase: 1,
          expPerSecondBase: 0.5,
          hpPerSecondBase: 1,
          learnedTechniques: {},
          activeRefiningTechniqueId: null,
          canUseQiConversion: false,
          isQiConversionActive: false,
          worldState: {
            defeatedBosses: {},
            currentBossToSpawn: "boss_demon_general",
            defeatedFixedEntities: {},
          },
          secta: {
            nombre: "Secta del Viento Azure",
            rango: "Disc√≠pulo Externo",
            puntosContribucion: 0,
            misionesActivas: [],
            misionesCompletadas: {},
            rivalesDerrotadosClave: {},
          },
          // ---- PROPIEDADES DE ANIMACI√ìN DEL SPRITE - ASEG√öRATE QUE EST√âN AQU√ç Y CORRECTAS ----
          spriteSheetUrl: "img/personaje_cultivador_spritesheet.png",
          frameWidth: 64, // Ancho de un solo frame del sprite
          frameHeight: 64, // Alto de un solo frame del sprite
          directionRowMap: {
            // Mapeo de direcci√≥n a la fila Y en la hoja de sprites (0-indexed)
            down: 0, // Fila 0 para mirar/caminar hacia abajo
            left: 1, // Fila 1 para mirar/caminar hacia la izquierda
            right: 2, // Fila 2 para mirar/caminar hacia la derecha
            up: 3, // Fila 3 para mirar/caminar hacia arriba
          },
          animationFrames: 4, // N√∫mero de frames por direcci√≥n en la hoja
          currentFrame: 0, // Frame actual de la animaci√≥n (0 a animationFrames - 1)
          currentDirection: "down", // Direcci√≥n inicial: 'up', 'down', 'left', 'right'
          isMoving: false,
          animationTimer: null, // Para el intervalo de la animaci√≥n de caminar
          idleTimeout: null, // Para volver al estado idle despu√©s de moverse
          animationSpeed: 150, // Milisegundos entre frames de animaci√≥n
          // ---- FIN PROPIEDADES DE ANIMACI√ìN ----
          // NUEVO: Para animaci√≥n de sprites
          sprites: {
            idle: "img/personaje_cultivador_idle.png", // O 'img/personaje_cultivador_down.png' si es tu frontal
            up: "img/personaje_cultivador_up.png",
            down: "img/personaje_cultivador_down.png",
            left: "img/personaje_cultivador_left.png",
            right: "img/personaje_cultivador_right.png",
          },
          currentSpriteKey: "idle", // 'idle', 'up', 'down', 'left', 'right'
          movementAnimationTimeout: null,
          // FIN NUEVO
          burningTurns: 0,
          burnDamage: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          defenseBoostTurns: 0,
          defenseBoostAmount: 0,
          dodgeNextAttack: false,
          healingRainTurns: 0,
          healingRainAmount: 0,
          // Para Ritual de Sangre
          bloodRitualTurns: 0,
          bloodRitualAttackBoost: 0,
          // Para Aura de Pureza
          immuneTurns: 0,
          // Para Clon Fantasma
          cloneActive: false,
          cloneHealth: 0,
          cloneTurns: 0,
          // Para Elemental
          elementalTurns: 0,
          tempAttackBonus: 0,
          tempDefenseBonus: 0,
          // Para Barrera M√≠stica
          magicShieldValue: 0,
          magicShieldTurns: 0,
          // Para Cambio Temporal (si se implementa un efecto directo)
          temporalShiftTurns: 0,
        },
        cultivationInterval: null,
        inventory: {
          "Piedras Espirituales": 0,
          "Hierbas Medicinales": 0,
          "Cristales de Qi": 0,
        },
        map: {
          width: 200, // M√°s peque√±o para pruebas iniciales
          height: 200,
          defaultTerrain: "GRASSLAND",
          terrainZones: [
            // Ejemplo de Zona de Inicio cerca de la Secta (PRADERA)
            {
              x1: 10,
              y1: 10,
              x2: 29,
              y2: 29,
              type: "GRASSLAND",
              name: "Praderas de la Secta",
              spawnSettings: {
                targetEntities: [
                  // Lista de objetivos de spawn para esta zona
                  {
                    entityTypeId: "monster_secta_debil",
                    count: 10,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster", count: 10, currentCount: 0 },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "cristal_qi", count: 3, currentCount: 0 },
                  {
                    entityTypeId: "cultivator_rival_low",
                    count: 5,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0, // Cuando llegue a 0, puede reaparecer
                respawnCooldown: 300, // Segundos para reaparecer despu√©s de vaciarse o parcialmente
                lastSpawnCheck: 0, // Timestamp del √∫ltimo intento de spawn
              },
            },
            // Bosque Esmeralda
            {
              x1: 30,
              y1: 10,
              x2: 59,
              y2: 39,
              type: "FOREST",
              name: "Bosque Esmeralda",
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_bosque_lobo",
                    count: 8,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_bosque_arana",
                    count: 5,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "resource_hierbas_bosque",
                    count: 3,
                    currentCount: 0,
                  },
                  { entityTypeId: "monster_alpha", count: 5, currentCount: 0 },
                ],
                respawnTimer: 0,
                respawnCooldown: 450, // M√°s lento para recursos quiz√°
                lastSpawnCheck: 0,
              },
            },
            // Desierto Abrasador
            {
              x1: 10,
              y1: 40,
              x2: 89,
              y2: 69,
              type: "DESERT",
              name: "Desierto Abrasador",
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_desierto_escorpion",
                    count: 7,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "monster_desierto_golem_arena",
                    count: 2,
                    currentCount: 0,
                    isElite: true,
                  }, // Golem como elite
                ],
                respawnTimer: 0,
                respawnCooldown: 600,
                lastSpawnCheck: 0,
              },
            },
            // RUINAS
            {
              x1: 10,
              y1: 100,
              x2: 45,
              y2: 250,
              type: "RUINS",
              name: "Ruinas antiguas",
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "boss_ancient_golem",
                    count: 20,
                    currentCount: 0,
                  },
                  {
                    entityTypeId: "esqueleto_podrido",
                    count: 25,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // Ci√©naga Sombr√≠a
            {
              x1: 35,
              y1: 15,
              x2: 45,
              y2: 25,
              type: "SWAMP",
              name: "Ci√©naga Sombr√≠a",
              spawnSettings: {
                targetEntities: [
                  {
                    entityTypeId: "monster_cienaga_serpiente",
                    count: 4,
                    currentCount: 0,
                  },
                ],
                respawnTimer: 0,
                respawnCooldown: 400,
                lastSpawnCheck: 0,
              },
            },
            // ... otras zonas (monta√±as, ruinas, agua sin spawns de monstruos terrestres)
            {
              x1: 0,
              y1: 0,
              x2: 199,
              y2: 9,
              type: "MOUNTAIN",
              name: "Monta√±as del Norte",
            }, // Sin spawnSettings = no spawns
            // ...
            // ARENA DE LA SECTA
            {
              x1: 2,
              y1: 12,
              x2: 8,
              y2: 17, // Ejemplo de coordenadas (ajusta seg√∫n tu mapa)
              type: "ARENA", // Puedes usar 'DESERT' o crear un G_TERRAIN_TYPES.ARENA
              name: "Arena de la Secta",
              // No necesita spawnSettings por ahora, a menos que quieras peque√±os mobs decorativos all√≠.
            },
          ],
          terrainGrid: null,
          entities: [],
        },
        battle: {
          active: false,
          enemy: null,
          playerTurn: true,
        },
        gameTime: 0, // Un simple contador de segundos del juego para los temporizadores
        lastGameTimeUpdate: Date.now(),
        activeCombatAbilities: [],
      };

      // --- CONSTANTES Y DATOS DEL JUEGO --- (sin cambios, deben estar aqu√≠)
      let G_TILE_SIZE = 100; // Valor por defecto para escritorio
      const G_PLAYER_DISCOVERY_RANGE = 3;
      // --- VARIABLES GLOBALES ADICIONALES PARA CONTROL UI M√ìVIL ---
      let mapControlsManuallyHidden = false;
      let currentTileSize = G_TILE_SIZE; // Usaremos este para los c√°lculos de renderizado
      let recoveryProgress = 0;
      let recoveryDirection = 1; // 1 para aumentar, -1 para disminuir
      const RECOVERY_CYCLE_DURATION = 2;
      const G_COMBAT_ENTITY_TYPES = [
        "monster",
        "esqueleto_podrido",
        "bandido_desfiladero",
        "monster_desierto_escorpion",
        "monster_secta_debil",
        "monster_alpha",
        "cultivator_rival_low",
        "cultivator_adept_hostile",
        "boss_demon_general",
        "boss_ancient_golem",
        "monster_cienaga_serpiente",
        "monster_bosque_lobo",
        "monster_bosque_arana",
        "monster_desierto_golem_arena",
        "jabali_colmilludo_alfa",
      ];
      const G_MAX_MAP_ENTITIES = 30;
      const G_RESPAWN_THRESHOLD = 15;
      const G_SAFE_RESPAWN_X = 10;
      const G_SAFE_RESPAWN_Y = 10;
      const G_SAFE_RESPAWN_SEARCH_RADIUS = 3;
      const G_TERRAIN_TYPES = {
        GRASSLAND: { symbol: "üü©", color: "#34A853", name: "Pradera" }, // Verde para pastizales
        FOREST: { symbol: "üå≤", color: "#1E824C", name: "Bosque" }, // Verde oscuro para bosques
        MOUNTAIN: { symbol: "‚õ∞Ô∏è", color: "#A9A9A9", name: "Monta√±a" }, // Gris para monta√±as
        WATER: { symbol: "üü¶", color: "#4A86E8", name: "Agua" }, // Azul para agua (intransitable)
        RUINS: { symbol: "üèõÔ∏è", color: "#706050", name: "Ruinas" }, // Marr√≥n/Gris para ruinas
        DESERT: { symbol: "üü®", color: "#F9E79F", name: "Desierto" }, // Amarillo claro para desierto
        SWAMP: { symbol: "üü™", color: "#5D3A9A", name: "Pantano" }, // P√∫rpura/Verde oscuro para pantano
        ARENA: { symbol: "üèüÔ∏è", color: "#D2B48C", name: "Arena" },
        // A√±ade m√°s seg√∫n necesites
      };

      const PLAYER_SPRITE_FRAME_WIDTH = 64; // <--- ¬°AJUSTA ESTO AL ANCHO DE UN FRAME DE TU SPRITE!
      const PLAYER_SPRITE_FRAME_HEIGHT = 64; // <--- ¬°AJUSTA ESTO AL ALTO DE UN FRAME DE TU SPRITE!
      const PLAYER_ANIMATION_SPEED = 150; // Milisegundos entre frames de caminata (ajusta a gusto)
      const PLAYER_WALK_CYCLE = [0, 1, 0, 2]; // Los frames de columna a ciclar para caminar.
      // Si tu animaci√≥n es 0-1-2-1, ser√≠a [0,1,2,1]
      // Si es 0-1-0-2 ser√≠a [0,1,0,2] (para un efecto de pie y luego paso)
      // Para tu sprite de 4 frames por direcci√≥n: [0, 1, 2, 3] y el frame 0 es el de "quieto"
      // o puedes usar [1,2,3,0] si el 0 es un frame de paso
      // Una animaci√≥n com√∫n es "quieto" -> paso1 -> "quieto" -> paso2
      // O para ciclo continuo: paso1 -> paso2 -> paso3 -> paso4 -> paso1 ...
      // Para el sprite que mostraste, parece ser:
      // Frame 0: Quieto
      // Frame 1: Paso A
      // Frame 2: Quieto (o un frame intermedio)
      // Frame 3: Paso B
      // Entonces un ciclo podr√≠a ser [0, 1, 0, 3] o [1,0,3,0] para animaci√≥n mientras se mueve
      // O si todos son frames de paso: [0,1,2,3]
      // VAMOS A USAR UN CICLO [1,0,3,0] (asumiendo frame 0 es el base/quieto y 1,3 son pasos)
      // Si el frame 0 es un paso y el personaje se "desliza" al estar quieto, cambia esto.
      // Definir las posiciones Y del sprite sheet para cada direcci√≥n
      const PLAYER_SPRITE_DIRECTIONS_Y = {
        down: 0 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 1 (√≠ndice 0) para caminar hacia abajo
        left: 1 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 2 (√≠ndice 1) para caminar hacia la izquierda
        right: 2 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 3 (√≠ndice 2) para caminar hacia la derecha
        up: 3 * PLAYER_SPRITE_FRAME_HEIGHT, // Fila 4 (√≠ndice 3) para caminar hacia arriba
      };
      // Podr√≠amos a√±adir una propiedad 'walkable' a cada tipo de terreno
      G_TERRAIN_TYPES.MOUNTAIN.walkable = false; // Ejemplo, monta√±as podr√≠an ser no transitables
      G_TERRAIN_TYPES.WATER.walkable = false;
      // Por defecto, asumimos que son transitables si no se especifica 'walkable: false'
      const G_BLOCKING_ENTITY_TYPES = [
        "shop",
        "secta_entrada_principal",
        "npc_secta_guia",
        "npc_secta_admin",

        // A√±ade aqu√≠ otros 'originalEntityTypeId' o 'type' de entidades que deben bloquear
        // Por ejemplo, si tus NPCs tienen un 'type' espec√≠fico o los identificas por 'npcId'
      ];
      const SECTA_DATA = {
        nombre: "Secta del Viento Azure",
        rangos: [
          {
            nombre: "Disc√≠pulo Externo",
            pcsRequeridos: 0,
            beneficios: "Acceso b√°sico a la secta.",
          },
          {
            nombre: "Disc√≠pulo Interno",
            pcsRequeridos: 50,
            desafioRivalId: "rival_interno_1",
            beneficios:
              "Acceso al Patio Interno, misiones de mayor nivel, +5% ganancia de Qi al cultivar en la secta.",
          },
          {
            nombre: "Disc√≠pulo Principal",
            pcsRequeridos: 200,
            desafioRivalId: "rival_principal_1",
            beneficios:
              "Acceso a la Biblioteca de T√©cnicas (nuevas t√©cnicas), +10% ganancia de EXP en misiones de secta.",
          },
          {
            nombre: "Di√°cono",
            pcsRequeridos: 500,
            desafioRivalId: "guardian_diacono_1",
            beneficios:
              "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir peque√±os grupos de disc√≠pulos (mec√°nica futura).",
          },
          {
            nombre: "Anciano",
            pcsRequeridos: 1500,
            desafioRivalId: "guardian_anciano_1",
            beneficios:
              "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir medianos grupos de disc√≠pulos (mec√°nica futura).",
          },
          {
            nombre: "Gran Anciano",
            pcsRequeridos: 2500,
            desafioRivalId: "guardian_gran_anciano_1",
            beneficios:
              "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir grandes grupos de disc√≠pulos (mec√°nica futura).",
          },
          {
            nombre: "Maestro de Secta",
            pcsRequeridos: 5000,
            desafioRivalId: "guardian_maestro_1",
            beneficios:
              "Asignaci√≥n semanal de Piedras Espirituales, puede dirigir la secta completa (mec√°nica futura).",
          },
        ],
        npcs: {
          guia_lin: {
            nombre: "Gu√≠a Lin",
            rol: "Maestro de Reclutas",
            dialogoInicial:
              "Bienvenido, joven aspirante... ¬øEst√°s listo para empezar?",
            misionesOfrecidas: [
              "mision_recolectar_hierbas_1", // Aunque la entrega sea a Yao, Lin puede ofrecerla
              "mision_eliminar_demonios_1",
              "mision_lobos_bosque_1", // Nueva misi√≥n ofrecida por Lin
              "mision_cultivador_hostil_1", // Nueva misi√≥n ofrecida por Lin
              "mision_componentes_alquimia_1",
              "mision_investigar_anomalia_1",
              "mision_cazar_bestia_especifica_1",
              "mision_escolta_mercader_1",
              "mision_recuperar_artefacto_1",
              // ... a√±ade m√°s ID de misiones que Lin ofrezca
            ],
          },
          admin_yao: {
            nombre: "Administrador Yao",
            rol: "Intendente de la Secta",
            dialogoInicial:
              "Entrega recursos valiosos o completa encargos para ganar Puntos de Contribuci√≥n. Tambi√©n puedes adquirir algunos suministros aqu√≠.",
            aceptaRecursos: [
              "Hierbas Medicinales",
              "Cristales de Qi",
              "N√∫cleo de Bestia Menor",
            ], // ...etc.
            tiendaSectaId: "tienda_secta_basica",
            misionesOfrecidas: [
              "mision_escorpiones_desierto_1", // Nueva misi√≥n ofrecida por Yao
              // ... a√±ade m√°s ID de misiones que Yao ofrezca
            ],
          },
        },
      };
      const MISIONES_DATA = {
        mision_recolectar_hierbas_1: {
          titulo: "Suministros para la Enfermer√≠a",
          descripcion:
            "La hermana mayor Mei necesita 10 Hierbas Medicinales para reponer las existencias de la enfermer√≠a. Recolecta Hierbas Medicinales y entr√©gaselas al Administrador Yao.",
          objetivo: {
            tipo: "entregar_item",
            item: "Hierbas Medicinales",
            cantidad: 10,
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 50,
            exp: 100,
            items: { "Piedras Espirituales": 20 },
          },
          npcInicio: "guia_lin",
        },
        mision_eliminar_demonios_1: {
          titulo: "Limpiando el Bosque Perif√©rico",
          descripcion:
            "Peque√±os demonios han estado merodeando el bosque cercano a la secta. Elimina 5 Demonios Menores para asegurar el √°rea.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster",
            cantidad: 5,
            nombreDisplay: "Demonio Menor",
          },
          recompensa: {
            pcs: 75,
            exp: 150,
            items: { "Piedras Espirituales": 30 },
          },
          progreso: 0,
          npcInicio: "guia_lin",
        },
        mision_componentes_alquimia_1: {
          titulo: "Medicina Urgente",
          descripcion:
            "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Ra√≠ces de Fuego Terrenal' para una p√≠ldora vital. Se dice que crecen en zonas con fluctuaciones elementales.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "Flor de Luna Escarchada", cantidad: 3 },
              { nombre: "Ra√≠z de Fuego Terrenal", cantidad: 2 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 250,
            items: {
              "P√≠ldora de Recuperaci√≥n Menor": 2,
              "Piedras Espirituales": 50,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Externo",
        },
        mision_investigar_anomalia_1: {
          titulo: "Anomal√≠a en el Bosque Susurrante",
          descripcion:
            "Se han reportado extra√±os susurros y una energ√≠a inquietante proveniente del Bosque Susurrante al este. Investiga la fuente de la perturbaci√≥n y reporta tus hallazgos.",
          objetivo: {
            tipo: "explorar_y_reportar",
            areaClave: "BosqueSusurranteAnomalia",
            npcReporte: "guia_lin",
          },
          recompensa: {
            pcs: 100,
            exp: 200,
            items: { "Talism√°n de Percepci√≥n": 1 },
          },
          npcInicio: "guia_lin",
        },
        mision_cazar_bestia_especifica_1: {
          titulo: "La Amenaza del Jabal√≠ Colmilludo",
          descripcion:
            "Un Jabal√≠ Colmilludo particolarmente agresivo ha estado atacando a los recolectores de la secta cerca del Ca√±√≥n Rocoso. Caza a esta bestia y trae su 'Colmillo intacto' como prueba.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "jabali_colmilludo_alfa",
            itemPrueba: "Colmillo de Jabal√≠ Alfa",
            cantidadItemPrueba: 1,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 300,
            items: { "Piedras Espirituales": 70, "Carne de Bestia Ex√≥tica": 3 },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 5,
        },
        mision_escolta_mercader_1: {
          titulo: "Protecci√≥n Mercantil",
          descripcion:
            "Un mercader aliado de la secta necesita una escolta para atravesar el Desfiladero Sombr√≠o, conocido por sus bandidos. Aseg√∫rate de que llegue a salvo al Puesto Comercial del Oeste.",
          objetivo: {
            tipoSimplificado: "eliminar_enemigos_en_area",
            enemigoTipo: "bandido_desfiladero",
            cantidad: 5,
            areaNombre: "Desfiladero Sombr√≠o",
            npcReporte: "admin_yao",
          },
          recompensa: {
            pcs: 250,
            exp: 500,
            items: {
              "Mapa del Tesoro Fragmentado": 1,
              "Piedras Espirituales": 150,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Interno",
        },
        mision_recuperar_artefacto_1: {
          titulo: "El Comp√°s Espiritual Perdido",
          descripcion:
            "Un antiguo Comp√°s Espiritual, vital para la navegaci√≥n en las Ruinas Olvidadas, fue robado por cultores renegados. Inf√≠ltrate en su campamento en las colinas y recupera el artefacto.",
          objetivo: {
            tipo: "derrotar_mini_boss_y_recuperar_item",
            enemigoMiniBossId: "lider_renegado_1",
            itemArtefacto: "Comp√°s Espiritual Antiguo",
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 300,
            exp: 600,
            items: {
              "Manual de Formaci√≥n B√°sica": 1,
              "Piedras Espirituales": 200,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Interno",
          requisitoNivel: 8,
        },
        mision_desafio_interno_1: {
          titulo: "Prueba de Disc√≠pulo Interno",
          descripcion:
            "Para ser reconocido como Disc√≠pulo Interno, debes demostrar tu fuerza venciendo al Guardi√°n de la Prueba, Han Li. Encu√©ntralo en la arena de desaf√≠os de la secta.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_interno_1",
          },
          recompensa: { pcs: 200, exp: 300, nuevoRango: "Disc√≠pulo Interno" },
          autoActivarAlCumplirRequisitos: true,
        },
        mision_desafio_principal_1: {
          titulo: "Prueba de Disc√≠pulo Principal",
          descripcion:
            "La Anciana Shui espera en la arena. Demuestra que eres digno del rango de Disc√≠pulo Principal.",
          objetivo: {
            tipo: "derrotar_npc_especifico",
            npcId: "rival_principal_1",
          },
          recompensa: { pcs: 500, exp: 800, nuevoRango: "Disc√≠pulo Principal" },
          autoActivarAlCumplirRequisitos: true,
        },
        // Misiones de Ejemplo por Nivel:
        mision_lobos_bosque_1: {
          titulo: "Amenaza Lupina",
          descripcion:
            "Una manada de Lobos del Bosque se ha vuelto agresiva. El Gu√≠a Lin te pide que elimines 3 de ellos.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_bosque_lobo",
            cantidad: 3,
            nombreDisplay: "Lobo del Bosque",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 100,
            exp: 200,
            items: { "Piedras Espirituales": 50, "Colmillo de Lobo": 1 },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 5, // Se desbloquea al nivel 5
        },
        mision_escorpiones_desierto_1: {
          titulo: "Aguijones Peligrosos",
          descripcion:
            "Los Escorpiones de las Dunas est√°n causando problemas a las caravanas. Elimina 5 y reporta al Administrador Yao.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "monster_desierto_escorpion",
            cantidad: 5,
            nombreDisplay: "Escorpi√≥n de las Dunas",
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 150,
            exp: 350,
            items: { "Piedras Espirituales": 70, "Aguij√≥n de Escorpi√≥n": 2 },
          },
          npcInicio: "admin_yao", // Puede ser otro NPC
          requisitoNivel: 10, // Se desbloquea al nivel 10
        },
        mision_cultivador_hostil_1: {
          titulo: "Rivalidad Temprana",
          descripcion:
            "Un Cultivador Novato Hostil ha estado desafiando a disc√≠pulos de nuestra secta. El Gu√≠a Lin quiere que le des una lecci√≥n. Derr√≥talo.",
          objetivo: {
            tipo: "eliminar_enemigo",
            enemigoTipo: "cultivator_rival_low",
            cantidad: 1,
            nombreDisplay: "Cultivador Novato Hostil",
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 200,
            exp: 400,
            items: {
              "P√≠ldora de Recuperaci√≥n Menor": 1,
              "Piedras Espirituales": 100,
            },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 8,
        },
        // Aseg√∫rate de que las misiones que quieres que se entreguen a un NPC tengan `npcEntrega` en su `objetivo`.
        mision_componentes_alquimia_1: {
          titulo: "Medicina Urgente",
          descripcion:
            "El Alquimista de la Secta, Anciano Chen, necesita urgentemente 3 'Flores de Luna Escarchada' y 2 'Ra√≠ces de Fuego Terrenal' para una p√≠ldora vital. Se dice que crecen en zonas con fluctuaciones elementales. Entr√©galas al Administrador Yao.",
          objetivo: {
            tipo: "recolectar_multiples_items",
            items: [
              { nombre: "Flor de Luna Escarchada", cantidad: 3 },
              { nombre: "Ra√≠z de Fuego Terrenal", cantidad: 2 },
            ],
            npcEntrega: "admin_yao",
          },
          recompensa: {
            pcs: 120,
            exp: 250,
            items: {
              "P√≠ldora de Recuperaci√≥n Menor": 2,
              "Piedras Espirituales": 50,
            },
          },
          npcInicio: "guia_lin",
          requisitoRango: "Disc√≠pulo Externo",
        },
        mision_cazar_bestia_especifica_1: {
          titulo: "La Amenaza del Jabal√≠ Colmilludo",
          descripcion:
            "Un Jabal√≠ Colmilludo particolarmente agresivo ha estado atacando a los recolectores de la secta cerca del Ca√±√≥n Rocoso. Caza a esta bestia y trae su 'Colmillo intacto' como prueba al Gu√≠a Lin.",
          objetivo: {
            tipo: "cazar_y_recuperar_item_de_loot",
            enemigoTipo: "jabali_colmilludo_alfa",
            itemPrueba: "Colmillo de Jabal√≠ Alfa",
            cantidadItemPrueba: 1,
            npcEntrega: "guia_lin",
          },
          recompensa: {
            pcs: 150,
            exp: 300,
            items: { "Piedras Espirituales": 70, "Carne de Bestia Ex√≥tica": 3 },
          },
          npcInicio: "guia_lin",
          requisitoNivel: 5,
        },
      };

      const shopData = {
        name: "Pabell√≥n de Tesoros del Drag√≥n Oculto",
        inventory: [
          { itemName: "Hierbas Medicinales", price: 1, stock: 100 },
          { itemName: "Cristales de Qi", price: 1, stock: 100 },
          {
            itemName: "Espada de Hierro",
            type: "equipment",
            category: "weapon",
            attackBonus: 5,
            price: 50,
            stock: 1,
            description: "Una espada b√°sica pero fiable. (+5 Ataque)",
          },
          { itemName: "Rollo: Absorci√≥n de Qi Menor", price: 15, stock: 10 },
          { itemName: "Rollo: Corte de Espada B√°sico", price: 50, stock: 10 },
          { itemName: "Rollo: Conversi√≥n de Qi", price: 25, stock: 10 },
          { itemName: "Rollo: Prisi√≥n de Hielo", price: 180, stock: 5 },
          { itemName: "Rollo: Golpe de Llamas", price: 170, stock: 5 },
          { itemName: "Rollo: Furia del Trueno", price: 190, stock: 5 },
          { itemName: "Rollo: Dardo Venenoso", price: 150, stock: 5 },
          { itemName: "Rollo: Piel de Piedra", price: 175, stock: 5 },
          { itemName: "Rollo: Paso de las Sombras", price: 220, stock: 3 },
          { itemName: "Rollo: Drenaje de Alma", price: 200, stock: 3 },
          { itemName: "Rollo: Golpe Cicl√≥n", price: 250, stock: 3 },
          { itemName: "Rollo: Lluvia Curativa", price: 210, stock: 3 },
          { itemName: "Rollo: Explosi√≥n Mental", price: 230, stock: 3 },
          { itemName: "Rollo: Voluntad de Hierro", price: 200, stock: 3 },
          { itemName: "Rollo: Flecha Celestial", price: 280, stock: 2 },
          { itemName: "Rollo: Abrazo de la Naturaleza", price: 190, stock: 3 },
          { itemName: "Rollo: Rugido de Drag√≥n", price: 300, stock: 2 },
          { itemName: "Rollo: Clon Fantasma", price: 240, stock: 2 },
          { itemName: "Rollo: Cambio Temporal", price: 260, stock: 2 },
          { itemName: "Rollo: Ritual de Sangre", price: 210, stock: 3 },
          { itemName: "Rollo: Aura de Pureza", price: 230, stock: 3 },
          { itemName: "Rollo: Invocar Elemental", price: 320, stock: 1 },
          { itemName: "Rollo: Barrera M√≠stica", price: 220, stock: 3 },
        ],
      };
      const techniqueData = {
        qi_absorption_boost_1: {
          id: "qi_absorption_boost_1",
          name: "T√©cnica de Absorci√≥n de Qi Menor",
          description:
            "Aumenta la cantidad de Qi ganado por segundo al cultivar en 0.5.",
          type: "passive_cultivation",
          effect: { statToBoost: "qiPerSecondBase", value: 0.5 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 60,
            levelTimeMultiplier: 1.5,
          },
          refinementCost: {
            baseTime: 30,
            materials: { "Piedras Espirituales": 20 },
            levelRequirement: 1,
          },
          icon: "üìú",
        },
        body_fortification_1: {
          id: "body_fortification_1",
          name: "Fortificaci√≥n Corporal B√°sica",
          description:
            "Aumenta tu Defensa base permanentemente en 1 por nivel de refinamiento.",
          type: "passive_stat",
          effect: { statToBoost: "baseDefense", value: 1 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 2,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Hierbas Medicinales": 3, "Piedras Espirituales": 10 },
            levelRequirement: 3,
          },
          icon: "üí™",
        },
        sword_slash_1: {
          id: "sword_slash_1",
          name: "Corte de Espada B√°sico",
          description:
            "Desbloquea la habilidad de combate 'Corte de Espada'. Causa da√±o f√≠sico adicional. Mejora con refinamiento.",
          type: "active_ability",
          abilityId: "sword_slash",
          effect: { baseDamageMultiplier: 1.2 },
          manaCost: 10,
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          refinementCost: {
            baseTime: 45,
            materials: { "Cristales de Qi": 2, "Piedras Espirituales": 20 },
            levelRequirement: 5,
          },
          icon: "‚öîÔ∏è",
        },
        qi_to_hp_conversion_1: {
          id: "qi_to_hp_conversion_1",
          name: "T√©cnica de Conversi√≥n de Qi",
          description:
            "Permite activar/desactivar la conversi√≥n de Man√° en HP al cultivar. Mejora la tasa de conversi√≥n y eficiencia con cada nivel de refinamiento.",
          type: "active_refinement_effect",
          effect: {
            baseManaCostPerSecond: 2.0,
            baseHpGainPerSecond: 1.0,
            hpGainIncreasePerLevel: 2,
            manaCostReductionPerLevel: 0.1,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 90,
            levelTimeMultiplier: 1.6,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Cristales de Qi": 5, "Piedras Espirituales": 10 },
            levelRequirement: 1,
          },
          icon: "‚òØÔ∏è",
        },
        ice_prison_1: {
          id: "ice_prison_1",
          name: "Prisi√≥n de Hielo",
          description: "Congela al enemigo, inmoviliz√°ndolo por 1-2 turnos.",
          type: "active_ability",
          abilityId: "ice_prison",
          effect: { freezeDuration: 1, freezeChance: 0.7, manaCost: 25 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 120,
            levelTimeMultiplier: 1.7,
          },
          refinementCost: {
            baseTime: 40,
            materials: { "Cristal de Hielo": 3, "Piedras Espirituales": 40 },
            levelRequirement: 8,
          },
          icon: "‚ùÑÔ∏è",
        },
        flame_strike_1: {
          id: "flame_strike_1",
          name: "Golpe de Llamas",
          description:
            "Ataque de fuego que causa da√±o inicial y quemadura continua.",
          type: "active_ability",
          abilityId: "flame_strike",
          effect: {
            baseDamageMultiplier: 0.9,
            burnDamagePerTurn: 5,
            burnDuration: 3,
            manaCost: 30,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 120,
            levelTimeMultiplier: 1.7,
          },
          refinementCost: {
            baseTime: 45,
            materials: { "Esencia de Fuego": 2, "Piedras Espirituales": 35 },
            levelRequirement: 10,
          },
          icon: "üî•",
        },
        thunder_fury_1: {
          id: "thunder_fury_1",
          name: "Furia del Trueno",
          description: "Ataque el√©ctrico que aturde al enemigo por 1 turno.",
          type: "active_ability",
          abilityId: "thunder_fury",
          effect: { baseDamageMultiplier: 1.1, stunChance: 0.6, manaCost: 35 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 130,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 50,
            materials: { "N√∫cleo de Tormenta": 1, "Piedras Espirituales": 45 },
            levelRequirement: 12,
          },
          icon: "‚ö°",
        },
        poison_dart_1: {
          id: "poison_dart_1",
          name: "Dardo Venenoso",
          description: "Envenena al enemigo causando da√±o por varios turnos.",
          type: "active_ability",
          abilityId: "poison_dart",
          effect: {
            baseDamageMultiplier: 0.4,
            poisonDamagePerTurn: 8,
            poisonDuration: 4,
            manaCost: 20,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 110,
            levelTimeMultiplier: 1.6,
          },
          refinementCost: {
            baseTime: 35,
            materials: { "Venenos Mortales": 4, "Piedras Espirituales": 30 },
            levelRequirement: 6,
          },
          icon: "‚ò†Ô∏è",
        },
        stone_skin_1: {
          id: "stone_skin_1",
          name: "Piel de Piedra",
          description: "Aumenta tu defensa temporalmente durante el combate.",
          type: "active_ability",
          abilityId: "stone_skin",
          effect: { defenseBoost: 15, duration: 3, manaCost: 25 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 125,
            levelTimeMultiplier: 1.7,
          },
          refinementCost: {
            baseTime: 40,
            materials: { "Fragmentos de Jade": 5, "Piedras Espirituales": 35 },
            levelRequirement: 9,
          },
          icon: "ü™®",
        },
        shadow_step_1: {
          id: "shadow_step_1",
          name: "Paso de las Sombras",
          description: "Teletransportaci√≥n corta que evita el pr√≥ximo ataque.",
          type: "active_ability",
          abilityId: "shadow_step",
          effect: { dodgeChance: 0.8, manaCost: 40 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 140,
            levelTimeMultiplier: 1.9,
          },
          refinementCost: {
            baseTime: 55,
            materials: { "Esencia Oscura": 3, "Piedras Espirituales": 50 },
            levelRequirement: 14,
          },
          icon: "üë£",
        },
        soul_drain_1: {
          id: "soul_drain_1",
          name: "Drenaje de Alma",
          description: "Roba vida del enemigo y cura al usuario.",
          type: "active_ability",
          abilityId: "soul_drain",
          effect: {
            baseDamageMultiplier: 0.7,
            lifeStealPercent: 0.5,
            manaCost: 30,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 130,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 45,
            materials: { "Almas Condenadas": 2, "Piedras Espirituales": 40 },
            levelRequirement: 11,
          },
          icon: "üíÄ",
        },
        cyclone_strike_1: {
          id: "cyclone_strike_1",
          name: "Golpe Cicl√≥n",
          description: "Ataque de √°rea que da√±a a todos los enemigos.",
          type: "active_ability",
          abilityId: "cyclone_strike",
          effect: { baseDamageMultiplier: 0.8, aoeDamage: true, manaCost: 45 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 150,
            levelTimeMultiplier: 2.0,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "N√∫cleo de V√≥rtice": 1, "Piedras Espirituales": 55 },
            levelRequirement: 15,
          },
          icon: "üå™Ô∏è",
        },
        healing_rain_1: {
          id: "healing_rain_1",
          name: "Lluvia Curativa",
          description: "Cura al usuario y a aliados cercanos cada turno.",
          type: "active_ability",
          abilityId: "healing_rain",
          effect: { healPerTurn: 20, duration: 3, manaCost: 35 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 135,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 50,
            materials: { "Roc√≠o Celestial": 4, "Piedras Espirituales": 40 },
            levelRequirement: 12,
          },
          icon: "üåßÔ∏è",
        },
        mind_blast_1: {
          id: "mind_blast_1",
          name: "Explosi√≥n Mental",
          description: "Da√±o basado en man√° y reduce la defensa del enemigo.",
          type: "active_ability",
          abilityId: "mind_blast",
          effect: {
            baseDamageMultiplier: 0.6,
            manaDamageMultiplier: 0.3,
            defenseReduction: 5,
            manaCost: 40,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 145,
            levelTimeMultiplier: 1.9,
          },
          refinementCost: {
            baseTime: 55,
            materials: { "Cristales Ps√≠quicos": 3, "Piedras Espirituales": 45 },
            levelRequirement: 13,
          },
          icon: "üß†",
        },
        iron_will_1: {
          id: "iron_will_1",
          name: "Voluntad de Hierro",
          description:
            "Reduce el da√±o recibido y aumenta la resistencia a efectos.",
          type: "passive_stat",
          effect: { statToBoost: "damageReduction", value: 0.05 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 160,
            levelTimeMultiplier: 2.1,
          },
          refinementCost: {
            baseTime: 50,
            materials: {
              "Mineral de Hierro Espiritual": 5,
              "Piedras Espirituales": 40,
            },
            levelRequirement: 10,
          },
          icon: "üõ°Ô∏è",
        },
        celestial_arrow_1: {
          id: "celestial_arrow_1",
          name: "Flecha Celestial",
          description:
            "Ataque de largo alcance que ignora la defensa del enemigo.",
          type: "active_ability",
          abilityId: "celestial_arrow",
          effect: {
            baseDamageMultiplier: 1.2,
            ignoreDefense: true,
            manaCost: 50,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 170,
            levelTimeMultiplier: 2.2,
          },
          refinementCost: {
            baseTime: 60,
            materials: { "Plumas de F√©nix": 2, "Piedras Espirituales": 60 },
            levelRequirement: 16,
          },
          icon: "üèπ",
        },
        nature_grasp_1: {
          id: "nature_grasp_1",
          name: "Abrazo de la Naturaleza",
          description:
            "Enreda al enemigo reduciendo su velocidad y causando da√±o continuo.",
          type: "active_ability",
          abilityId: "nature_grasp",
          effect: {
            baseDamageMultiplier: 0.5,
            rootDuration: 2,
            damagePerTurn: 7,
            manaCost: 30,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 120,
            levelTimeMultiplier: 1.7,
          },
          refinementCost: {
            baseTime: 45,
            materials: {
              "Semillas Ancestrales": 4,
              "Piedras Espirituales": 35,
            },
            levelRequirement: 9,
          },
          icon: "üåø",
        },
        dragon_roar_1: {
          id: "dragon_roar_1",
          name: "Rugido de Drag√≥n",
          description: "Aturde y asusta a los enemigos, reduciendo su ataque.",
          type: "active_ability",
          abilityId: "dragon_roar",
          effect: {
            aoeStunChance: 0.4,
            attackReduction: 10,
            duration: 2,
            manaCost: 55,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 180,
            levelTimeMultiplier: 2.3,
          },
          refinementCost: {
            baseTime: 65,
            materials: { "Escamas de Drag√≥n": 3, "Piedras Espirituales": 70 },
            levelRequirement: 18,
          },
          icon: "üêâ",
        },
        phantom_clone_1: {
          id: "phantom_clone_1",
          name: "Clon Fantasma",
          description: "Crea un clon que distrae a los enemigos.",
          type: "active_ability",
          abilityId: "phantom_clone",
          effect: {
            cloneHealth: 30,
            duration: 2,
            aggroChance: 0.8,
            manaCost: 40,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 150,
            levelTimeMultiplier: 2.0,
          },
          refinementCost: {
            baseTime: 50,
            materials: { "Espejos Astrales": 2, "Piedras Espirituales": 45 },
            levelRequirement: 12,
          },
          icon: "üë§",
        },
        temporal_shift_1: {
          id: "temporal_shift_1",
          name: "Cambio Temporal",
          description: "Ralentiza a los enemigos y aumenta tu velocidad.",
          type: "active_ability",
          abilityId: "temporal_shift",
          effect: {
            enemySlow: 0.3,
            playerSpeedBoost: 0.4,
            duration: 3,
            manaCost: 45,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 160,
            levelTimeMultiplier: 2.1,
          },
          refinementCost: {
            baseTime: 55,
            materials: { "Relojes de Arena": 3, "Piedras Espirituales": 50 },
            levelRequirement: 14,
          },
          icon: "‚è≥",
        },
        blood_ritual_1: {
          id: "blood_ritual_1",
          name: "Ritual de Sangre",
          description: "Sacrifica vida para aumentar dr√°sticamente tu ataque.",
          type: "active_ability",
          abilityId: "blood_ritual",
          effect: { hpCost: 20, attackBoost: 30, duration: 3, manaCost: 25 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 130,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 40,
            materials: { "Sangre de Demonio": 3, "Piedras Espirituales": 35 },
            levelRequirement: 11,
          },
          icon: "ü©∏",
        },
        aura_of_purity_1: {
          id: "aura_of_purity_1",
          name: "Aura de Pureza",
          description: "Elimina efectos negativos y otorga inmunidad temporal.",
          type: "active_ability",
          abilityId: "aura_of_purity",
          effect: { cleanseEffects: true, immunityDuration: 2, manaCost: 35 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 140,
            levelTimeMultiplier: 1.9,
          },
          refinementCost: {
            baseTime: 45,
            materials: {
              "L√°grimas de Unicornio": 2,
              "Piedras Espirituales": 40,
            },
            levelRequirement: 13,
          },
          icon: "‚ú®",
        },
        summon_elemental_1: {
          id: "summon_elemental_1",
          name: "Invocar Elemental",
          description:
            "Invoca un elemental que lucha a tu lado durante el combate.",
          type: "active_ability",
          abilityId: "summon_elemental",
          effect: {
            elementalType: "fire",
            elementalHealth: 50,
            elementalAttack: 20,
            duration: 4,
            manaCost: 60,
          },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 190,
            levelTimeMultiplier: 2.4,
          },
          refinementCost: {
            baseTime: 65,
            materials: { "N√∫cleo Elemental": 1, "Piedras Espirituales": 65 },
            levelRequirement: 17,
          },
          icon: "üåã",
        },
        mystic_barrier_1: {
          id: "mystic_barrier_1",
          name: "Barrera M√≠stica",
          description: "Crea un escudo que absorbe da√±o m√°gico.",
          type: "active_ability",
          abilityId: "mystic_barrier",
          effect: { magicShield: 40, duration: 3, manaCost: 35 },
          maxLevel: 100,
          cultivationSettings: {
            baseTimeToLevelUp: 135,
            levelTimeMultiplier: 1.8,
          },
          refinementCost: {
            baseTime: 45,
            materials: { "Polvo de Arcano": 4, "Piedras Espirituales": 40 },
            levelRequirement: 12,
          },
          icon: "üîÆ",
        },
      };
      const entityTypes = {
        //FIJOS
        shop: {
          symbol: "üè™",
          name: "Tienda Misteriosa",
          interaction: "browse",
          type: "shop", // 'type' es importante para la interacci√≥n
          // fixedX: 12, // Podr√≠as tener esto
          // fixedY: 13, // O esto
          fixedLocation: { x: 12, y: 13 }, // O esto (preferiblemente esto)
          discovered: true, // ¬°IMPORTANTE para que se muestre desde el inicio!
        },

        secta_entrada_principal: {
          symbol: "‚õ©Ô∏è",
          name: "Sal√≥n Principal de la Secta",
          interaction: "access_sect_hall",
          // fixedX: 12, // Si ten√≠as esto antes
          // fixedY: 15, // Si ten√≠as esto antes
          // ASEG√öRATE DE TENER ESTO EN SU LUGAR:
          fixedLocation: { x: 15, y: 15 }, // O las coordenadas correctas para tu secta
        },

        // --- ELEMENTOS DECORATIVOS ---
        deco_arbol_grande: {
          symbol: "üå≥",
          name: "Arbol Ancestral",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_peque√±o: {
          symbol: "üå≥",
          name: "Pino",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_arbol_normal: {
          symbol: "üå≥",
          name: "Otro arbol",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_roca_musgosa: {
          symbol: "ü™®",
          name: "Roca Musgosa",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        },
        deco_ruina_pilar: {
          symbol: "üèõ",
          name: "Pilar Ca√≠do",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        }, // Usar un s√≠mbolo diferente si 'üèõÔ∏è' ya est√° en uso
        deco_flor_rara: {
          symbol: "üå∏",
          name: "Flor Luminiscente",
          isDecorative: true,
          noInteraction: true,
          discovered: true,
        }, // Diferente de tu lugar de cultivo
        // ... a√±ade m√°s seg√∫n necesites
        //NPCS
        master: {
          symbol: "üë¥",
          name: "Maestro Anciano",
          teaching: "t√©cnica",
          expGain: 50,
          interaction: "learn_from_master",
        },
        npc_secta_guia: {
          symbol: "üë®‚Äçüè´",
          name: "Gu√≠a Lin",
          interaction: "talk_secta_npc",
          npcId: "guia_lin",
          fixedLocation: { x: 13, y: 15 },
        },
        npc_secta_admin: {
          symbol: " üë¥",
          name: "Administrador Yao",
          interaction: "talk_secta_npc",
          npcId: "admin_yao",
          fixedLocation: { x: 13, y: 16 },
        },
        rival_interno_1: {
          symbol: "üò†",
          name: "Han Li (Guardi√°n Interno)",
          typeOverride: "monster",
          hp: 250,
          attack: 60,
          defense: 15,
          exp: 150,
          maxHp: 250,
          isSectChallengeRival: true,
          npcId: "rival_interno_1",
          fixedLocation: { x: 5, y: 12 },
        },
        rival_principal_1: {
          symbol: "üò°",
          name: "Anciana Shui (Prueba Principal)",
          typeOverride: "monster",
          hp: 600,
          attack: 90,
          defense: 25,
          exp: 400,
          maxHp: 600,
          isSectChallengeRival: true,
          npcId: "rival_principal_1",
          fixedLocation: { x: 4, y: 12 },
          specialChance: 0.2,
          specialAttackMultiplier: 1.6,
        },
        //== FIN NPC===
        //RECURSOS
        cristal_qi: {
          symbol: "üíé",
          name: "Cristal de Qi",
          reward: "Cristales de Qi",
          interaction: "collect_resource",
        },
        cultivation: {
          symbol: "üå∏",
          name: "Lugar de Cultivo",
          benefit: "mana",
          manaGain: 20,
          interaction: "meditate_spot",
        },
        resource_hierbas_bosque: {
          symbol: "üåø", // <--- ¬°ASEG√öRATE DE QUE ESTO EST√â!
          name: "Hierbas del Bosque Profundo",
          type: "resource",
          reward: "Hierbas Medicinales",
          interaction: "collect_resource",
        },
        //ENEMIGOS
        monster: {
          symbol: "üëπ",
          name: "Demonio Menor",
          hp: 60,
          attack: 30,
          defense: 2,
          exp: 25,
          maxHp: 60,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_secta_debil: {
          symbol: "üêæ",
          name: "Bestia Menor de Pradera",
          hp: 40,
          attack: 30,
          defense: 1,
          exp: 12,
          maxHp: 40,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_bosque_lobo: {
          symbol: "üê∫",
          name: "Lobo del Bosque",
          hp: 70,
          attack: 40,
          defense: 3,
          exp: 20,
          maxHp: 70,
          lootTable: [
            { itemName: "Colmillo de Lobo", quantity: [1, 1], chance: 0.4 },
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.6,
            },
            { itemName: "Carne Fresca", quantity: [1, 2], chance: 0.6 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },
        monster_bosque_arana: {
          symbol: "üï∑Ô∏è",
          name: "Ara√±a Tejesombras",
          hp: 50,
          attack: 45,
          defense: 5,
          exp: 18,
          maxHp: 50,
          lootTable: [
            { itemName: "Seda de Ara√±a", quantity: [1, 3], chance: 0.7 },
            { itemName: "Veneno D√©bil", quantity: [1, 1], chance: 0.2 },
            { itemName: "Piedras Espirituales", quantity: [1, 2], chance: 1 },
          ],
        },

        monster_desierto_escorpion: {
          symbol: "ü¶Ç",
          name: "Escorpi√≥n de las Dunas",
          hp: 90,
          attack: 30,
          defense: 8,
          exp: 35,
          maxHp: 90,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              name: "Aguij√≥n venenoso",
              damageMultiplier: 2.0,
              chance: 0.2,
              type: "area_attack_simulated",
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Aguij√≥n de Escorpi√≥n", quantity: [1, 1], chance: 0.5 },
            { itemName: "Quitina Resistente", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [2, 4], chance: 1 },
          ],
        },
        monster_desierto_golem_arena: {
          symbol: "üß±",
          name: "Golem de Tormenta de Arena",
          hp: 200,
          attack: 35,
          defense: 15,
          exp: 80,
          maxHp: 200,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              name: "Tornado de arena",
              damageMultiplier: 2.0,
              chance: 0.2,
              type: "area_attack_simulated",
            },
            {
              name: "stone_skin_1",
              effect: { defenseBoost: 15, duration: 3, manaCost: 25 },
              chance: 0.2,
              type: "area_attack_simulated",
            },
          ],
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "N√∫cleo de Arena", quantity: [1, 1], chance: 0.6 },
            { itemName: "Fragmento Des√©rtico", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [4, 8], chance: 1 },
          ],
        },
        monster_cienaga_serpiente: {
          symbol: "üêç",
          name: "Serpiente de Ci√©naga",
          hp: 60,
          attack: 28,
          defense: 2,
          exp: 22,
          maxHp: 60,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          abilities: [
            {
              name: "Mordida Venenosa",
              damageMultiplier: 2.0,
              chance: 0.4,
              type: "area_attack_simulated",
            },
          ],
          lootTable: [
            { itemName: "Escama de Serpiente", quantity: [1, 2], chance: 0.5 },
            {
              itemName: "Ra√≠z de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.3,
            },
            { itemName: "Veneno de Ci√©naga", quantity: [1, 1], chance: 0.3 },
            { itemName: "Piedras Espirituales", quantity: [2, 4], chance: 1 },
          ],
        },
        cultivator_rival_low: {
          symbol: "üò†",
          name: "Cultivador Novato Hostil",
          hp: 150,
          attack: 50,
          defense: 5,
          exp: 80,
          maxHp: 150,
          specialChance: 0.2,
          specialAttackMultiplier: 1.5,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
          ],
        },
        monster_alpha: {
          symbol: "üê∫",
          name: "Demonio Alfa",
          hp: 200,
          attack: 60,
          defense: 4,
          exp: 35,
          maxHp: 200,
          lootTable: [
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 1 },
            { itemName: "Hierbas Medicinales", quantity: [1, 3], chance: 0.3 },
            {
              itemName: "N√∫cleo de Bestia Menor",
              quantity: [1, 1],
              chance: 0.25,
            },
            { itemName: "Cristal de Hielo", quantity: [1, 2], chance: 0.1 },
            { itemName: "Esencia de Fuego", quantity: [1, 2], chance: 0.1 },
            { itemName: "Piedras Espirituales", quantity: [4, 10], chance: 1 },
          ],
        },
        cultivator_adept_hostile: {
          symbol: "üò°",
          name: "Cultivador Adepto Agresivo",
          hp: 400,
          attack: 80,
          defense: 10,
          exp: 250,
          maxHp: 400,
          specialChance: 0.25,
          specialAttackMultiplier: 1.7,
          healChance: 0.1,
          lootTable: [
            { itemName: "Piedras Espirituales", quantity: [1, 10], chance: 1 },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
            { itemName: "Venenos Mortales", quantity: [1, 3], chance: 0.05 },
            { itemName: "Fragmentos de Jade", quantity: [1, 2], chance: 0.02 },
            { itemName: "Esencia Oscura", quantity: [1, 1], chance: 0.05 },
            {
              itemName: "Rollo: Dardo Venenoso",
              quantity: [1, 1],
              chance: 0.05,
            },
            {
              itemName: "Rollo: Piel de Piedra",
              quantity: [1, 1],
              chance: 0.05,
            },
            {
              itemName: "Rollo: Voluntad de Hierro",
              quantity: [1, 1],
              chance: 0.015,
            },
            {
              itemName: "Rollo: Flecha Celestial",
              quantity: [1, 1],
              chance: 0.05,
            },
            {
              itemName: "Rollo: Abrazo de la Naturaleza",
              quantity: [1, 1],
              chance: 0.01,
            },
            {
              itemName: "Rollo: Rugido de Drag√≥n",
              quantity: [1, 1],
              chance: 0.01,
            },
            {
              itemName: "Rollo: Clon Fantasma",
              quantity: [1, 1],
              chance: 0.01,
            },
          ],
        },

        flor_luna_escarchada_guardian: {
          symbol: "‚ùÑÔ∏è",
          name: "Esp√≠ritu de Hielo Protector",
          typeOverride: "monster",
          hp: 120,
          attack: 35,
          defense: 10,
          exp: 40,
          maxHp: 120,
          lootTable: [
            {
              itemName: "Flor de Luna Escarchada",
              quantity: [1, 2],
              chance: 0.8,
            },
            { itemName: "Cristales de Qi", quantity: [1, 3], chance: 0.3 },
          ],
        },
        raiz_fuego_terrenal_elemental: {
          symbol: "üî•",
          name: "Elemental de Magma Menor",
          typeOverride: "monster",
          hp: 150,
          attack: 40,
          defense: 5,
          exp: 45,
          maxHp: 150,
          lootTable: [
            {
              itemName: "Ra√≠z de Fuego Terrenal",
              quantity: [1, 1],
              chance: 0.7,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [5, 10],
              chance: 0.5,
            },
          ],
        },
        bandido_desfiladero: {
          symbol: "üò†",
          name: "Bandido del Desfiladero",
          typeOverride: "monster",
          hp: 180,
          attack: 45,
          defense: 10,
          exp: 60,
          maxHp: 180,
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 30],
              chance: 0.5,
            },
            { itemName: "Daga Oxidada", quantity: [1, 1], chance: 0.2 },
          ],
        },

        esqueleto_podrido: {
          symbol: "üíÄ",
          name: "Esqueleto podrido",
          typeOverride: "monster",
          hp: 180,
          attack: 45,
          defense: 10,
          exp: 60,
          maxHp: 180,
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [10, 30],
              chance: 0.5,
            },
            { itemName: "Daga Oxidada", quantity: [1, 1], chance: 0.2 },
          ],
        },
        //MINIBOSSES
        jabali_colmilludo_alfa: {
          symbol: "üêó",
          name: "Jabal√≠ Colmilludo Alfa",
          typeOverride: "monster",
          hp: 300,
          attack: 55,
          defense: 20,
          exp: 120,
          maxHp: 300,
          isMiniBoss: true,
          lootTable: [
            {
              itemName: "Colmillo de Jabal√≠ Alfa",
              quantity: [1, 1],
              chance: 0.9,
            },
            {
              itemName: "Carne de Bestia Ex√≥tica",
              quantity: [1, 3],
              chance: 0.6,
            },
            { itemName: "Piel Resistente", quantity: [1, 2], chance: 0.4 },
            { itemName: "Piedras Espirituales", quantity: [4, 10], chance: 1 },
          ],
          fixedLocation: { x: 5, y: 23 },
        },

        lider_renegado_1: {
          symbol: "üë§",
          name: "L√≠der Cultor Renegado Kai",
          typeOverride: "monster",
          hp: 500,
          attack: 70,
          defense: 25,
          exp: 250,
          maxHp: 500,
          isMiniBoss: true,
          specialChance: 0.25,
          specialAttackMultiplier: 1.6,
          lootTable: [
            {
              itemName: "Comp√°s Espiritual Antiguo",
              quantity: [1, 1],
              chance: 1.0,
            },
            {
              itemName: "P√≠ldora de Qi Condensado",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Piedras Espirituales",
              quantity: [100, 200],
              chance: 0.8,
            },
          ],
          fixedLocation: { x: 17, y: 12 },
        },

        //BOSSES

        boss_demon_general: {
          symbol: "üëø",
          name: "General Demonio de la Sombra",
          typeOverride: "monster",
          hp: 500,
          attack: 45,
          defense: 20,
          exp: 300,
          maxHp: 500,
          isBoss: true,
          specialChance: 0.35,
          specialAttackMultiplier: 1.8,
          healChance: 0.15,
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [150, 300],
              chance: 1.0,
            },
            {
              itemName: "N√∫cleo Demon√≠aco Mayor",
              quantity: [1, 1],
              chance: 0.8,
            },
            {
              itemName: "Rollo: Palma Destructora de Monta√±as",
              quantity: [1, 1],
              chance: 0.25,
            },
            {
              itemName: "Fragmento de Arma Celestial",
              quantity: [1, 1],
              chance: 0.1,
            },
            {
              itemName: "Rollo: Cambio Temporal",
              quantity: [1, 1],
              chance: 0.25,
            },
            {
              itemName: "Rollo: Ritual de Sangre",
              quantity: [1, 1],
              chance: 0.2,
            },
            {
              itemName: "Rollo: Aura de Pureza",
              quantity: [1, 1],
              chance: 0.22,
            },
            {
              itemName: "Rollo: Invocar Elemental",
              quantity: [1, 1],
              chance: 0.18,
            },
            {
              itemName: "Rollo: Barrera M√≠stica",
              quantity: [1, 1],
              chance: 0.25,
            },
          ],
          nextBossId: "boss_ancient_golem",
          fixedLocation: { x: 18, y: 25 },
        },

        boss_ancient_golem: {
          symbol: "üóø",
          name: "Golem Ancestral de Jade",
          typeOverride: "monster",
          hp: 800,
          attack: 35,
          defense: 50,
          exp: 500,
          maxHp: 800,
          isBoss: true,
          abilities: [
            {
              name: "Golpe S√≠smico",
              damageMultiplier: 2.0,
              chance: 0.2,
              type: "area_attack_simulated",
            },
            { name: "Restauraci√≥n P√©trea", healPercentage: 0.2, chance: 0.1 },
          ],
          lootTable: [
            {
              itemName: "Piedras Espirituales",
              quantity: [300, 500],
              chance: 1.0,
            },
            {
              itemName: "Coraz√≥n de Golem de Jade",
              quantity: [1, 1],
              chance: 0.9,
            },
            {
              itemName: "Rollo: Armadura de Tierra Impenetrable",
              quantity: [1, 1],
              chance: 0.3,
            },
            {
              itemName: "Fragmento de Arma Celestial",
              quantity: [1, 1],
              chance: 0.15,
            },
            {
              itemName: "Mineral de Hierro Espiritual",
              quantity: [5, 10],
              chance: 0.6,
            },
            { itemName: "Fragmentos de Jade", quantity: [3, 6], chance: 0.7 },
            {
              itemName: "N√∫cleo Elemental",
              quantity: [1, 2],
              chance: 0.3,
              extraData: { elementalType: "earth" },
            },
            {
              itemName: "Rollo: Piel de Piedra",
              quantity: [1, 1],
              chance: 0.25,
            },
          ],
          nextBossId: null,
          fixedLocation: { x: 20, y: 13 },
        },
      };

      const itemData = {
        "Hierbas Medicinales": {
          description: "Restaura un 30% de tu HP M√°ximo.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al m√°ximo.";
            const h = Math.floor(ps.maxHp * 0.3);
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Cristales de Qi": {
          description: "Restaura un 30% de tu Man√° M√°ximo.",
          effect: (ps) => {
            if (ps.mana >= ps.maxMana) return "Man√° al m√°ximo.";
            const h = Math.floor(ps.maxMana * 0.3);
            const o = ps.mana;
            ps.mana = Math.min(ps.maxMana, ps.mana + h);
            return `Recuperado ${ps.mana - o} Man√°.`;
          },
          canUse: (ps) => ps.mana < ps.maxMana,
        },
        "Piedras Espirituales": {
          description: "Imbuida de energ√≠a. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido Piedra Espiritual y ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Flor de Luna Escarchada": {
          description: "Flor brillante usada en alquimia.",
          canUse: () => false,
        },
        "Ra√≠z de Fuego Terrenal": {
          description: "Ra√≠z que irradia calor, ingrediente alqu√≠mico.",
          canUse: () => false,
        },
        "P√≠ldora de Recuperaci√≥n Menor": {
          description: "P√≠ldora alqu√≠mica que restaura 50 HP.",
          effect: (ps) => {
            if (ps.hp >= ps.maxHp) return "Vida al m√°ximo.";
            const h = 50;
            const o = ps.hp;
            ps.hp = Math.min(ps.maxHp, ps.hp + h);
            return `Usada P√≠ldora, recuperado ${ps.hp - o} HP.`;
          },
          canUse: (ps) => ps.hp < ps.maxHp,
        },
        "Talism√°n de Percepci√≥n": {
          description: "Agudiza sentidos. Otorga EXP.",
          effect: (ps, gex) => {
            gex(100);
            return `Estudiado Talism√°n, ganado 100 EXP.`;
          },
          canUse: () => true,
        },
        "Colmillo de Jabal√≠ Alfa": {
          description: "Colmillo intacto de Jabal√≠ Alfa. Prueba de caza.",
          canUse: () => false,
        },
        "Carne de Bestia Ex√≥tica": {
          description: "Nutritiva. Restaura 25% HP y 10% Man√°.",
          effect: (ps) => {
            let m = "";
            const hA = Math.floor(ps.maxHp * 0.25);
            if (ps.hp < ps.maxHp) {
              const o = ps.hp;
              ps.hp = Math.min(ps.maxHp, ps.hp + hA);
              m += `Recuperado ${ps.hp - o} HP. `;
            }
            const mA = Math.floor(ps.maxMana * 0.1);
            if (ps.mana < ps.maxMana) {
              const o = ps.mana;
              ps.mana = Math.min(ps.maxMana, ps.mana + mA);
              m += `Recuperado ${ps.mana - o} Man√°.`;
            }
            return m || "HP y Man√° al m√°ximo.";
          },
          canUse: (ps) => ps.hp < ps.maxHp || ps.mana < ps.maxMana,
        },
        "Mapa del Tesoro Fragmentado": {
          description: "Fragmento de mapa antiguo. ¬øOtras partes?",
          effect: (ps, gex) => {
            gex(50);
            return `Examinado fragmento, ganado 50 EXP. Indica zona monta√±osa...`;
          },
          canUse: () => true,
        },
        "Comp√°s Espiritual Antiguo": {
          description: "Artefacto de secta que resuena con energ√≠as.",
          canUse: () => false,
        },
        "Manual de Formaci√≥n B√°sica": {
          description: "Ense√±a principios de formaciones defensivas.",
          effect: (ps) => {
            ps.baseDefense += 2;
            recalculatePlayerStats();
            return `Estudiado Manual. Defensa base +2.`;
          },
          canUse: () => true,
        },
        "N√∫cleo de Bestia Menor": {
          description: "N√∫cleo de bestia demon√≠aca. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido N√∫cleo, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Rollo: Absorci√≥n de Qi Menor": {
          description: "Ense√±a 'T√©cnica de Absorci√≥n de Qi Menor'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_absorption_boost_1"),
          canUse: () => true,
        },
        "Rollo: Fortificaci√≥n Corporal B√°sica": {
          description: "Ense√±a 'Fortificaci√≥n Corporal B√°sica'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "body_fortification_1"),
          canUse: () => true,
        },
        "Rollo: Corte de Espada B√°sico": {
          description: "Ense√±a 'Corte de Espada B√°sico'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "sword_slash_1"),
          canUse: () => true,
        },
        "Rollo: Conversi√≥n de Qi": {
          description: "Ense√±a 'T√©cnica de Conversi√≥n de Qi'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "qi_to_hp_conversion_1"),
          canUse: () => true,
        },
        "Rollo: Prisi√≥n de Hielo": {
          description: "Ense√±a 'Prisi√≥n de Hielo'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "ice_prison_1"),
          canUse: () => true,
        },
        "Rollo: Golpe de Llamas": {
          description: "Ense√±a 'Golpe de Llamas'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "flame_strike_1"),
          canUse: () => true,
        },
        "Rollo: Furia del Trueno": {
          description: "Ense√±a 'Furia del Trueno'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "thunder_fury_1"),
          canUse: () => true,
        },
        "Rollo: Dardo Venenoso": {
          description: "Ense√±a 'Dardo Venenoso'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "poison_dart_1"),
          canUse: () => true,
        },
        "Rollo: Piel de Piedra": {
          description: "Ense√±a 'Piel de Piedra'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "stone_skin_1"),
          canUse: () => true,
        },
        "Rollo: Paso de las Sombras": {
          description: "Ense√±a 'Paso de las Sombras'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "shadow_step_1"),
          canUse: () => true,
        },
        "Rollo: Drenaje de Alma": {
          description: "Ense√±a 'Drenaje de Alma'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "soul_drain_1"),
          canUse: () => true,
        },
        "Rollo: Golpe Cicl√≥n": {
          description: "Ense√±a 'Golpe Cicl√≥n'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "cyclone_strike_1"),
          canUse: () => true,
        },
        "Rollo: Lluvia Curativa": {
          description: "Ense√±a 'Lluvia Curativa'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "healing_rain_1"),
          canUse: () => true,
        },
        "Rollo: Explosi√≥n Mental": {
          description: "Ense√±a 'Explosi√≥n Mental'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "mind_blast_1"),
          canUse: () => true,
        },
        "Rollo: Voluntad de Hierro": {
          description: "Ense√±a 'Voluntad de Hierro'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "iron_will_1"),
          canUse: () => true,
        },
        "Rollo: Flecha Celestial": {
          description: "Ense√±a 'Flecha Celestial'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "celestial_arrow_1"),
          canUse: () => true,
        },
        "Rollo: Abrazo de la Naturaleza": {
          description: "Ense√±a 'Abrazo de la Naturaleza'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "nature_grasp_1"),
          canUse: () => true,
        },
        "Rollo: Rugido de Drag√≥n": {
          description: "Ense√±a 'Rugido de Drag√≥n'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "dragon_roar_1"),
          canUse: () => true,
        },
        "Rollo: Clon Fantasma": {
          description: "Ense√±a 'Clon Fantasma'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "phantom_clone_1"),
          canUse: () => true,
        },
        "Rollo: Cambio Temporal": {
          description: "Ense√±a 'Cambio Temporal'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "temporal_shift_1"),
          canUse: () => true,
        },
        "Rollo: Ritual de Sangre": {
          description: "Ense√±a 'Ritual de Sangre'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "blood_ritual_1"),
          canUse: () => true,
        },
        "Rollo: Aura de Pureza": {
          description: "Ense√±a 'Aura de Pureza'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "aura_of_purity_1"),
          canUse: () => true,
        },
        "Rollo: Invocar Elemental": {
          description: "Ense√±a 'Invocar Elemental'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "summon_elemental_1"),
          canUse: () => true,
        },
        "Rollo: Barrera M√≠stica": {
          description: "Ense√±a 'Barrera M√≠stica'.",
          effect: (ps) => learnTechniqueFromRoll(ps, "mystic_barrier_1"),
          canUse: () => true,
        },
        "Cristal de Hielo": {
          description: "Cristal g√©lido. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Cristal de Hielo, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia de Fuego": {
          description: "Energ√≠a √≠gnea concentrada. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Absorbido Esencia de Fuego, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "N√∫cleo de Tormenta": {
          description: "Coraz√≥n de tormenta. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido N√∫cleo de Tormenta, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Venenos Mortales": {
          description: "Venenos potentes. Otorga 15 EXP.",
          effect: (ps, gex) => {
            gex(15);
            return `Estudiado Venenos Mortales, ganado 15 EXP.`;
          },
          canUse: () => true,
        },
        "Fragmentos de Jade": {
          description: "Jade imbuido de energ√≠a. Otorga 20 EXP.",
          effect: (ps, gex) => {
            gex(20);
            return `Absorbido Fragmentos de Jade, ganado 20 EXP.`;
          },
          canUse: () => true,
        },
        "Esencia Oscura": {
          description: "Energ√≠a de sombras. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Absorbido Esencia Oscura, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Almas Condenadas": {
          description: "Ecos de almas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Liberado Almas Condenadas, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "N√∫cleo de V√≥rtice": {
          description: "Energ√≠a ca√≥tica. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Absorbido N√∫cleo de V√≥rtice, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Roc√≠o Celestial": {
          description: "Gotas de energ√≠a celestial. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Bebido Roc√≠o Celestial, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "Cristales Ps√≠quicos": {
          description: "Resuenan con poder mental. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Meditado con Cristales Ps√≠quicos, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "Mineral de Hierro Espiritual": {
          description: "Hierro imbuido con Qi. Otorga 25 EXP.",
          effect: (ps, gex) => {
            gex(25);
            return `Refinado Mineral, ganado 25 EXP.`;
          },
          canUse: () => true,
        },
        "Plumas de F√©nix": {
          description: "Imbuidas con esencia de renovaci√≥n. Otorga 60 EXP.",
          effect: (ps, gex) => {
            gex(60);
            return `Meditado con Plumas de F√©nix, ganado 60 EXP.`;
          },
          canUse: () => true,
        },
        "Semillas Ancestrales": {
          description: "Llenas de vitalidad. Otorga 30 EXP.",
          effect: (ps, gex) => {
            gex(30);
            return `Plantado Semillas en dantian, ganado 30 EXP.`;
          },
          canUse: () => true,
        },
        "Escamas de Drag√≥n": {
          description: "Imbuidas con poder drac√≥nico. Otorga 70 EXP.",
          effect: (ps, gex) => {
            gex(70);
            return `Estudiado Escamas de Drag√≥n, ganado 70 EXP.`;
          },
          canUse: () => true,
        },
        "Espejos Astrales": {
          description: "Reflejan otros planos. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Meditado con Espejos Astrales, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
        "Relojes de Arena": {
          description: "Manipulan flujo del tiempo. Otorga 50 EXP.",
          effect: (ps, gex) => {
            gex(50);
            return `Estudiado Relojes de Arena, ganado 50 EXP.`;
          },
          canUse: () => true,
        },
        "Sangre de Demonio": {
          description: "Sangre corrupta pero potente. Otorga 35 EXP.",
          effect: (ps, gex) => {
            gex(35);
            return `Analizado Sangre de Demonio, ganado 35 EXP.`;
          },
          canUse: () => true,
        },
        "L√°grimas de Unicornio": {
          description:
            "Purificadoras con propiedades curativas. Otorga 45 EXP.",
          effect: (ps, gex) => {
            gex(45);
            return `Usado L√°grimas para purificar Qi, ganado 45 EXP.`;
          },
          canUse: () => true,
        },
        "N√∫cleo Elemental": {
          description: "Esencia de poder elemental. Otorga 65 EXP.",
          effect: (ps, gex) => {
            gex(65);
            return `Absorbido N√∫cleo Elemental, ganado 65 EXP.`;
          },
          canUse: () => true,
        },
        "Polvo de Arcano": {
          description: "Brillante con propiedades m√°gicas. Otorga 40 EXP.",
          effect: (ps, gex) => {
            gex(40);
            return `Utilizado Polvo de Arcano en ritual, ganado 40 EXP.`;
          },
          canUse: () => true,
        },
      };

      // --- FUNCIONES HELPER PARA UI M√ìVIL ---
      function isMobileView() {
        return (
          window.matchMedia("(max-width: 768px)").matches ||
          window.matchMedia("(hover: none) and (pointer: coarse)").matches
        );
      }

      /// <!-- CAMBIO TAMA√ëO MAPA M√ìVIL -->
      function calculateAndSetTileSize() {
        const mapContainerElement = document.querySelector(".map-container");
        if (!mapContainerElement) {
          console.warn(
            "calculateAndSetTileSize: mapContainerElement no encontrado, usando G_TILE_SIZE por defecto."
          );
          currentTileSize = G_TILE_SIZE;
          return G_TILE_SIZE;
        }

        if (isMobileView()) {
          const availableWidth = mapContainerElement.clientWidth;
          const availableHeight = mapContainerElement.clientHeight;

          // Decidir cu√°ntos tiles queremos ver en pantalla en m√≥vil (aproximado)
          // Ajusta estos valores seg√∫n tus preferencias visuales.
          const TILES_VISIBLE_X_MOBILE = 5; // Por ejemplo, queremos ver unos 15 tiles de ancho
          const TILES_VISIBLE_Y_MOBILE = 3; // Y unos 10 de alto

          const tileSizeBasedOnWidth = availableWidth / TILES_VISIBLE_X_MOBILE;
          const tileSizeBasedOnHeight =
            availableHeight / TILES_VISIBLE_Y_MOBILE;

          currentTileSize = Math.floor(
            Math.min(tileSizeBasedOnWidth, tileSizeBasedOnHeight)
          );
          currentTileSize = Math.max(20, currentTileSize); // Asegurar un tama√±o m√≠nimo razonable (ej. 20px)

          console.log(
            `Mobile View: Container W: ${availableWidth}, H: ${availableHeight}. Calculated Tile Size: ${currentTileSize}`
          );
        } else {
          currentTileSize = G_TILE_SIZE; // Usar el tama√±o fijo para escritorio
          console.log(`Desktop View: Using G_TILE_SIZE: ${currentTileSize}`);
        }
        return currentTileSize;
      }
      // <!-- FIN CAMBIO TAMA√ëO MAPA M√ìVIL -->

      function isAnyModalOpen() {
        const modals = [
          "interactionModal",
          "activeCultivationModal",
          "shopModal",
          "sectHallModal",
          "cultivationChoiceModal",
          "techniqueModal",
        ];
        for (const modalId of modals) {
          const modalElement = document.getElementById(modalId);
          if (modalElement && modalElement.style.display === "flex") {
            return true;
          }
        }
        return false;
      }

      // NUEVA FUNCI√ìN para controlar la visibilidad de la barra inferior
      function updateBottomNavVisibility() {
        if (!bottomNavBar) return;

        if (gameState.battle.active || isAnyModalOpen()) {
          bottomNavBar.classList.add("hidden");
        } else {
          bottomNavBar.classList.remove("hidden");
        }
      }

      function showTouchControls() {
        const joystick = document.getElementById("joystick-container");
        const actionBtn = document.getElementById("action-button-touch");

        if (
          isMobileView() &&
          !mapControlsManuallyHidden &&
          !gameState.battle.active &&
          !isAnyModalOpen()
        ) {
          if (joystick) joystick.style.display = "block";
          if (actionBtn) actionBtn.style.display = "block";
        } else {
          if (joystick) joystick.style.display = "none";
          if (actionBtn) actionBtn.style.display = "none";
        }
      }

      function hideTouchControls() {
        const joystick = document.getElementById("joystick-container");
        const actionBtn = document.getElementById("action-button-touch");
        if (joystick) joystick.style.display = "none";
        if (actionBtn) actionBtn.style.display = "none";
      }

      function toggleMapControlsVisibility() {
        mapControlsManuallyHidden = !mapControlsManuallyHidden;
        const btn = document.getElementById("toggleMapControlsBtn");
        if (mapControlsManuallyHidden) {
          hideTouchControls();
          btn.textContent = "Mostrar Controles";
        } else {
          showTouchControls();
          btn.textContent = "Ocultar Controles";
        }
      }

      // --- FUNCIONES DEL JUEGO (MODIFICADAS Y EXISTENTES) ---

      function learnTechniqueFromRoll(playerState, techId) {
        if (!techniqueData[techId]) return "Error: T√©cnica desconocida.";
        if (playerState.learnedTechniques[techId]) {
          return `Ya conoces esta t√©cnica: ${techniqueData[techId].name}.`;
        }
        const techCultivationSettings =
          techniqueData[techId].cultivationSettings;
        playerState.learnedTechniques[techId] = {
          level: 0,
          currentCultivationProgress: 0,
          cultivationTimeToNextLevel: techCultivationSettings
            ? techCultivationSettings.baseTimeToLevelUp
            : 60,
        };
        if (techId === "qi_to_hp_conversion_1") {
          playerState.canUseQiConversion = true;
          updateToggleQiConversionButtonVisibility();
        }
        return `Has aprendido '${techniqueData[techId].name}'. Puedes cultivarla para mejorarla.`;
      }

      function showModal(title, text, nonInteractive = false) {
        const modalElement = document.getElementById("interactionModal");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalTextEl = document.getElementById("modalText");

        if (!modalElement || !modalTitleEl || !modalTextEl) {
          console.error(
            "CRITICAL: Modal o sus elementos internos no encontrados."
          );
          alert(`Error UI: Modal no encontrado.\nMensaje: ${title} - ${text}`);
          return;
        }

        modalTitleEl.textContent = title;
        modalTextEl.innerHTML = text.replace(/\n/g, "<br>");

        const closeButton = modalElement.querySelector(
          "button.close-modal-btn"
        ); // Busca por clase

        if (closeButton) {
          if (nonInteractive) {
            closeButton.style.display = "none"; // Ocultar si es no interactivo
          } else {
            closeButton.style.display = "block"; // Asegurar que sea visible si es interactivo
            // El onclick="closeModal()" ya est√° en el HTML, por lo que no necesitamos reasignarlo.
          }
        } else if (!nonInteractive) {
          console.warn(
            "#interactionModal no tiene un bot√≥n de cierre con clase .close-modal-btn y no es nonInteractive."
          );
        }

        modalElement.style.display = "flex";
        hideTouchControls();
        updateBottomNavVisibility();
      }

      function closeModal() {
        const modalElement = document.getElementById("interactionModal");
        if (modalElement) {
          modalElement.style.display = "none";
        }
        updatePlayerBarsOnMap();
        showTouchControls(); // Restaurar controles t√°ctiles (si aplica)
        updateBottomNavVisibility();
      }

      function ensureFixedEntities() {
        const player = gameState.player;
        let entities = gameState.map.entities;

        let idsParaProcesar = [
          "shop",
          "secta_entrada_principal",
          "npc_secta_guia",
          "npc_secta_admin",
          // ===> A√ëADE TU JABAL√ç AQU√ç <===
          "jabali_colmilludo_alfa",
          // ===> FIN DE LA ADICI√ìN <===
          // Puedes a√±adir otros IDs de entidades fijas aqu√≠ directamente
        ];

        // L√≥gica para jefes principales (actuales)
        if (
          player.worldState.currentBossToSpawn &&
          entityTypes[player.worldState.currentBossToSpawn]
        ) {
          const bossDef = entityTypes[player.worldState.currentBossToSpawn];
          if (
            bossDef.fixedLocation &&
            !player.worldState.defeatedBosses[
              player.worldState.currentBossToSpawn
            ]
          ) {
            if (
              !idsParaProcesar.includes(player.worldState.currentBossToSpawn)
            ) {
              idsParaProcesar.push(player.worldState.currentBossToSpawn);
            }
          }
        }

        // L√≥gica para rivales de desaf√≠o de secta (actuales)
        player.secta.misionesActivas.forEach((misionActiva) => {
          const misionData = MISIONES_DATA[misionActiva.id];
          if (
            misionData?.objetivo?.tipo === "derrotar_npc_especifico" &&
            misionData.objetivo.npcId
          ) {
            const rivalId = misionData.objetivo.npcId;
            if (
              entityTypes[rivalId]?.fixedLocation &&
              !player.secta.misionesCompletadas[misionActiva.id]
            ) {
              if (!idsParaProcesar.includes(rivalId)) {
                idsParaProcesar.push(rivalId);
              }
            }
          }
        });

        // Nueva l√≥gica: A√±adir entidades fijas que podr√≠an estar ligadas a misiones activas
        // (si implementas `missionRequirementId`)
        player.secta.misionesActivas.forEach((misionActiva) => {
          // Ejemplo: Si la misi√≥n "mision_cazar_bestia_especifica_1" est√° activa
          // y el jabal√≠ tiene un `missionRequirementId: "mision_cazar_bestia_especifica_1"`
          // y a√∫n no est√° en idsParaProcesar, lo a√±adir√≠as.
          // Este es un ejemplo, necesitar√≠as iterar sobre `entityTypes` para encontrar tales entidades.
          // Por ahora, como lo a√±adiste directamente a `idsParaProcesar`, esto es m√°s simple.
        });

        console.log(
          "[EnsureFixed] IDs a procesar:",
          JSON.parse(JSON.stringify(idsParaProcesar))
        );

        idsParaProcesar.forEach((entityTypeId) => {
          const definition = entityTypes[entityTypeId];
          if (!definition) {
            console.warn(
              `[EnsureFixed] Definici√≥n no encontrada para ${entityTypeId}`
            );
            return;
          }

          if (!definition.fixedLocation) {
            // Si una entidad en idsParaProcesar no tiene fixedLocation, no podemos colocarla as√≠.
            // Esto es un error de configuraci√≥n o la entidad no deber√≠a estar en esta lista.
            console.warn(
              `[EnsureFixed] La entidad ${entityTypeId} est√° en idsParaProcesar pero no tiene 'fixedLocation' en su definici√≥n.`
            );
            return;
          }

          const fixedX = definition.fixedLocation.x;
          const fixedY = definition.fixedLocation.y;

          const existingEntityInstance = entities.find(
            (e) =>
              (e.x === fixedX &&
                e.y === fixedY &&
                (e.type === (definition.typeOverride || entityTypeId) ||
                  e.originalEntityTypeId === entityTypeId)) ||
              (definition.npcId && e.npcId === definition.npcId) // Para NPCs
          );

          let debeExistir = true;

          // L√≥gica de si debe existir (para jefes, rivales, o entidades ligadas a misiones)
          if (definition.isSectChallengeRival && definition.npcId) {
            const desafioMision = Object.values(MISIONES_DATA).find(
              (m) =>
                m.objetivo?.tipo === "derrotar_npc_especifico" &&
                m.objetivo?.npcId === definition.npcId
            );
            const misionId = desafioMision
              ? Object.keys(MISIONES_DATA).find(
                  (key) => MISIONES_DATA[key] === desafioMision
                )
              : null;
            if (misionId) {
              if (player.secta.misionesCompletadas[misionId])
                debeExistir = false;
              else if (
                !player.secta.misionesActivas.some((m) => m.id === misionId)
              )
                debeExistir = false;
            } else debeExistir = false;
          } else if (definition.isBoss || definition.isMiniBoss) {
            // Tratar MiniBoss de forma similar a Boss para 'defeated'
            // Usaremos una nueva propiedad en player.worldState para rastrear minibosses fijos derrotados
            // si no quieres que reaparezcan inmediatamente.
            if (
              player.worldState.defeatedFixedEntities &&
              player.worldState.defeatedFixedEntities[entityTypeId]
            ) {
              // Si tiene un tiempo de respawn, podr√≠a reaparecer
              const lastDefeatedTime =
                player.worldState.defeatedFixedEntities[entityTypeId].time;
              const respawnTimeSeconds = definition.respawnTime; // ej. 300 segundos
              if (
                respawnTimeSeconds &&
                (Date.now() - lastDefeatedTime) / 1000 < respawnTimeSeconds
              ) {
                debeExistir = false; // A√∫n no es tiempo de reaparecer
              } else if (respawnTimeSeconds) {
                debeExistir = true; // Tiempo de respawn cumplido
                // Opcional: remover de defeatedFixedEntities para que no se re-evalue el tiempo hasta la pr√≥xima derrota
                // delete player.worldState.defeatedFixedEntities[entityTypeId];
              } else {
                debeExistir = false; // No tiene respawnTime, as√≠ que si est√° derrotado, no reaparece.
              }
            }
          } else if (definition.missionRequirementId) {
            // L√≥gica para entidades que dependen de una misi√≥n activa
            if (
              !player.secta.misionesActivas.some(
                (m) => m.id === definition.missionRequirementId
              )
            ) {
              debeExistir = false; // La misi√≥n requerida no est√° activa
            }
            // Podr√≠as a√±adir una comprobaci√≥n de si la misi√≥n ya fue completada y la entidad debe desaparecer.
            if (
              player.secta.misionesCompletadas[
                definition.missionRequirementId
              ] &&
              !definition.respawnTime
            ) {
              // Si la misi√≥n est√° completada y la entidad no tiene respawn, no debe existir.
              debeExistir = false;
            }
          }

          if (debeExistir) {
            if (!existingEntityInstance) {
              console.log(
                `[EnsureFixed] CREANDO nueva instancia para ${entityTypeId} en (${fixedX}, ${fixedY}).`
              );
              const newEntityData = {
                x: fixedX,
                y: fixedY,
                type: definition.typeOverride || entityTypeId,
                symbol: definition.symbol,
                name: definition.name,
                interaction: definition.interaction,
                npcId: definition.npcId,
                discovered:
                  definition.discovered === true ||
                  definition.isBoss ||
                  definition.isMiniBoss, // Los jefes/minibosses suelen estar descubiertos
                isFixed: true,
                id: `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                  .toString(16)
                  .slice(2)}`,
                originalEntityTypeId: entityTypeId,
                // Copiar stats de combate y loot
                ...(definition.hp && {
                  hp: definition.hp,
                  maxHp: definition.maxHp || definition.hp,
                }),
                ...(definition.attack && { attack: definition.attack }),
                ...(definition.defense && { defense: definition.defense }),
                ...(definition.exp && { exp: definition.exp }),
                ...(definition.lootTable && {
                  lootTable: JSON.parse(JSON.stringify(definition.lootTable)),
                }), // Copia profunda del lootTable
                ...(definition.isBoss && { isBoss: true }),
                ...(definition.isMiniBoss && { isMiniBoss: true }), // A√±adido
                ...(definition.specialChance && {
                  specialChance: definition.specialChance,
                }),
                ...(definition.specialAttackMultiplier && {
                  specialAttackMultiplier: definition.specialAttackMultiplier,
                }),
                ...(definition.healChance && {
                  healChance: definition.healChance,
                }),
                ...(definition.abilities && {
                  abilities: JSON.parse(JSON.stringify(definition.abilities)),
                }),
              };
              if (newEntityData.hp && !newEntityData.maxHp)
                newEntityData.maxHp = newEntityData.hp;

              // No necesitamos `...definition` aqu√≠ porque ya estamos copiando expl√≠citamente y de entityTypes
              const finalEntity = { ...newEntityData };
              // delete finalEntity.fixedLocation; // No es necesario porque newEntityData no lo incluye

              entities.push(finalEntity);
            } else {
              // Actualizar propiedades de la instancia existente si es necesario
              existingEntityInstance.isFixed = true;
              if (
                definition.discovered === true ||
                definition.isBoss ||
                definition.isMiniBoss
              ) {
                existingEntityInstance.discovered = true;
              }
              if (!existingEntityInstance.id) {
                existingEntityInstance.id = `${entityTypeId}_fixed_${Date.now()}_${Math.random()
                  .toString(16)
                  .slice(2)}`;
              }
              if (!existingEntityInstance.originalEntityTypeId) {
                existingEntityInstance.originalEntityTypeId = entityTypeId;
              }
              // Asegurar que las stats est√©n actualizadas si se recarga el juego
              // (esto puede ser importante si las definiciones cambian entre versiones)
              if (definition.hp) existingEntityInstance.hp = definition.hp;
              if (definition.maxHp)
                existingEntityInstance.maxHp = definition.maxHp;
              else if (definition.hp && !existingEntityInstance.maxHp)
                existingEntityInstance.maxHp = definition.hp;
              // ... podr√≠as actualizar otras stats aqu√≠ si es necesario ...
            }
          } else {
            // No debe existir
            if (existingEntityInstance) {
              console.log(
                `[EnsureFixed] ELIMINANDO instancia existente de ${entityTypeId} en (${fixedX}, ${fixedY}) porque 'debeExistir' es false.`
              );
              entities = entities.filter(
                (e) => e.id !== existingEntityInstance.id
              );
            }
          }
        });
        gameState.map.entities = entities; // Reasignar por si se filtraron entidades
      }
      //GENERAR MAPA!
      function generateMap(isFullReset = true) {
        calculateAndSetTileSize();

        if (isFullReset) {
          console.log(
            "generateMap: Full reset. Entities BEFORE filtering for isFixed:"
          );
          gameState.map.entities.forEach((e) => {
            if (
              e.type === "secta_entrada_principal" ||
              e.type === "npc_secta_guia" ||
              e.type === "npc_secta_admin"
            ) {
              console.log(
                `  - ${e.name || e.type} at (${e.x},${e.y}), isFixed: ${
                  e.isFixed
                }, ID: ${e.id}`
              );
            }
          });

          // Limpiar entidades que no son fijas si es un reseteo completo
          // Esto es importante para que populateZoneWithObjects no cuente entidades viejas
          gameState.map.entities = gameState.map.entities.filter(
            (e) => e.isFixed
          );
          console.log(
            "generateMap: Full reset. Entities AFTER filtering for isFixed:"
          );
          gameState.map.entities.forEach((e) => {
            if (
              e.type === "secta_entrada_principal" ||
              e.type === "npc_secta_guia" ||
              e.type === "npc_secta_admin"
            ) {
              console.log(
                `  - KEPT: ${e.name || e.type} at (${e.x},${e.y}), isFixed: ${
                  e.isFixed
                }, ID: ${e.id}`
              );
            }
          });
          // Resetear currentCount en las spawnSettings de las zonas
          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings && zone.spawnSettings.targetEntities) {
              zone.spawnSettings.targetEntities.forEach((target) => {
                target.currentCount = 0;
              });
              zone.spawnSettings.respawnTimer = 0; // Asegurar que el timer est√© a 0 para el llenado inicial
              zone.spawnSettings.lastSpawnCheck = 0; // Resetear lastSpawnCheck tambi√©n
            }
          });

          gameState.map.terrainZones.forEach((zone) => {
            if (zone.spawnSettings) {
              console.log(
                `generateMap: Processing zone "${zone.name}" for initial population.`
              );
              populateZoneWithObjects(zone, true); // true para forzar el llenado inicial completo
              console.log(
                "generateMap: Full reset. Populating decorative elements."
              );
              populateDecorativeElements(50); // A√±ade, por ejemplo, 50 elementos decorativos
            }
          });
        } else {
          // Para una "reaparici√≥n" m√°s ligera (si a√∫n necesitas este concepto fuera de las zonas)
          // Filtra solo las entidades que NO son gestionadas por zonas y NO son fijas

          gameState.map.entities = gameState.map.entities.filter(
            (e) => e.isFixed || e.isDecorative || (!e.zoneOrigin && !e.isFixed)
          );
        }
        updatePlayerPosition(); // Esto llamar√° a renderMap()
        showTouchControls();
        // Siempre asegurar que las entidades fijas est√©n presentes y correctas
        ensureFixedEntities();
        console.log("generateMap: Entities AFTER ensureFixedEntities has run:");
        gameState.map.entities.forEach((e) => {
          if (
            e.type === "secta_entrada_principal" ||
            e.type === "npc_secta_guia" ||
            e.type === "npc_secta_admin"
          ) {
            console.log(
              `  - FINAL: ${e.name || e.type} at (${e.x},${e.y}), isFixed: ${
                e.isFixed
              }, ID: ${e.id}`
            );
          }
        });
      }

      function populateDecorativeElements(numberOfElements = 3000) {
        const decorativeKeys = Object.keys(entityTypes).filter(
          (key) => entityTypes[key].isDecorative
        );
        if (decorativeKeys.length === 0) {
          console.log("[Decor] No decorative entity types found."); // LOG
          return;
        }
        // MODIFICACI√ìN: A√±adir las claves encontradas al log
        console.log(
          `[Decor] Attempting to populate ${numberOfElements} decorative elements. Found ${decorativeKeys.length} types:`,
          decorativeKeys.join(", ")
        );

        let addedCount = 0;
        for (let i = 0; i < numberOfElements; i++) {
          let spawnX,
            spawnY,
            attempts = 0;
          let positionFound = false;
          const randomDecoKey =
            decorativeKeys[Math.floor(Math.random() * decorativeKeys.length)];

          while (attempts < 20 && !positionFound) {
            // Intentos para encontrar posici√≥n
            spawnX = Math.floor(Math.random() * gameState.map.width);
            spawnY = Math.floor(Math.random() * gameState.map.height);

            // Para decorativos, la condici√≥n de "caminable" puede ser menos estricta
            // Lo importante es que la celda no est√© ya ocupada.
            const isOccupied = gameState.map.entities.some(
              (e) => e.x === spawnX && e.y === spawnY
            );
            const isPlayerPos =
              spawnX === gameState.player.x && spawnY === gameState.player.y;

            if (!isOccupied && !isPlayerPos) {
              positionFound = true;
            }
            attempts++;
          }

          if (positionFound) {
            const decoDefinition = entityTypes[randomDecoKey];
            if (!decoDefinition || !decoDefinition.symbol) {
              console.warn(
                `[Decor] Definition or symbol missing for deco key: ${randomDecoKey}`
              );
              continue;
            }
            const newDeco = {
              ...decoDefinition, // Copia todas las propiedades de la definici√≥n
              x: spawnX,
              y: spawnY,
              type: randomDecoKey, // El tipo ES la clave original de entityTypes
              id: `${randomDecoKey}_${Date.now()}_${i}_${Math.random()
                .toString(16)
                .slice(2)}`,
              discovered: true, // Importante: los decorativos suelen estar descubiertos
              isFixed: true, // Importante: para que no se limpien f√°cilmente
              isDecorative: true, // Asegura que sea true, incluso si la definici√≥n lo omite
            };

            gameState.map.entities.push(newDeco);
            addedCount++;
            // MODIFICACI√ìN: Log m√°s detallado, incluyendo si isDecorative es true en la instancia
            console.log(
              `[Decor] Added: ${newDeco.name} (Symbol: ${newDeco.symbol}, Type: ${newDeco.type}, IsDecorative: ${newDeco.isDecorative}) at ${spawnX},${spawnY}. ID: ${newDeco.id}`
            );
          } else {
            // console.log(`[Decor] Could not find position for a decorative element of type ${randomDecoKey} after 20 attempts.`);
          }
        }
        console.log(
          `[Decor] Finished populating. Added ${addedCount} decorative elements out of ${numberOfElements} attempts.`
        );
      }

      function populateZoneWithObjects(zone, initialPopulation = false) {
        if (!zone.spawnSettings) {
          console.log(
            `populateZoneWithObjects: Zone "${zone.name}" has no spawnSettings. Skipping.`
          );
          return;
        }

        console.log(
          `populateZoneWithObjects: Called for zone "${zone.name}". InitialPopulation: ${initialPopulation}`
        );

        zone.spawnSettings.targetEntities.forEach((targetSpawnInfo) => {
          console.log(
            `  Zone "${zone.name}": Processing target spawn info for entityTypeId "${targetSpawnInfo.entityTypeId}", count: ${targetSpawnInfo.count}, currentCount: ${targetSpawnInfo.currentCount}`
          );

          const entityTypeDefinition =
            entityTypes[targetSpawnInfo.entityTypeId];
          if (!entityTypeDefinition) {
            console.warn(
              `  Zone "${zone.name}": Definition for entityTypeId "${targetSpawnInfo.entityTypeId}" NOT FOUND in entityTypes.`
            );
            return;
          }

          let attemptSpawns =
            targetSpawnInfo.count - targetSpawnInfo.currentCount;
          console.log(
            `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Need to spawn ${attemptSpawns} (target: ${targetSpawnInfo.count}, current: ${targetSpawnInfo.currentCount})`
          );

          if (!initialPopulation && zone.spawnSettings.respawnTimer > 0) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Zone in cooldown (timer: ${zone.spawnSettings.respawnTimer}). Skipping spawn.`
            );
            return;
          }

          if (attemptSpawns <= 0 && !initialPopulation) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": No spawns needed and not initial population. Skipping.`
            );
            return;
          }
          if (
            attemptSpawns <= 0 &&
            initialPopulation &&
            targetSpawnInfo.currentCount >= targetSpawnInfo.count
          ) {
            console.log(
              `  Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Initial population, but already at target count. Skipping.`
            );
            return;
          }

          let spawnedThisCycle = 0;
          for (let i = 0; i < attemptSpawns; i++) {
            if (targetSpawnInfo.currentCount >= targetSpawnInfo.count) {
              console.log(
                `    Zone "${zone.name}", Entity "${targetSpawnInfo.entityTypeId}": Reached target count (${targetSpawnInfo.currentCount}/${targetSpawnInfo.count}). Stopping spawns for this type.`
              );
              break;
            }

            let spawnX,
              spawnY,
              attempts = 0;
            let positionFound = false;
            while (attempts < 20 && !positionFound) {
              spawnX =
                zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1 + 1));
              spawnY =
                zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1 + 1));

              const targetTerrainId = getTerrainTypeAt(spawnX, spawnY);
              const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
              const terrainWalkable =
                !targetTerrainData || targetTerrainData.walkable !== false;

              const isOccupied = gameState.map.entities.some(
                (e) => e.x === spawnX && e.y === spawnY
              );
              const isPlayerPos =
                spawnX === gameState.player.x && spawnY === gameState.player.y;

              if (terrainWalkable && !isOccupied && !isPlayerPos) {
                positionFound = true;
              }
              attempts++;
            }

            if (positionFound) {
              let newEntity;
              newEntity = {
                ...entityTypeDefinition, // <--- COPIAR TODAS LAS PROPIEDADES DE LA DEFINICI√ìN PRIMERO
                x: spawnX,
                y: spawnY,
                type:
                  entityTypeDefinition.typeOverride ||
                  targetSpawnInfo.entityTypeId,
                id: `${
                  targetSpawnInfo.entityTypeId
                }_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                zoneOrigin: zone.name,
                originalEntityTypeId: targetSpawnInfo.entityTypeId,
                discovered: false,
                //name: entityTypeDefinition.name,
                //symbol: entityTypeDefinition.symbol,
                //interaction: entityTypeDefinition.interaction,
                //reward: entityTypeDefinition.reward,
              };
              // Asegurar HP/MaxHP para entidades de combate y limpiar para no combatientes
              if (
                G_COMBAT_ENTITY_TYPES.includes(newEntity.type) ||
                newEntity.isBoss ||
                newEntity.isSectChallengeRival
              ) {
                // Si entityTypeDefinition ya tiene hp/maxHp, el spread ya los copi√≥.
                // Este bloque es m√°s para asegurar que existan o para poner valores por defecto.
                newEntity.hp = newEntity.hp ?? entityTypeDefinition.hp ?? 50;
                newEntity.maxHp = newEntity.maxHp ?? newEntity.hp;
                // Aqu√≠ 'attack', 'defense', 'exp', 'lootTable' ya deber√≠an estar copiados por el spread de entityTypeDefinition
              } else {
                // Para recursos u otras entidades no combativas
                delete newEntity.hp;
                delete newEntity.maxHp;
                delete newEntity.attack; // Asegurarse de que no tengan stats de combate
                delete newEntity.defense;
                delete newEntity.exp;
                // lootTable podr√≠a ser relevante para recursos si lo usaras para definir m√∫ltiples items de un nodo.
              }

              // Correcci√≥n espec√≠fica si es un recurso, para que su 'type' en el mapa sea solo 'resource' si as√≠ lo deseas
              // para la l√≥gica de interacci√≥n, o mantener el tipo espec√≠fico si prefieres.
              // La l√≥gica actual en handleEntityInteraction ya maneja bien `targetSpawnInfo.entityTypeId` como type.
              // if (entityTypeDefinition.type === "resource") newEntity.type = "resource";

              gameState.map.entities.push(newEntity);
              targetSpawnInfo.currentCount++;
              spawnedThisCycle++;
              console.log(
                `    SUCCESS: Spawned "${newEntity.name}" (Attack: ${newEntity.attack}, Final Type: ${newEntity.type}, OrigTypeID: ${newEntity.originalEntityTypeId}) in zone "${zone.name}" at (${spawnX},${spawnY}).`
              );
            } else {
              // console.log(`    FAILED: Could not find position for "${targetSpawnInfo.entityTypeId}" ...`);
              break;
            }
          }
          if (spawnedThisCycle > 0 && !initialPopulation) {
            zone.spawnSettings.respawnTimer =
              zone.spawnSettings.respawnCooldown;
            console.log(
              `  Zone "${zone.name}": Spawned ${spawnedThisCycle} of "${targetSpawnInfo.entityTypeId}". Setting respawn timer to ${zone.spawnSettings.respawnCooldown}s.`
            );
          }
        });
      }

      // Funci√≥n para llamar en el bucle principal del juego o con setInterval
      function gameTickUpdater() {
        const now = Date.now();
        const deltaTime = (now - gameState.lastGameTimeUpdate) / 1000;
        gameState.gameTime += deltaTime;
        gameState.lastGameTimeUpdate = now;

        gameState.map.terrainZones.forEach((zone) => {
          if (zone.spawnSettings) {
            if (zone.spawnSettings.respawnTimer > 0) {
              zone.spawnSettings.respawnTimer -= deltaTime;
              if (zone.spawnSettings.respawnTimer < 0)
                zone.spawnSettings.respawnTimer = 0;
            }

            // Comprobar si CUALQUIER tipo de entidad en la zona necesita reaparecer
            let needsRespawn = false;
            for (const target of zone.spawnSettings.targetEntities) {
              if (target.currentCount < target.count) {
                needsRespawn = true;
                break;
              }
            }
            // Ajustado el cooldown del chequeo de respawn para ser m√°s frecuente (e.g. 5-10s)
            const SPAWN_CHECK_COOLDOWN = 10; // Segundos
            if (
              needsRespawn &&
              zone.spawnSettings.respawnTimer <= 0 &&
              gameState.gameTime - (zone.spawnSettings.lastSpawnCheck || 0) >
                SPAWN_CHECK_COOLDOWN
            ) {
              console.log(
                `gameTickUpdater: Zone "${zone.name}" needs respawn and timer is 0. Calling populateZoneWithObjects.`
              ); // LOG
              zone.spawnSettings.lastSpawnCheck = gameState.gameTime; // Actualizar ANTES de llamar para evitar bucles r√°pidos
              populateZoneWithObjects(zone, false); // false porque no es poblaci√≥n inicial
            }
          }
        });
        // ...
      }
      // movePlayer() no necesita grandes cambios, ya que updatePlayerPosition()
      // se encarga ahora del scroll.
      let animationFrameIndex = 0; // Para ciclar a trav√©s de PLAYER_WALK_CYCLE
      let lastPlayerMoveTime = 0; // Para controlar el tiempo de la animaci√≥n

      function movePlayer(dx, dy) {
        movePlayerCallCount++;
        const callId = movePlayerCallCount;
        // console.log(`[MovePlayer CALL #${callId}] dx:${dx}, dy:${dy}. Current Player: (${gameState.player.x}, ${gameState.player.y})`);

        if (gameState.player.isCultivating || gameState.battle.active) return;

        const newX = gameState.player.x + dx;
        const newY = gameState.player.y + dy;
        // console.log(`[MovePlayer CALL #${callId}] Calculated New Pos: (${newX},${newY})`);

        // 1. Comprobar l√≠mites del MUNDO
        if (
          newX < 0 ||
          newX >= gameState.map.width ||
          newY < 0 ||
          newY >= gameState.map.height
        ) {
          console.log(
            `[MovePlayer CALL #${callId}] Movimiento bloqueado: Fuera de l√≠mites.`
          );
          return;
        }

        // 2. Comprobar si el TERRENO en newX, newY es transitable
        const targetTerrainId = getTerrainTypeAt(newX, newY);
        const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
        if (targetTerrainData && targetTerrainData.walkable === false) {
          console.log(
            `[MovePlayer CALL #${callId}] Movimiento bloqueado: Terreno no transitable (${targetTerrainData.name}).`
          );
          showModal(
            "Camino Bloqueado",
            `No puedes moverte sobre ${targetTerrainData.name}.`
          );
          return;
        }

        // 3. Comprobar ENTIDADES en newX, newY
        const entityAtNewPosition = gameState.map.entities.find(
          (e) => e.x === newX && e.y === newY
        );

        if (entityAtNewPosition) {
          console.log(
            `[MovePlayer CALL #${callId}] Entidad encontrada en (${newX},${newY}):`,
            JSON.parse(JSON.stringify(entityAtNewPosition))
          ); // Log profundo de la entidad

          const entityTypeToCheck =
            entityAtNewPosition.originalEntityTypeId ||
            entityAtNewPosition.type;
          console.log(
            `[MovePlayer CALL #${callId}] Tipo de entidad a verificar para bloqueo: '${entityTypeToCheck}'`
          );

          const entityDef = entityTypes[entityTypeToCheck]; // Usar el tipo correcto para buscar la definici√≥n
          if (entityDef) {
            console.log(
              `[MovePlayer CALL #${callId}] Definici√≥n de entidad encontrada:`,
              JSON.parse(JSON.stringify(entityDef))
            );
          } else {
            console.log(
              `[MovePlayer CALL #${callId}] ADVERTENCIA: No se encontr√≥ definici√≥n para el tipo '${entityTypeToCheck}'.`
            );
          }

          // 3.1. Si es una entidad de combate, iniciar batalla
          if (
            G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) ||
            entityAtNewPosition.isBoss ||
            entityAtNewPosition.isSectChallengeRival
          ) {
            console.log(
              `[MovePlayer CALL #${callId}] Movimiento resulta en batalla con: ${entityAtNewPosition.name}`
            );
            startBattle(entityAtNewPosition);
            return;
          }

          // 3.2. NUEVA L√ìGICA: Comprobar si es una entidad que bloquea el paso
          let isBlockingByType =
            G_BLOCKING_ENTITY_TYPES.includes(entityTypeToCheck);
          let isBlockingByNpcId = entityDef && entityDef.npcId;

          console.log(
            `[MovePlayer CALL #${callId}] Verificando bloqueo: isBlockingByType (${entityTypeToCheck} en G_BLOCKING_ENTITY_TYPES) -> ${isBlockingByType}`
          );
          console.log(
            `[MovePlayer CALL #${callId}] Verificando bloqueo: isBlockingByNpcId (entidadDef tiene npcId) -> ${isBlockingByNpcId}`
          );

          if (isBlockingByType || isBlockingByNpcId) {
            console.log(
              `[MovePlayer CALL #${callId}] MOVIMIENTO BLOQUEADO por entidad: ${entityAtNewPosition.name}`
            );
            // showModal("Camino Bloqueado", `No puedes caminar sobre ${entityAtNewPosition.name}.`); // Opcional
            return;
          }

          console.log(
            `[MovePlayer CALL #${callId}] Entidad ${entityAtNewPosition.name} no es de combate ni bloqueante por tipo/npcId. Se permite pasar (interacci√≥n con Espacio).`
          );
        } else {
          console.log(
            `[MovePlayer CALL #${callId}] No hay entidad en (${newX},${newY}).`
          );
        }

        // Si llegamos aqu√≠, la celda es transitable
        console.log(
          `[MovePlayer CALL #${callId}] Movimiento permitido a (${newX},${newY}).`
        );
        gameState.player.x = newX;
        gameState.player.y = newY;
        updatePlayerPosition(`movePlayer_call_${callId}`);
        // L√≥gica de emboscada (sin cambios)
        const adjacentOffsets = [
          { dx: 0, dy: -1 },
          { dx: 0, dy: 1 },
          { dx: -1, dy: 0 },
          { dx: 1, dy: 0 },
        ];
        for (const offset of adjacentOffsets) {
          const adjX = newX + offset.dx;
          const adjY = newY + offset.dy;
          if (
            adjX >= 0 &&
            adjX < gameState.map.width &&
            adjY >= 0 &&
            adjY < gameState.map.height
          ) {
            const adjEntity = gameState.map.entities.find(
              (e) => e.x === adjX && e.y === adjY
            );
            if (
              adjEntity &&
              (G_COMBAT_ENTITY_TYPES.includes(adjEntity.type) ||
                adjEntity.isBoss ||
                adjEntity.isSectChallengeRival)
            ) {
              if (!adjEntity.discovered) {
                adjEntity.discovered = true;
                renderMap();
              }
              showModal(
                "¬°Emboscada!",
                `¬°Un ${adjEntity.name} te ha visto y ataca!`,
                true
              );
              setTimeout(() => {
                closeModal();
                startBattle(adjEntity);
              }, 1500);
              return;
            }
          }
        }
        updateUI();
      }

      // Ajuste menor en window.addEventListener('resize')
      window.addEventListener("resize", () => {
        calculateAndSetTileSize();
        // renderMap(); // updatePlayerPosition se encarga de esto
        updatePlayerPosition();
      });

      function getTerrainTypeAt(x, y) {
        if (
          x < 0 ||
          x >= gameState.map.width ||
          y < 0 ||
          y >= gameState.map.height
        ) {
          return null; // Fuera de los l√≠mites del mapa
        }

        // Opci√≥n A: Si usas terrainGrid directamente
        if (
          gameState.map.terrainGrid &&
          gameState.map.terrainGrid[y] &&
          gameState.map.terrainGrid[y][x]
        ) {
          return gameState.map.terrainGrid[y][x];
        }

        // Opci√≥n B: Usando terrainZones
        for (const zone of gameState.map.terrainZones) {
          if (x >= zone.x1 && x <= zone.x2 && y >= zone.y1 && y <= zone.y2) {
            return zone.type;
          }
        }
        return gameState.map.defaultTerrain; // Devuelve el terreno por defecto
      }

      function renderMap(callerId = "unknown") {
        // A√±adido callerId para depuraci√≥n
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!mapElement || !mapContainerElement) {
          return;
        }

        const currentContainerWidth = mapContainerElement.clientWidth;
        const currentContainerHeight = mapContainerElement.clientHeight;

        const playerScreenX = currentContainerWidth / 2 - currentTileSize / 2;
        const playerScreenY = currentContainerHeight / 2 - currentTileSize / 2;
        const mapExpectedScrollX =
          -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapExpectedScrollY =
          -(gameState.player.y * currentTileSize) + playerScreenY;

        const viewWorldXStart = Math.floor(
          -mapExpectedScrollX / currentTileSize
        );
        const viewWorldYStart = Math.floor(
          -mapExpectedScrollY / currentTileSize
        );
        const tilesInViewX =
          Math.ceil(currentContainerWidth / currentTileSize) + 2; // +2 para margen
        const tilesInViewY =
          Math.ceil(currentContainerHeight / currentTileSize) + 2; // +2 para margen
        const viewWorldXEnd = viewWorldXStart + tilesInViewX;
        const viewWorldYEnd = viewWorldYStart + tilesInViewY;

        mapElement.innerHTML = "";

        // 1. Renderizar TERRENO BASE
        for (let y = viewWorldYStart; y < viewWorldYEnd; y++) {
          for (let x = viewWorldXStart; x < viewWorldXEnd; x++) {
            if (
              x < 0 ||
              x >= gameState.map.width ||
              y < 0 ||
              y >= gameState.map.height
            ) {
              continue; // No dibujar fuera de los l√≠mites del mundo
            }
            const terrainId = getTerrainTypeAt(x, y);
            const terrainData = G_TERRAIN_TYPES[terrainId];
            if (terrainData) {
              const terrainTile = document.createElement("div");
              terrainTile.className = "tile terrain-tile";
              terrainTile.style.left = `${x * currentTileSize}px`;
              terrainTile.style.top = `${y * currentTileSize}px`;
              terrainTile.style.width = `${currentTileSize}px`;
              terrainTile.style.height = `${currentTileSize}px`;

              // --- INICIO VARIEDAD VISUAL TERRENO ---
              let tileColor = terrainData.color;
              let detailSymbol = "";
              let detailOpacity = 0.15; // Opacidad para s√≠mbolos de detalle

              // Generar un valor pseudoaleatorio basado en coordenadas para consistencia
              const noiseVal = ((x * 31 + y * 13) % 100) / 100.0; // Simple hash

              if (terrainId === "GRASSLAND") {
                if (noiseVal < 0.1) {
                  // 10% de tiles un poco m√°s oscuros
                  tileColor = "#2A8C4A"; // Un verde ligeramente m√°s oscuro
                } else if (noiseVal < 0.15) {
                  // 5% con un "matojo"
                  detailSymbol = "Ÿ¨"; // Coma o ap√≥strofe como peque√±o detalle
                } else if (noiseVal < 0.2) {
                  detailSymbol = "¬∑";
                }
              } else if (terrainId === "FOREST") {
                if (noiseVal < 0.15) {
                  tileColor = "#166F3C"; // M√°s oscuro
                } else if (noiseVal < 0.25) {
                  detailSymbol = "‚àó"; // Un peque√±o asterisco
                }
              } else if (terrainId === "DESERT") {
                if (noiseVal < 0.08) {
                  tileColor = "#FAD7A0"; // Ligeramente diferente
                } else if (noiseVal < 0.15) {
                  detailSymbol = "¬∑";
                }
              }
              // A√±adir m√°s reglas para otros tipos de terreno

              terrainTile.style.backgroundColor = tileColor;
              // --- FIN VARIEDAD VISUAL TERRENO ---

              terrainTile.style.fontSize = `${currentTileSize * 0.6}px`;
              terrainTile.style.display = "flex";
              terrainTile.style.alignItems = "center";
              terrainTile.style.justifyContent = "center";
              terrainTile.style.zIndex = "1";

              // S√≠mbolo principal del terreno (m√°s opaco)
              const mainSymbolSpan = document.createElement("span");
              mainSymbolSpan.textContent = terrainData.symbol;
              mainSymbolSpan.style.opacity = "0.3";
              terrainTile.appendChild(mainSymbolSpan);

              // S√≠mbolo de detalle (si existe, m√°s transparente)
              if (detailSymbol) {
                const detailSymbolSpan = document.createElement("span");
                detailSymbolSpan.textContent = detailSymbol;
                detailSymbolSpan.style.position = "absolute"; // Para superponerlo
                // Posicionarlo aleatoriamente dentro del tile de forma sutil
                detailSymbolSpan.style.left = `${noiseVal * 50 + 25}%`; // entre 25% y 75%
                detailSymbolSpan.style.top = `${((y * 7 + x * 3) % 50) + 25}%`; // diferente variaci√≥n aleatoria
                detailSymbolSpan.style.opacity = `${detailOpacity}`;
                detailSymbolSpan.style.fontSize = `${currentTileSize * 0.4}px`; // M√°s peque√±o
                detailSymbolSpan.style.transform = "translate(-50%, -50%)"; // Centrar el s√≠mbolo de detalle
                terrainTile.appendChild(detailSymbolSpan);
              }
              mapElement.appendChild(terrainTile);
            }
          }
        }

        // 2. Renderizar ENTIDADES (Monstruos, NPCs, Recursos, Decorativos)
        gameState.map.entities.forEach((entity) => {
          // LOG para ver todas las entidades que se intentan renderizar y sus propiedades
          // console.log(`[RenderMap] Checking entity: ${entity.name || entity.type}, X:${entity.x}, Y:${entity.y}, Discovered: ${entity.discovered}, Decorative: ${entity.isDecorative}, Fixed: ${entity.isFixed}, Symbol: ${entity.symbol}`);

          if (entity.discovered) {
            if (
              entity.x >= viewWorldXStart &&
              entity.x < viewWorldXEnd &&
              entity.y >= viewWorldYStart &&
              entity.y < viewWorldYEnd
            ) {
              const tile = document.createElement("div");

              const displayTypeKey = entity.type;
              tile.className = `tile entity-on-map ${displayTypeKey.replace(
                /\s/g,
                "_"
              )}`;

              tile.style.left = `${entity.x * currentTileSize}px`;
              tile.style.top = `${entity.y * currentTileSize}px`;
              tile.style.width = `${currentTileSize}px`;
              tile.style.height = `${currentTileSize}px`;
              tile.style.fontSize = `${
                currentTileSize * (entity.isDecorative ? 0.5 : 0.6)
              }px`;

              // Esta l√≥gica para obtener el s√≠mbolo ya es robusta en tu c√≥digo:
              const definitionForSymbol =
                entityTypes[entity.originalEntityTypeId] ||
                entityTypes[entity.type];
              tile.textContent =
                entity.symbol ||
                (definitionForSymbol ? definitionForSymbol.symbol : "?");

              if (!tile.textContent || tile.textContent === "?") {
                console.warn(
                  `[RenderMap] Entity ${entity.name || entity.type} at (${
                    entity.x
                  },${
                    entity.y
                  }) has NO SYMBOL or symbol is '?'! Definition key for fallback: ${
                    entity.originalEntityTypeId || entity.type
                  }. Entity instance:`,
                  JSON.parse(JSON.stringify(entity))
                );
              }

              tile.style.zIndex = entity.isDecorative ? "3" : "5";
              tile.style.backgroundColor = "transparent";
              if (entity.isDecorative) {
                tile.style.opacity = "0.7";
                // MODIFICACI√ìN: Log espec√≠fico cuando se va a dibujar un decorativo
                // console.log(`[RenderMap] Drawing DECORATIVE entity: ${entity.name || entity.type} (Symbol: ${tile.textContent}) at ${entity.x},${entity.y} with zIndex ${tile.style.zIndex} and opacity ${tile.style.opacity}`);
              }

              mapElement.appendChild(tile);
            }
          }
        });
        updatePlayerVisualSize(); // Asegura que el tama√±o del jugador tambi√©n se actualice
      }

      function updatePlayerSpriteVisual() {
        // Aseg√∫rate que el nombre sea este
        const player = gameState.player;
        const playerElement = document.getElementById("player");
        if (!playerElement) return;

        // Verificaci√≥n para depurar el error de la l√≠nea 2263
        if (
          !player.directionRowMap ||
          typeof player.currentDirection === "undefined"
        ) {
          console.error(
            "CRITICAL: player.directionRowMap o player.currentDirection no est√°n definidos en updatePlayerSpriteVisual.",
            player
          );
          // Podr√≠as establecer valores por defecto aqu√≠ como un parche temporal,
          // pero lo ideal es que est√©n bien inicializados en gameState.
          // player.currentDirection = player.currentDirection || 'down';
          // player.directionRowMap = player.directionRowMap || { 'down': 0, 'left': 1, 'right': 2, 'up': 3 };
          // player.currentFrame = player.currentFrame || 0;
          // player.frameWidth = player.frameWidth || 64;
          // player.frameHeight = player.frameHeight || 64;
          return; // Salir si faltan datos cruciales para evitar m√°s errores
        }

        const row = player.directionRowMap[player.currentDirection];
        const col = player.currentFrame;

        // Otra verificaci√≥n
        if (typeof row === "undefined" || typeof col === "undefined") {
          console.error(
            "CRITICAL: 'row' o 'col' son undefined en updatePlayerSpriteVisual.",
            {
              playerDir: player.currentDirection,
              playerFrame: player.currentFrame,
              map: player.directionRowMap,
            }
          );
          return;
        }

        const offsetX = col * player.frameWidth;
        const offsetY = row * player.frameHeight;

        playerElement.style.backgroundPosition = `-${offsetX}px -${offsetY}px`;

        if (gameState.battle.active) {
          const battlePlayerSprite = document.querySelector(
            ".battle-area .character-sprite"
          );
          if (battlePlayerSprite) {
            const battleRow = player.directionRowMap["down"];
            const battleFrame = 0;
            const battleOffsetX = battleFrame * player.frameWidth;
            const battleOffsetY = battleRow * player.frameHeight;
            battlePlayerSprite.style.backgroundPosition = `-${battleOffsetX}px -${battleOffsetY}px`;
          }
        }
      }

      // Aseg√∫rate que G_TILE_SIZE sea igual a las dimensiones de tu frame de sprite
      // Si no, tendr√°s que ajustar c√≥mo se define el tama√±o del jugador.
      // En calculateAndSetTileSize, si currentTileSize se calcula din√°micamente,
      // y quieres que el jugador SIEMPRE tenga el tama√±o del sprite:
      function updatePlayerVisualSize() {
        const playerElement = document.getElementById("player");
        if (playerElement) {
          // ESTO ES CRUCIAL: El tama√±o del div del jugador DEBE ser el tama√±o de UN FRAME
          // Si currentTileSize representa el tama√±o deseado del jugador en pantalla,
          // y tus frames en la hoja de sprites son de un tama√±o fijo (ej. 64x64),
          // entonces el div del jugador tambi√©n debe ser de ese tama√±o fijo para que background-position funcione.
          // O, si quieres que el jugador se reescale con currentTileSize, entonces frameWidth/Height
          // deben ser iguales a currentTileSize, y background-size debe escalar la hoja completa.

          // Opci√≥n A: El jugador mantiene el tama√±o del frame original, y currentTileSize es solo para el mapa.
          playerElement.style.width = `${gameState.player.frameWidth}px`;
          playerElement.style.height = `${gameState.player.frameHeight}px`;
          // En este caso, .player y .character-sprite NO deber√≠an cambiar su width/height en @media queries
          // basados en currentTileSize, sino mantener el tama√±o del frame.

          // Opci√≥n B: El jugador se reescala con los tiles del mapa (m√°s complejo con spritesheets).
          // Si eliges esto, frameWidth y frameHeight en gameState.player deber√≠an ser actualizados
          // por calculateAndSetTileSize() para ser igual a currentTileSize.
          // Y el background-size del spritesheet necesitar√≠a ajustarse para que un "frame virtual"
          // dentro de la hoja escalada coincida con currentTileSize.
          // Ejemplo para Opci√≥n B:
          //playerElement.style.width = `${currentTileSize}px`;
          //playerElement.style.height = `${currentTileSize}px`;
          // Y en updatePlayerSpriteVisual, los c√°lculos de offsetX/Y necesitar√≠an
          // usar este currentTileSize en lugar de player.frameWidth/Height si la hoja
          // tambi√©n se est√° escalando.
          // Por ahora, mantengamos la Opci√≥n A (tama√±o de frame fijo) que es m√°s simple
          // si tu CSS para .player no est√° siendo sobrescrito por las @media queries.
        }
      }

      function updatePlayerPosition(callerId = "unknown") {
        const playerElement = document.getElementById("player");
        const mapElement = document.getElementById("gameMap");
        const mapContainerElement = document.querySelector(".map-container");

        if (!playerElement || !mapElement || !mapContainerElement) {
          console.error(
            "UpdatePlayerPosition: Elemento(s) clave no encontrado(s)."
          );
          return;
        }

        const playerVisualWidth = gameState.player.frameWidth; // Usar el tama√±o real del frame del sprite
        const playerVisualHeight = gameState.player.frameHeight;

        const playerScreenX =
          mapContainerElement.clientWidth / 2 - playerVisualWidth / 2;
        const playerScreenY =
          mapContainerElement.clientHeight / 2 - playerVisualHeight / 2;

        playerElement.style.left = `${playerScreenX}px`;
        playerElement.style.top = `${playerScreenY}px`;

        const mapScrollX =
          -(gameState.player.x * currentTileSize) + playerScreenX;
        const mapScrollY =
          -(gameState.player.y * currentTileSize) + playerScreenY;

        mapElement.style.transform = `translate(${mapScrollX}px, ${mapScrollY}px)`;

        gameState.map.entities.forEach((entity) => {
          const distance =
            Math.abs(entity.x - gameState.player.x) +
            Math.abs(entity.y - gameState.player.y);
          if (distance <= G_PLAYER_DISCOVERY_RANGE) {
            if (!entity.discovered) entity.discovered = true;
          }
        });

        renderMap(callerId);
        updatePlayerSpriteVisual();
        updatePlayerVisualSize();
        updatePlayerBarsOnMap(); // <--- LLAMADA A√ëADIDA
      }

      // ... (el resto de tus funciones JS, como updateUI, movePlayer, interact, etc. SIN CAMBIOS IMPORTANTES aqu√≠,
      //      ya que los cambios principales son en el renderizado y tama√±o de tiles)
      function updateUI() {
        const player = gameState.player;
        document.getElementById("playerLevel").textContent = player.level;
        document.getElementById("playerRealm").textContent = player.realm;
        document.getElementById("hpText").textContent = `${Math.floor(
          player.hp
        )}/${player.maxHp}`;
        document.getElementById("manaText").textContent = `${Math.floor(
          player.mana
        )}/${player.maxMana}`;
        document.getElementById("expText").textContent = `${Math.floor(
          player.exp
        )}/${player.expToNext}`;

        // Barras del Sidebar
        const hpBarSidebar = document.getElementById("hpBar");
        const manaBarSidebar = document.getElementById("manaBar");
        const expBarSidebar = document.getElementById("expBar");

        if (hpBarSidebar)
          hpBarSidebar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        if (manaBarSidebar)
          manaBarSidebar.style.width = `${
            (player.mana / player.maxMana) * 100
          }%`;
        if (expBarSidebar)
          expBarSidebar.style.width = `${
            (player.exp / player.expToNext) * 100
          }%`;

        document.getElementById(
          "playerCoords"
        ).textContent = `X: ${player.x}, Y: ${player.y}`;

        updateToggleQiConversionButtonVisibility(); // Asumo que esta funci√≥n existe y es correcta
        updateInventoryUI(); // Asumo que esta funci√≥n existe y es correcta
        updateSectUI(); // Asumo que esta funci√≥n existe y es correcta

        updatePlayerBarsOnMap(); // <--- LLAMADA A√ëADIDA para las barras sobre el jugador
      }

      function updateInventoryUI() {
        const inventoryDisplay = document.getElementById("inventory");
        inventoryDisplay.innerHTML = "";
        Object.entries(gameState.inventory).forEach(([itemName, count]) => {
          if (count <= 0 && itemName !== "Piedras Espirituales") return;

          const itemDiv = document.createElement("div");
          itemDiv.className = "inventory-item";

          const itemInfo = itemData[itemName];
          const description = itemInfo
            ? itemInfo.description
            : "Un objeto misterioso.";
          itemDiv.innerHTML = `<strong>${itemName}: ${count}</strong><br><small><em>${description}</em></small>`;

          if (count > 0 && itemInfo && itemInfo.effect) {
            const canBeUsedNow = itemInfo.canUse
              ? itemInfo.canUse(gameState.player)
              : true;
            itemDiv.style.cursor = canBeUsedNow ? "pointer" : "not-allowed";
            itemDiv.style.opacity = canBeUsedNow ? 1 : 0.6;
            itemDiv.title = canBeUsedNow
              ? `Usar ${itemName}`
              : `No puedes usar ${itemName} ahora.`;
            if (canBeUsedNow) {
              itemDiv.onclick = () => useItem(itemName);
            }
          } else {
            itemDiv.style.opacity = 0.8;
            itemDiv.style.cursor = "default";
          }
          inventoryDisplay.appendChild(itemDiv);
        });
      }

      function updateToggleQiConversionButtonVisibility() {
        const button = document.getElementById("toggleQiConversionButton");
        if (gameState.player.canUseQiConversion) {
          button.style.display = "inline-block";
          button.textContent = gameState.player.isQiConversionActive
            ? "‚òØÔ∏è Detener Conversi√≥n Qi"
            : "‚òØÔ∏è Activar Conversi√≥n Qi";
        } else {
          button.style.display = "none";
        }
      }

      function updateRefinementUI() {}

      let movePlayerCallCount = 0;

      let lastPlayerAnimationUpdateTime = 0; // Renombrado para claridad

      function movePlayer(dx, dy) {
        const playerState = gameState.player; // Acceso m√°s corto

        if (playerState.isCultivating || gameState.battle.active) {
          if (playerState.isMoving) {
            // Si se estaba moviendo y se interrumpe
            playerState.isMoving = false;
            updatePlayerSpriteVisual();
          }
          return;
        }

        const prevDirection = playerState.spriteFacingDirection;
        let newDirection = prevDirection;

        if (dx > 0) newDirection = "right";
        else if (dx < 0) newDirection = "left";
        else if (dy > 0) newDirection = "down";
        else if (dy < 0) newDirection = "up";

        // console.log(`[MovePlayer] Attempt move. dx:${dx}, dy:${dy}. NewDir: ${newDirection}`);

        playerState.isMoving = true; // Intenci√≥n de moverse

        if (prevDirection !== newDirection) {
          playerState.spriteFacingDirection = newDirection;
          animationFrameIndex = 0; // Reiniciar animaci√≥n al cambiar de direcci√≥n
          playerState.spriteWalkFrame = PLAYER_WALK_CYCLE[animationFrameIndex];
          // console.log(`[MovePlayer] Direction changed to ${newDirection}. Reset animFrameIdx to 0.`);
        }

        const now = Date.now();
        if (now - lastPlayerAnimationUpdateTime > PLAYER_ANIMATION_SPEED) {
          animationFrameIndex =
            (animationFrameIndex + 1) % PLAYER_WALK_CYCLE.length;
          playerState.spriteWalkFrame = PLAYER_WALK_CYCLE[animationFrameIndex];
          lastPlayerAnimationUpdateTime = now;
          // console.log(`[MovePlayer] Animation tick. animFrameIdx: ${animationFrameIndex}, spriteWalkFrame set to col: ${playerState.spriteWalkFrame}`);
        }

        const newX = playerState.x + dx;
        const newY = playerState.y + dy;
        let canMove = true;

        if (
          newX < 0 ||
          newX >= gameState.map.width ||
          newY < 0 ||
          newY >= gameState.map.height
        ) {
          canMove = false;
        } else {
          const targetTerrainId = getTerrainTypeAt(newX, newY);
          const targetTerrainData = G_TERRAIN_TYPES[targetTerrainId];
          if (targetTerrainData && targetTerrainData.walkable === false) {
            // showModal("Camino Bloqueado", `No puedes moverte sobre ${targetTerrainData.name}.`); // Puede ser muy verboso
            canMove = false;
          } else {
            const entityAtNewPosition = gameState.map.entities.find(
              (e) =>
                e.x === newX &&
                e.y === newY &&
                e.type !== "shop" &&
                e.type !== "secta_entrada_principal" &&
                !(entityTypes[e.type] && entityTypes[e.type].npcId)
            );
            if (entityAtNewPosition) {
              if (
                G_COMBAT_ENTITY_TYPES.includes(entityAtNewPosition.type) ||
                entityAtNewPosition.isBoss ||
                entityAtNewPosition.isSectChallengeRival
              ) {
                playerState.isMoving = false; // Detener animaci√≥n antes de la batalla
                updatePlayerSpriteVisual();
                startBattle(entityAtNewPosition);
                return;
              }
            }
          }
        }

        if (canMove) {
          playerState.x = newX;
          playerState.y = newY;
          updatePlayerPosition(`movePlayer_success`);
          updateUI();
        } else {
          playerState.isMoving = false; // No se pudo mover, no est√° "movi√©ndose"
          // console.log("[MovePlayer] Movement blocked.");
        }

        updatePlayerSpriteVisual(); // Actualizar el sprite con la direcci√≥n y estado de movimiento actuales

        clearTimeout(playerState.stopMoveAnimTimer);
        playerState.stopMoveAnimTimer = setTimeout(() => {
          // console.log("[MovePlayer] Stop animation timer fired.");
          playerState.isMoving = false;
          // playerState.spriteWalkFrame = PLAYER_WALK_CYCLE[0]; // Volver al frame definido como "quieto"
          updatePlayerSpriteVisual(); // Asegurar que se muestre el frame de quieto
        }, PLAYER_ANIMATION_SPEED + 50); // Un poco m√°s que la velocidad de animaci√≥n del frame
      }

      let playerMovementKeysDown = {
        // Para rastrear qu√© teclas de movimiento est√°n presionadas
        up: false,
        down: false,
        left: false,
        right: false,
      };
      function handlePlayerMovementInput(direction, isKeyDown) {
        const player = gameState.player;

        if (isKeyDown) {
          playerMovementKeysDown[direction] = true;
          player.currentDirection = direction;
          player.isMoving = true;

          if (player.idleTimeout) {
            clearTimeout(player.idleTimeout);
            player.idleTimeout = null;
          }

          if (!player.animationTimer) {
            player.currentFrame = 1;
            updatePlayerSpriteVisual(); // <--- CORREGIR AQU√ç
            player.animationTimer = setInterval(() => {
              if (player.isMoving) {
                player.currentFrame =
                  (player.currentFrame + 1) % player.animationFrames;
                if (player.currentFrame === 0) player.currentFrame = 1;
                updatePlayerSpriteVisual(); // <--- CORREGIR AQU√ç
              }
            }, player.animationSpeed);
          }
        } else {
          playerMovementKeysDown[direction] = false;
          const stillMoving = Object.values(playerMovementKeysDown).some(
            (status) => status === true
          );

          if (!stillMoving) {
            player.isMoving = false;
            if (player.animationTimer) {
              clearInterval(player.animationTimer);
              player.animationTimer = null;
            }
            player.idleTimeout = setTimeout(() => {
              if (!player.isMoving) {
                player.currentFrame = 0;
                updatePlayerSpriteVisual(); // <--- CORREGIR AQU√ç
              }
            }, player.animationSpeed);
          } else {
            if (playerMovementKeysDown["up"]) player.currentDirection = "up";
            else if (playerMovementKeysDown["down"])
              player.currentDirection = "down";
            else if (playerMovementKeysDown["left"])
              player.currentDirection = "left";
            else if (playerMovementKeysDown["right"])
              player.currentDirection = "right";
            updatePlayerSpriteVisual(); // <--- CORREGIR AQU√ç
          }
        }
      }

      function interact() {
        if (gameState.player.isCultivating) {
          showModal(
            "Acci√≥n no permitida",
            "Det√©n tu cultivo antes de interactuar."
          );
          return;
        }
        if (gameState.battle.active) {
          showModal(
            "Acci√≥n no permitida",
            "No puedes interactuar durante el combate."
          );
          return;
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;
        const offsets = [
          { dx: 0, dy: 0 },
          { dx: 0, dy: -1 },
          { dx: 1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: -1, dy: 0 },
        ];

        for (const offset of offsets) {
          const targetX = playerX + offset.dx;
          const targetY = playerY + offset.dy;
          const entity = gameState.map.entities.find(
            (e) => e.x === targetX && e.y === targetY
          );

          if (entity) {
            if (
              G_COMBAT_ENTITY_TYPES.includes(entity.type) ||
              entity.isBoss ||
              entity.isSectChallengeRival
            ) {
              const desafioMision = gameState.player.secta.misionesActivas.find(
                (m) =>
                  MISIONES_DATA[m.id]?.objetivo?.tipo ===
                    "derrotar_npc_especifico" &&
                  MISIONES_DATA[m.id]?.objetivo?.npcId === entity.npcId
              );
              if (entity.isSectChallengeRival) {
                if (desafioMision) {
                  showModal(
                    "¬°Desaf√≠o Aceptado!",
                    `Te preparas para enfrentar a ${entity.name}.`,
                    true
                  );
                  setTimeout(() => {
                    closeModal();
                    startBattle(entity);
                  }, 1500);
                } else {
                  showModal(
                    "Paz, por ahora...",
                    `${entity.name} te observa, pero no hay raz√≥n para luchar.`
                  );
                }
              } else {
                showModal(
                  "¬°A la Batalla!",
                  `Decides enfrentar a ${entity.name}.`,
                  true
                );
                setTimeout(() => {
                  closeModal();
                  startBattle(entity);
                }, 1000);
              }
              return;
            } else if (
              entity.interaction ||
              entityTypes[entity.type]?.interaction ||
              [
                "resource",
                "master",
                "cultivation",
                "shop",
                "secta_entrada_principal",
              ].includes(entity.type)
            ) {
              handleEntityInteraction(entity);
              return;
            }
          }
        }
      }

      function handleEntityInteraction(entity) {
        if (!entity) return;

        let interactionType = entity.interaction; // Priorizar la interacci√≥n de la instancia

        // Si no hay interacci√≥n en la instancia, buscar en la definici√≥n de entityTypes
        // usando entity.originalEntityTypeId si est√° disponible, sino entity.type
        const definitionKey = entity.originalEntityTypeId || entity.type;
        if (!interactionType && entityTypes[definitionKey]) {
          interactionType = entityTypes[definitionKey].interaction;
        }

        if (interactionType) {
          switch (interactionType) {
            case "browse":
              if (entity.type === "shop") {
                openShop();
                return;
              }
              break;
            case "talk_secta_npc":
              if (entity.npcId) {
                interactWithSectNPC(entity.npcId);
                return;
              }
              break;
            case "access_sect_hall":
              if (entity.type === "secta_entrada_principal") {
                openSectHallInterface();
                return;
              }
              break;
            case "collect_resource":
              const rewardItem =
                entity.reward ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].reward
                  : null) ||
                "Piedras Espirituales"; // √öltimo fallback

              const itemNameDisplay =
                entity.name ||
                (entityTypes[entity.originalEntityTypeId]
                  ? entityTypes[entity.originalEntityTypeId].name
                  : entity.type);

              gameState.inventory[rewardItem] =
                (gameState.inventory[rewardItem] || 0) + 1;
              showModal(
                "Recurso Encontrado",
                `Has obtenido: 1 ${rewardItem}! (de ${itemNameDisplay})`
              );
              removeEntity(entity);
              updateInventoryUI();
              return;
            case "learn_from_master":
              const expGain =
                entity.expGain || entityTypes[entity.type]?.expGain || 50;
              gainExperience(expGain);
              showModal(
                "Encuentro con Maestro",
                `El ${entity.name} te ha ense√±ado sabidur√≠a. Ganas ${expGain} EXP!`
              );
              removeEntity(entity);
              return;
            case "meditate_spot":
              const manaGain =
                entity.manaGain || entityTypes[entity.type]?.manaGain || 20;
              gameState.player.mana = Math.min(
                gameState.player.maxMana,
                gameState.player.mana + manaGain
              );
              showModal(
                "Lugar de Cultivo",
                `Has meditado en '${entity.name}'. Recuperas ${manaGain} Man√°.`
              );
              removeEntity(entity);
              updateUI();
              return;
            default:
              console.warn(
                `Interacci√≥n '${interactionType}' desconocida para ${entity.name} (Tipo: ${entity.type}, ID: ${entity.id}).`
              );
              break;
          }
        } else {
          console.log(
            `No hay acci√≥n definida para tipo '${entity.type}' (Entidad: ${entity.name}, ID: ${entity.id}, OrigTypeID: ${entity.originalEntityTypeId}).`
          );
        }
      }

      function interactWithSectNPC(npcId) {
        const npcData = SECTA_DATA.npcs[npcId];
        const player = gameState.player;
        if (!npcData) {
          console.error(
            `[interactWithSectNPC] NPC Data no encontrada para npcId: ${npcId}`
          );
          return;
        }

        console.log(
          `[NPC Interaction] Starting interaction with NPC: ${npcData.nombre} (ID: ${npcId})`
        );
        console.log(
          `[NPC Interaction] Player Active Missions (Raw):`,
          JSON.parse(JSON.stringify(player.secta.misionesActivas))
        );
        console.log(
          `[NPC Interaction] Player Inventory:`,
          JSON.parse(JSON.stringify(gameState.inventory))
        );

        let modalContentHTML = `<h3>${npcData.nombre} (${npcData.rol})</h3>`;
        modalContentHTML += `<p><em>"${npcData.dialogoInicial}"</em></p><hr>`;

        const elementsToProcess = [];

        // --- SECCI√ìN: MISIONES PARA COMPLETAR ---
        modalContentHTML += `<h4>Misiones para Entregar/Reportar:</h4>`;
        let algunaMisionParaCompletar = false;

        player.secta.misionesActivas.forEach((misionActiva) => {
          const misionDef = MISIONES_DATA[misionActiva.id];

          // Log b√°sico para cada misi√≥n activa
          console.log(
            `[NPC Interaction] Evaluating Active Mission: "${misionDef?.titulo}" (ID: ${misionActiva.id})`
          );

          // Comprobaciones cruciales: misionDef, objetivo, y objetivoOriginal deben existir.
          if (
            !misionDef ||
            !misionDef.objetivo ||
            !misionActiva.objetivoOriginal
          ) {
            console.warn(
              `[NPC Interaction] Skipping mission ID ${misionActiva.id}: Missing misionDef, misionDef.objetivo, or misionActiva.objetivoOriginal.`
            );
            return; // Saltar esta misi√≥n si los datos esenciales faltan
          }

          const objetivo = misionActiva.objetivoOriginal; // Usar el objetivo original guardado
          console.log(
            `[NPC Interaction] Mission "${
              misionDef.titulo
            }": Target NPC for delivery/report is "${
              objetivo.npcEntrega
            }". Current NPC is "${npcId}". Match: ${
              objetivo.npcEntrega === npcId
            }`
          );

          // Solo procesar si el NPC actual es el NPC de entrega/reporte de la misi√≥n
          if (objetivo.npcEntrega === npcId) {
            let listaParaEntregar = false;
            let objetivoStatus = "";

            console.log(
              `[NPC Interaction] Mission "${misionDef.titulo}" IS for this NPC. Original objective type: ${objetivo.tipo}`
            );

            switch (objetivo.tipo) {
              case "entregar_item":
                const playerHasItem = gameState.inventory[objetivo.item] || 0;
                const needsItem = objetivo.cantidad;
                console.log(
                  `  - Type 'entregar_item'. Item: "${objetivo.item}", Needs: ${needsItem}, Player Has: ${playerHasItem}`
                );
                if (playerHasItem >= needsItem) {
                  listaParaEntregar = true;
                  objetivoStatus = `(Tienes ${playerHasItem}/${needsItem} ${objetivo.item})`;
                } else {
                  objetivoStatus = `(Necesitas ${
                    needsItem - playerHasItem
                  } m√°s ${objetivo.item})`;
                }
                break;

              case "eliminar_enemigo":
                const currentProgressElim = misionActiva.progreso || 0;
                const needsElim = objetivo.cantidad;
                console.log(
                  `  - Type 'eliminar_enemigo'. Target: "${objetivo.nombreDisplay}", Needs: ${needsElim}, Progress: ${currentProgressElim}`
                );
                if (currentProgressElim >= needsElim) {
                  listaParaEntregar = true; // Significa que los enemigos fueron eliminados, lista para 'reportar'
                  objetivoStatus = `(${currentProgressElim}/${needsElim} ${objetivo.nombreDisplay} eliminados)`;
                } else {
                  objetivoStatus = `(Elimina ${
                    needsElim - currentProgressElim
                  } m√°s ${objetivo.nombreDisplay})`;
                }
                break;

              case "recolectar_multiples_items":
                let todosRecolectados = true;
                let itemsStatusArray = [];
                console.log(
                  `  - Type 'recolectar_multiples_items'. Items required:`,
                  objetivo.items
                );
                for (const itemReq of objetivo.items) {
                  const playerHasMulti =
                    gameState.inventory[itemReq.nombre] || 0;
                  const needsMulti = itemReq.cantidad;
                  console.log(
                    `    - Item: "${itemReq.nombre}", Needs: ${needsMulti}, Player Has: ${playerHasMulti}`
                  );
                  if (playerHasMulti < needsMulti) {
                    todosRecolectados = false;
                  }
                  itemsStatusArray.push(
                    `${playerHasMulti}/${needsMulti} ${itemReq.nombre}`
                  );
                }
                if (todosRecolectados) {
                  listaParaEntregar = true;
                }
                objetivoStatus = `(${itemsStatusArray.join(", ")})`;
                break;

              case "cazar_y_recuperar_item_de_loot":
                const playerHasLootItem =
                  (gameState.inventory[objetivo.itemPrueba] || 0) >=
                  objetivo.cantidadItemPrueba;
                // El progreso a 1 indica que el tipo de enemigo que suelta el item fue derrotado.
                const killedCorrectEnemyType = misionActiva.progreso === 1;
                console.log(
                  `  - Type 'cazar_y_recuperar_item_de_loot'. Item: "${
                    objetivo.itemPrueba
                  }", Needs Qty: ${
                    objetivo.cantidadItemPrueba
                  }, Player Has Qty: ${
                    gameState.inventory[objetivo.itemPrueba] || 0
                  }. Killed enemy type: ${killedCorrectEnemyType}`
                );
                if (killedCorrectEnemyType && playerHasLootItem) {
                  // Debe haber matado al enemigo Y tener el √≠tem
                  listaParaEntregar = true;
                  objetivoStatus = `(Tienes ${objetivo.itemPrueba})`;
                } else if (!killedCorrectEnemyType) {
                  objetivoStatus = `(Caza al ${
                    entityTypes[objetivo.enemigoTipo]?.name ||
                    objetivo.enemigoTipo
                  } y consigue ${objetivo.itemPrueba})`;
                } else {
                  // Killed enemy, but doesn't have item (sold it? used it? or it never dropped - handle this in loot drop if needed)
                  objetivoStatus = `(Necesitas ${objetivo.itemPrueba}. ¬øLo perdiste o no lo obtuviste?)`;
                }
                break;

              // A√±adir m√°s casos aqu√≠ para otros tipos de misi√≥n que se completan con este NPC
              default:
                console.warn(
                  `[NPC Interaction] Unhandled objective type "${objetivo.tipo}" for mission "${misionDef.titulo}" completion check with NPC.`
                );
                objetivoStatus = `(Objetivo: ${objetivo.tipo} - estado no verificado aqu√≠)`;
                break;
            }

            console.log(
              `[NPC Interaction] Mission "${misionDef.titulo}": listaParaEntregar = ${listaParaEntregar}. Objetivo status display: ${objetivoStatus}`
            );

            // Solo mostrar el bot√≥n de completar si listaParaEntregar es true
            if (listaParaEntregar) {
              const buttonId = `complete-mission-btn-${misionActiva.id.replace(
                /\W/g,
                "_"
              )}`;
              modalContentHTML += `<div style="padding: 5px; border: 1px solid #55cc55; margin-bottom: 5px; background-color: rgba(85,204,85,0.1);">
                                            <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                            <button id="${buttonId}">Completar Misi√≥n</button>
                                        </div>`;
              elementsToProcess.push({
                buttonId: buttonId,
                action: () => {
                  console.log(
                    `[NPC Interaction] Clicked "Completar Misi√≥n" button for ${misionActiva.id}`
                  );
                  // Pasar npcId como npcIdEntregaManual a completeMission
                  if (completeMission(misionActiva.id, npcId)) {
                    // Si la misi√≥n se complet√≥ con √©xito, el modal del NPC se refrescar√°
                    // porque completeMission llama a showModal y al cerrarlo se actualiza el UI
                    // o, como alternativa, podemos forzar el refresco aqu√≠.
                    // closeModal(); // Cierra el modal de interacci√≥n actual
                    interactWithSectNPC(npcId); // Vuelve a abrir el modal del NPC con el estado actualizado
                  }
                  // Si completeMission devuelve false, generalmente ya muestra un modal de error/info.
                },
              });
              algunaMisionParaCompletar = true;
              console.log(
                `[NPC Interaction] SUCCESS: Added "Completar Misi√≥n" button for ${misionDef.titulo}`
              );
            } else {
              // Opcional: Mostrar la misi√≥n pero sin el bot√≥n de completar si no est√° lista
              modalContentHTML += `<div style="padding: 5px; border: 1px solid #777; margin-bottom: 5px; background-color: rgba(100,100,100,0.1);">
                                            <strong>${misionDef.titulo}</strong> ${objetivoStatus}<br>
                                            <small><em>(A√∫n no cumples todos los requisitos para entregar/reportar esta misi√≥n)</em></small>
                                        </div>`;
              console.log(
                `[NPC Interaction] INFO: Mission "${misionDef.titulo}" is for this NPC but not ready for completion. Displaying status.`
              );
            }
          } else {
            // Log si la misi√≥n no es para este NPC
            // console.log(`[NPC Interaction] Mission "${misionDef.titulo}" is not designated for this NPC (Delivery NPC: ${objetivo.npcEntrega}).`);
          }
        });

        if (
          !algunaMisionParaCompletar &&
          !player.secta.misionesActivas.some(
            (m) => MISIONES_DATA[m.id]?.objetivo?.npcEntrega === npcId
          )
        ) {
          // Si no hay misiones para completar con ESTE NPC, y tampoco hay misiones activas que SEAN para este NPC (incluso si no est√°n listas)
          modalContentHTML +=
            "<p>No tienes misiones para entregarme o reportarme en este momento.</p>";
          console.log(
            `[NPC Interaction] No missions found that are completable OR assignable to this NPC for completion.`
          );
        } else if (!algunaMisionParaCompletar) {
          // Hay misiones asignadas a este NPC, pero ninguna est√° lista para completarse.
          modalContentHTML +=
            "<p>Revisa los objetivos de tus misiones activas. Parece que a√∫n no est√°n listas para entregar/reportar.</p>";
          console.log(
            `[NPC Interaction] Missions are assigned to this NPC, but none are ready for completion yet.`
          );
        }
        modalContentHTML += "<hr>";

        // --- SECCI√ìN: MISIONES DISPONIBLES (CON FILTRO DE NIVEL Y RANGO) ---
        // (Esta secci√≥n parece estar bien, la mantengo como estaba en tu c√≥digo anterior con la l√≥gica de requisitos)
        if (npcData.misionesOfrecidas && npcData.misionesOfrecidas.length > 0) {
          modalContentHTML += "<h4>Misiones Disponibles:</h4>";
          modalContentHTML += `<div id="npc-dynamic-content-missions" style="max-height: 200px; overflow-y: auto; border: 1px solid #444; padding: 10px; margin-bottom:10px;">`;
          let algunaMisionDisponibleMostrada = false;
          npcData.misionesOfrecidas.forEach((misionId, index) => {
            const mision = MISIONES_DATA[misionId];
            if (
              mision &&
              !player.secta.misionesActivas.some((m) => m.id === misionId) &&
              !player.secta.misionesCompletadas[misionId]
            ) {
              const nivelRequerido = mision.requisitoNivel || 0;
              const rangoRequeridoNombre = mision.requisitoRango;
              let cumpleRequisitos = true;

              if (player.level < nivelRequerido) {
                cumpleRequisitos = false;
              }
              if (rangoRequeridoNombre) {
                const indiceRangoJugador = SECTA_DATA.rangos.findIndex(
                  (r) => r.nombre === player.secta.rango
                );
                const indiceRangoRequerido = SECTA_DATA.rangos.findIndex(
                  (r) => r.nombre === rangoRequeridoNombre
                );
                if (indiceRangoJugador < indiceRangoRequerido) {
                  cumpleRequisitos = false;
                }
              }

              if (cumpleRequisitos) {
                let recompensaTextoResumido = `Recompensa: ${
                  mision.recompensa.pcs || 0
                } PCS, ${mision.recompensa.exp || 0} EXP`;
                if (mision.recompensa.items)
                  recompensaTextoResumido += ", Objetos";
                if (mision.recompensa.nuevoRango)
                  recompensaTextoResumido += `, Ascenso a ${mision.recompensa.nuevoRango}`;

                const buttonId = `accept-mission-btn-${misionId.replace(
                  /\W/g,
                  "_"
                )}-${index}`;
                const botonHTML = `<button id="${buttonId}">Aceptar Misi√≥n</button>`;

                modalContentHTML += `<div style="padding: 5px; border: 1px solid #555; margin-bottom: 5px;">
                                            <strong>${
                                              mision.titulo
                                            }</strong> (Req. Nv: ${
                  nivelRequerido > 0 ? nivelRequerido : "Ninguno"
                }${
                  rangoRequeridoNombre ? ", Rango: " + rangoRequeridoNombre : ""
                })<br><small>${mision.descripcion}</small><br>
                                            <small style="color: #aaa;"><em>${recompensaTextoResumido}</em></small><br>
                                            ${botonHTML} 
                                        </div>`;
                elementsToProcess.push({
                  buttonId: buttonId,
                  missionIdToAccept: misionId,
                });
                algunaMisionDisponibleMostrada = true;
              }
            }
          });
          if (!algunaMisionDisponibleMostrada)
            modalContentHTML +=
              "<p>No hay nuevas misiones para ti en este momento que cumplan tus requisitos.</p>";
          modalContentHTML += `</div>`;
          modalContentHTML += "<hr>";
        } else {
          modalContentHTML +=
            "<p>No tengo misiones para ti en este momento.</p><hr>";
        }

        // --- SECCI√ìN: ENTREGA DE RECURSOS ---
        // (Esta secci√≥n parece estar bien, la mantengo)
        if (npcData.aceptaRecursos && npcData.aceptaRecursos.length > 0) {
          modalContentHTML += `<h4>Entregar Recursos:</h4>`;
          modalContentHTML += `<div id="npc-dynamic-content-resources" style="max-height: 150px; overflow-y: auto;">`;
          let puedeEntregarAlgo = false;
          npcData.aceptaRecursos.forEach((itemName) => {
            const cantidadPlayer = gameState.inventory[itemName] || 0;
            if (cantidadPlayer > 0) {
              const pcsPorItem =
                itemName === "Hierbas Medicinales"
                  ? 2
                  : itemName === "Cristales de Qi"
                  ? 5
                  : itemName === "N√∫cleo de Bestia Menor"
                  ? 10
                  : 1;
              const buttonIdEntregar1 = `entregar-1-${itemName.replace(
                /\W/g,
                "_"
              )}`;
              const buttonIdEntregarAll = `entregar-all-${itemName.replace(
                /\W/g,
                "_"
              )}`;
              modalContentHTML += `<p>${itemName} (Tienes: ${cantidadPlayer}): 
                                    <button id="${buttonIdEntregar1}">Entregar 1 (${pcsPorItem} PCS)</button>
                                    ${
                                      cantidadPlayer > 1
                                        ? `<button id="${buttonIdEntregarAll}">Entregar Todo (${
                                            pcsPorItem * cantidadPlayer
                                          } PCS)</button>`
                                        : ""
                                    }
                                </p>`;
              elementsToProcess.push({
                buttonId: buttonIdEntregar1,
                action: () => {
                  entregarRecursoSecta(itemName, 1, pcsPorItem);
                  interactWithSectNPC(npcId);
                },
              });
              if (cantidadPlayer > 1) {
                elementsToProcess.push({
                  buttonId: buttonIdEntregarAll,
                  action: () => {
                    entregarRecursoSecta(
                      itemName,
                      cantidadPlayer,
                      pcsPorItem * cantidadPlayer
                    );
                    interactWithSectNPC(npcId);
                  },
                });
              }
              puedeEntregarAlgo = true;
            }
          });
          if (!puedeEntregarAlgo)
            modalContentHTML +=
              "<p>No tienes recursos que pueda necesitar en este momento.</p>";
          modalContentHTML += `</div><hr>`;
        }

        showModal("Interacci√≥n con " + npcData.nombre, modalContentHTML);

        const modalTextEl = document.getElementById("modalText");
        if (modalTextEl) {
          elementsToProcess.forEach((item) => {
            const buttonElement = modalTextEl.querySelector(
              "#" + item.buttonId
            );
            if (buttonElement) {
              if (item.missionIdToAccept) {
                buttonElement.addEventListener("click", () => {
                  acceptMission(item.missionIdToAccept);
                  interactWithSectNPC(npcId);
                });
              } else if (item.action) {
                buttonElement.addEventListener("click", item.action);
              }
            } else {
              console.warn(
                "[NPC Interaction] Could not find button with ID:",
                item.buttonId,
                "in #modalText to attach listener."
              );
            }
          });
        } else {
          console.error(
            "[NPC Interaction] #modalText element not found for attaching listeners to dynamic buttons."
          );
        }
      }

      function entregarRecursoSecta(itemName, cantidad, pcsGanados) {
        if ((gameState.inventory[itemName] || 0) < cantidad) {
          showModal("Error", "No tienes suficientes objetos.");
          return;
        }
        gameState.inventory[itemName] -= cantidad;
        gameState.player.secta.puntosContribucion += pcsGanados;
        showModal(
          "Recurso Entregado",
          `Entregaste ${cantidad} ${itemName} y ganaste ${pcsGanados} PCS.`
        );
        updateSectUI();
        updateInventoryUI();
        checkAndActivateRankChallengeMissions();
        closeModal();
      }

      function acceptMission(misionId) {
        const misionData = MISIONES_DATA[misionId];
        const player = gameState.player;
        if (!misionData) {
          showModal("Error de Misi√≥n", "Datos no encontrados.");
          return;
        }
        if (
          player.secta.misionesActivas.some((m) => m.id === misionId) ||
          player.secta.misionesCompletadas[misionId]
        ) {
          showModal("Error de Misi√≥n", "Ya activa/completada.");
          return;
        }
        if (!misionData.objetivo) {
          showModal("Error de Misi√≥n", "Objetivo no definido.");
          return;
        }

        let nuevaMisionActiva;
        try {
          nuevaMisionActiva = {
            id: misionId,
            progreso: 0,
            objetivoOriginal: JSON.parse(JSON.stringify(misionData.objetivo)),
          };
        } catch (error) {
          showModal("Error de Misi√≥n", "Problema al procesar objetivo.");
          return;
        }

        player.secta.misionesActivas.push(nuevaMisionActiva);
        showModal("Misi√≥n Aceptada", `Has aceptado: ${misionData.titulo}`);
        updateSectUI();

        const npcInteractionModal = document.getElementById("interactionModal");
        const modalTitleElement = document.getElementById("modalTitle");
        if (
          npcInteractionModal.style.display === "flex" &&
          modalTitleElement &&
          modalTitleElement.textContent.includes("Interacci√≥n con Secta")
        ) {
          closeModal();
        }
      }

      function removeEntity(entityToRemove) {
        const index = gameState.map.entities.findIndex(
          (e) => e.id === entityToRemove.id
        ); // Usar ID √∫nico

        if (index > -1) {
          const removedEntity = gameState.map.entities.splice(index, 1)[0];

          // Si la entidad proven√≠a de una zona de spawn, actualizar el contador de esa zona
          if (removedEntity.zoneOrigin) {
            const originZone = gameState.map.terrainZones.find(
              (z) => z.name === removedEntity.zoneOrigin && z.spawnSettings
            );
            if (originZone) {
              const targetSpawnInfo =
                originZone.spawnSettings.targetEntities.find(
                  (t) => t.entityTypeId === removedEntity.originalEntityTypeId // <-- USAR ESTO
                );
              if (targetSpawnInfo && targetSpawnInfo.currentCount > 0) {
                targetSpawnInfo.currentCount--;
                // console.log(`Entidad ${removedEntity.name} eliminada de zona ${originZone.name}. Restantes de tipo ${targetSpawnInfo.entityTypeId}: ${targetSpawnInfo.currentCount}`);

                // Si el contador baja y el timer estaba en cooldown, podemos resetear el timer
                // para que intente reaparecer antes si la zona est√° por debajo del objetivo.
                // Opcional: Podr√≠as querer que el cooldown siempre se cumpla.
                // if (originZone.spawnSettings.respawnTimer > 10) { // Si estaba en cooldown largo
                //    originZone.spawnSettings.respawnTimer = 10; // Poner un cooldown corto para el pr√≥ximo chequeo
                // }
              }
            }
          }
          renderMap(); // Actualizar visualizaci√≥n
        }
      }

      function isRespawnNeeded() {
        const player = gameState.player;
        const activeBoss = gameState.map.entities.find(
          (e) =>
            e.isBoss &&
            !player.worldState.defeatedBosses[e.id || e.type] &&
            Math.abs(e.x - player.x) <= 5 &&
            Math.abs(e.y - player.y) <= 5
        );
        return !activeBoss;
      }

      function toggleCultivation() {
        if (gameState.battle.active) {
          showModal("Acci√≥n no permitida", "No puedes cultivar en combate.");
          return;
        }
        if (gameState.player.isCultivating) {
          showActiveCultivationModal();
        } else {
          openCultivationChoiceModal();
        }
      }

      function openCultivationChoiceModal() {
        const player = gameState.player;
        const techniquesListDiv = document.getElementById(
          "cultivableTechniquesList"
        );
        techniquesListDiv.innerHTML = "";
        let hasCultivableTechniques = false;
        for (const techId in player.learnedTechniques) {
          const playerTech = player.learnedTechniques[techId];
          const techData = techniqueData[techId];
          if (
            techData &&
            techData.cultivationSettings &&
            playerTech.level < techData.maxLevel
          ) {
            hasCultivableTechniques = true;
            const techButton = document.createElement("button");
            techButton.className = "cultivation-option-btn";
            techButton.textContent = `${techData.name} (Nv. ${playerTech.level})`;
            techButton.onclick = () => {
              startCultivationMode("technique", techId);
              closeCultivationChoiceModal();
            };
            techniquesListDiv.appendChild(techButton);
          }
        }
        if (!hasCultivableTechniques) {
          techniquesListDiv.innerHTML =
            "<p>No tienes t√©cnicas que requieran m√°s cultivo.</p>";
        }
        document.getElementById("cultivationChoiceModal").style.display =
          "flex";
        hideTouchControls();
      }

      function closeCultivationChoiceModal() {
        document.getElementById("cultivationChoiceModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
      }

      function startCultivationMode(type, targetId = null) {
        const player = gameState.player;
        if (player.isCultivating) {
          stopCultivation();
        }

        player.isCultivating = true;
        player.cultivationMode.type = type;
        player.cultivationMode.targetId = targetId;
        player.cultivationMode.startTime = Date.now();

        // Si se inicia el modo de recuperaci√≥n, reseteamos el progreso de su barra visual
        if (type === "recovery") {
          recoveryProgress = 0;
          recoveryDirection = 1;
        }

        const cultivateBtnSidebar = document.getElementById("cultivateButton");
        if (cultivateBtnSidebar) {
          cultivateBtnSidebar.textContent = "üö´ Detener Cultivo";
        } else {
          console.error(
            "Error en startCultivationMode: No se encontr√≥ 'cultivateButton'."
          );
        }

        if (gameState.cultivationInterval)
          clearInterval(gameState.cultivationInterval);
        gameState.cultivationInterval = setInterval(
          processCultivationTick,
          1000
        );

        showActiveCultivationModal();
      }

      function stopCultivation() {
        const player = gameState.player;
        if (!player.isCultivating) return;
        player.isCultivating = false;

        if (gameState.cultivationInterval) {
          clearInterval(gameState.cultivationInterval);
          gameState.cultivationInterval = null;
        }

        closeActiveCultivationModal();

        const cultivateBtn = document.getElementById("cultivateButton");
        if (cultivateBtn) cultivateBtn.textContent = "üßò‚Äç‚ôÄÔ∏è Cultivar";

        const durationSeconds = Math.floor(
          (Date.now() - player.cultivationMode.startTime) / 1000
        );
        showModal(
          "Cultivo Terminado",
          `Has terminado de meditar/cultivar por ${durationSeconds} segundos.`
        );
        updateUI();
        if (
          document.getElementById("techniqueModal").style.display === "flex"
        ) {
          showTechniquePanel();
        }
      }

      function showActiveCultivationModal() {
        const player = gameState.player;
        const mode = player.cultivationMode;

        const modal = document.getElementById("activeCultivationModal");
        const title = document.getElementById("activeCultivationTitle");
        const description = document.getElementById(
          "activeCultivationDescription"
        );

        const techniqueProgressUIDiv = document.getElementById(
          "activeCultivationProgressUI"
        );
        const recoveryProgressUIDiv = document.getElementById(
          "recoveryCultivationProgressUI"
        );
        const cultivationBoostSection = document.getElementById(
          "cultivationBoostSection"
        ); // Nueva referencia
        if (!player.isCultivating) {
          closeActiveCultivationModal();
          return;
        }

        // Ocultar barras sobre el jugador en el mapa mientras el modal est√° abierto
        const playerBarsOnMap = document.getElementById(
          "playerOnMapBarsContainer"
        );
        if (playerBarsOnMap) playerBarsOnMap.style.display = "none";

        // Ocultar barras sobre el sprite en batalla (aunque no deber√≠a estar en batalla y cultivando)
        const playerBarsInBattle = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        if (playerBarsInBattle) playerBarsInBattle.style.display = "none";

        if (techniqueProgressUIDiv)
          techniqueProgressUIDiv.style.display = "none";
        if (recoveryProgressUIDiv) recoveryProgressUIDiv.style.display = "none";
        if (cultivationBoostSection)
          cultivationBoostSection.style.display = "none";

        if (mode.type === "recovery") {
          title.textContent = "Meditaci√≥n Restauradora";
          description.textContent =
            "Recuperando energ√≠a vital, Qi y absorbiendo experiencia del entorno.";

          if (recoveryProgressUIDiv) {
            recoveryProgressUIDiv.style.display = "block";
            const recoveryProgressBar = document.getElementById(
              "recoveryProgressBar"
            );
            const recoveryCycleText =
              document.getElementById("recoveryCycleText");

            // Referencias a los elementos de HP y Man√° del modal
            const modalHpText = document.getElementById("modalHpText");
            const modalHpBar = document.getElementById("modalHpBar");
            const modalManaText = document.getElementById("modalManaText");
            const modalManaBar = document.getElementById("modalManaBar");

            if (recoveryProgressBar)
              recoveryProgressBar.style.width = `${recoveryProgress}%`;
            if (recoveryCycleText)
              recoveryCycleText.textContent =
                recoveryDirection === 1
                  ? "Inhalando Qi..."
                  : "Exhalando impurezas...";

            // Actualizar texto y barras de HP/Man√° en el modal
            if (modalHpText)
              modalHpText.textContent = `${Math.floor(player.hp)}/${
                player.maxHp
              }`;
            if (modalHpBar)
              modalHpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
            if (modalManaText)
              modalManaText.textContent = `${Math.floor(player.mana)}/${
                player.maxMana
              }`;
            if (modalManaBar)
              modalManaBar.style.width = `${
                (player.mana / player.maxMana) * 100
              }%`;
          }
        } else if (mode.type === "technique" && mode.targetId) {
          const techData = techniqueData[mode.targetId];
          const playerTech = player.learnedTechniques[mode.targetId];

          if (techData && playerTech) {
            title.textContent = `Cultivando: ${techData.name}`;
            description.textContent = techData.description;

            if (techniqueProgressUIDiv) {
              techniqueProgressUIDiv.style.display = "block";
              const targetNameSpan = document.getElementById(
                "activeCultivationTargetName"
              );
              const targetLevelSpan = document.getElementById(
                "activeCultivationTargetLevel"
              );
              const techniqueProgressBar = document.getElementById(
                "activeCultivationProgressBar"
              );
              const techniqueProgressText = document.getElementById(
                "activeCultivationProgressText"
              );

              if (targetNameSpan) targetNameSpan.textContent = techData.name;
              if (targetLevelSpan)
                targetLevelSpan.textContent = playerTech.level;

              const timeToNext =
                playerTech.cultivationTimeToNextLevel ||
                (techData.cultivationSettings
                  ? techData.cultivationSettings.baseTimeToLevelUp
                  : Infinity);
              const progressPercent =
                playerTech.currentCultivationProgress && timeToNext !== Infinity
                  ? (playerTech.currentCultivationProgress / timeToNext) * 100
                  : playerTech.level >= techData.maxLevel
                  ? 100
                  : 0;
              if (techniqueProgressBar)
                techniqueProgressBar.style.width = `${Math.min(
                  100,
                  progressPercent
                )}%`;
              if (techniqueProgressText)
                techniqueProgressText.textContent =
                  timeToNext === Infinity
                    ? "Nivel M√°ximo"
                    : `${Math.floor(
                        playerTech.currentCultivationProgress || 0
                      )}s / ${timeToNext}s`;
            }

            // Mostrar y configurar la secci√≥n de aceleraci√≥n
            if (cultivationBoostSection) {
              cultivationBoostSection.style.display = "block";
              document.getElementById(
                "cultivationModalPlayerStones"
              ).textContent = gameState.inventory["Piedras Espirituales"] || 0;
              const boostButton = document.getElementById(
                "boostCultivationButton"
              );
              if (boostButton) {
                boostButton.disabled =
                  (gameState.inventory["Piedras Espirituales"] || 0) < 1 ||
                  playerTech.level >= techData.maxLevel;
                if (playerTech.level >= techData.maxLevel) {
                  boostButton.title = "T√©cnica al m√°ximo nivel";
                } else if (
                  (gameState.inventory["Piedras Espirituales"] || 0) < 1
                ) {
                  boostButton.title = "Piedras Espirituales insuficientes";
                } else {
                  boostButton.title = "Acelerar Cultivo (1 Piedra = 10s)";
                }
              }
            }
          } else {
            // Fallback a recuperaci√≥n si hay un error
            title.textContent = "Meditaci√≥n Restauradora";
            description.textContent =
              "Error al cargar datos de t√©cnica/habilidad. Cultivo de recuperaci√≥n activado.";
            if (recoveryProgressUIDiv) {
              recoveryProgressUIDiv.style.display = "block";
              const modalHpText = document.getElementById("modalHpText");
              const modalHpBar = document.getElementById("modalHpBar");
              const modalManaText = document.getElementById("modalManaText");
              const modalManaBar = document.getElementById("modalManaBar");
              if (modalHpText)
                modalHpText.textContent = `${Math.floor(player.hp)}/${
                  player.maxHp
                }`;
              if (modalHpBar)
                modalHpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
              if (modalManaText)
                modalManaText.textContent = `${Math.floor(player.mana)}/${
                  player.maxMana
                }`;
              if (modalManaBar)
                modalManaBar.style.width = `${
                  (player.mana / player.maxMana) * 100
                }%`;
            }
          }
        } // No a√±adas llaves extra aqu√≠, aseg√∫rate de que la funci√≥n cierra correctamente.

        if (modal) modal.style.display = "flex";

        hideTouchControls();
      }

      function closeActiveCultivationModal() {
        document.getElementById("activeCultivationModal").style.display =
          "none";
        updatePlayerBarsOnMap();
        showTouchControls();
      }

      function processCultivationTick() {
        const player = gameState.player;
        if (!player.isCultivating) {
          if (gameState.cultivationInterval)
            clearInterval(gameState.cultivationInterval);
          gameState.cultivationInterval = null;
          return;
        }

        const mode = player.cultivationMode.type;
        const targetId = player.cultivationMode.targetId;

        if (mode === "recovery") {
          // --- Recuperaci√≥n General ---
          if (player.hp < player.maxHp)
            player.hp = Math.min(
              player.maxHp,
              player.hp + player.hpPerSecondBase
            );

          let manaGainThisTick = player.qiPerSecondBase;
          if (
            player.canUseQiConversion &&
            player.isQiConversionActive &&
            player.learnedTechniques["qi_to_hp_conversion_1"]
          ) {
            const conversionTechInfo = techniqueData["qi_to_hp_conversion_1"];
            const playerConversionTech =
              player.learnedTechniques["qi_to_hp_conversion_1"];
            if (conversionTechInfo?.effect && playerConversionTech.level > 0) {
              const effectDef = conversionTechInfo.effect;
              const techLevel = playerConversionTech.level;
              let currentManaCost =
                effectDef.baseManaCostPerSecond -
                (effectDef.manaCostReductionPerLevel || 0) * (techLevel - 1);
              currentManaCost = Math.max(0.1, currentManaCost);
              let currentHpGain =
                effectDef.baseHpGainPerSecond +
                (effectDef.hpGainIncreasePerLevel || 0) * (techLevel - 1);
              if (player.mana >= currentManaCost && player.hp < player.maxHp) {
                player.mana -= currentManaCost;
                manaGainThisTick = 0;
                player.hp = Math.min(player.maxHp, player.hp + currentHpGain);
              }
            }
          }
          if (player.mana < player.maxMana && manaGainThisTick > 0) {
            player.mana = Math.min(
              player.maxMana,
              player.mana + manaGainThisTick
            );
          }
          gainExperience(player.expPerSecondBase);

          // --- L√≥gica para la barra de progreso de ciclo de recuperaci√≥n ---
          const increment = 100 / RECOVERY_CYCLE_DURATION;
          recoveryProgress += recoveryDirection * increment;
          if (recoveryProgress >= 100) {
            recoveryProgress = 100;
            recoveryDirection = -1;
          } else if (recoveryProgress <= 0) {
            recoveryProgress = 0;
            recoveryDirection = 1;
          }

          // Actualizar UI del ciclo de recuperaci√≥n si el modal est√° abierto
          if (
            document.getElementById("activeCultivationModal").style.display ===
            "flex"
          ) {
            const recoveryProgressBar = document.getElementById(
              "recoveryProgressBar"
            );
            const recoveryCycleText =
              document.getElementById("recoveryCycleText");
            if (recoveryProgressBar)
              recoveryProgressBar.style.width = `${recoveryProgress}%`;
            if (recoveryCycleText)
              recoveryCycleText.textContent =
                recoveryDirection === 1
                  ? "Inhalando Qi..."
                  : "Exhalando impurezas...";
          }
        } else if (mode === "technique" && targetId) {
          // ... (l√≥gica de cultivo de t√©cnica sin cambios aqu√≠ para las barras del modal,
          //      ya que esas barras son principalmente para 'recovery')
          const playerTech = player.learnedTechniques[targetId];
          const techData = techniqueData[targetId];
          if (
            playerTech &&
            techData &&
            techData.cultivationSettings &&
            playerTech.level < techData.maxLevel
          ) {
            playerTech.currentCultivationProgress =
              (playerTech.currentCultivationProgress || 0) + 1;
            gainExperience(player.expPerSecondBase * 0.2);
            if (
              playerTech.currentCultivationProgress >=
              playerTech.cultivationTimeToNextLevel
            ) {
              playerTech.level++;
              playerTech.currentCultivationProgress = 0;
              if (playerTech.level < techData.maxLevel) {
                playerTech.cultivationTimeToNextLevel = Math.floor(
                  techData.cultivationSettings.baseTimeToLevelUp *
                    (techData.cultivationSettings.levelTimeMultiplier *
                      playerTech.level)
                );
                playerTech.cultivationTimeToNextLevel = Math.max(
                  techData.cultivationSettings.baseTimeToLevelUp,
                  playerTech.cultivationTimeToNextLevel
                );
              } else {
                playerTech.cultivationTimeToNextLevel = Infinity;
              }
              applyTechniqueEffect(targetId, playerTech.level);
              recalculatePlayerStats();
              let message = `¬°Has cultivado '${techData.name}' al Nivel ${playerTech.level}!`;
              if (playerTech.level >= techData.maxLevel) {
                message += " (¬°Nivel M√°ximo alcanzado!)";
              }
              stopCultivation();
              showModal(
                "¬°T√©cnica Mejorada!",
                message +
                  "\n\nEl cultivo se ha detenido. Puedes reiniciarlo si lo deseas."
              );
              if (
                document.getElementById("techniqueModal").style.display ===
                "flex"
              )
                showTechniquePanel();
            }
          } else if (
            playerTech &&
            techData &&
            playerTech.level >= techData.maxLevel
          ) {
            stopCultivation();
          }
        } else if (mode === "skill" && targetId) {
          // ...
        }

        updateUI();
        if (
          document.getElementById("activeCultivationModal").style.display ===
          "flex"
        ) {
          showActiveCultivationModal(); // Refresca el modal, incluyendo la nueva barra de recuperaci√≥n
        }
      }

      function boostCultivationProgress() {
        const player = gameState.player;
        const mode = player.cultivationMode;

        if (
          !player.isCultivating ||
          mode.type !== "technique" ||
          !mode.targetId
        ) {
          showModal(
            "Error de Aceleraci√≥n",
            "Solo puedes acelerar el cultivo activo de una t√©cnica espec√≠fica."
          );
          return;
        }

        if ((gameState.inventory["Piedras Espirituales"] || 0) < 1) {
          showModal(
            "Piedras Insuficientes",
            "No tienes suficientes Piedras Espirituales para acelerar."
          );
          return;
        }

        const techId = mode.targetId;
        const playerTech = player.learnedTechniques[techId];
        const techData = techniqueData[techId];

        if (
          !playerTech ||
          !techData ||
          !techData.cultivationSettings ||
          playerTech.level >= techData.maxLevel
        ) {
          // A√±adida comprobaci√≥n de techData.cultivationSettings
          showModal(
            "L√≠mite Alcanzado",
            "Esta t√©cnica ya est√° en su nivel m√°ximo, no se puede cultivar m√°s, o faltan datos de cultivo."
          );
          const boostButton = document.getElementById("boostCultivationButton");
          if (boostButton) boostButton.disabled = true;
          return;
        }

        // Consumir piedra
        gameState.inventory["Piedras Espirituales"]--;

        // A√±adir progreso (10 segundos)
        playerTech.currentCultivationProgress =
          (playerTech.currentCultivationProgress || 0) + 10;
        gainExperience(player.expPerSecondBase * 0.2 * 2);

        let leveledUpThisBoost = false;
        let firstLevelUpMessage = "";

        // Asegurarse de que cultivationTimeToNextLevel est√° inicializado si el nivel es 0
        if (
          playerTech.level === 0 &&
          (!playerTech.cultivationTimeToNextLevel ||
            playerTech.cultivationTimeToNextLevel === Infinity)
        ) {
          playerTech.cultivationTimeToNextLevel =
            techData.cultivationSettings.baseTimeToLevelUp;
        }

        while (
          playerTech.currentCultivationProgress >=
            playerTech.cultivationTimeToNextLevel &&
          playerTech.level < techData.maxLevel
        ) {
          playerTech.level++;
          playerTech.currentCultivationProgress -=
            playerTech.cultivationTimeToNextLevel;

          if (playerTech.level < techData.maxLevel) {
            playerTech.cultivationTimeToNextLevel = Math.floor(
              techData.cultivationSettings.baseTimeToLevelUp *
                (techData.cultivationSettings.levelTimeMultiplier *
                  playerTech.level)
            );
            // La siguiente l√≠nea es crucial: Asegura que el tiempo calculado no sea MENOR que el baseTimeToLevelUp.
            // Y aqu√≠ estaba el error: se usaba baseTimeToNextLevel en lugar de baseTimeToLevelUp
            playerTech.cultivationTimeToNextLevel = Math.max(
              techData.cultivationSettings.baseTimeToLevelUp,
              playerTech.cultivationTimeToNextLevel
            ); // <-- CORRECCI√ìN IMPORTANTE AQU√ç
          } else {
            playerTech.currentCultivationProgress = 0;
            playerTech.cultivationTimeToNextLevel = Infinity;
          }

          applyTechniqueEffect(techId, playerTech.level);
          recalculatePlayerStats();

          if (!leveledUpThisBoost) {
            firstLevelUpMessage = `¬°Aceleraste '${techData.name}' al Nivel ${playerTech.level}!`;
            if (playerTech.level >= techData.maxLevel) {
              firstLevelUpMessage += " (¬°Nivel M√°ximo alcanzado!)";
            }
          }
          leveledUpThisBoost = true;
        }

        if (leveledUpThisBoost) {
          stopCultivation();
          showModal(
            "¬°T√©cnica Mejorada con Aceleraci√≥n!",
            firstLevelUpMessage +
              "\n\nEl cultivo se ha detenido. Puedes reiniciarlo."
          );
        } else if (playerTech.level >= techData.maxLevel) {
          stopCultivation();
          showModal(
            "Nivel M√°ximo Alcanzado",
            `La t√©cnica ${techData.name} ya est√° en su m√°ximo potencial. El cultivo se ha detenido.`
          );
        }

        updateUI();
        // Es importante llamar a showActiveCultivationModal() DESPU√âS de stopCultivation() si el cultivo se detuvo,
        // o si no se detuvo, para que refleje el estado actual.
        // Si se detuvo, el modal se cerrar√° por stopCultivation(). Si el modal no est√° abierto, esta llamada no har√° nada.
        if (
          document.getElementById("activeCultivationModal").style.display ===
          "flex"
        ) {
          showActiveCultivationModal();
        }

        if (
          document.getElementById("techniqueModal").style.display === "flex"
        ) {
          showTechniquePanel();
        }
      }

      function toggleQiConversionMode() {
        if (!gameState.player.canUseQiConversion) {
          showModal(
            "Habilidad Bloqueada",
            "Debes dominar la T√©cnica de Conversi√≥n de Qi."
          );
          return;
        }
        if (gameState.player.isCultivating) {
          showModal(
            "Acci√≥n no Permitida",
            "Det√©n tu cultivo antes de cambiar conversi√≥n."
          );
          return;
        }
        gameState.player.isQiConversionActive =
          !gameState.player.isQiConversionActive;
        updateToggleQiConversionButtonVisibility();
        showModal(
          "Modo de Cultivo",
          `Conversi√≥n de Qi ${
            gameState.player.isQiConversionActive ? "Activada" : "Desactivada"
          }.`
        );
      }

      function useItem(itemName) {
        if (gameState.battle.active) {
          showModal(
            "Acci√≥n no permitida",
            "No puedes usar objetos del inventario en combate desde aqu√≠."
          );
          return;
        }
        if (
          !gameState.inventory[itemName] ||
          gameState.inventory[itemName] <= 0
        ) {
          showModal("Inventario Vac√≠o", `No tienes ${itemName}.`);
          return;
        }
        const itemInfo = itemData[itemName];
        if (!itemInfo || !itemInfo.effect) {
          showModal(
            "Error",
            `${itemName} no tiene efecto o no se puede usar as√≠.`
          );
          return;
        }
        if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
          let reason = "No puedes usar esto ahora.";
          if (
            itemName === "Hierbas Medicinales" &&
            gameState.player.hp >= gameState.player.maxHp
          )
            reason = "Vida al m√°ximo.";
          if (
            itemName === "Cristales de Qi" &&
            gameState.player.mana >= gameState.player.maxMana
          )
            reason = "Man√° al m√°ximo.";
          showModal("No se puede usar", reason);
          return;
        }
        const message =
          itemName === "Piedras Espirituales" ||
          itemName === "N√∫cleo de Bestia Menor" ||
          (itemInfo.description &&
            (itemInfo.description.includes("Otorga") ||
              itemInfo.description.includes("otorga")))
            ? itemInfo.effect(gameState.player, gainExperience)
            : itemInfo.effect(gameState.player);

        // Solo decrementar si el mensaje no indica un error (por si el efecto mismo retorna un error)
        if (
          message &&
          !message.toLowerCase().includes("error") &&
          !message.toLowerCase().includes("al m√°ximo")
        ) {
          gameState.inventory[itemName]--;
        }
        showModal("Objeto Usado", message);
        updateUI();
      }

      function gainExperience(amount) {
        if (amount <= 0) return;
        gameState.player.exp += amount;
        while (gameState.player.exp >= gameState.player.expToNext) {
          levelUp();
        }
      }

      function levelUp() {
        const player = gameState.player;
        player.exp -= player.expToNext;
        player.level++;

        const hpIncrease = 20 + Math.floor(player.level / 2);
        const manaIncrease = 10 + Math.floor(player.level / 3);
        const attackIncrease = 2 + Math.floor(player.level / 4);
        const defenseIncrease = 1 + Math.floor(player.level / 5);

        player.baseMaxHp += hpIncrease;
        player.baseMaxMana += manaIncrease;
        player.baseAttack += attackIncrease;
        player.baseDefense += defenseIncrease;

        player.hp = player.baseMaxHp; // Rellenar HP y Mana al subir de nivel
        player.mana = player.baseMaxMana;
        player.expToNext = Math.floor(
          player.expToNext * (1.3 + player.level * 0.02)
        );

        const oldRealm = player.realm;
        const realms = [
          "Mortal",
          "Forjado del Cuerpo",
          "Condensaci√≥n de Qi",
          "Fundaci√≥n",
          "N√∫cleo Dorado",
          "Alma Naciente",
          "Esp√≠ritu Primordial",
        ];
        const realmIndex = Math.min(
          Math.floor((player.level - 1) / 5),
          realms.length - 1
        );
        player.realm = realms[realmIndex];
        let realmChangeMessage = "";
        if (player.realm !== oldRealm) {
          realmChangeMessage = `\n\n¬°Has avanzado al Reino de ${player.realm}! Sientes una profunda transformaci√≥n...`;
          generateMap(true);
        }
        recalculatePlayerStats();

        showModal(
          "¬°Nivel Aumentado!",
          `Nivel ${player.level}!\nReino: ${player.realm}\n+${hpIncrease} HP, +${manaIncrease} Man√°\n+${attackIncrease} Atk, +${defenseIncrease} Def${realmChangeMessage}`
        );
      }

      function recalculatePlayerStats() {
        const player = gameState.player;
        // Reiniciar stats a base
        player.maxHp = player.baseMaxHp;
        player.maxMana = player.baseMaxMana;
        player.attack = player.baseAttack;
        player.defense = player.baseDefense;

        // Asegurar que HP y Mana actuales no excedan los m√°ximos recalculados
        player.hp = Math.min(player.hp, player.maxHp);
        player.mana = Math.min(player.mana, player.maxMana);

        gameState.activeCombatAbilities = []; // Reiniciar lista de habilidades de combate activas

        // Procesar t√©cnicas aprendidas para habilidades de combate activas y efectos pasivos directos
        for (const techId in player.learnedTechniques) {
          const playerTech = player.learnedTechniques[techId];
          if (playerTech.level > 0) {
            // Solo si la t√©cnica ha sido cultivada al menos al nivel 1 (o 0 si as√≠ lo defines)
            const techInfo = techniqueData[techId];
            if (
              techInfo?.type === "active_ability" &&
              !gameState.activeCombatAbilities.find(
                (ab) => ab.id === techInfo.abilityId
              )
            ) {
              gameState.activeCombatAbilities.push({
                id: techInfo.abilityId,
                name: techInfo.name,
                source: "technique",
                sourceTechniqueId: techId, // Guardar el ID de la t√©cnica fuente es √∫til
              });
            }
            // Si tienes t√©cnicas pasivas que modifican stats como "Fortificaci√≥n Corporal B√°sica",
            // sus efectos ya se aplicaron al player.baseStat cuando se aprendieron/subieron de nivel en applyTechniqueEffect.
            // recalculatePlayerStats se encarga de que maxHp, attack, etc., se actualicen desde baseMaxHp, baseAttack.
          }
        }
        updateUI(); // Actualizar la UI con los stats recalculados
      }

      function startBattle(mapEntity) {
        const toggleBtn = document.getElementById('toggleMapControlsBtn');
        if (toggleBtn) {
            toggleBtn.classList.add('hidden-during-battle');
        }
        const player = gameState.player;
        if (player.isCultivating) stopCultivation();
        hideTouchControls();

        // Detener animaci√≥n de caminar al entrar en batalla
        player.isMoving = false;
        if (player.animationTimer) {
          clearInterval(player.animationTimer);
          player.animationTimer = null;
        }
        if (player.idleTimeout) {
          clearTimeout(player.idleTimeout);
          player.idleTimeout = null;
        }
        player.currentDirection = "down"; // O la direcci√≥n que quieras en batalla
        player.currentFrame = 0; // Frame idle
        updatePlayerSpriteVisual(); // Actualizar para mostrar el sprite de batalla

        gameState.battle.active = true;
        gameState.battle.enemy = {
          ...mapEntity,
          hp: mapEntity.hp,
          maxHp: mapEntity.maxHp || mapEntity.hp,
          entityRef: mapEntity,
          frozenTurns: 0,
          stunnedTurns: 0,
          burningTurns: 0,
          burnDamage: 0,
          poisonedTurns: 0,
          poisonDamage: 0,
          defenseReductionTurns: 0,
          defenseReductionAmount: 0,
          rootedTurns: 0,
          rootDamage: 0,
          attackReductionTurns: 0,
          attackReductionAmount: 0,
        };
        gameState.battle.playerTurn = true;

        document.getElementById("battleScreen").style.display = "flex";
        populateBattleActionButtons();
        updateBattleUI();
        logBattle(`¬°Un ${gameState.battle.enemy.name} te enfrenta!`);
        updateBottomNavVisibility();
        updatePlayerBarsOnMap();
      }

      function populateBattleActionButtons() {
        const battleActionButtons = document.getElementById(
          "battleActionButtons"
        );
        battleActionButtons.innerHTML = `
            <button onclick="battleAction('attack')">‚öîÔ∏è Atacar</button>
            <button onclick="battleAction('defend')">üõ°Ô∏è Defender</button>
            <button onclick="battleAction('qi_fist')">üßò Pu√±o de Qi</button> 
            <button onclick="battleAction('escape')">üèÉ Huir</button>
        `;
        gameState.activeCombatAbilities.forEach((ability) => {
          const abilityButton = document.createElement("button");
          let buttonText = `‚ú® ${ability.name}`;
          let canAfford = true;
          if (ability.source === "technique" && ability.sourceTechniqueId) {
            const techLevel =
              gameState.player.learnedTechniques[ability.sourceTechniqueId]
                ?.level;
            if (techLevel > 0) buttonText += ` (Nv.${techLevel})`;
            else {
              abilityButton.disabled = true;
              abilityButton.title = "Requiere refinamiento";
            }
          }
          const techDetails =
            ability.source === "technique" && ability.sourceTechniqueId
              ? techniqueData[ability.sourceTechniqueId]
              : null;
          let manaCost = 0;
          if (
            techDetails &&
            techDetails.effect &&
            techDetails.effect.manaCost
          ) {
            manaCost = techDetails.effect.manaCost;
          } else if (ability.id === "qi_blast_minor") {
            manaCost = 15;
          } else if (techDetails && techDetails.manaCost) {
            manaCost = techDetails.manaCost;
          }
          if (manaCost > 0 && gameState.player.mana < manaCost) {
            canAfford = false;
          }

          abilityButton.textContent = buttonText;
          abilityButton.onclick = () => battleAction(ability.id, ability);
          abilityButton.disabled = abilityButton.disabled || !canAfford;
          if (!canAfford && !abilityButton.disabled)
            abilityButton.title = "Man√° insuficiente";

          battleActionButtons.appendChild(abilityButton);
        });
      }

      function updateBattleUI() {
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        const battleScreenActive = document.getElementById('battleScreen').style.display === 'flex';

        // --- Actualizaci√≥n del Jugador (Barras sobre el sprite) ---
        const playerBarsContainer = document.getElementById("playerInBattleSpriteBarsContainer");
        const playerSpriteInBattle = document.querySelector(".battle-area .character .character-sprite");

        if (playerBarsContainer && playerSpriteInBattle && battleScreenActive) {
            playerBarsContainer.style.display = 'flex';
            const spriteTop = playerSpriteInBattle.offsetTop;
            const spriteLeft = playerSpriteInBattle.offsetLeft;
            const spriteWidth = playerSpriteInBattle.offsetWidth;
            const barContainerHeight = playerBarsContainer.offsetHeight;

            playerBarsContainer.style.top = `${spriteTop - barContainerHeight - 3}px`;
            playerBarsContainer.style.left = `${spriteLeft + (spriteWidth / 2)}px`;

            const playerHpFill = document.getElementById("playerInBattleSpriteHpFill");
            const playerManaFill = document.getElementById("playerInBattleSpriteManaFill");
            if(playerHpFill) playerHpFill.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
            if(playerManaFill) playerManaFill.style.width = `${Math.max(0, (player.mana / player.maxMana) * 100)}%`;

        } else if (playerBarsContainer) {
            playerBarsContainer.style.display = 'none';
        }

        // --- Actualizaci√≥n del Enemigo (Info y barras sobre el sprite) ---
        const enemyInfoContainer = document.getElementById('enemyInBattleInfoContainer');
        const enemySpriteEl = document.getElementById('enemySprite');
        
        // MOVER LA DECLARACI√ìN DE enemyHpPercent AQU√ç ARRIBA
        let enemyHpPercent = 0;
        if (enemy) { // Asegurarse que enemy exista antes de calcular
            enemyHpPercent = Math.max(0, (enemy.hp / (enemy.maxHp || enemy.hp)) * 100);
        }

        if (enemy && enemyInfoContainer && enemySpriteEl && battleScreenActive) {
            enemyInfoContainer.style.display = 'flex';

            const spriteTop = enemySpriteEl.offsetTop;
            const spriteLeft = enemySpriteEl.offsetLeft;
            const spriteWidth = enemySpriteEl.offsetWidth;
            const infoContainerHeight = enemyInfoContainer.offsetHeight;

            if (isMobileView()) {
                console.log("[Mobile Battle UI] Enemy Sprite - offsetTop:", spriteTop, "offsetLeft:", spriteLeft, "offsetWidth:", spriteWidth);
                console.log("[Mobile Battle UI] Enemy InfoContainer - offsetHeight:", infoContainerHeight);
                console.log("[Mobile Battle UI] Calculated top:", `${spriteTop - infoContainerHeight - 5}px`, "Calculated left:", `${spriteLeft + (spriteWidth / 2)}px`);
            }

            enemyInfoContainer.style.top = `${spriteTop - infoContainerHeight - 5}px`;
            enemyInfoContainer.style.left = `${spriteLeft + (spriteWidth / 2)}px`;

            const enemyNameLevelEl = document.getElementById('enemyBattleNameLevel');
            const enemySpriteHpFill = document.getElementById('enemyInBattleSpriteHpFill'); // Barra SOBRE el sprite

            if (enemyNameLevelEl) {
                let enemyDisplayName = enemy.name;
                if (enemy.level) enemyDisplayName += ` (Nv.${enemy.level})`;
                else if (enemy.isBoss) enemyDisplayName += ` (Jefe)`;
                else if (enemy.isMiniBoss) enemyDisplayName += ` (√âlite)`;
                enemyNameLevelEl.textContent = enemyDisplayName;
            }
            if (enemySpriteHpFill) enemySpriteHpFill.style.width = `${enemyHpPercent}%`; // Usa la variable ya calculada

        } else if (enemyInfoContainer) {
            enemyInfoContainer.style.display = 'none';
        }

        // --- Actualizaci√≥n del resto de la UI de batalla (nombres debajo, barras principales, etc.) ---
        if (battleScreenActive) {
            document.getElementById('playerBattleName').textContent = `Cultivador (Nv.${player.level})`;
            document.getElementById('playerBattleHp').textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
            document.getElementById('playerBattleHpBar').style.width = `${(player.hp / player.maxHp) * 100}%`;
            
            // updatePlayerBarsInBattle(); // Esta llamada podr√≠a ser redundante si ya actualizamos las barras del jugador arriba.
                                        // Mantenla si hace algo m√°s o si la l√≥gica de arriba se mueve.

            if (enemy && enemySpriteEl) { // A√±adir chequeo para enemySpriteEl aqu√≠ tambi√©n
                enemySpriteEl.textContent = enemy.symbol || '?';
                document.getElementById('enemyName').textContent = enemy.name;
                document.getElementById('enemyHp').textContent = `${Math.floor(enemy.hp)}/${enemy.maxHp || enemy.hp}`;
                document.getElementById('enemyHpBar').style.width = `${enemyHpPercent}%`; // Usa la variable ya calculada
            }
        }
    }
      function battleAction(action, abilityDetails = null) {
        if (!gameState.battle.playerTurn || !gameState.battle.active) return;
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        let actionTaken = true;
        let playerTechLevel = 0;
        if (
          abilityDetails &&
          abilityDetails.source === "technique" &&
          abilityDetails.sourceTechniqueId
        ) {
          playerTechLevel =
            player.learnedTechniques[abilityDetails.sourceTechniqueId]?.level ||
            0;
        }

        // --- Aplicar DoTs y HoTs al JUGADOR ---
        if (player.burningTurns > 0) {
          player.hp -= player.burnDamage;
          logBattle(`Sufres ${player.burnDamage} da√±o por quemadura.`);
          player.burningTurns--;
          if (player.burningTurns === 0) logBattle("Quemadura se extingue.");
        }
        if (player.poisonedTurns > 0) {
          player.hp -= player.poisonDamage;
          logBattle(`Sufres ${player.poisonDamage} da√±o por veneno.`);
          player.poisonedTurns--;
          if (player.poisonedTurns === 0) logBattle("Veneno desaparece.");
        }
        if (player.healingRainTurns > 0) {
          const heal = player.healingRainAmount;
          player.hp = Math.min(player.maxHp, player.hp + heal);
          logBattle(`Lluvia Curativa te sana ${heal} HP.`);
          player.healingRainTurns--;
          if (player.healingRainTurns === 0) logBattle("Lluvia Curativa cesa.");
        }

        // --- Revertir buffs/debuffs temporales del JUGADOR ---
        if (player.defenseBoostTurns > 0) {
          player.defenseBoostTurns--;
          if (player.defenseBoostTurns === 0) {
            player.defense -= player.defenseBoostAmount;
            logBattle(`Piel de Piedra termina. Defensa: ${player.defense}.`);
            player.defenseBoostAmount = 0;
          }
        }
        if (player.bloodRitualTurns > 0 && action !== "blood_ritual") {
          player.bloodRitualTurns--;
          if (player.bloodRitualTurns === 0) {
            player.attack -= player.bloodRitualAttackBoost;
            logBattle(`Ritual de Sangre termina. Ataque: ${player.attack}.`);
            player.bloodRitualAttackBoost = 0;
          }
        }
        if (player.immuneTurns > 0 && action !== "aura_of_purity") {
          player.immuneTurns--;
          if (player.immuneTurns === 0) {
            logBattle(`Inmunidad termina.`);
          }
        }
        if (
          player.cloneActive &&
          player.cloneTurns > 0 &&
          action !== "phantom_clone"
        ) {
          player.cloneTurns--;
          if (player.cloneTurns === 0) {
            player.cloneActive = false;
            logBattle("Clon Fantasma desaparece.");
          }
        }
        if (player.elementalTurns > 0 && action !== "summon_elemental") {
          player.elementalTurns--;
          if (player.elementalTurns === 0) {
            player.attack -= player.tempAttackBonus;
            player.defense -= player.tempDefenseBonus;
            logBattle("Elemental invocado desaparece.");
            player.tempAttackBonus = 0;
            player.tempDefenseBonus = 0;
          }
        }
        if (player.magicShieldTurns > 0 && action !== "mystic_barrier") {
          player.magicShieldTurns--;
          if (player.magicShieldTurns === 0 && player.magicShieldValue > 0) {
            logBattle("Barrera M√≠stica se disipa.");
            player.magicShieldValue = 0;
          }
        }

        if (player.hp <= 0) {
          logBattle("Has sucumbido antes de actuar.");
          player.hp = 0;
          setTimeout(() => {
            player.hp = Math.floor(player.maxHp * 0.1);
            player.mana = Math.floor(player.maxMana * 0.1);
            const expLossPercentage = 0.1;
            const expToLose = Math.floor(player.exp * expLossPercentage);
            player.exp = Math.max(0, player.exp - expToLose);
            logBattle(`Pierdes ${expToLose} EXP.`);
            const safeRespawnCoords = findSafeRespawnLocation(
              G_SAFE_RESPAWN_X,
              G_SAFE_RESPAWN_Y
            );
            player.x = safeRespawnCoords.x;
            player.y = safeRespawnCoords.y;
            updatePlayerPosition();
            endBattle(false);
            showModal("Derrota", "Has sido derrotado...");
          }, 2000);
          return;
        }

        switch (action) {
          case "attack":
            const damage = Math.max(
              1,
              player.attack -
                (enemy.defense || 0) +
                Math.floor(Math.random() * 5 - 2)
            );
            enemy.hp -= damage;
            logBattle(`Atacas causando ${damage} da√±o.`);
            break;
          case "defend":
            let healAmount = Math.floor(player.maxHp * 0.1);
            player.hp = Math.min(player.maxHp, player.hp + healAmount);
            logBattle(`Te defiendes y recuperas ${healAmount} HP.`);
            const meditationSkillInfo = getSkillById("se_mana_regen_1");
            if (
              meditationSkillInfo &&
              player.learnedSkills["se_mana_regen_1"]
            ) {
              const manaRegenEffect = meditationSkillInfo.effects.find(
                (e) => e.effectId === "mana_regen_on_defend"
              );
              if (manaRegenEffect) {
                player.mana = Math.min(
                  player.maxMana,
                  player.mana + manaRegenEffect.value
                );
                logBattle(
                  `Meditaci√≥n profunda restaura ${manaRegenEffect.value} man√°.`
                );
              }
            }
            break;
          case "qi_fist":
            const qiFistCost = 10;
            if (player.mana >= qiFistCost) {
              player.mana -= qiFistCost;
              const magicDamage = Math.max(
                1,
                Math.floor(player.attack * 0.8 + player.maxMana * 0.2) -
                  (enemy.defense || 0)
              );
              enemy.hp -= magicDamage;
              logBattle(`Pu√±o de Qi causa ${magicDamage} da√±o m√°gico.`);
            } else {
              logBattle("Man√° insuficiente para Pu√±o de Qi.");
              actionTaken = false;
            }
            break;
          case "escape":
            if (enemy.isBoss) {
              logBattle(`¬°No puedes huir de un ${enemy.name}!`);
            } else if (Math.random() < 0.7) {
              logBattle("¬°Escapaste!");
              endBattle(false);
              return;
            } else {
              logBattle("¬°No pudiste escapar!");
            }
            break;
          case "sword_slash":
            const swordTechDetails = techniqueData["sword_slash_1"];
            const swordManaCost = swordTechDetails.manaCost || 10;
            if (player.mana >= swordManaCost) {
              player.mana -= swordManaCost;
              const damageMultiplier =
                swordTechDetails.effect.baseDamageMultiplier +
                (playerTechLevel - 1) * 0.2;
              const swordDamage = Math.max(
                1,
                Math.floor(player.attack * damageMultiplier) -
                  (enemy.defense || 0)
              );
              enemy.hp -= swordDamage;
              logBattle(
                `¬°${swordTechDetails.name} (Nv.${playerTechLevel}) causa ${swordDamage} da√±o!`
              );
            } else {
              logBattle(`Man√° insuficiente para ${swordTechDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "qi_blast_minor":
            const qiBlastCostSkill = 15;
            if (player.mana >= qiBlastCostSkill) {
              player.mana -= qiBlastCostSkill;
              const qiDamage = Math.max(
                1,
                Math.floor(player.attack * 0.6 + player.maxMana * 0.4) -
                  (enemy.defense || 0)
              );
              enemy.hp -= qiDamage;
              logBattle(
                `¬°Lanzas ${abilityDetails.name} causando ${qiDamage} da√±o Qi!`
              );
            } else {
              logBattle(`Man√° insuficiente para ${abilityDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "ice_prison":
            const icePrisonDetails = techniqueData["ice_prison_1"];
            const iceManaCost = icePrisonDetails.effect.manaCost;
            if (player.mana >= iceManaCost) {
              player.mana -= iceManaCost;
              const freezeChance =
                icePrisonDetails.effect.freezeChance +
                (playerTechLevel - 1) * 0.05;
              if (Math.random() < freezeChance) {
                const freezeDuration =
                  icePrisonDetails.effect.freezeDuration +
                  Math.floor((playerTechLevel - 1) / 2);
                enemy.frozenTurns = Math.max(enemy.frozenTurns, freezeDuration);
                logBattle(
                  `¬°${icePrisonDetails.name} (Nv.${playerTechLevel}) congela a ${enemy.name} por ${freezeDuration} turnos!`
                );
              } else {
                logBattle(
                  `¬°${icePrisonDetails.name} (Nv.${playerTechLevel}) fall√≥!`
                );
              }
            } else {
              logBattle(`Man√° insuficiente para ${icePrisonDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "flame_strike":
            const flameStrikeDetails = techniqueData["flame_strike_1"];
            const flameManaCost = flameStrikeDetails.effect.manaCost;
            if (player.mana >= flameManaCost) {
              player.mana -= flameManaCost;
              const baseDam = Math.floor(
                player.attack *
                  (flameStrikeDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.1)
              );
              const burnDam =
                flameStrikeDetails.effect.burnDamagePerTurn +
                (playerTechLevel - 1) * 2;
              const burnDur = flameStrikeDetails.effect.burnDuration;
              enemy.hp -= baseDam;
              enemy.burningTurns = Math.max(enemy.burningTurns, burnDur);
              enemy.burnDamage = Math.max(enemy.burnDamage, burnDam);
              logBattle(
                `¬°${flameStrikeDetails.name} (Nv.${playerTechLevel}) causa ${baseDam} da√±o e inflige quemadura de ${burnDam} por ${burnDur} turnos!`
              );
            } else {
              logBattle(`Man√° insuficiente para ${flameStrikeDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "thunder_fury":
            const thunderDetails = techniqueData["thunder_fury_1"];
            const thunderManaCost = thunderDetails.effect.manaCost;
            if (player.mana >= thunderManaCost) {
              player.mana -= thunderManaCost;
              const damage = Math.floor(
                player.attack *
                  (thunderDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.15)
              );
              enemy.hp -= damage;
              logBattle(
                `${thunderDetails.name} (Nv.${playerTechLevel}) golpea con ${damage} da√±o.`
              );
              const stunChance =
                thunderDetails.effect.stunChance + (playerTechLevel - 1) * 0.08;
              if (Math.random() < stunChance) {
                enemy.stunnedTurns = Math.max(
                  enemy.stunnedTurns,
                  1 + Math.floor((playerTechLevel - 1) / 3)
                );
                logBattle(`¬°${enemy.name} queda aturdido!`);
              }
            } else {
              logBattle(`Man√° insuficiente para ${thunderDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "poison_dart":
            const poisonDetails = techniqueData["poison_dart_1"];
            const poisonManaCost = poisonDetails.effect.manaCost;
            if (player.mana >= poisonManaCost) {
              player.mana -= poisonManaCost;
              const baseDam = Math.floor(
                player.attack *
                  (poisonDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.05)
              );
              const poisonDam =
                poisonDetails.effect.poisonDamagePerTurn +
                Math.floor((playerTechLevel - 1) * 1.5);
              const poisonDur = poisonDetails.effect.poisonDuration;
              enemy.hp -= baseDam;
              enemy.poisonedTurns = Math.max(enemy.poisonedTurns, poisonDur);
              enemy.poisonDamage = Math.max(enemy.poisonDamage, poisonDam);
              logBattle(
                `¬°${poisonDetails.name} (Nv.${playerTechLevel}) causa ${baseDam} da√±o e inflige veneno de ${poisonDam} por ${poisonDur} turnos!`
              );
            } else {
              logBattle(`Man√° insuficiente para ${poisonDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "stone_skin":
            const stoneSkinDetails = techniqueData["stone_skin_1"];
            const stoneManaCost = stoneSkinDetails.effect.manaCost;
            if (player.mana >= stoneManaCost) {
              player.mana -= stoneManaCost;
              if (player.defenseBoostTurns > 0) {
                logBattle(`Refrescas ${stoneSkinDetails.name}.`);
              } else {
                player.defenseBoostAmount =
                  stoneSkinDetails.effect.defenseBoost +
                  (playerTechLevel - 1) * 3;
                player.defense += player.defenseBoostAmount;
                logBattle(
                  `${stoneSkinDetails.name} (Nv.${playerTechLevel}) aumenta tu defensa en ${player.defenseBoostAmount}. Defensa: ${player.defense}.`
                );
              }
              player.defenseBoostTurns = stoneSkinDetails.effect.duration;
            } else {
              logBattle(`Man√° insuficiente para ${stoneSkinDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "shadow_step":
            const shadowDetails = techniqueData["shadow_step_1"];
            const shadowManaCost = shadowDetails.effect.manaCost;
            if (player.mana >= shadowManaCost) {
              player.mana -= shadowManaCost;
              player.dodgeNextAttack = true;
              logBattle(
                `¬°${shadowDetails.name} (Nv.${playerTechLevel})! Te preparas para esquivar.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${shadowDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "soul_drain":
            const soulDrainDetails = techniqueData["soul_drain_1"];
            const soulManaCost = soulDrainDetails.effect.manaCost;
            if (player.mana >= soulManaCost) {
              player.mana -= soulManaCost;
              const damageDealt = Math.max(
                1,
                Math.floor(
                  player.attack *
                    (soulDrainDetails.effect.baseDamageMultiplier +
                      (playerTechLevel - 1) * 0.1)
                ) - (enemy.defense || 0)
              );
              enemy.hp -= damageDealt;
              const lifeStolen = Math.floor(
                damageDealt *
                  (soulDrainDetails.effect.lifeStealPercent +
                    (playerTechLevel - 1) * 0.05)
              );
              player.hp = Math.min(player.maxHp, player.hp + lifeStolen);
              logBattle(
                `${soulDrainDetails.name} (Nv.${playerTechLevel}) drena ${damageDealt} HP y te cura ${lifeStolen} HP.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${soulDrainDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "cyclone_strike":
            const cycloneDetails = techniqueData["cyclone_strike_1"];
            const cycloneManaCost = cycloneDetails.effect.manaCost;
            if (player.mana >= cycloneManaCost) {
              player.mana -= cycloneManaCost;
              const damageDealt = Math.max(
                1,
                Math.floor(
                  player.attack *
                    (cycloneDetails.effect.baseDamageMultiplier +
                      (playerTechLevel - 1) * 0.1)
                ) - (enemy.defense || 0)
              );
              enemy.hp -= damageDealt;
              logBattle(
                `${cycloneDetails.name} (Nv.${playerTechLevel}) golpea a ${enemy.name} con ${damageDealt} da√±o.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${cycloneDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "healing_rain":
            const healingRainDetails = techniqueData["healing_rain_1"];
            const healingManaCost = healingRainDetails.effect.manaCost;
            if (player.mana >= healingManaCost) {
              player.mana -= healingManaCost;
              player.healingRainTurns = healingRainDetails.effect.duration;
              player.healingRainAmount =
                healingRainDetails.effect.healPerTurn +
                (playerTechLevel - 1) * 5;
              logBattle(
                `${healingRainDetails.name} (Nv.${playerTechLevel}) invoca lluvia curativa por ${player.healingRainTurns} turnos.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${healingRainDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "mind_blast":
            const mindBlastDetails = techniqueData["mind_blast_1"];
            const mindManaCost = mindBlastDetails.effect.manaCost;
            if (player.mana >= mindManaCost) {
              player.mana -= mindManaCost;
              const damageDealt = Math.max(
                1,
                Math.floor(
                  player.attack *
                    (mindBlastDetails.effect.baseDamageMultiplier +
                      (playerTechLevel - 1) * 0.05) +
                    player.maxMana *
                      (mindBlastDetails.effect.manaDamageMultiplier +
                        (playerTechLevel - 1) * 0.02)
                ) - (enemy.defense || 0)
              );
              enemy.hp -= damageDealt;
              const defReduction =
                mindBlastDetails.effect.defenseReduction +
                (playerTechLevel - 1) * 1;
              enemy.defense = Math.max(0, (enemy.defense || 0) - defReduction);
              logBattle(
                `${mindBlastDetails.name} (Nv.${playerTechLevel}) causa ${damageDealt} da√±o y reduce defensa enemiga en ${defReduction}.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${mindBlastDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "celestial_arrow":
            const arrowDetails = techniqueData["celestial_arrow_1"];
            if (player.mana >= arrowDetails.effect.manaCost) {
              player.mana -= arrowDetails.effect.manaCost;
              const damage = Math.floor(
                player.attack *
                  (arrowDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.1)
              );
              enemy.hp -= damage;
              logBattle(
                `${arrowDetails.name} (Nv.${playerTechLevel}) ignora defensas y causa ${damage} da√±o.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${arrowDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "nature_grasp":
            const natureDetails = techniqueData["nature_grasp_1"];
            if (player.mana >= natureDetails.effect.manaCost) {
              player.mana -= natureDetails.effect.manaCost;
              const initialDamage = Math.floor(
                player.attack *
                  (natureDetails.effect.baseDamageMultiplier +
                    (playerTechLevel - 1) * 0.05)
              );
              enemy.hp -= initialDamage;
              enemy.rootedTurns = Math.max(
                enemy.rootedTurns,
                natureDetails.effect.rootDuration
              );
              enemy.rootDamage = Math.max(
                enemy.rootDamage,
                natureDetails.effect.damagePerTurn + (playerTechLevel - 1) * 1
              );
              logBattle(
                `${natureDetails.name} (Nv.${playerTechLevel}) causa ${initialDamage} da√±o y enreda, causando ${enemy.rootDamage} da√±o por ${enemy.rootedTurns} turnos.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${natureDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "dragon_roar":
            const roarDetails = techniqueData["dragon_roar_1"];
            if (player.mana >= roarDetails.effect.manaCost) {
              player.mana -= roarDetails.effect.manaCost;
              const stunChance =
                roarDetails.effect.aoeStunChance + (playerTechLevel - 1) * 0.03;
              if (Math.random() < stunChance) {
                enemy.stunnedTurns = Math.max(enemy.stunnedTurns, 1);
                logBattle(
                  `${roarDetails.name} (Nv.${playerTechLevel}) aturde a ${enemy.name}!`
                );
              }
              const attackRed =
                roarDetails.effect.attackReduction + (playerTechLevel - 1) * 2;
              enemy.attack = Math.max(5, (enemy.attack || 0) - attackRed);
              enemy.attackReductionTurns = roarDetails.effect.duration;
              enemy.attackReductionAmount = attackRed;
              logBattle(
                `${roarDetails.name} reduce ataque enemigo en ${attackRed} por ${roarDetails.effect.duration} turnos.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${roarDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "phantom_clone":
            const cloneDetails = techniqueData["phantom_clone_1"];
            if (player.mana >= cloneDetails.effect.manaCost) {
              player.mana -= cloneDetails.effect.manaCost;
              player.cloneActive = true;
              player.cloneHealth =
                cloneDetails.effect.cloneHealth + (playerTechLevel - 1) * 10;
              player.cloneTurns =
                cloneDetails.effect.duration +
                Math.floor((playerTechLevel - 1) / 2);
              logBattle(
                `${cloneDetails.name} (Nv.${playerTechLevel}) crea clon con ${player.cloneHealth} HP por ${player.cloneTurns} turnos.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${cloneDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "temporal_shift":
            const temporalDetails = techniqueData["temporal_shift_1"];
            if (player.mana >= temporalDetails.effect.manaCost) {
              player.mana -= temporalDetails.effect.manaCost;
              player.temporalShiftTurns = temporalDetails.effect.duration;
              logBattle(
                `${temporalDetails.name} (Nv.${playerTechLevel}) distorsiona tiempo por ${player.temporalShiftTurns} turnos.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${temporalDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "blood_ritual":
            const bloodDetails = techniqueData["blood_ritual_1"];
            const hpCost =
              bloodDetails.effect.hpCost - (playerTechLevel - 1) * 2;
            if (
              player.hp > hpCost &&
              player.mana >= bloodDetails.effect.manaCost
            ) {
              player.hp -= hpCost;
              player.mana -= bloodDetails.effect.manaCost;
              if (player.bloodRitualTurns === 0) {
                player.bloodRitualAttackBoost =
                  bloodDetails.effect.attackBoost + (playerTechLevel - 1) * 5;
                player.attack += player.bloodRitualAttackBoost;
              } else {
                logBattle(`Refrescas Ritual de Sangre.`);
              }
              player.bloodRitualTurns = bloodDetails.effect.duration;
              logBattle(
                `${bloodDetails.name} (Nv.${playerTechLevel}) sacrifica ${hpCost} HP, aumenta ataque en ${player.bloodRitualAttackBoost} por ${player.bloodRitualTurns} turnos. Ataque: ${player.attack}.`
              );
            } else {
              logBattle(`HP o Man√° insuficiente para ${bloodDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "aura_of_purity":
            const auraDetails = techniqueData["aura_of_purity_1"];
            if (player.mana >= auraDetails.effect.manaCost) {
              player.mana -= auraDetails.effect.manaCost;
              let cleansed = false;
              if (player.poisonedTurns > 0) {
                player.poisonedTurns = 0;
                player.poisonDamage = 0;
                cleansed = true;
              }
              if (player.burningTurns > 0) {
                player.burningTurns = 0;
                player.burnDamage = 0;
                cleansed = true;
              }
              if (cleansed)
                logBattle(
                  `${auraDetails.name} (Nv.${playerTechLevel}) purifica efectos negativos.`
                );
              player.immuneTurns =
                auraDetails.effect.immunityDuration +
                Math.floor((playerTechLevel - 1) / 2);
              logBattle(`Ganas inmunidad por ${player.immuneTurns} turnos.`);
            } else {
              logBattle(`Man√° insuficiente para ${auraDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "summon_elemental":
            const summonDetails = techniqueData["summon_elemental_1"];
            if (player.mana >= summonDetails.effect.manaCost) {
              player.mana -= summonDetails.effect.manaCost;
              player.tempAttackBonus =
                (summonDetails.effect.elementalAttack || 20) +
                (playerTechLevel - 1) * 3;
              player.tempDefenseBonus =
                Math.floor((summonDetails.effect.elementalAttack || 20) / 2) +
                (playerTechLevel - 1) * 2;
              player.attack += player.tempAttackBonus;
              player.defense += player.tempDefenseBonus;
              player.elementalTurns = summonDetails.effect.duration;
              logBattle(
                `${summonDetails.name} (Nv.${playerTechLevel}) invoca elemental, +${player.tempAttackBonus} Atk, +${player.tempDefenseBonus} Def por ${player.elementalTurns} turnos.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${summonDetails.name}.`);
              actionTaken = false;
            }
            break;
          case "mystic_barrier":
            const barrierDetails = techniqueData["mystic_barrier_1"];
            if (player.mana >= barrierDetails.effect.manaCost) {
              player.mana -= barrierDetails.effect.manaCost;
              player.magicShieldValue =
                (barrierDetails.effect.magicShield || 40) +
                (playerTechLevel - 1) * 10;
              player.magicShieldTurns = barrierDetails.effect.duration;
              logBattle(
                `${barrierDetails.name} (Nv.${playerTechLevel}) crea barrera que absorber√° ${player.magicShieldValue} da√±o m√°gico por ${player.magicShieldTurns} turnos.`
              );
            } else {
              logBattle(`Man√° insuficiente para ${barrierDetails.name}.`);
              actionTaken = false;
            }
            break;

          default:
            logBattle("Acci√≥n desconocida.");
            actionTaken = false;
            break;
        }

        if (!actionTaken) {
          updateBattleUI();
          return;
        }
        gameState.battle.playerTurn = false;
        updateBattleUI();

        if (enemy.hp <= 0) {
          handleEnemyDefeat();
        } else {
          let enemyDiedToDot = false;
          if (enemy.burningTurns > 0) {
            enemy.hp -= enemy.burnDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.burnDamage
              } por quemadura. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.poisonedTurns > 0) {
            enemy.hp -= enemy.poisonDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.poisonDamage
              } por veneno. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }
          if (!enemyDiedToDot && enemy.rootedTurns > 0) {
            enemy.hp -= enemy.rootDamage;
            logBattle(
              `${enemy.name} sufre ${
                enemy.rootDamage
              } por enredo. HP: ${Math.floor(enemy.hp)}`
            );
            if (enemy.hp <= 0) enemyDiedToDot = true;
          }

          if (enemyDiedToDot) {
            handleEnemyDefeat();
          } else {
            setTimeout(enemyTurn, 1000);
          }
        }
      }

      function handleEnemyDefeat() {
        const enemy = gameState.battle.enemy;
        const player = gameState.player; // A√±adir referencia al jugador

        logBattle(`¬°Has derrotado al ${enemy.name}!`);
        gainExperience(enemy.exp);

        // ... (tu l√≥gica de progreso de misiones existente) ...
        const misionesActivasDelJugador = [...player.secta.misionesActivas];
        misionesActivasDelJugador.forEach((misionActiva) => {
          const misionDataOriginal = MISIONES_DATA[misionActiva.id];
          if (!misionDataOriginal || !misionActiva.objetivoOriginal) return;
          const objetivo = misionActiva.objetivoOriginal;

          if (objetivo.tipo === "eliminar_enemigo") {
            const enemyJustDefeated = gameState.battle.enemy;
            if (
              enemyJustDefeated.originalEntityTypeId === objetivo.enemigoTipo || // Comparar con originalEntityTypeId
              enemyJustDefeated.name === objetivo.nombreDisplay
            ) {
              misionActiva.progreso = (misionActiva.progreso || 0) + 1;
              logBattle(
                `Progreso '${misionDataOriginal.titulo}': ${misionActiva.progreso}/${objetivo.cantidad}`
              );
            }
          } else if (objetivo.tipo === "derrotar_npc_especifico") {
            if (enemy.isSectChallengeRival && enemy.npcId === objetivo.npcId) {
              completeMission(misionActiva.id);
            }
          } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot") {
            // Comprobar si el enemigo derrotado es el objetivo de la caza
            if (enemy.originalEntityTypeId === objetivo.enemigoTipo) {
              // El loot se a√±ade m√°s abajo. Aqu√≠ solo podr√≠as marcar un progreso
              // si la misi√≥n lo requiere antes de obtener el item.
              // Por ejemplo, si la misi√≥n es "derrota X y luego trae Y".
              // Si la misi√≥n es solo "trae Y" y el loot es la √∫nica condici√≥n,
              // la comprobaci√≥n del item en inventario se hace al ENTREGAR al NPC.
              // PERO, es bueno marcar que el tipo correcto fue derrotado
              misionActiva.progreso = 1; // 1 significa que el tipo correcto fue derrotado
              logBattle(
                `Has derrotado a un ${enemy.name}. Busca el ${objetivo.itemPrueba} entre el bot√≠n.`
              );
            }
          }
        });
        updateSectUI();

        // L√≥gica de Loot
        if (enemy.lootTable && enemy.lootTable.length > 0) {
          enemy.lootTable.forEach((loot) => {
            if (Math.random() < loot.chance) {
              const quantity =
                loot.quantity && loot.quantity.length === 2
                  ? Math.floor(
                      Math.random() * (loot.quantity[1] - loot.quantity[0] + 1)
                    ) + loot.quantity[0]
                  : 1;
              gameState.inventory[loot.itemName] =
                (gameState.inventory[loot.itemName] || 0) + quantity;
              logBattle(`¬°${enemy.name} solt√≥ ${quantity} ${loot.itemName}!`);

              // Si el item looteado es el item de la misi√≥n "cazar_y_recuperar_item_de_loot"
              player.secta.misionesActivas.forEach((mActiva) => {
                const mDataOrig = MISIONES_DATA[mActiva.id];
                if (
                  mDataOrig?.objetivo?.tipo ===
                    "cazar_y_recuperar_item_de_loot" &&
                  enemy.originalEntityTypeId ===
                    mDataOrig.objetivo.enemigoTipo && // Asegurarse que es del enemigo correcto
                  loot.itemName === mDataOrig.objetivo.itemPrueba
                ) {
                  // El progreso ya se puso a 1 al derrotar. Aqu√≠ solo confirmamos.
                  // La UI de la misi√≥n ya deber√≠a reflejarlo bien.
                  console.log(
                    `[Loot] Item de misi√≥n "${loot.itemName}" obtenido para "${mDataOrig.titulo}".`
                  );
                }
              });
            }
          });
        }

        // Manejo de Jefes y Entidades Fijas Derrotadas
        if (enemy.isBoss) {
          player.worldState.defeatedBosses[
            enemy.originalEntityTypeId || enemy.type
          ] = true; // Usar originalEntityTypeId si existe
          if (enemy.nextBossId) {
            player.worldState.currentBossToSpawn = enemy.nextBossId;
          } else {
            player.worldState.currentBossToSpawn = null;
          }
          // generateMap(true); // Opcional regenerar todo el mapa. ensureFixedEntities se encargar√° de no reaparecerlo.
        } else if (
          enemy.isFixed &&
          (enemy.isMiniBoss ||
            entityTypes[enemy.originalEntityTypeId]?.respawnTime)
        ) {
          // Para entidades fijas que son minibosses o tienen un tiempo de respawn.
          if (!player.worldState.defeatedFixedEntities) {
            player.worldState.defeatedFixedEntities = {};
          }
          player.worldState.defeatedFixedEntities[enemy.originalEntityTypeId] =
            {
              time: Date.now(),
              // defeated: true // Ya impl√≠cito por estar en el objeto
            };
          console.log(
            `[Defeat] Miniboss/Fixed ${enemy.name} (ID: ${enemy.originalEntityTypeId}) marcado como derrotado.`
          );
        }

        updateUI();
        setTimeout(() => endBattle(true), 2000); // endBattle(true) ya llama a removeEntity para el enemigo de la batalla.
        // ensureFixedEntities se encargar√° de si debe reaparecer o no en la pr√≥xima carga/tick.
      }

      function completeMission(misionId, npcIdEntregaManual = null) {
        // npcIdEntregaManual es para cuando se completa desde el di√°logo del NPC
        const player = gameState.player;
        const misionActiva = player.secta.misionesActivas.find(
          (m) => m.id === misionId
        );
        const misionDataOriginal = MISIONES_DATA[misionId];

        if (!misionActiva || !misionDataOriginal) {
          console.error(
            `Error al intentar completar misi√≥n: ${misionId}. Datos no encontrados.`
          );
          showModal("Error de Misi√≥n", "Datos de la misi√≥n no encontrados.");
          return false; // Indicar fallo
        }

        // No filtrar m√°s por !player.secta.misionesActivas.some(m => m.id === misionId) aqu√≠,
        // ya que la estamos buscando DENTRO de las activas.

        console.log(
          `Intentando completar misi√≥n: ${misionDataOriginal.titulo}`
        );

        // Verificar si los objetivos est√°n realmente cumplidos ANTES de dar recompensas
        let objetivosCumplidos = false;
        const objetivo = misionActiva.objetivoOriginal;

        switch (objetivo.tipo) {
          case "entregar_item":
            if (
              (gameState.inventory[objetivo.item] || 0) >= objetivo.cantidad
            ) {
              // Solo restar si es una entrega manual a un NPC o si es una misi√≥n que se autocompleta con entrega
              // (por ahora, asumimos que todas las de entrega requieren NPC)
              if (
                npcIdEntregaManual &&
                npcIdEntregaManual === objetivo.npcEntrega
              ) {
                gameState.inventory[objetivo.item] -= objetivo.cantidad;
                updateInventoryUI();
                objetivosCumplidos = true;
              } else if (!objetivo.npcEntrega) {
                // Caso raro: misi√≥n de entrega sin NPC espec√≠fico (se autocompleta)
                gameState.inventory[objetivo.item] -= objetivo.cantidad;
                updateInventoryUI();
                objetivosCumplidos = true;
              } else {
                // No se cumple aqu√≠, se debe completar hablando con el NPC
                // showModal("Entrega Pendiente", `Debes entregar ${objetivo.item} a ${SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre || 'un NPC'}.`);
                return false;
              }
            } else {
              showModal(
                "Objetivo Incompleto",
                `A√∫n necesitas ${
                  objetivo.cantidad - (gameState.inventory[objetivo.item] || 0)
                } ${objetivo.item}.`
              );
              return false;
            }
            break;
          case "eliminar_enemigo":
            if (misionActiva.progreso >= objetivo.cantidad) {
              objetivosCumplidos = true;
              // No hay √≠tems que restar aqu√≠. La finalizaci√≥n ser√° al hablar con el NPC.
            } else {
              // showModal("Objetivo Incompleto", `A√∫n necesitas eliminar m√°s enemigos.`);
              return false;
            }
            break;
          case "recolectar_multiples_items":
            let todosItemsRecolectados = true;
            for (const itemReq of objetivo.items) {
              if (
                (gameState.inventory[itemReq.nombre] || 0) < itemReq.cantidad
              ) {
                todosItemsRecolectados = false;
                showModal(
                  "Objetivo Incompleto",
                  `A√∫n necesitas recolectar m√°s ${itemReq.nombre}.`
                );
                break;
              }
            }
            if (todosItemsRecolectados) {
              if (
                npcIdEntregaManual &&
                npcIdEntregaManual === objetivo.npcEntrega
              ) {
                for (const itemReq of objetivo.items) {
                  gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                }
                updateInventoryUI();
                objetivosCumplidos = true;
              } else if (!objetivo.npcEntrega) {
                for (const itemReq of objetivo.items) {
                  gameState.inventory[itemReq.nombre] -= itemReq.cantidad;
                }
                updateInventoryUI();
                objetivosCumplidos = true;
              } else {
                return false;
              }
            } else {
              return false;
            }
            break;
          case "cazar_y_recuperar_item_de_loot":
            // El progreso a 1 indica que el √≠tem FUE looteado. Ahora se comprueba si A√öN lo tiene.
            if (
              misionActiva.progreso === 1 &&
              (gameState.inventory[objetivo.itemPrueba] || 0) >=
                objetivo.cantidadItemPrueba
            ) {
              if (
                npcIdEntregaManual &&
                npcIdEntregaManual === objetivo.npcEntrega
              ) {
                gameState.inventory[objetivo.itemPrueba] -=
                  objetivo.cantidadItemPrueba;
                updateInventoryUI();
                objetivosCumplidos = true;
              } else if (!objetivo.npcEntrega) {
                gameState.inventory[objetivo.itemPrueba] -=
                  objetivo.cantidadItemPrueba;
                updateInventoryUI();
                objetivosCumplidos = true;
              } else {
                return false;
              }
            } else {
              showModal(
                "Objeto Faltante",
                `Parece que ya no tienes ${objetivo.itemPrueba} o no lo has obtenido a√∫n.`
              );
              return false;
            }
            break;
          case "derrotar_npc_especifico": // Estas se autocompletan al derrotar al NPC
            // El progreso ya se verific√≥ al llamar a completeMission desde handleEnemyDefeat
            objetivosCumplidos = true;
            break;
          // A√±adir m√°s casos seg√∫n tipos de misi√≥n
          default:
            console.warn(
              `Tipo de objetivo desconocido '${objetivo.tipo}' para misi√≥n ${misionId}`
            );
            showModal("Error de Misi√≥n", "Tipo de objetivo no reconocido.");
            return false;
        }

        if (!objetivosCumplidos) {
          console.log(
            `Objetivos no cumplidos para ${misionDataOriginal.titulo} al intentar completar.`
          );
          return false; // No completar si los objetivos no est√°n verificados
        }

        // --- Dar Recompensas ---
        player.secta.puntosContribucion +=
          misionDataOriginal.recompensa.pcs || 0;
        gainExperience(misionDataOriginal.recompensa.exp || 0);
        let recompensaItemsTexto = "";
        if (misionDataOriginal.recompensa.items) {
          for (const itemName in misionDataOriginal.recompensa.items) {
            gameState.inventory[itemName] =
              (gameState.inventory[itemName] || 0) +
              misionDataOriginal.recompensa.items[itemName];
            recompensaItemsTexto += `${misionDataOriginal.recompensa.items[itemName]} ${itemName}, `;
          }
          updateInventoryUI();
          if (recompensaItemsTexto)
            recompensaItemsTexto = recompensaItemsTexto.slice(0, -2); // quitar √∫ltima coma y espacio
        }

        let recompensaTextoGlobal = `Recompensas: ${
          misionDataOriginal.recompensa.pcs || 0
        } PCS, ${misionDataOriginal.recompensa.exp || 0} EXP`;
        if (recompensaItemsTexto)
          recompensaTextoGlobal += `, ${recompensaItemsTexto}`;

        player.secta.misionesActivas = player.secta.misionesActivas.filter(
          (m) => m.id !== misionId
        );
        player.secta.misionesCompletadas[misionId] = true;

        showModal(
          "¬°Misi√≥n Completada!",
          `Completaste: ${misionDataOriginal.titulo}.\n${recompensaTextoGlobal}`
        );

        if (misionDataOriginal.recompensa.nuevoRango) {
          player.secta.rango = misionDataOriginal.recompensa.nuevoRango;
          showModal(
            "¬°Ascenso en la Secta!",
            `¬°Felicidades! Ascendiste a ${player.secta.rango}.`
          );
          applyRankBenefits(player.secta.rango);
        }
        updateSectUI();
        checkAndActivateRankChallengeMissions(); // Verificar si se desbloquean desaf√≠os de rango
        return true; // Indicar √©xito
      }

      function updateSectUI() {
        const player = gameState.player;
        document.getElementById("sectaNombreDisplay").textContent =
          player.secta.nombre;
        document.getElementById("playerSectRank").textContent =
          player.secta.rango;
        document.getElementById("playerPCS").textContent =
          player.secta.puntosContribucion;

        const missionsListDiv = document.getElementById("activeMissionsList");
        missionsListDiv.innerHTML = "";

        if (player.secta.misionesActivas.length === 0) {
          missionsListDiv.innerHTML = "<p>Ninguna misi√≥n activa.</p>";
        } else {
          player.secta.misionesActivas.forEach((misionActiva) => {
            const misionDataOriginal = MISIONES_DATA[misionActiva.id];
            if (misionDataOriginal && misionActiva.objetivoOriginal) {
              // Asegurar que objetivoOriginal exista
              let progresoTexto = "";
              const objetivo = misionActiva.objetivoOriginal;
              const npcEntregaNombre =
                SECTA_DATA.npcs[objetivo.npcEntrega]?.nombre ||
                "NPC correspondiente";

              if (objetivo.tipo === "eliminar_enemigo") {
                progresoTexto = ` (${misionActiva.progreso || 0}/${
                  objetivo.cantidad
                } ${objetivo.nombreDisplay || "objetivos"})`;
                if ((misionActiva.progreso || 0) >= objetivo.cantidad) {
                  progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "entregar_item") {
                const tiene = gameState.inventory[objetivo.item] || 0;
                const necesita = objetivo.cantidad;
                progresoTexto = ` (Tienes ${tiene}/${necesita} ${objetivo.item})`;
                if (tiene >= necesita) {
                  progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "recolectar_multiples_items") {
                let todosListos = true;
                let itemsStatusArray = objetivo.items.map((itemReq) => {
                  const tiene = gameState.inventory[itemReq.nombre] || 0;
                  const necesita = itemReq.cantidad;
                  if (tiene < necesita) todosListos = false;
                  return `${tiene}/${necesita} ${itemReq.nombre}`;
                });
                progresoTexto = ` (${itemsStatusArray.join(", ")})`;
                if (todosListos) {
                  progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "cazar_y_recuperar_item_de_loot") {
                const tieneItem =
                  (gameState.inventory[objetivo.itemPrueba] || 0) >=
                  objetivo.cantidadItemPrueba;
                progresoTexto =
                  misionActiva.progreso === 1 && tieneItem
                    ? ` (Prueba '${objetivo.itemPrueba}' obtenida)`
                    : ` (Cazar ${objetivo.enemigoTipo} y obtener ${objetivo.itemPrueba})`;
                if (misionActiva.progreso === 1 && tieneItem) {
                  progresoTexto += ` <strong>¬°Listo para entregar a ${npcEntregaNombre}!</strong>`;
                }
              } else if (objetivo.tipo === "derrotar_npc_especifico") {
                // Estas se autocompletan, as√≠ que no aparecer√°n mucho aqu√≠ si se completan r√°pido
                progresoTexto = ` (Derrotar a ${
                  entityTypes[objetivo.npcId]?.name || "objetivo"
                })`;
              }
              const p = document.createElement("p");
              p.innerHTML = `<strong>${misionDataOriginal.titulo}</strong><small>${progresoTexto}</small>`;
              missionsListDiv.appendChild(p);
            }
          });
        }
      }

      function checkAndActivateRankChallengeMissions() {
        const player = gameState.player;
        const currentRankIndex = SECTA_DATA.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );

        if (currentRankIndex === -1) {
          console.error(
            "Error: Rango actual del jugador no encontrado en SECTA_DATA.rangos"
          );
          return;
        }

        // Si ya est√° en el rango m√°ximo, no hay m√°s desaf√≠os
        if (currentRankIndex + 1 >= SECTA_DATA.rangos.length) {
          // console.log("Jugador en el rango m√°ximo o no hay m√°s rangos definidos.");
          return;
        }

        const nextRankData = SECTA_DATA.rangos[currentRankIndex + 1];

        // Verificar si el jugador cumple los PCS para el siguiente rango
        if (player.secta.puntosContribucion >= nextRankData.pcsRequeridos) {
          // Verificar si hay un ID de rival para el desaf√≠o de este pr√≥ximo rango
          if (nextRankData.desafioRivalId) {
            const desafioMisionId = Object.keys(MISIONES_DATA).find((mId) => {
              const mision = MISIONES_DATA[mId];
              return (
                mision.objetivo?.tipo === "derrotar_npc_especifico" &&
                mision.objetivo?.npcId === nextRankData.desafioRivalId &&
                (mision.autoActivarAlCumplirRequisitos === true ||
                  mision.recompensa?.nuevoRango === nextRankData.nombre)
              ); // Condici√≥n para identificar la misi√≥n de desaf√≠o
            });

            if (desafioMisionId) {
              // Verificar si la misi√≥n de desaf√≠o NO est√° ya activa o completada
              const isMissionActive = player.secta.misionesActivas.some(
                (m) => m.id === desafioMisionId
              );
              const isMissionCompleted =
                player.secta.misionesCompletadas[desafioMisionId];

              if (!isMissionActive && !isMissionCompleted) {
                acceptMission(desafioMisionId);
                const misionData = MISIONES_DATA[desafioMisionId];
                showModal(
                  "¬°Nuevo Desaf√≠o de Rango!",
                  `Has alcanzado los requisitos de PCS para el rango de ${nextRankData.nombre}.\n` +
                    `Se ha activado la misi√≥n de desaf√≠o: "${misionData.titulo}".\n` +
                    `¬°Prep√°rate y busca a tu oponente en la arena de la secta!`
                );

                // Asegurar que el NPC del desaf√≠o (el rival) aparezca en el mapa si tiene fixedLocation
                // ensureFixedEntities() deber√≠a encargarse de esto si el rival est√° en la lista de entidades fijas
                // y no ha sido derrotado (lo cual es el caso si la misi√≥n se acaba de activar).
                // Si el rival no es una entidad fija por defecto, podr√≠as a√±adirlo aqu√≠ din√°micamente,
                // pero es m√°s limpio manejarlo con ensureFixedEntities.
                ensureFixedEntities();
                renderMap(); // Para asegurar que el rival (si es nuevo) se muestre
              } else {
                // console.log(`Misi√≥n de desaf√≠o ${desafioMisionId} para ${nextRankData.nombre} ya est√° activa o completada.`);
              }
            } else {
              console.warn(
                `No se encontr√≥ una misi√≥n de desaf√≠o auto-activable para el rival ${nextRankData.desafioRivalId} del rango ${nextRankData.nombre}.`
              );
            }
          } else {
            // console.log(`El siguiente rango ${nextRankData.nombre} no tiene un desafioRivalId definido. Podr√≠a ser un rango sin desaf√≠o.`);
          }
        } else {
          // console.log(`Jugador no tiene suficientes PCS para el siguiente rango ${nextRankData.nombre}. Necesita: ${nextRankData.pcsRequeridos}, Tiene: ${player.secta.puntosContribucion}`);
        }
        updateSectUI(); // Actualizar la UI de la secta por si algo cambi√≥
      }

      function applyRankBenefits(newRankName) {
        const rankData = SECTA_DATA.rangos.find(
          (r) => r.nombre === newRankName
        );
        if (rankData) {
          showModal(
            "Beneficios de Rango",
            `Has obtenido beneficios de ${newRankName}: ${rankData.beneficios}`
          );
        }
        updateUI();
      }

      function enemyTurn() {
        if (!gameState.battle.active || gameState.battle.playerTurn) return;
        const player = gameState.player;
        const enemy = gameState.battle.enemy;
        let enemyDamage = enemy.attack; // Inicializar con el ataque base del enemigo
        let actionMessage = `${enemy.name} te ataca`;
        let enemySkippedTurn = false;

        // --- LOGS INICIALES DEL TURNO DEL ENEMIGO ---
        console.log(`--- Enemy Turn Start: ${enemy.name} ---`);
        console.log(
          `Enemy Base Attack: ${enemy.attack}, Initial enemyDamage: ${enemyDamage}`
        );
        console.log(
          `Player Defense: ${player.defense}, Player HP: ${player.hp}`
        );
        console.log(
          `Enemy Status - Frozen: ${enemy.frozenTurns}, Stunned: ${enemy.stunnedTurns}, Burning: ${enemy.burningTurns} (Dmg: ${enemy.burnDamage}), Poisoned: ${enemy.poisonedTurns} (Dmg: ${enemy.poisonDamage}), Rooted: ${enemy.rootedTurns}`
        );
        console.log(
          `Player Status - Dodge: ${player.dodgeNextAttack}, Clone: ${player.cloneActive} (HP: ${player.cloneHealth}), MagicShield: ${player.magicShieldValue}`
        );
        // --- FIN LOGS INICIALES ---

        // ... (l√≥gica de DoTs y HoTs del enemigo sin cambios) ...
        if (enemy.burningTurns > 0) {
          enemy.hp -= enemy.burnDamage;
          logBattle(
            `${enemy.name} sufre ${
              enemy.burnDamage
            } por quemadura (inicio turno). HP: ${Math.floor(enemy.hp)}`
          );
          enemy.burningTurns--;
          if (enemy.burningTurns === 0)
            logBattle(`Quemadura en ${enemy.name} se extingue.`);
          if (enemy.hp <= 0) {
            handleEnemyDefeat();
            return;
          }
        }
        if (enemy.poisonedTurns > 0) {
          enemy.hp -= enemy.poisonDamage;
          logBattle(
            `${enemy.name} sufre ${
              enemy.poisonDamage
            } por veneno (inicio turno). HP: ${Math.floor(enemy.hp)}`
          );
          enemy.poisonedTurns--;
          if (enemy.poisonedTurns === 0)
            logBattle(`Veneno en ${enemy.name} desaparece.`);
          if (enemy.hp <= 0) {
            handleEnemyDefeat();
            return;
          }
        }
        if (enemy.rootedTurns > 0) {
          enemy.rootedTurns--;
          logBattle(`${enemy.name} sigue enredado.`);
          if (enemy.rootedTurns === 0)
            logBattle(`Enredo en ${enemy.name} se deshace.`);
        }

        if (enemy.frozenTurns > 0) {
          logBattle(`¬°${enemy.name} est√° congelado!`);
          enemy.frozenTurns--;
          enemySkippedTurn = true;
        } else if (enemy.stunnedTurns > 0) {
          logBattle(`¬°${enemy.name} est√° aturdido!`);
          enemy.stunnedTurns--;
          enemySkippedTurn = true;
        }

        if (enemy.attackReductionTurns > 0) {
          enemy.attackReductionTurns--;
          if (enemy.attackReductionTurns === 0) {
            // enemy.attack += enemy.attackReductionAmount; // CUIDADO: Esto modifica el ataque base permanentemente si no se gestiona bien
            // Es mejor aplicar la reducci√≥n al 'enemyDamage' del turno actual
            logBattle(`Reducci√≥n de ataque en ${enemy.name} termina.`);
            // enemy.attackReductionAmount = 0; // Ya no es necesario si se aplica al damage del turno
          } else {
            // Aplicar la reducci√≥n al da√±o de este turno si el debuff est√° activo
            enemyDamage = Math.max(
              1,
              enemy.attack - (enemy.attackReductionAmount || 0)
            );
            console.log(
              `Enemy attack reduced. Current turn damage: ${enemyDamage}`
            );
          }
        }

        if (enemySkippedTurn) {
          console.log("Enemy skipped turn due to status effect.");
          gameState.battle.playerTurn = true;
          updateBattleUI();
          updateUI();
          return;
        }

        // L√≥gica de ataque especial o curaci√≥n del enemigo
        if (enemy.specialChance && Math.random() < enemy.specialChance) {
          enemyDamage = Math.floor(
            enemy.attack * (enemy.specialAttackMultiplier || 1.5)
          );
          actionMessage = `${enemy.name} usa golpe de Qi y`;
          console.log(
            `Enemy uses Special Attack! Damage before defense: ${enemyDamage}`
          );
        } else if (enemy.healChance && Math.random() < enemy.healChance) {
          const heal = Math.floor(enemy.maxHp * 0.15);
          enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
          logBattle(`${enemy.name} recupera ${heal} vida.`);
          console.log("Enemy healed.");
          gameState.battle.playerTurn = true;
          updateBattleUI();
          updateUI();
          return;
        }
        // L√≥gica de habilidades de jefe
        if (enemy.isBoss && enemy.abilities) {
          for (const ability of enemy.abilities) {
            if (Math.random() < (ability.chance || 0.1)) {
              if (ability.type === "area_attack_simulated") {
                enemyDamage = Math.floor(
                  enemy.attack * (ability.damageMultiplier || 1.0)
                );
                actionMessage = `${enemy.name} usa ${ability.name}! Aura opresiva te envuelve, y`;
                console.log(
                  `Boss uses Ability '${ability.name}'! Damage before defense: ${enemyDamage}`
                );
              } else if (
                ability.type === "healPercentage" &&
                ability.healPercentage
              ) {
                const bossHeal = Math.floor(
                  enemy.maxHp * ability.healPercentage
                );
                enemy.hp = Math.min(enemy.maxHp, enemy.hp + bossHeal);
                logBattle(
                  `${enemy.name} usa ${ability.name} y recupera ${bossHeal} vida!`
                );
                console.log("Boss healed with ability.");
                gameState.battle.playerTurn = true;
                updateBattleUI();
                updateUI();
                return;
              }
              break;
            }
          }
        }

        console.log(
          `After enemy special/ability checks, enemyDamage is: ${enemyDamage}`
        );

        // L√≥gica de esquivar del jugador
        if (player.dodgeNextAttack) {
          const shadowDetails = techniqueData["shadow_step_1"];
          const dodgeTechLevel =
            player.learnedTechniques["shadow_step_1"]?.level || 1;
          const dodgeChance =
            (shadowDetails?.effect?.dodgeChance || 0.8) +
            (dodgeTechLevel - 1) * 0.03;
          if (Math.random() < dodgeChance) {
            logBattle(`¬°Esquivas el ataque de ${enemy.name}!`);
            player.dodgeNextAttack = false;
            console.log("Player dodged attack.");
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
          } else {
            logBattle(`Intentaste esquivar, ¬°pero ${enemy.name} te alcanz√≥!`);
            player.dodgeNextAttack = false;
            console.log("Player failed to dodge.");
          }
        }

        // L√≥gica del clon del jugador
        if (player.cloneActive && player.cloneHealth > 0) {
          const cloneDetails = techniqueData["phantom_clone_1"];
          const aggroCloneChance =
            (cloneDetails?.effect?.aggroChance || 0.8) +
            (player.learnedTechniques["phantom_clone_1"]?.level || 1 - 1) *
              0.02;
          if (Math.random() < aggroCloneChance) {
            let damageToClone = Math.max(
              1,
              enemyDamage - 0 + Math.floor(Math.random() * 5 - 2)
            ); // Clon no tiene defensa
            player.cloneHealth -= damageToClone;
            logBattle(
              `Clon intercepta ataque, recibe ${damageToClone} da√±o. HP clon: ${player.cloneHealth}.`
            );
            if (player.cloneHealth <= 0) {
              player.cloneActive = false;
              logBattle("¬°Clon destruido!");
            }
            console.log("Clone took damage.");
            gameState.battle.playerTurn = true;
            updateBattleUI();
            updateUI();
            return;
          } else {
            logBattle(`Clon distrae, pero ${enemy.name} te enfoca!`);
            console.log("Clone did not take aggro.");
          }
        }

        // L√≥gica de Barrera M√≠stica del jugador
        let isEnemyAttackMagic = actionMessage.includes("golpe de Qi"); // Simplificaci√≥n, podr√≠as tener una propiedad en el ataque del enemigo
        if (player.magicShieldValue > 0 && isEnemyAttackMagic) {
          let absorbedDamage = Math.min(player.magicShieldValue, enemyDamage);
          enemyDamage -= absorbedDamage;
          player.magicShieldValue -= absorbedDamage;
          logBattle(
            `Barrera M√≠stica absorbe ${absorbedDamage} da√±o m√°gico. Barrera: ${player.magicShieldValue}.`
          );
          if (player.magicShieldValue <= 0) {
            logBattle("Barrera M√≠stica rota.");
          }
          console.log(
            `Magic shield absorbed ${absorbedDamage}. Remaining shield: ${player.magicShieldValue}. Enemy damage now: ${enemyDamage}`
          );
        }

        // --- C√ÅLCULO FINAL DE DA√ëO ---
        // A√±adir un aleatorizador al da√±o base del enemigo ANTES de restar la defensa del jugador
        const randomFactor = Math.floor(Math.random() * 5 - 2); // Entre -2 y +2
        const damageBeforeDefense = Math.max(1, enemyDamage + randomFactor);
        const damageDealt = Math.max(0, damageBeforeDefense - player.defense);

        console.log(
          `Final Calculation - EnemyDamage (after buffs/specials): ${enemyDamage}, RandomFactor: ${randomFactor}, DamageBeforePlayerDefense: ${damageBeforeDefense}, PlayerDefense: ${player.defense}, FinalDamageDealt: ${damageDealt}`
        );
        // --- FIN C√ÅLCULO FINAL DE DA√ëO ---

        if (damageDealt > 0) {
          player.hp -= damageDealt;
          logBattle(`${actionMessage} causando ${damageDealt} da√±o.`);
        } else {
          logBattle(
            `${actionMessage} pero tu defensa bloquea el ataque o el da√±o es insignificante.`
          );
        }

        // ... (resto de la l√≥gica de derrota del jugador y fin de turno sin cambios) ...
        if (player.hp <= 0) {
          player.hp = 0;
          logBattle("¬°Has sido derrotado!");
          setTimeout(() => {
            player.hp = Math.floor(player.maxHp * 0.1);
            player.mana = Math.floor(player.maxMana * 0.1);
            const expLoss = Math.floor(player.exp * 0.1);
            player.exp = Math.max(0, player.exp - expLoss);
            logBattle(`Pierdes ${expLoss} EXP.`);
            const safeCoords = findSafeRespawnLocation(
              G_SAFE_RESPAWN_X,
              G_SAFE_RESPAWN_Y
            );
            player.x = safeCoords.x;
            player.y = safeCoords.y;
            updatePlayerPosition();
            endBattle(false);
            showModal(
              "Derrota",
              "Has sido derrotado. Regresas a un lugar seguro, mermado."
            );
          }, 2000);
          return;
        }

        if (player.elementalTurns > 0) {
          player.elementalTurns--;
          if (player.elementalTurns === 0) {
            player.attack -= player.tempAttackBonus;
            player.defense -= player.tempDefenseBonus;
            logBattle("Elemental invocado desaparece.");
            player.tempAttackBonus = 0;
            player.tempDefenseBonus = 0;
          }
        }
        gameState.battle.playerTurn = true;
        updateBattleUI();
        updateUI();
      }

      function endBattle(victory) {
        const player = gameState.player;
        gameState.battle.active = false;
        document.getElementById("battleScreen").style.display = "none";
        document.getElementById("battleLog").innerHTML = "";
        // Ocultar las barras sobre el sprite en batalla expl√≠citamente al finalizar
        const barsInBattleContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        if (barsInBattleContainer) {
          barsInBattleContainer.style.display = "none";
        }
        if (victory && gameState.battle.enemy?.entityRef) {
          removeEntity(gameState.battle.enemy.entityRef);
        }
        gameState.battle.enemy = null;

        // Restaurar sprite a idle despu√©s de la batalla
        player.currentDirection = "down"; // O la √∫ltima direcci√≥n antes de la batalla
        player.currentFrame = 0;
        player.isMoving = false; // Asegurarse de que no est√© en estado de movimiento
        updatePlayerSpriteVisual();

        recalculatePlayerStats();
        updateUI();
        updateBottomNavVisibility();
        showTouchControls();
        updatePlayerBarsOnMap();
      }

      function findSafeRespawnLocation(preferredX, preferredY) {
        const isHostile = (entity) =>
          G_COMBAT_ENTITY_TYPES.includes(entity.type) || entity.isBoss;
        let preferredSpotOccupiedByHostile = gameState.map.entities.some(
          (e) => e.x === preferredX && e.y === preferredY && isHostile(e)
        );
        if (!preferredSpotOccupiedByHostile)
          return { x: preferredX, y: preferredY };
        for (let r = 1; r <= G_SAFE_RESPAWN_SEARCH_RADIUS; r++) {
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
              const cx = preferredX + dx;
              const cy = preferredY + dy;
              if (
                cx < 0 ||
                cx >= gameState.map.width ||
                cy < 0 ||
                cy >= gameState.map.height
              )
                continue;
              const isCompletelyEmpty = !gameState.map.entities.some(
                (e) => e.x === cx && e.y === cy
              );
              if (isCompletelyEmpty) return { x: cx, y: cy };
            }
          }
        }
        return { x: preferredX, y: preferredY };
      }

      function logBattle(message) {
        const log = document.getElementById("battleLog");
        const p = document.createElement("p");
        p.textContent = message;
        log.appendChild(p);
        log.scrollTop = log.scrollHeight;
      }

      function showTechniquePanel() {
        const container = document.getElementById("learnedTechniquesContainer");
        container.innerHTML = "";
        const player = gameState.player;
        if (Object.keys(player.learnedTechniques).length === 0) {
          container.innerHTML = "<p>A√∫n no has aprendido ninguna t√©cnica.</p>";
        }
        for (const techId in player.learnedTechniques) {
          const techInfo = techniqueData[techId];
          const playerTech = player.learnedTechniques[techId];
          if (!techInfo) continue;
          const div = document.createElement("div");
          div.className = "technique-item";
          let levelText =
            playerTech.level >= techInfo.maxLevel
              ? `Nivel: ${playerTech.level} (MAX)`
              : `Nivel: ${playerTech.level} / ${techInfo.maxLevel}`;
          let description = techInfo.description;
          // Podr√≠as a√±adir l√≥gica aqu√≠ para mostrar el efecto actual basado en el nivel
          // Ejemplo: if (techInfo.effect.baseDamageMultiplier) description += ` (Da√±o actual: ${...})`;
          div.innerHTML = `<strong>${techInfo.name} ${
            techInfo.icon || ""
          }</strong> (${levelText})<br><small>${description}</small><br>`;
          if (
            techInfo.cultivationSettings &&
            playerTech.level < techInfo.maxLevel
          ) {
            const progress = playerTech.currentCultivationProgress || 0;
            const timeToNext =
              playerTech.cultivationTimeToNextLevel ||
              (techInfo.cultivationSettings
                ? techInfo.cultivationSettings.baseTimeToLevelUp
                : Infinity);
            div.innerHTML += `<small>Progreso Cultivo: ${Math.floor(
              progress
            )}s / ${timeToNext}s para Nv. ${playerTech.level + 1}</small><br>`;
          }
          container.appendChild(div);
        }
        document.getElementById("techniqueModal").style.display = "flex";
        hideTouchControls();
      }

      function startTechniqueRefinement(techId) {}

      function stopTechniqueRefinement() {}

      function applyTechniqueEffect(techId, newLevel) {
        const techInfo = techniqueData[techId];
        const player = gameState.player;
        if (!techInfo) return;
        const effect = techInfo.effect;
        switch (techInfo.type) {
          case "passive_cultivation":
            if (player.hasOwnProperty(effect.statToBoost)) {
              player[effect.statToBoost] += effect.value;
            }
            break;
          case "passive_stat":
            if (player.hasOwnProperty(effect.statToBoost)) {
              player[effect.statToBoost] += effect.value;
            }
            recalculatePlayerStats();
            break;
          case "active_ability":
            recalculatePlayerStats();
            break;
          case "active_refinement_effect": // O el tipo que uses para Conversi√≥n de Qi
            if (techId === "qi_to_hp_conversion_1") {
              if (newLevel >= 1) {
                player.canUseQiConversion = true;
                updateToggleQiConversionButtonVisibility();
              }
              // Aqu√≠ no se modifican los stats base del jugador directamente,
              // sino que se asume que la l√≥gica que USA esta t√©cnica (en processCultivationTick)
              // leer√° el nivel actual de la t√©cnica desde player.learnedTechniques[techId].level
              // y aplicar√° los efectos escalados (como hpGainIncreasePerLevel) basados en ese nivel.
              // Lo importante es que el nivel de la t√©cnica S√ç se ha incrementado.
              console.log(
                `T√©cnica ${techInfo.name} mejorada a Nv.${newLevel}. Sus efectos de conversi√≥n ser√°n m√°s potentes.`
              );
            }
            break;
        }
        updateUI();
      }

      function closeTechniqueModal() {
        document.getElementById("techniqueModal").style.display = "none";
        updatePlayerBarsOnMap();
        showTouchControls();
      }

      let currentShopPage = 1;
      const shopItemsPerPage = 6;

      function openShop() {
        document.getElementById(
          "playerSpiritualStones"
        ).textContent = `Piedras Espirituales: ${
          gameState.inventory["Piedras Espirituales"] || 0
        }`;
        document.getElementById("shopModal").style.display = "flex";
        renderShopProducts();
        hideTouchControls();
      }

      function renderShopProducts() {
        const shopProductsEl = document.getElementById("shopProducts");
        shopProductsEl.innerHTML = "";
        const activeCategory =
          document.querySelector("#shopCategories .active")?.dataset.category ||
          "all";
        const searchTerm = document
          .getElementById("shopSearch")
          .value.toLowerCase();
        const priceVal = parseInt(document.getElementById("priceRange").value);
        document.getElementById(
          "priceRangeValue"
        ).textContent = `${priceVal} PS`;

        let filteredItems = shopData.inventory.filter((item) => {
          const itemNameLower = item.itemName.toLowerCase();
          const itemCategory = item.category || "other";
          const itemTypeForFilter =
            item.type ||
            (itemNameLower.includes("rollo:") ? "scroll" : "other");

          if (
            searchTerm &&
            !itemNameLower.includes(searchTerm) &&
            !(
              item.description &&
              item.description.toLowerCase().includes(searchTerm)
            )
          )
            return false;
          if (item.price > priceVal) return false;

          if (activeCategory !== "all") {
            if (activeCategory === "combat" && !techIsCombat(item.itemName))
              return false;
            if (
              activeCategory === "cultivation" &&
              !techIsCultivation(item.itemName)
            )
              return false;
            if (
              activeCategory === "scroll" &&
              !itemNameLower.startsWith("rollo: ")
            )
              return false;
            if (
              activeCategory === "consumable" &&
              itemTypeForFilter !== "consumable" &&
              ![
                "Hierbas Medicinales",
                "Cristales de Qi",
                "P√≠ldora de Recuperaci√≥n Menor",
              ].includes(item.itemName)
            )
              return false;
            if (activeCategory === "weapon" && itemCategory !== "weapon")
              return false;
            if (activeCategory === "armor" && itemCategory !== "armor")
              return false;
            if (activeCategory === "material" && !isMaterial(item.itemName))
              return false;
          }
          return true;
        });

        const totalPages = Math.ceil(filteredItems.length / shopItemsPerPage);
        const startIndex = (currentShopPage - 1) * shopItemsPerPage;
        const pageItems = filteredItems.slice(
          startIndex,
          startIndex + shopItemsPerPage
        );

        pageItems.forEach((item) => {
          const itemInfo = itemData[item.itemName] || {};
          const productCard = document.createElement("div");
          productCard.className = "product-card";
          let itemIcon = getItemIcon(item.itemName, item.category);
          let itemType = getItemShopType(
            item.itemName,
            item.category,
            item.type
          );

          productCard.innerHTML = `
                <div class="product-header">
                    <div>
                        <div class="product-name">${itemIcon} ${
            item.itemName
          }</div>
                        <span class="product-type">${itemType}</span>
                    </div>
                    <div class="product-price">${item.price} PS</div>
                </div>
                <div class="product-description">${
                  itemInfo.description ||
                  item.description ||
                  "Un objeto misterioso."
                }</div>
                ${
                  item.levelRequirement
                    ? `<div><strong>Req:</strong> Nv ${item.levelRequirement}</div>`
                    : ""
                }
                ${
                  typeof item.stock === "number"
                    ? `<div><strong>Disp:</strong> ${item.stock}</div>`
                    : ""
                }
                <div class="product-actions">
                    <button class="buy-btn" data-item="${
                      item.itemName
                    }" data-price="${item.price}">Comprar</button>
                </div>`;
          const buyBtn = productCard.querySelector(".buy-btn");
          if (
            (gameState.inventory["Piedras Espirituales"] || 0) < item.price ||
            item.stock === 0
          ) {
            buyBtn.disabled = true;
            buyBtn.title =
              item.stock === 0 ? "Agotado" : "Piedras insuficientes";
          }
          buyBtn.addEventListener("click", () => buyFromShop(item.itemName));
          shopProductsEl.appendChild(productCard);
        });
        renderShopPagination(totalPages);
      }

      function techIsCombat(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "active_ability" ||
            techniqueData[techId].abilityId)
        );
      }
      function techIsCultivation(itemName) {
        if (!itemName.startsWith("Rollo: ")) return false;
        const techName = itemName.substring(7);
        const techId = Object.keys(techniqueData).find(
          (id) => techniqueData[id].name === techName
        );
        return (
          techId &&
          (techniqueData[techId].type === "passive_cultivation" ||
            techniqueData[techId].type === "passive_stat" ||
            techniqueData[techId].type === "active_refinement_effect")
        );
      }
      function isMaterial(itemName) {
        const knownMaterials = [
          "Cristal de Hielo",
          "Esencia de Fuego",
          "N√∫cleo de Tormenta",
          "Venenos Mortales",
          "Fragmentos de Jade",
          "Esencia Oscura",
          "Almas Condenadas",
          "N√∫cleo de V√≥rtice",
          "Roc√≠o Celestial",
          "Cristales Ps√≠quicos",
          "Mineral de Hierro Espiritual",
          "Plumas de F√©nix",
          "Semillas Ancestrales",
          "Escamas de Drag√≥n",
          "Espejos Astrales",
          "Relojes de Arena",
          "Sangre de Demonio",
          "L√°grimas de Unicornio",
          "N√∫cleo Elemental",
          "Polvo de Arcano",
          "Piedras Espirituales",
          "Cristales de Qi",
          "Hierbas Medicinales",
        ];
        return knownMaterials.includes(itemName);
      }

      function getItemIcon(itemName, category) {
        if (itemName.includes("Espada") || category === "weapon") return "‚öîÔ∏è";
        if (itemName.includes("Armadura") || category === "armor") return "üõ°Ô∏è";
        if (itemName.includes("Hierba")) return "üåø";
        if (itemName.includes("Cristal")) return "üíé";
        if (itemName.includes("Piedra")) return "üíé";
        if (itemName.startsWith("Rollo:")) return "üìú";
        return "üì¶";
      }

      function getItemShopType(itemName, category, type) {
        if (itemName.startsWith("Rollo: ")) return "T√©cnica";
        if (category === "weapon") return "Arma";
        if (category === "armor") return "Armadura";
        if (
          type === "consumable" ||
          [
            "Hierbas Medicinales",
            "Cristales de Qi",
            "P√≠ldora de Recuperaci√≥n Menor",
          ].includes(itemName)
        )
          return "Consumible";
        if (isMaterial(itemName)) return "Material";
        return "Objeto";
      }

      function renderShopPagination(totalPages) {
        const pagination = document.getElementById("shopPagination");
        pagination.innerHTML = "";
        if (totalPages <= 1) return;
        const prevBtn = document.createElement("button");
        prevBtn.className = "page-btn";
        prevBtn.textContent = "¬´";
        prevBtn.addEventListener("click", () => {
          if (currentShopPage > 1) {
            currentShopPage--;
            renderShopProducts();
          }
        });
        pagination.appendChild(prevBtn);
        const startPage = Math.max(1, currentShopPage - 1);
        const endPage = Math.min(totalPages, currentShopPage + 1);
        for (let i = startPage; i <= endPage; i++) {
          const pageBtn = document.createElement("button");
          pageBtn.className = `page-btn ${
            i === currentShopPage ? "active" : ""
          }`;
          pageBtn.textContent = i;
          pageBtn.addEventListener("click", () => {
            currentShopPage = i;
            renderShopProducts();
          });
          pagination.appendChild(pageBtn);
        }
        const nextBtn = document.createElement("button");
        nextBtn.className = "page-btn";
        nextBtn.textContent = "¬ª";
        nextBtn.addEventListener("click", () => {
          if (currentShopPage < totalPages) {
            currentShopPage++;
            renderShopProducts();
          }
        });
        pagination.appendChild(nextBtn);
      }

      function closeShopModal() {
        document.getElementById("shopModal").style.display = "none";
        updatePlayerBarsOnMap();
        showTouchControls();
      }

      function buyFromShop(itemName) {
        const itemToBuy = shopData.inventory.find(
          (i) => i.itemName === itemName
        );
        const playerStones = gameState.inventory["Piedras Espirituales"] || 0;
        if (
          !itemToBuy ||
          itemToBuy.stock === 0 ||
          playerStones < itemToBuy.price
        ) {
          showModal(
            "Error Compra",
            "No se puede comprar (fondos insuficientes, agotado o no existe)."
          );
          return;
        }
        gameState.inventory["Piedras Espirituales"] -= itemToBuy.price;
        if (itemToBuy.type === "equipment" && itemToBuy.attackBonus) {
          gameState.player.baseAttack += itemToBuy.attackBonus;
          recalculatePlayerStats();
          showModal(
            "¬°Equipo Comprado!",
            `Compraste ${itemName}. Ataque base +${itemToBuy.attackBonus}.`
          );
        } else {
          gameState.inventory[itemName] =
            (gameState.inventory[itemName] || 0) + 1;
          if (
            itemData[itemName] &&
            itemData[itemName].effect &&
            itemName.startsWith("Rollo: ")
          ) {
            showModal(
              "¬°Rollo Comprado!",
              `Has comprado ${itemName}. √ösalo desde tu inventario para aprender la t√©cnica.`
            );
          } else {
            showModal("¬°Objeto Comprado!", `Has comprado ${itemName}.`);
          }
        }
        if (typeof itemToBuy.stock === "number" && itemToBuy.stock > 0)
          itemToBuy.stock--;
        openShop();
        updateUI();
      }

      function sellToShop(itemName, quantityToSell, totalStonesEarned) {}

      function saveGame() {
        try {
          const gameStateToSave = JSON.parse(JSON.stringify(gameState));
          const gameDataJson = JSON.stringify(gameStateToSave, null, 2);
          const blob = new Blob([gameDataJson], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "camino_del_cultivador_save.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showModal("Partida Guardada", "Progreso guardado como archivo JSON.");
        } catch (error) {
          showModal("Error al Guardar", `Hubo un problema: ${error.message}`);
        }
      }
      function triggerFileUpload() {
        document.getElementById("fileInput").click();
      }

      // --- CARGA DE PARTIDA ---

      function loadGameFromFile(event) {
        const file = event.target.files[0];
        if (!file) {
          showModal("Carga Cancelada", "No se seleccion√≥ archivo.");
          return;
        }
        if (file.type !== "application/json") {
          showModal("Error de Archivo", "Selecciona un JSON v√°lido.");
          event.target.value = null;
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            // 0. DETENER PROCESOS EN CURSO Y LIMPIAR ESTADO ANTERIOR PARCIALMENTE
            if (gameState.player.isCultivating) {
              stopCultivation(); // Aseg√∫rate que esta funci√≥n limpie gameState.cultivationInterval
            }
            if (gameState.battle.active) {
              endBattle(false); // false indica que no es una victoria
            }
            // Limpiar el intervalo de cultivo expl√≠citamente si stopCultivation no lo hace o por si acaso
            if (gameState.cultivationInterval) {
              clearInterval(gameState.cultivationInterval);
              gameState.cultivationInterval = null;
            }

            const loadedGameState = JSON.parse(e.target.result);

            // Validaci√≥n b√°sica del formato del archivo cargado
            if (
              typeof loadedGameState !== "object" ||
              loadedGameState === null ||
              !loadedGameState.player ||
              !loadedGameState.map ||
              !loadedGameState.inventory
            ) {
              throw new Error(
                "Formato de guardado incorrecto o datos esenciales (jugador, mapa, inventario) faltantes."
              );
            }

            // 1. CARGAR DATOS DEL JUGADOR (PLAYER DATA)
            // Primero, copia las propiedades primitivas y luego maneja los objetos anidados.
            for (const key in loadedGameState.player) {
              if (loadedGameState.player.hasOwnProperty(key)) {
                if (
                  typeof loadedGameState.player[key] !== "object" ||
                  loadedGameState.player[key] === null
                ) {
                  gameState.player[key] = loadedGameState.player[key];
                }
              }
            }

            // Objetos anidados dentro de player (copia profunda para evitar problemas de referencia)
            gameState.player.learnedTechniques = loadedGameState.player
              .learnedTechniques
              ? JSON.parse(
                  JSON.stringify(loadedGameState.player.learnedTechniques)
                )
              : {};
            gameState.player.secta = loadedGameState.player.secta
              ? JSON.parse(JSON.stringify(loadedGameState.player.secta))
              : {
                  nombre: "Secta del Viento Azure",
                  rango: "Disc√≠pulo Externo",
                  puntosContribucion: 0,
                  misionesActivas: [],
                  misionesCompletadas: {},
                  rivalesDerrotadosClave: {},
                };
            gameState.player.worldState = loadedGameState.player.worldState
              ? JSON.parse(JSON.stringify(loadedGameState.player.worldState))
              : {
                  defeatedBosses: {},
                  currentBossToSpawn: "boss_demon_general",
                };
            gameState.player.cultivationMode = loadedGameState.player
              .cultivationMode
              ? JSON.parse(
                  JSON.stringify(loadedGameState.player.cultivationMode)
                )
              : { type: null, targetId: null, startTime: 0 };
            gameState.player.directionRowMap = loadedGameState.player
              .directionRowMap
              ? JSON.parse(
                  JSON.stringify(loadedGameState.player.directionRowMap)
                )
              : { down: 0, left: 1, right: 2, up: 3 };
            gameState.player.sprites = loadedGameState.player.sprites
              ? JSON.parse(JSON.stringify(loadedGameState.player.sprites))
              : {
                  idle: "img/personaje_cultivador_idle.png",
                  up: "img/personaje_cultivador_up.png",
                  down: "img/personaje_cultivador_down.png",
                  left: "img/personaje_cultivador_left.png",
                  right: "img/personaje_cultivador_right.png",
                };

            // Asegurar propiedades del sprite (valores por defecto si no est√°n en el guardado)
            gameState.player.spriteSheetUrl =
              loadedGameState.player.spriteSheetUrl ||
              gameState.player.spriteSheetUrl ||
              "img/personaje_cultivador_spritesheet.png";
            gameState.player.frameWidth =
              loadedGameState.player.frameWidth ||
              gameState.player.frameWidth ||
              64;
            gameState.player.frameHeight =
              loadedGameState.player.frameHeight ||
              gameState.player.frameHeight ||
              64;
            gameState.player.animationFrames =
              loadedGameState.player.animationFrames ||
              gameState.player.animationFrames ||
              4;
            gameState.player.currentFrame = 0; // Siempre resetear frame al cargar
            gameState.player.currentDirection =
              loadedGameState.player.currentDirection ||
              gameState.player.currentDirection ||
              "down";
            gameState.player.animationSpeed =
              loadedGameState.player.animationSpeed ||
              gameState.player.animationSpeed ||
              150;

            // Resetear estados transitorios del jugador
            gameState.player.isMoving = false;
            if (gameState.player.animationTimer)
              clearInterval(gameState.player.animationTimer);
            gameState.player.animationTimer = null;
            if (gameState.player.idleTimeout)
              clearTimeout(gameState.player.idleTimeout);
            gameState.player.idleTimeout = null;
            gameState.player.isCultivating = false; // El cultivo no se reanuda autom√°ticamente

            // 2. CARGAR INVENTARIO (CRUCIAL)
            gameState.inventory = loadedGameState.inventory
              ? JSON.parse(JSON.stringify(loadedGameState.inventory))
              : { "Piedras Espirituales": 0 };

            // 3. CARGAR DATOS DEL MAPA (MAP DATA)
            // Las entidades del mapa (gameState.map.entities) ser√°n reconstruidas por generateMap(true).
            // Lo importante es cargar las dimensiones y las definiciones de zona si se guardan.
            gameState.map.width = loadedGameState.map.width || 200;
            gameState.map.height = loadedGameState.map.height || 200;
            gameState.map.defaultTerrain =
              loadedGameState.map.defaultTerrain || "GRASSLAND";
            if (loadedGameState.map.terrainZones) {
              // Si guardas las terrainZones (suelen ser est√°ticas pero por si acaso)
              gameState.map.terrainZones = JSON.parse(
                JSON.stringify(loadedGameState.map.terrainZones)
              );
            }
            // La rejilla de terreno (terrainGrid) se suele generar, as√≠ que no es necesario cargarla.
            gameState.map.terrainGrid = null; // Para forzar su regeneraci√≥n si es necesario.
            // Las entidades (monstruos, recursos no fijos) se regenerar√°n. Las entidades fijas (tienda, NPCs de secta)
            // ser√°n gestionadas por ensureFixedEntities dentro de generateMap.

            // 4. CARGAR OTROS ESTADOS GLOBALES DEL JUEGO
            gameState.gameTime = loadedGameState.gameTime || 0;
            gameState.lastGameTimeUpdate = Date.now(); // Resetear al momento de carga
            gameState.activeCombatAbilities = []; // Se recalcular√° despu√©s

            // 5. RECONSTRUIR EL MUNDO DEL JUEGO Y ACTUALIZAR ESTADOS
            // generateMap(true) se encarga de:
            // - Limpiar entidades no fijas.
            // - Repoblar zonas con entidades (monstruos, recursos) seg√∫n spawnSettings (currentCount se resetea).
            // - A√±adir elementos decorativos.
            // - Llamar a ensureFixedEntities() para asegurar la presencia de entidades fijas (tienda, secta, NPCs).
            // - initializeTerrainGrid() (si est√° implementado dentro o es llamado por funciones que usa generateMap).
            generateMap(true);

            recalculatePlayerStats(); // Recalcula stats derivados y habilidades de combate activas.

            // Actualizar la interfaz gr√°fica y la posici√≥n del jugador.
            // La posici√≥n del jugador (X, Y) ya fue cargada en gameState.player.
            calculateAndSetTileSize(); // Ajustar tama√±o de tiles si la ventana cambi√≥.
            updatePlayerVisualSize(); // Ajustar tama√±o del sprite del jugador.
            updatePlayerSpriteVisual(); // Configurar el frame y direcci√≥n correctos del sprite.
            updatePlayerPosition("loadGameFromFile_end"); // Mueve el mapa y renderiza. Esto tambi√©n llama a updateUI().

            // Estado de batalla generalmente no se guarda en medio de una.
            gameState.battle.active = false;
            document.getElementById("battleScreen").style.display = "none";
            if (document.getElementById("playerInBattleSpriteBarsContainer")) {
              document.getElementById(
                "playerInBattleSpriteBarsContainer"
              ).style.display = "none";
            }

            showModal("Partida Cargada", "¬°Partida restaurada con √©xito!");
          } catch (error) {
            showModal(
              "Error al Cargar",
              `Hubo un problema al leer o procesar el archivo: ${error.message}`
            );
            console.error("Error loading game:", error);
          } finally {
            event.target.value = null; // Resetear el input de archivo para permitir cargar el mismo archivo de nuevo.
          }
        };
        reader.onerror = () => {
          showModal(
            "Error de Lectura",
            "No se pudo leer el archivo de guardado."
          );
          event.target.value = null;
        };
        reader.readAsText(file);
      }

      // Aseg√∫rate de que tu funci√≥n initializeTerrainGrid (si la tienes separada) se llame
      // al inicio del juego (en DOMContentLoaded antes de generateMap) y, si es necesario,
      // tambi√©n despu√©s de cargar las terrainZones en loadGameFromFile si estas cambian.
      // Si getTerrainTypeAt solo usa terrainZones, no necesitas un grid separado.

      // En tu DOMContentLoaded, aseg√∫rate que initializeTerrainGrid (si la usas) se llame antes de generateMap:
      /*
        document.addEventListener('DOMContentLoaded', () => {
            // ...
            initializeTerrainGrid(); // Si usas gameState.map.terrainGrid expl√≠citamente
            generateMap(true);
            // ...
        });
    */

      function showHelp() {
        showModal(
          "Ayuda - Camino del Cultivador",
          "Explora y convi√©rtete en un cultivador poderoso.\n\n" +
            'üßò Cultiva (Bot√≥n "Cultivar") para mejorar HP/Man√°/EXP y tus T√©cnicas.\n' +
            "üìñ Aprende y Refina T√©cnicas para obtener nuevas habilidades y mejoras pasivas.\n" +
            "‚¨ÜÔ∏è Sube de Nivel para aumentar tus estad√≠sticas base.\n" + // Actualizado
            "üëπ Combate demonios y rivales.\n" +
            "üíé Recolecta recursos y tesoros.\n" +
            "üìú Busca o compra rollos de t√©cnicas para volverte m√°s fuerte\n\n" + // Eliminada menci√≥n al √°rbol de habilidades
            "Controles (Teclado):\n" +
            "  WASD/Flechas: Moverse\n" +
            "  ESPACIO: Interactuar\n\n" +
            "Controles (T√°ctil):\n" +
            "  Joystick: Moverse\n" +
            '  Bot√≥n "Acci√≥n": Interactuar'
        );
      }
      //ACTUALIZAR BARRAS DEL JUGADOR
      function updatePlayerBarsOnMap() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerOnMapBarsContainer"
        );
        const hpFill = document.getElementById("playerOnMapHpFill");
        const manaFill = document.getElementById("playerOnMapManaFill");
        const playerElement = document.getElementById("player"); // El sprite del jugador

        if (!barsContainer || !hpFill || !manaFill || !playerElement) {
          // console.warn("Elementos de barras sobre el jugador no encontrados en el DOM.");
          return;
        }

        // Ocultar barras si el jugador est√° en batalla o si alg√∫n modal principal est√° abierto.
        if (gameState.battle.active || isAnyModalOpen()) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // La posici√≥n del playerElement (sprite) ya est√° calculada y centrada en updatePlayerPosition.
        // Usamos su 'top' y 'left' (que son relativos al map-container) como referencia.
        const playerVisualTop = parseFloat(playerElement.style.top) || 0;
        const playerVisualLeft = parseFloat(playerElement.style.left) || 0;
        const playerVisualWidth = playerElement.offsetWidth;

        // Posicionar las barras ligeramente encima del sprite del jugador.
        const barHeightWithGap = barsContainer.offsetHeight || 13; // Alto total aprox. de las 2 barras + gap
        barsContainer.style.top = `${playerVisualTop - barHeightWithGap - 5}px`; // 5px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // El 'transform: translateX(-50%)' en el CSS ayuda con esto si 'left' es el centro.
        barsContainer.style.left = `${
          playerVisualLeft + playerVisualWidth / 2
        }px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      function updatePlayerBarsInBattle() {
        const player = gameState.player;
        const barsContainer = document.getElementById(
          "playerInBattleSpriteBarsContainer"
        );
        const hpFill = document.getElementById("playerInBattleSpriteHpFill");
        const manaFill = document.getElementById(
          "playerInBattleSpriteManaFill"
        );
        const playerSpriteInBattle = document.querySelector(
          ".battle-area .character .character-sprite"
        );

        if (!barsContainer || !hpFill || !manaFill || !playerSpriteInBattle) {
          // console.warn("Elementos de barras sobre el sprite del jugador en batalla no encontrados.");
          if (barsContainer) barsContainer.style.display = "none"; // Ocultar si faltan elementos
          return;
        }

        // Solo mostrar si la pantalla de batalla est√° activa
        if (
          !gameState.battle.active ||
          document.getElementById("battleScreen").style.display !== "flex"
        ) {
          barsContainer.style.display = "none";
          return;
        }
        barsContainer.style.display = "flex";

        // Posicionar las barras ligeramente encima del sprite del jugador en batalla.
        // El sprite (.character-sprite) es un div, necesitamos su offsetTop y offsetLeft
        // relativo a su padre (.character) que ahora es 'position: relative'.

        const spriteTop = playerSpriteInBattle.offsetTop; // Distancia desde el borde superior del .character
        const spriteLeft = playerSpriteInBattle.offsetLeft; // Distancia desde el borde izquierdo del .character
        const spriteWidth = playerSpriteInBattle.offsetWidth;

        const barHeightWithGap = barsContainer.offsetHeight || 12; // Alto total aprox. de las 2 barras + gap

        // El 'top' de las barras ser√° el 'top' del sprite menos la altura de las barras y un peque√±o margen.
        barsContainer.style.top = `${spriteTop - barHeightWithGap - 3}px`; // 3px de espacio sobre el sprite

        // Centrar horizontalmente con el sprite del jugador.
        // 'left' ser√° el 'left' del sprite m√°s la mitad del ancho del sprite.
        // El 'transform: translateX(-50%)' en CSS centra el contenedor de barras.
        barsContainer.style.left = `${spriteLeft + spriteWidth / 2}px`;

        // Actualizar el relleno de las barras.
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        const manaPercent = Math.max(0, (player.mana / player.maxMana) * 100);

        hpFill.style.width = `${hpPercent}%`;
        manaFill.style.width = `${manaPercent}%`;
      }

      const joystickContainer = document.getElementById("joystick-container");
      const joystickPad = document.getElementById("joystick-pad");
      const joystickHandle = document.getElementById("joystick-handle");
      const actionButtonTouch = document.getElementById("action-button-touch");
      let joystickActive = false;
      let joystickCurrentDx = 0; // Guardar la direcci√≥n actual del joystick
      let joystickCurrentDy = 0;

      const JOYSTICK_THRESHOLD = 15;
      const JOYSTICK_GAME_MOVE_INTERVAL = 250;
      let joystickGameMoveTimerId = null;
      let lastJoystickMoveTime = 0;
      let joystickLoopId = null;
      let joystickTouchIdentifier = null; // <!-- CAMBIO JOYSTICK: Para seguir el dedo correcto -->

      function initJoystick() {
        if (
          !joystickContainer ||
          !joystickPad ||
          !joystickHandle ||
          !actionButtonTouch
        ) {
          console.error(
            "Error inicializando joystick: Elementos no encontrados."
          );
          return;
        }
        resetJoystickHandle();

        joystickPad.addEventListener(
          "touchstart",
          (event) => {
            if (
              gameState.player.isCultivating ||
              gameState.battle.active ||
              joystickActive
            )
              return;
            const touch = event.changedTouches[0];
            if (!touch) return;
            const padRect = joystickPad.getBoundingClientRect();
            if (
              touch.clientX < padRect.left ||
              touch.clientX > padRect.right ||
              touch.clientY < padRect.top ||
              touch.clientY > padRect.bottom
            ) {
              return;
            }
            event.preventDefault();
            joystickActive = true;
            joystickTouchIdentifier = touch.identifier;
            document.addEventListener("touchmove", handleJoystickMove, {
              passive: false,
            });
            document.addEventListener("touchend", handleJoystickEnd, {
              passive: false,
            });
            document.addEventListener("touchcancel", handleJoystickEnd, {
              passive: false,
            });

            // No iniciar el gameMoveTimer aqu√≠, la animaci√≥n la maneja handlePlayerMovementInput
            // updateJoystickHandlePosition y determinar direcci√≥n inicial
            updateJoystickHandlePosition(touch, true); // true para indicar que es el inicio
          },
          { passive: false }
        );

        actionButtonTouch.addEventListener("click", () => {
          if (!gameState.player.isCultivating && !gameState.battle.active) {
            interact();
          }
        });
      }
      function resetJoystickHandle() {
        if (joystickHandle)
          joystickHandle.style.transform = "translate(0px, 0px)";
        joystickCurrentDx = 0;
        joystickCurrentDy = 0;
      }
      // <!-- CAMBIO JOYSTICK: Modificaciones en los manejadores -->
      function handleJoystickStart(event) {
        // event.preventDefault(); // Puede ser necesario, pero probar sin √©l primero si causa problemas
        if (
          gameState.player.isCultivating ||
          gameState.battle.active ||
          joystickActive
        )
          return;

        // Solo procesar el primer toque en el pad
        const touch = event.changedTouches[0];
        if (!touch) return;

        // Comprobar si el toque est√° realmente dentro del joystickPad (opcional, pero bueno para evitar activaciones accidentales)
        const padRect = joystickPad.getBoundingClientRect();
        if (
          touch.clientX < padRect.left ||
          touch.clientX > padRect.right ||
          touch.clientY < padRect.top ||
          touch.clientY > padRect.bottom
        ) {
          return;
        }

        event.preventDefault(); // Prevenir scroll/zoom si el toque es para el joystick

        joystickActive = true;
        joystickTouchIdentifier = touch.identifier; // Guardar el ID del dedo

        // A√±adir listeners de movimiento y fin al documento para seguir el dedo fuera del pad
        document.addEventListener("touchmove", handleJoystickMove, {
          passive: false,
        });
        document.addEventListener("touchend", handleJoystickEnd, {
          passive: false,
        });
        document.addEventListener("touchcancel", handleJoystickEnd, {
          passive: false,
        });

        if (!joystickGameMoveTimerId) {
          joystickGameMoveTimerId = setInterval(
            processJoystickGameMove,
            JOYSTICK_GAME_MOVE_INTERVAL
          );
        }
        updateJoystickHandlePosition(touch);
        // console.log("Joystick Start, ID:", joystickTouchIdentifier);
      }
      function handleJoystickMove(event) {
        if (!joystickActive) return;

        // Encontrar el toque correcto
        let touch = null;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touch = event.changedTouches[i];
            break;
          }
        }

        if (touch) {
          event.preventDefault(); // Prevenir scroll si el movimiento es del dedo del joystick
          updateJoystickHandlePosition(touch);
          // console.log("Joystick Move");
        }
      }

      function updateJoystickHandlePosition(touch, isStart = false) {
        const padRect = joystickPad.getBoundingClientRect();
        if (padRect.width === 0 || padRect.height === 0) return;

        const joystickCenterX = padRect.left + padRect.width / 2;
        const joystickCenterY = padRect.top + padRect.height / 2;

        const currentX = touch.clientX - joystickCenterX;
        const currentY = touch.clientY - joystickCenterY;

        const angle = Math.atan2(currentY, currentX);
        const maxDistance =
          joystickPad.offsetWidth / 2 - joystickHandle.offsetWidth / 2;
        if (maxDistance <= 0) return;

        const distance = Math.min(maxDistance, Math.hypot(currentX, currentY));
        const limitedX = distance * Math.cos(angle);
        const limitedY = distance * Math.sin(angle);
        if (joystickHandle)
          joystickHandle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;

        let newJoystickDx = 0;
        let newJoystickDy = 0;
        let newDirection = null;

        const magnitude = Math.hypot(currentX, currentY);
        if (magnitude > JOYSTICK_THRESHOLD) {
          if (Math.abs(currentX) > Math.abs(currentY)) {
            newJoystickDx = currentX > 0 ? 1 : -1;
            newDirection = currentX > 0 ? "right" : "left";
          } else {
            newJoystickDy = currentY > 0 ? 1 : -1;
            newDirection = currentY > 0 ? "down" : "up";
          }
        }

        if (
          newDirection &&
          (newDirection !== gameState.player.currentDirection ||
            isStart ||
            !gameState.player.isMoving)
        ) {
          // Si la direcci√≥n cambia o si est√°bamos parados, actualizamos
          // Primero, "soltamos" la direcci√≥n anterior si la hay y est√°bamos movi√©ndonos
          if (
            gameState.player.isMoving &&
            gameState.player.currentDirection &&
            gameState.player.currentDirection !== newDirection
          ) {
            handlePlayerMovementInput(gameState.player.currentDirection, false);
          }
          // Luego, "presionamos" la nueva direcci√≥n
          handlePlayerMovementInput(newDirection, true);
          // Y movemos l√≥gicamente
          movePlayer(newJoystickDx, newJoystickDy);
        } else if (!newDirection && gameState.player.isMoving) {
          // Si no hay nueva direcci√≥n (el dedo volvi√≥ al centro) y est√°bamos movi√©ndonos
          handlePlayerMovementInput(gameState.player.currentDirection, false);
        }
        // Guardar para referencia en processJoystickGameMove si lo vuelves a usar
        joystickCurrentDx = newJoystickDx;
        joystickCurrentDy = newJoystickDy;
      }

      function handleJoystickEnd(event) {
        // Simplificado
        if (!joystickActive) return;
        let touchEndedIsOurs = false;
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches[i].identifier === joystickTouchIdentifier) {
            touchEndedIsOurs = true;
            break;
          }
        }
        if (touchEndedIsOurs) {
          joystickActive = false;
          joystickTouchIdentifier = null;
          resetJoystickHandle();
          document.removeEventListener("touchmove", handleJoystickMove);
          document.removeEventListener("touchend", handleJoystickEnd);
          document.removeEventListener("touchcancel", handleJoystickEnd);

          // "Soltar" la tecla de movimiento actual
          if (gameState.player.isMoving) {
            handlePlayerMovementInput(gameState.player.currentDirection, false);
          }
          joystickCurrentDx = 0;
          joystickCurrentDy = 0;
        }
      }
      // processJoystickGameMove se mantiene igual
      // <!-- FIN CAMBIO JOYSTICK -->
      function processJoystickGameMove() {
        // Esta funci√≥n se llama cada JOYSTICK_GAME_MOVE_INTERVAL
        if (
          joystickActive &&
          (joystickCurrentDx !== 0 || joystickCurrentDy !== 0)
        ) {
          // console.log(`[processJoystickGameMove] Effective move: dx=${joystickCurrentDx}, dy=${joystickCurrentDy}. Calling movePlayer.`);
          movePlayer(joystickCurrentDx, joystickCurrentDy);
        }
      }
      function joystickLoop() {
        if (!joystickActive) {
          joystickLoopId = null;
          return;
        }
        const now = Date.now();
        if (now - lastJoystickMoveTime > JOYSTICK_MOVE_INTERVAL) {
          let dx = 0,
            dy = 0;
          const magnitude = Math.hypot(joystickCurrentX, joystickCurrentY);
          if (magnitude > JOYSTICK_THRESHOLD) {
            if (Math.abs(joystickCurrentX) > Math.abs(joystickCurrentY)) {
              dx = joystickCurrentX > 0 ? 1 : -1;
            } else {
              dy = joystickCurrentY > 0 ? 1 : -1;
            }
          }
          if (dx !== 0 || dy !== 0) {
            movePlayer(dx, dy);
            lastJoystickMoveTime = now;
          }
        }
        joystickLoopId = requestAnimationFrame(joystickLoop);
      }
      // --- NUEVAS FUNCIONES PARA LOS MODALES DE INVENTARIO Y PERSONAJE (EJEMPLOS) ---

      // Modal para Inventario Detallado (si decides usar un modal en lugar del sidebar)
      function openInventoryModal() {
        let inventoryContent = "<h2>Inventario</h2>";
        inventoryContent += '<div class="inventory-grid" style="max-height: 60vh; overflow-y: auto;">'; // Grid dentro del modal

        if (Object.keys(gameState.inventory).every(key => gameState.inventory[key] === 0 && key !== "Piedras Espirituales")) {
            inventoryContent += "<p>Tu inventario est√° vac√≠o, excepto por tus Piedras Espirituales.</p>";
            if (gameState.inventory["Piedras Espirituales"] > 0) {
                inventoryContent += `<p>Piedras Espirituales: ${gameState.inventory["Piedras Espirituales"]}</p>`;
            }
        } else {
            Object.entries(gameState.inventory).forEach(([itemName, count]) => {
            if (count <= 0 && itemName !== "Piedras Espirituales") return; // No mostrar items con 0 cantidad (excepto piedras)

            const itemInfo = itemData[itemName];
            const description = itemInfo ? itemInfo.description : "Un objeto misterioso.";
            const canBeUsedNow = itemInfo && itemInfo.canUse ? itemInfo.canUse(gameState.player) : (itemInfo && itemInfo.effect ? true : false);
            const isEquipment = itemInfo && itemInfo.type === "equipment"; // Asumiendo que tienes 'type' en itemData

            inventoryContent += `
                <div class="inventory-item-modal" style="border: 1px solid #d4af37; padding: 10px; margin-bottom: 8px; border-radius: 5px; background: rgba(212,175,55,0.1);">
                <strong>${getItemIcon(itemName, itemInfo?.category)} ${itemName}: ${count}</strong><br>
                <small><em>${description}</em></small><br>`;

            if (itemInfo && itemInfo.effect && !isEquipment) { // Solo mostrar bot√≥n "Usar" para no equipables
                inventoryContent += `<button class="modal-use-item-btn" data-itemname="${itemName}" ${!canBeUsedNow ? 'disabled title="No se puede usar ahora"' : ''} style="margin-top: 5px; padding: 5px 10px;">Usar</button>`;
            } else if (isEquipment) {
                // Aqu√≠ podr√≠as poner un bot√≥n "Equipar" o mostrar stats si es un arma/armadura
                // Por ahora lo dejamos sin bot√≥n de acci√≥n directa en el modal de inventario general
            }
            inventoryContent += `</div>`;
            });
        }
        inventoryContent += '</div>';
        showModal("Detalles del Inventario", inventoryContent); // Usas tu funci√≥n showModal existente

        // A√±adir event listeners a los botones "Usar" generados din√°micamente
        document.querySelectorAll('.modal-use-item-btn').forEach(button => {
            button.addEventListener('click', function() {
            const itemName = this.dataset.itemname;
            // Llamar a la funci√≥n de usar item, pero esta vez el modal se cerrar√° y reabrir√°
            // o se actualizar√° si la l√≥gica de useItem no cierra todos los modales.
            const itemInfo = itemData[itemName];
            let message = "";
            if (itemInfo && itemInfo.effect) {
                if (itemInfo.canUse && !itemInfo.canUse(gameState.player)) {
                    message = "No puedes usar esto ahora.";
                } else {
                    message = (itemName === "Piedras Espirituales" || itemName === "N√∫cleo de Bestia Menor" || (itemInfo.description && (itemInfo.description.includes("Otorga") || itemInfo.description.includes("otorga"))))
                    ? itemInfo.effect(gameState.player, gainExperience)
                    : itemInfo.effect(gameState.player);
                    if (message && !message.toLowerCase().includes("error") && !message.toLowerCase().includes("al m√°ximo")) {
                    gameState.inventory[itemName]--;
                    }
                }
            } else {
                message = `${itemName} no tiene un efecto usable.`;
            }
            // Actualizar la UI del juego (stats, inventario en sidebar si a√∫n es visible)
            updateUI();
            // Volver a abrir el modal de inventario para reflejar el cambio
            closeModal(); // Cierra el modal actual
            openInventoryModal(); // Vuelve a abrir con el contenido actualizado
            showModal("Objeto Usado", message); // Muestra el mensaje del uso del objeto sobre el modal de inventario
            });
        });
        }

      // Modal para Personaje (Stats, Equipo, etc.)
      function openCharacterModal() {
        const player = gameState.player;
        let characterContent = `
                <h2>${player.realm} - Nivel ${player.level}</h2>
                <div style="text-align: left; margin-top: 15px;">
                <p><strong>Vida:</strong> ${Math.floor(player.hp)} / ${
          player.maxHp
        }</p>
                <div class="stat-bar" style="height:18px;"><div class="stat-fill hp-fill" style="width: ${
                  (player.hp / player.maxHp) * 100
                }%;"></div></div>
                <p><strong>Man√°:</strong> ${Math.floor(player.mana)} / ${
          player.maxMana
        }</p>
                <div class="stat-bar" style="height:18px;"><div class="stat-fill mana-fill" style="width: ${
                  (player.mana / player.maxMana) * 100
                }%;"></div></div>
                <p><strong>Experiencia:</strong> ${Math.floor(player.exp)} / ${
          player.expToNext
        }</p>
                <div class="stat-bar" style="height:18px;"><div class="stat-fill exp-fill" style="width: ${
                  (player.exp / player.expToNext) * 100
                }%;"></div></div>
                <hr style="margin: 15px 0;">
                <p><strong>Ataque:</strong> ${player.attack}</p>
                <p><strong>Defensa:</strong> ${player.defense}</p>
                <p><strong>Piedras Espirituales:</strong> ${
                  gameState.inventory["Piedras Espirituales"] || 0
                }</p>
                <hr style="margin: 15px 0;">
                <h4>Secta: ${player.secta.nombre}</h4>
                <p><strong>Rango:</strong> ${player.secta.rango}</p>
                <p><strong>Puntos de Contribuci√≥n:</strong> ${
                  player.secta.puntosContribucion
                } PCS</p>
                </div>
                `;
        // Aqu√≠ podr√≠as a√±adir una secci√≥n para el equipo si lo implementas.
        showModal("Detalles del Personaje", characterContent);
      }

      // Placeholder para un futuro modal de men√∫ principal
      function openMainMenuModal() {
        let menuContent = `
                <h2>Men√∫ Principal</h2>
                <button class="cultivation-option-btn" onclick="saveGame(); closeModal();">üíæ Guardar Partida</button>
                <button class="cultivation-option-btn" onclick="triggerFileUpload(); closeModal();">üìÅ Cargar Partida</button>
                <button class="cultivation-option-btn" onclick="showHelp();">‚ùì Ayuda</button>
                <button class="cultivation-option-btn" onclick="closeModal();">‚Ü©Ô∏è Volver al Juego</button>
            `;
        // Usamos el showModal gen√©rico pero sin el bot√≥n de cierre por defecto, ya que "Volver al Juego" hace esa funci√≥n.
        // Para ello, tu showModal necesitar√≠a una forma de ocultar su propio bot√≥n de cierre.
        // Si showModal no lo permite, necesitar√≠as un modal espec√≠fico para el men√∫.
        // Por ahora, asumir√© que el showModal gen√©rico tiene un bot√≥n de cierre que se ocultar√°
        // o que el usuario usar√° el bot√≥n "Volver al Juego".

        // Modificamos el modal gen√©rico para que no muestre su propio bot√≥n "Cerrar" si se lo indicamos
        const modalElement = document.getElementById("interactionModal");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalTextEl = document.getElementById("modalText");
        const closeButton = modalElement.querySelector(
          "button.close-modal-btn"
        );

        modalTitleEl.textContent = "Men√∫ Principal"; // El H2 ya est√° en menuContent
        modalTextEl.innerHTML = menuContent.replace(
          "<h2>Men√∫ Principal</h2>",
          ""
        ); // Quitar el H2 duplicado
        if (closeButton) closeButton.style.display = "none"; // Ocultar el bot√≥n de cierre por defecto del modal

        modalElement.style.display = "flex";
        hideTouchControls();
        updateBottomNavVisibility();
      }

      function openSectHallInterface() {
        const player = gameState.player;
        const sectData = SECTA_DATA;
        console.log(
          "[SectHall] Abrir interfaz. Rango actual:",
          player.secta.rango,
          "PCS:",
          player.secta.puntosContribucion
        ); // LOG INICIAL

        document.getElementById(
          "sectHallModalTitle"
        ).textContent = `Sal√≥n ${player.secta.nombre}`;
        document.getElementById("sectHallPlayerRank").textContent =
          player.secta.rango;
        document.getElementById("sectHallPlayerPCS").textContent =
          player.secta.puntosContribucion;

        const availableMissionsDiv = document.getElementById(
          "sectHallAvailableMissions"
        );
        availableMissionsDiv.innerHTML =
          "<p>Habla con Gu√≠a Lin o Admin Yao para asignaciones generales.</p>";

        const rankChallengesDiv = document.getElementById(
          "sectHallRankChallenges"
        );
        rankChallengesDiv.innerHTML = "";

        const currentRankIndex = sectData.rangos.findIndex(
          (r) => r.nombre === player.secta.rango
        );
        console.log("[SectHall] currentRankIndex:", currentRankIndex); // LOG currentRankIndex

        let challengeButtonAdded = false;

        // Condici√≥n principal para mostrar el bot√≥n de consulta
        if (
          currentRankIndex !== -1 &&
          currentRankIndex + 1 < sectData.rangos.length
        ) {
          console.log(
            "[SectHall] Condici√≥n para mostrar bot√≥n CUMPLIDA. Hay un siguiente rango."
          ); // LOG
          const nextRankData = sectData.rangos[currentRankIndex + 1];
          console.log(
            "[SectHall] Siguiente rango:",
            nextRankData.nombre,
            "PCS Req:",
            nextRankData.pcsRequeridos
          ); // LOG nextRankData

          const challengeButton = document.createElement("button");
          challengeButton.textContent = `Consultar Desaf√≠o para ${nextRankData.nombre}`;
          challengeButton.className = "cultivation-option-btn";
          challengeButton.style.marginBottom = "10px";

          challengeButton.onclick = () => {
            // ... (l√≥gica del onclick que ya tienes, puedes a√±adir logs internos aqu√≠ tambi√©n si es necesario) ...
            console.log("[SectHall] Bot√≥n 'Consultar Desaf√≠o' CLICADO.");
            const pcsNecesarios = nextRankData.pcsRequeridos;
            const tieneSuficientesPCS =
              player.secta.puntosContribucion >= pcsNecesarios;
            const rivalIdParaDesafio = nextRankData.desafioRivalId;
            let mensajeDesafio = `<strong>Desaf√≠o para ascender a ${nextRankData.nombre}:</strong><br>`;
            let misionDesafioActiva = null;
            let misionDesafioDataObj = null;
            let idDeLaMisionAsociada = null;

            console.log(
              `[SectHall - OnClick] PCS Necesarios: ${pcsNecesarios}, Tiene PCS: ${tieneSuficientesPCS}, Rival ID: ${rivalIdParaDesafio}`
            );

            if (rivalIdParaDesafio) {
              const misionEntry = Object.entries(MISIONES_DATA).find(
                ([mKey, mVal]) =>
                  mVal.objetivo?.tipo === "derrotar_npc_especifico" &&
                  mVal.objetivo?.npcId === rivalIdParaDesafio &&
                  mVal.recompensa?.nuevoRango === nextRankData.nombre
              );
              console.log(
                "[SectHall - OnClick] Mision Entry encontrada:",
                misionEntry
              );

              if (misionEntry) {
                idDeLaMisionAsociada = misionEntry[0];
                misionDesafioDataObj = misionEntry[1];
                misionDesafioActiva = player.secta.misionesActivas.find(
                  (m) => m.id === idDeLaMisionAsociada
                );
                console.log(
                  "[SectHall - OnClick] ID Misi√≥n Asociada:",
                  idDeLaMisionAsociada,
                  "Misi√≥n Activa?:",
                  !!misionDesafioActiva
                );

                mensajeDesafio += `<em>"${misionDesafioDataObj.descripcion}"</em><br>`;
                mensajeDesafio += `Oponente: <strong>${
                  entityTypes[rivalIdParaDesafio]?.name ||
                  "Guardi√°n Desconocido"
                }</strong>.<br>`;
                mensajeDesafio += `Recompensas: ${
                  misionDesafioDataObj.recompensa.pcs || 0
                } PCS, ${misionDesafioDataObj.recompensa.exp || 0} EXP, Rango ${
                  nextRankData.nombre
                }.<br><hr>`;
              } else {
                mensajeDesafio += `Informaci√≥n del desaf√≠o espec√≠fico no encontrada (error de configuraci√≥n o la misi√≥n no est√° definida correctamente).<br><hr>`;
              }
            } else {
              mensajeDesafio += `Este rango no parece requerir un desaf√≠o de combate para ascender.<br><hr>`;
            }

            mensajeDesafio += `<strong>Requisitos Actuales:</strong><br>`;
            mensajeDesafio += `Puntos de Contribuci√≥n (PCS): ${player.secta.puntosContribucion} / ${pcsNecesarios} PCS. `;
            mensajeDesafio += tieneSuficientesPCS
              ? "<span style='color: #66ff66;'>(Cumplido)</span><br>"
              : `<span style='color: #ffcc66;'>(Faltan ${
                  pcsNecesarios - player.secta.puntosContribucion
                } PCS)</span><br>`;

            if (misionDesafioActiva) {
              mensajeDesafio +=
                "<br><strong style='color: #66ff66;'>¬°El desaf√≠o est√° ACTIVO!</strong> Dir√≠gete a la arena.";
            } else if (
              idDeLaMisionAsociada &&
              player.secta.misionesCompletadas[idDeLaMisionAsociada]
            ) {
              mensajeDesafio +=
                "<br><strong style='color: #aaa;'>Ya has completado este desaf√≠o.</strong>";
            } else if (
              tieneSuficientesPCS &&
              rivalIdParaDesafio &&
              misionDesafioDataObj &&
              idDeLaMisionAsociada
            ) {
              const activarDesafioBtnId = "activar-desafio-btn-specific";
              mensajeDesafio += `<br><button id="${activarDesafioBtnId}">Activar Misi√≥n de Desaf√≠o Ahora</button>`;

              window.tempChallengeActivationInfo = {
                misionId: idDeLaMisionAsociada,
                nextRankName: nextRankData.nombre,
              };
            } else if (!tieneSuficientesPCS) {
              mensajeDesafio +=
                "<br>A√∫n no cumples los requisitos de PCS para activar este desaf√≠o.";
            } else if (!rivalIdParaDesafio || !misionDesafioDataObj) {
              mensajeDesafio +=
                "<br>No hay un desaf√≠o de combate claramente definido para este rango o falta informaci√≥n de la misi√≥n.";
            }

            showModal("Informaci√≥n del Desaf√≠o de Rango", mensajeDesafio);

            if (
              window.tempChallengeActivationInfo &&
              document.getElementById("activar-desafio-btn-specific")
            ) {
              document.getElementById("activar-desafio-btn-specific").onclick =
                () => {
                  console.log(
                    "[SectHall - OnClick] Bot√≥n 'Activar Misi√≥n Ahora' CLICADO."
                  );
                  const info = window.tempChallengeActivationInfo;
                  const misionDataParaActivar = MISIONES_DATA[info.misionId];
                  const playerRef = gameState.player;
                  const nextRankDataRef = SECTA_DATA.rangos.find(
                    (r) => r.nombre === info.nextRankName
                  );

                  if (
                    misionDataParaActivar &&
                    nextRankDataRef &&
                    playerRef.secta.puntosContribucion >=
                      nextRankDataRef.pcsRequeridos
                  ) {
                    if (
                      !playerRef.secta.misionesActivas.some(
                        (m) => m.id === info.misionId
                      ) &&
                      !playerRef.secta.misionesCompletadas[info.misionId]
                    ) {
                      acceptMission(info.misionId);
                      closeModal();
                      openSectHallInterface();
                      ensureFixedEntities();
                      renderMap();
                    } else {
                      showModal(
                        "Desaf√≠o ya Gestionado",
                        "Este desaf√≠o ya est√° activo o ha sido completado."
                      );
                    }
                  } else {
                    showModal(
                      "Requisitos No Cumplidos",
                      "Ya no cumples los requisitos para activar este desaf√≠o."
                    );
                  }
                  delete window.tempChallengeActivationInfo;
                };
            } else if (
              document.getElementById("activar-desafio-btn-specific")
            ) {
              console.warn(
                "[SectHall - OnClick] Bot√≥n 'activar-desafio-btn-specific' existe, pero window.tempChallengeActivationInfo no est√° definido."
              );
            }
          };
          rankChallengesDiv.appendChild(challengeButton);
          challengeButtonAdded = true;
          console.log("[SectHall] Bot√≥n 'Consultar Desaf√≠o' A√ëADIDO al DOM."); // LOG si se a√±ade
        } else {
          // Este bloque se ejecuta si la condici√≥n if (currentRankIndex !== -1 && currentRankIndex + 1 < sectData.rangos.length) NO se cumple
          console.log("[SectHall] Condici√≥n para mostrar bot√≥n NO CUMPLIDA."); // LOG
          if (currentRankIndex === -1) {
            console.log(
              "[SectHall] Raz√≥n: currentRankIndex es -1 (rango del jugador no encontrado)."
            ); // LOG
          } else {
            console.log(
              "[SectHall] Raz√≥n: Jugador en rango m√°ximo o no hay m√°s rangos (currentRankIndex + 1 >= sectData.rangos.length)."
            ); // LOG
          }
        }

        // Mensajes de fallback si el bot√≥n no se a√±adi√≥
        if (!challengeButtonAdded) {
          console.log(
            "[SectHall] challengeButtonAdded es FALSE. Mostrando mensaje de fallback."
          ); // LOG
          if (currentRankIndex === -1) {
            rankChallengesDiv.innerHTML =
              "<p>Error al determinar tu rango actual.</p>";
          } else if (currentRankIndex + 1 >= sectData.rangos.length) {
            rankChallengesDiv.innerHTML =
              "<p>¬°Has alcanzado el rango m√°s alto o no hay m√°s desaf√≠os definidos!</p>";
          } else {
            // Esta situaci√≥n es menos com√∫n si la l√≥gica anterior es correcta,
            // pero podr√≠a ocurrir si hay un `nextRankData` pero por alguna raz√≥n no se crea el bot√≥n.
            rankChallengesDiv.innerHTML =
              "<p>No hay informaci√≥n de desaf√≠o disponible en este momento (situaci√≥n de fallback inesperada).</p>";
          }
        }

        document.getElementById("sectHallModal").style.display = "flex";
        hideTouchControls();
      }
      function acceptMissionFromSectHall(misionId) {
        acceptMission(misionId);
        if (document.getElementById("sectHallModal").style.display === "flex") {
          openSectHallInterface();
        }
      }
      function closeSectHallModal() {
        document.getElementById("sectHallModal").style.display = "none";
        showTouchControls();
        updatePlayerBarsOnMap();
        showTouchControls();
      }
      function openSectShop() {
        showModal("Tienda de Secta", "El Dep√≥sito a√∫n est√° siendo abastecido.");
      }

      // --- INICIALIZACI√ìN ---
      document.addEventListener("DOMContentLoaded", () => {
        const navBtnInventory = document.getElementById('navBtnInventory');
        console.log("Dentro de DOMContentLoaded, navBtnInventory:", navBtnInventory);
        if (navBtnInventory) {
            console.log("A√±adiendo listener al bot√≥n de inventario..."); // <-- A√ëADE ESTO
          navBtnInventory.addEventListener("click", () => {
            console.log("¬°Clic en el bot√≥n de Inventario detectado!"); // <-- A√ëADE ESTO
            openInventoryModal();
            // Necesitas una funci√≥n para abrir un MODAL de inventario
            // o decidir c√≥mo quieres mostrarlo.
            // Por ahora, un simple placeholder:
            // showModal("Inventario", "Aqu√≠ se mostrar√° tu inventario detallado.");
            // O, si quieres mostrar el panel lateral de inventario y scrollear a √©l (menos ideal):
            const inventoryPanel = document.querySelector(".inventory-panel");
            if (inventoryPanel) {
              inventoryPanel.scrollIntoView({ behavior: "smooth" });
              // Podr√≠as resaltar el panel de inventario temporalmente
            } else {
              // Si quieres un modal dedicado para el inventario:
              openInventoryModal(); // Tendr√≠as que crear esta funci√≥n y el modal
            }
          });
        }

        if (navBtnCharacter) {
          navBtnCharacter.addEventListener("click", () => {
            // Necesitas una funci√≥n para abrir un MODAL de personaje
            openCharacterModal(); // Tendr√≠as que crear esta funci√≥n y el modal
          });
        }

        if (navBtnCultivate) {
          navBtnCultivate.addEventListener("click", () => {
            toggleCultivation(); // Tu funci√≥n existente para iniciar/detener cultivo
          });
        }

        if (navBtnTechniques) {
          navBtnTechniques.addEventListener("click", () => {
            showTechniquePanel(); // Tu funci√≥n existente para mostrar el modal de t√©cnicas
          });
        }

        if (navBtnMenu) {
          navBtnMenu.addEventListener("click", () => {
            // Decide qu√© hace este bot√≥n. ¬øAbre el sidebar? ¬øUn men√∫ de pausa?
            // Ejemplo: si quieres que muestre el sidebar en vista m√≥vil donde est√° colapsado.
            const sidebar = document.querySelector(".sidebar");
            if (sidebar && isMobileView()) {
              // Podr√≠as implementar una l√≥gica para alternar la visibilidad del sidebar
              // o scrollear a √©l si es parte del layout principal.
              // Por ahora, un placeholder:
              sidebar.scrollIntoView({ behavior: "smooth" });
            } else {
              // showModal("Men√∫ Principal", "Opciones del juego / Guardar / Cargar / Ayuda.");
              // O si tienes una funci√≥n para abrir un modal de men√∫:
              openMainMenuModal(); // Tendr√≠as que crear esta funci√≥n
            }
          });
        }

        // Llamada inicial para asegurar el estado correcto de la barra
        updateBottomNavVisibility();

        // MODIFICACI√ìN DEL LISTENER DE TECLADO
        document.addEventListener("keydown", (e) => {
          if (
            gameState.player.isCultivating ||
            gameState.battle.active ||
            isAnyModalOpen()
          ) {
            if (e.code === "Escape") {
              /* ... tu l√≥gica de modales ... */
            }
            return;
          }
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
            case "Space":
              e.preventDefault();
              interact();
              return; // Interact no cambia
          }

          if (direction) {
            e.preventDefault();
            handlePlayerMovementInput(direction, true); // true para keyDown
            // El movePlayer original se llamar√° desde un intervalo o l√≥gica de juego si es necesario
            // para desacoplar la actualizaci√≥n visual de la l√≥gica de movimiento
            if (
              dxFromDirection(direction) !== 0 ||
              dyFromDirection(direction) !== 0
            ) {
              movePlayer(
                dxFromDirection(direction),
                dyFromDirection(direction)
              );
            }
          }
        });
        document.addEventListener("keyup", (e) => {
          if (
            gameState.player.isCultivating ||
            gameState.battle.active ||
            isAnyModalOpen()
          ) {
            return;
          }
          let direction = null;
          switch (e.code) {
            case "KeyW":
            case "ArrowUp":
              direction = "up";
              break;
            case "KeyS":
            case "ArrowDown":
              direction = "down";
              break;
            case "KeyA":
            case "ArrowLeft":
              direction = "left";
              break;
            case "KeyD":
            case "ArrowRight":
              direction = "right";
              break;
          }
          if (direction) {
            handlePlayerMovementInput(direction, false); // false para keyUp
          }
        });
        // Helper para convertir direcci√≥n a dx/dy para movePlayer
        function dxFromDirection(direction) {
          if (direction === "left") return -1;
          if (direction === "right") return 1;
          return 0;
        }

        function dyFromDirection(direction) {
          if (direction === "up") return -1;
          if (direction === "down") return 1;
          return 0;
        }

        const fileInput = document.getElementById("fileInput");
        if (fileInput) fileInput.addEventListener("change", loadGameFromFile);

        const toggleControlsBtn = document.getElementById(
          "toggleMapControlsBtn"
        );
        if (toggleControlsBtn)
          toggleControlsBtn.addEventListener(
            "click",
            toggleMapControlsVisibility
          );

        // Listener para redimensionar y recalcular el tama√±o de los tiles
        window.addEventListener("resize", () => {
          calculateAndSetTileSize();
          renderMap(); // Vuelve a dibujar con el nuevo tama√±o
          updatePlayerPosition(); // Asegura que el jugador est√© bien posicionado
        });

        // Iniciar el bucle de actualizaci√≥n del juego
        setInterval(gameTickUpdater, 1000); // Llama cada segundo, ajusta seg√∫n necesidad
        initJoystick();
        calculateAndSetTileSize();
        // generateMap() ahora es m√°s simple, isRespawn = false para carga inicial completa
        gameState.lastGameTimeUpdate = Date.now(); // Inicializar antes del primer tick
        // ---------- CAMBIO IMPORTANTE AQU√ç ----------
        generateMap(true); // Usar true para la generaci√≥n inicial completa, incluyendo decorativos
        // ---------- FIN DEL CAMBIO IMPORTANTE ----------
        recalculatePlayerStats();
        updatePlayerVisualSize(); // Asegura el tama√±o correcto del div del jugador
        updatePlayerSpriteVisual(); // Establece el sprite inicial
        updatePlayerPosition("DOMContentLoaded_init"); // Llama despu√©s de sprite visual

        updatePlayerSpriteVisual(); // Llamar una vez para establecer el sprite inicial

        showTouchControls();

        showModal(
          "Despertar del Cultivador",
          "Has despertado en un mundo de cultivadores buscando poder supremo. " +
            "Te encuentras cerca de la <strong>Secta del Viento Azure</strong>. Quiz√°s all√≠ encuentres tu camino.\n\n" +
            "<strong>Objetivo:</strong> Asciende en la secta, domina t√©cnicas, derrota enemigos y desvela secretos.\n\n" +
            "Busca al <strong>Gu√≠a Lin</strong> en la secta (‚õ©Ô∏è) para comenzar.\n\n" +
            'Usa Controles (Teclado/T√°ctil) para moverte e interactuar. Presiona "?" para ayuda.'
        );
        document
          .querySelectorAll("#shopCategories .category-item")
          .forEach((item) => {
            item.addEventListener("click", function () {
              document
                .querySelectorAll("#shopCategories .category-item")
                .forEach((i) => i.classList.remove("active"));
              this.classList.add("active");
              currentShopPage = 1;
              renderShopProducts();
            });
          });
        document.getElementById("shopSearch").addEventListener("input", () => {
          currentShopPage = 1;
          renderShopProducts();
        });
        document.getElementById("priceRange").addEventListener("input", (e) => {
          document.getElementById(
            "priceRangeValue"
          ).textContent = `${e.target.value} PS`;
          currentShopPage = 1;
          renderShopProducts();
        });
      });
    </script>
  </body>
</html>
